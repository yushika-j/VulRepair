Training/evaluation parameters Namespace(output_dir='./saved_models', model_type='t5', encoder_block_size=512, decoder_block_size=256, beam_size=50, model_name='model.bin', checkpoint_model_name='non_domain_model.bin', model_name_or_path='../codebert-base', config_name='', use_non_pretrained_model=False, tokenizer_name='../codebert-base', code_length=256, do_train=False, do_eval=False, do_test=True, load_model_from_checkpoint=False, evaluate_during_training=False, do_local_explanation=False, reasoning_method=None, train_batch_size=4, eval_batch_size=1, gradient_accumulation_steps=1, learning_rate=5e-05, weight_decay=0.0, adam_epsilon=1e-08, max_grad_norm=1.0, max_steps=-1, warmup_steps=0, seed=42, epochs=1, n_gpu=1, device=device(type='cuda', index=0))
***** Debugging Inference on Small Sample *****
============================================================
Sample #1
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 21397, 49460, 14646, 1215, 6031, 15368, 36, 29916, 3716, 1009, 3716, 4839, 25522, 49460, 5494, 5457, 3950, 2156, 3872, 40311, 5457, 3950, 2156, 295, 4765, 9271, 5457, 3950, 2156, 37390, 417, 5457, 3950, 25606, 16224, 579, 646, 11191, 791, 7881, 41697, 27779, 2156, 1009, 579, 4903, 5457, 48955, 2156, 1009, 786, 1755, 134, 2156, 1009, 1852, 808, 25606, 49133, 1215, 90, 1009, 7398, 5457, 48955, 2156, 1009, 5032, 1215, 6486, 2156, 1009, 22379, 1215, 6486, 25606, 49133, 1215, 44223, 1215, 90, 22379, 25606, 6979, 295, 176, 10799, 25606, 5032, 1397, 4832, 114, 36, 27785, 11808, 1215, 6031, 15368, 1215, 48154, 36, 3716, 4839, 4839, 25522, 37390, 417, 5457, 3950, 25606, 49325, 66, 25606, 35524, 37390, 417, 5457, 1528, 25606, 114, 36, 3872, 40311, 4839, 25522, 699, 1215, 29, 3343, 36, 3716, 4839, 25606, 12631, 506, 36, 579, 2156, 49667, 48669, 113, 808, 48669, 7862, 50267, 207, 417, 6, 50267, 48669, 113, 45416, 48669, 7862, 50267, 48669, 113, 33527, 4, 10936, 36037, 48669, 1297, 50267, 48669, 113, 49237, 48669, 7862, 50267, 48992, 49509, 2156, 3514, 9657, 1215, 808, 48793, 4839, 25606, 35524, 1493, 25522, 114, 36, 3716, 43839, 1852, 808, 4839, 12631, 506, 36, 579, 2156, 49667, 48669, 113, 808, 48669, 7862, 50267, 207, 417, 6, 50267, 48669, 113, 45416, 48669, 7862, 50267, 48669, 113, 33527, 4, 10936, 36037, 48669, 1297, 50267, 48669, 113, 49237, 48669, 7862, 50267, 10975, 48669, 48149, 44561, 14426, 48789, 113, 46394, 7744, 22, 48669, 1297, 50267, 48669, 113, 207, 29, 48669, 42248, 49509, 2156, 3514, 9657, 1215, 808, 48793, 2156, 3716, 43839, 1852, 808, 4839, 25606, 1493, 12631, 506, 36, 579, 2156, 49667, 48669, 113, 808, 48669, 7862, 50267, 207, 417, 6, 50267, 48669, 113, 45416, 48669, 7862, 50267, 48669, 113, 33527, 4, 10936, 36037, 48669, 1297, 50267, 48669, 113, 49237, 48669, 7862, 50267, 10975, 48669, 48149, 44561, 14426, 48789, 113, 46394, 7744, 22, 48669, 42248, 49509, 2156, 3514, 9657, 1215, 808, 48793, 4839, 25606, 35524, 114, 36, 27148, 6031, 15368, 1215, 37785, 36, 3716, 2156, 579, 2156, 7031, 8476, 36, 579, 4839, 4839, 49333, 208, 9309, 1215, 9335, 4839, 25522, 45432, 2154, 36, 34772, 1215, 49837, 2156, 22, 597, 13355, 50267, 560, 50267, 37785, 50267, 29, 50267, 179, 50267, 179, 4933, 877, 1215, 6031, 15368, 113, 4839, 25606, 49325, 66, 25606, 35524, 114, 36, 27785, 37062, 1215, 16320, 36, 3716, 2156, 5885, 47697, 1215, 104, 13181, 8460, 2068, 4839, 4839, 25522, 45432, 2154, 36, 34772, 1215, 49837, 2156, 22, 23031, 196, 50267, 995, 50267, 2739, 2838, 50267, 1990, 50267, 41510, 50267, 179, 50267, 179, 4933, 877, 1215, 6031, 15368, 113, 4839, 25606, 49325, 66, 25606, 35524, 579, 4903, 5457, 3872, 705, 1215, 1902, 36, 3716, 4839, 25606, 114, 36, 27785, 579, 4903, 4839, 49325, 66, 25606, 3872, 40311, 5457, 1528, 25606, 7398, 5457, 47192, 1215, 27822, 104, 36, 579, 4903, 2156, 359, 22379, 4839, 25606, 481, 36, 579, 4903, 4839, 25606, 114, 36, 27785, 7398, 4839, 25522, 45432, 2154, 36, 34772, 1215, 48050, 2156, 22, 49437, 50267, 11127, 4636, 50267, 38323, 1640, 207, 417, 3256, 50267, 207, 29, 113, 2156, 22379, 479, 2]

üîπ Input Tokens:
<s>CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , "{\\"id\\": <S2SV_blank> %d, <S2SV_blank> \\"method\\": <S2SV_blank> \\"mining.subscribe\\", <S2SV_blank> \\"params\\": <S2SV_blank> []}" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , "{\\"id\\": <S2SV_blank> %d, <S2SV_blank> \\"method\\": <S2SV_blank> \\"mining.subscribe\\", <S2SV_blank> \\"params\\": <S2SV_blank> [\\"" PACKAGE "/" VERSION "\\", <S2SV_blank> \\"%s\\"]}" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , "{\\"id\\": <S2SV_blank> %d, <S2SV_blank> \\"method\\": <S2SV_blank> \\"mining.subscribe\\", <S2SV_blank> \\"params\\": <S2SV_blank> [\\"" PACKAGE "/" VERSION "\\"]}" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , "Failed <S2SV_blank> to <S2SV_blank> send <S2SV_blank> s <S2SV_blank> in <S2SV_blank> initiate_stratum" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , "Timed <S2SV_blank> out <S2SV_blank> waiting <S2SV_blank> for <S2SV_blank> response <S2SV_blank> in <S2SV_blank> initiate_stratum" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , "JSON <S2SV_blank> decode <S2SV_blank> failed(%d): <S2SV_blank> %s" , err .</s>

üîπ Decoder Input IDs:
[0, 50268, 114, 36, 27785, 8218, 1215, 43726, 36, 786, 1755, 134, 4839, 1437, 50269, 4839, 25522, 45432, 2154, 1437, 50268, 36, 34772, 1215, 48050, 2156, 22, 597, 13355, 50267, 560, 50267, 6460, 50267, 42679, 50267, 13424, 1755, 134, 50267, 179, 50267, 179, 4933, 877, 1215, 6031, 15368, 113, 1437, 50269, 4839, 25606, 481, 1437, 50268, 25606, 114, 36, 295, 176, 10799, 28696, 132, 45056, 295, 176, 10799, 8061, 545, 1437, 50269, 4839, 25522, 45432, 2154, 1437, 50268, 36, 34772, 1215, 48050, 2156, 22, 597, 13355, 50267, 560, 50267, 6460, 50267, 42679, 50267, 282, 176, 10799, 50267, 179, 50267, 179, 4933, 877, 1215, 6031, 15368, 113, 1437, 50269, 4839, 25606, 481, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  if ( ! valid_hex ( nonce1 )  <S2SV_ModEnd>  ) { applog  <S2SV_ModStart>  ( LOG_INFO , "Failed <S2SV_blank> to <S2SV_blank> get <S2SV_blank> valid <S2SV_blank> nonce1 <S2SV_blank> in <S2SV_blank> initiate_stratum"  <S2SV_ModEnd>  ) ; free  <S2SV_ModStart>  ; if ( n2size < 2 || n2size > 16  <S2SV_ModEnd>  ) { applog  <S2SV_ModStart>  ( LOG_INFO , "Failed <S2SV_blank> to <S2SV_blank> get <S2SV_blank> valid <S2SV_blank> n2size <S2SV_blank> in <S2SV_blank> initiate_stratum"  <S2SV_ModEnd>  ) ; free
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Prediction:
<S2SV_ModStart>  ; if ( n2size < 1 )  <S2SV_ModEnd>  { applog (

üîπ Ground Truth:
<S2SV_ModStart>  if ( ! valid_hex ( nonce1 )  <S2SV_ModEnd>  ) { applog  <S2SV_ModStart>  ( LOG_INFO , "Failed <S2SV_blank> to <S2SV_blank> get <S2SV_blank> valid <S2SV_blank> nonce1 <S2SV_blank> in <S2SV_blank> initiate_stratum"  <S2SV_ModEnd>  ) ; free  <S2SV_ModStart>  ; if ( n2size < 2 || n2size > 16  <S2SV_ModEnd>  ) { applog  <S2SV_ModStart>  ( LOG_INFO , "Failed <S2SV_blank> to <S2SV_blank> get <S2SV_blank> valid <S2SV_blank> n2size <S2SV_blank> in <S2SV_blank> initiate_stratum"  <S2SV_ModEnd>  ) ; free
============================================================
============================================================
Sample #2
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 11338, 13842, 364, 1115, 1215, 17265, 36, 1161, 7779, 41147, 1215, 45012, 1009, 295, 5016, 2156, 5124, 10759, 1717, 1215, 24262, 1009, 46247, 2156, 1717, 1215, 2544, 5933, 4839, 25522, 10759, 29916, 364, 1115, 1215, 26061, 1215, 90, 1009, 364, 1115, 25606, 10759, 1717, 1215, 24262, 1009, 326, 43880, 25606, 1717, 1215, 2544, 326, 8476, 2156, 1907, 2156, 2849, 12528, 25606, 6979, 3212, 5457, 321, 2156, 25528, 25606, 326, 43880, 5457, 46247, 25606, 326, 8476, 5457, 5933, 25606, 364, 1115, 5457, 36, 10759, 29916, 364, 1115, 1215, 26061, 1215, 90, 1009, 4839, 46247, 25606, 19430, 1215, 565, 48692, 36, 1009, 364, 1115, 4839, 25606, 114, 36, 295, 5016, 43839, 295, 5016, 1215, 705, 30160, 28696, 112, 4839, 25522, 19430, 1215, 4454, 17831, 36, 36, 295, 5016, 2156, 49608, 29, 50267, 1640, 207, 257, 43, 50267, 705, 207, 257, 6, 50267, 8476, 50267, 207, 257, 113, 2156, 7, 330, 176, 6031, 36, 364, 1115, 1215, 26061, 1215, 12528, 1215, 43994, 2156, 22, 42230, 113, 2156, 364, 1115, 43839, 1907, 4839, 2156, 364, 1115, 43839, 1907, 2156, 364, 1115, 43839, 1732, 2156, 10649, 6997, 13709, 1215, 1549, 5871, 104, 36, 364, 1115, 43839, 5933, 4839, 4839, 4839, 25606, 671, 25606, 35524, 19430, 1215, 4454, 17831, 36, 36, 295, 5016, 2156, 49608, 29, 50267, 1640, 207, 257, 43, 50267, 705, 207, 257, 6, 50267, 8476, 50267, 207, 257, 113, 2156, 7, 330, 176, 6031, 36, 364, 1115, 1215, 26061, 1215, 12528, 1215, 43994, 2156, 22, 42230, 113, 2156, 364, 1115, 43839, 1907, 4839, 2156, 364, 1115, 43839, 1907, 2156, 364, 1115, 43839, 1732, 2156, 10649, 6997, 13709, 1215, 1549, 5871, 104, 36, 364, 1115, 43839, 5933, 4839, 4839, 4839, 25606, 326, 43880, 49371, 49907, 36, 10759, 29916, 364, 1115, 1215, 26061, 1215, 90, 4839, 25606, 326, 8476, 49826, 49907, 36, 10759, 29916, 364, 1115, 1215, 26061, 1215, 90, 4839, 25606, 5405, 36, 364, 1115, 43839, 1907, 4839, 25522, 403, 381, 591, 1215, 5499, 30104, 1215, 48710, 1215, 510, 14940, 3935, 4832, 1437, 50265, 1907, 5457, 1009, 36, 326, 43880, 4839, 25606, 1437, 50266, 25528, 5457, 10649, 6997, 13709, 1215, 1549, 5871, 104, 36, 326, 43880, 2055, 132, 4839, 25606, 19430, 1215, 4454, 17831, 36, 36, 295, 5016, 2156, 46481, 50267, 207, 29, 50267, 1640, 207, 257, 238, 50267, 808, 50267, 207, 257, 6, 50267, 8476, 50267, 207, 257, 113, 2156, 7, 330, 176, 6031, 36, 364, 1115, 1215, 20414, 1215, 43994, 2156, 22, 42230, 113, 2156, 1907, 4839, 2156, 1907, 2156, 1009, 36, 326, 43880, 2055, 112, 4839, 2156, 25528, 4839, 4839, 25606, 19430, 1215, 565, 48692, 176, 36, 1009, 326, 43880, 2156, 25528, 4839, 25606, 114, 36, 1907, 49230, 132, 4839, 25522, 1437, 50265, 2849, 12528, 5457, 1009, 36, 326, 43880, 2055, 204, 4839, 25606, 1437, 50266, 19430, 1215, 4454, 17831, 36, 36, 295, 5016, 2156, 22, 48669, 282, 48669, 90, 48669, 90, 50267, 40118, 50267, 207, 29, 50267, 1640, 207, 257, 30831, 2156, 1437, 50265, 7, 330, 176, 6031, 36, 364, 1115, 1215, 12528, 1215, 43994, 2156, 22, 42230, 113, 2156, 1009, 36, 326, 43880, 2055, 204, 4839, 2]

üîπ Input Tokens:
<s>CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , "%s <S2SV_blank> (%u) <S2SV_blank> v%u, <S2SV_blank> len <S2SV_blank> %u" , tok2str ( eap_frame_type_values , "unknown" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , "%s <S2SV_blank> (%u) <S2SV_blank> v%u, <S2SV_blank> len <S2SV_blank> %u" , tok2str ( eap_frame_type_values , "unknown" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET :  <S2SV_StartBug>  type = * ( tptr ) ;  <S2SV_EndBug>  len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ", <S2SV_blank> %s <S2SV_blank> (%u), <S2SV_blank> id <S2SV_blank> %u, <S2SV_blank> len <S2SV_blank> %u" , tok2str ( eap_code_values , "unknown" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) {  <S2SV_StartBug>  subtype = * ( tptr + 4 ) ;  <S2SV_EndBug>  ND_PRINT ( ( ndo , "\\n\\t\\t <S2SV_blank> Type <S2SV_blank> %s <S2SV_blank> (%u)" ,  <S2SV_StartBug>  tok2str ( eap_type_values , "unknown" , * ( tptr + 4 )</s>

üîπ Decoder Input IDs:
[0, 50268, 403, 381, 591, 1215, 5499, 30104, 1215, 48710, 1215, 510, 14940, 3935, 4832, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 4839, 25606, 1437, 50268, 1009, 36, 326, 43880, 4839, 25606, 19430, 1215, 565, 48692, 1215, 1549, 5871, 104, 36, 326, 43880, 2055, 132, 1437, 50268, 132, 4839, 25522, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 2055, 204, 4839, 25606, 1437, 50268, 2156, 22, 42230, 113, 2156, 2849, 12528, 4839, 2156, 2849, 12528, 1437, 50269, 4839, 4839, 25606, 1437, 50268, 25528, 4839, 25522, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 2055, 3212, 4839, 25606, 1437, 50268, 403, 381, 591, 1215, 48710, 1215, 14543, 10463, 4832, 403, 381, 591, 1215, 48710, 1215, 565, 10463, 4832, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 2055, 195, 4839, 25606, 114, 36, 2849, 12528, 45994, 381, 591, 1215, 48710, 1215, 14543, 10463, 4839, 1437, 50268, 4839, 4839, 25606, 1437, 50269, 19430, 1215, 4454, 17831, 36, 36, 1437, 50268, 4839, 4839, 25522, 19430, 1215, 565, 48692, 1215, 2881, 5871, 104, 36, 326, 43880, 2055, 231, 4839, 25606, 1437, 50268, 403, 381, 591, 1215, 48710, 1215, 597, 10388, 4832, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 2055, 195, 4839, 25606, 1437, 50268, 4839, 4839, 25522, 19430, 1215, 565, 48692, 1215, 2881, 5871, 104, 36, 326, 43880, 2055, 231, 4839, 25606, 1437, 50268, 403, 381, 591, 1215, 48710, 1215, 37266, 4832, 19430, 1215, 565, 48692, 1215, 398, 5871, 104, 36, 326, 43880, 2]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ;  <S2SV_ModStart>  * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2  <S2SV_ModStart>  2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ;  <S2SV_ModStart>  , "unknown" , subtype ) , subtype  <S2SV_ModEnd>  ) ) ;  <S2SV_ModStart>  len ) { ND_TCHECK_8BITS ( tptr + count ) ;  <S2SV_ModStart>  case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS )  <S2SV_ModStart>  ) ) ;  <S2SV_ModEnd>  ND_PRINT ( (  <S2SV_ModStart>  ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ;  <S2SV_ModStart>  case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;  <S2SV_ModStart>  ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ;  <S2SV_ModStart>  case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr</s>

üîπ Prediction:


üîπ Ground Truth:
<S2SV_ModStart>  case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ;  <S2SV_ModStart>  * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2  <S2SV_ModStart>  2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ;  <S2SV_ModStart>  , "unknown" , subtype ) , subtype  <S2SV_ModEnd>  ) ) ;  <S2SV_ModStart>  len ) { ND_TCHECK_8BITS ( tptr + count ) ;  <S2SV_ModStart>  case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS )  <S2SV_ModStart>  ) ) ;  <S2SV_ModEnd>  ND_PRINT ( (  <S2SV_ModStart>  ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ;  <S2SV_ModStart>  case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ;  <S2SV_ModStart>  ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ;  <S2SV_ModStart>  case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr
============================================================
============================================================
Sample #3
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 33871, 6979, 43556, 466, 330, 1215, 605, 5408, 1215, 48211, 36, 29916, 885, 5408, 1009, 885, 5408, 2156, 49562, 885, 5408, 1215, 48211, 1215, 808, 49099, 1215, 808, 2156, 1717, 398, 1009, 49099, 1215, 48939, 2156, 1717, 2881, 49099, 1215, 8476, 2156, 1717, 398, 1009, 910, 4182, 1215, 48939, 2156, 1717, 2881, 910, 4182, 1215, 8476, 2156, 1717, 2881, 25386, 4839, 25522, 29916, 43556, 1215, 30826, 1009, 23184, 5457, 885, 5408, 43839, 12402, 705, 1215, 25943, 43839, 23184, 25606, 29916, 43556, 1215, 27278, 1009, 1537, 5457, 43556, 466, 330, 1215, 30826, 1215, 27278, 36, 23184, 4839, 25606, 1717, 1549, 471, 4294, 5457, 49907, 36, 29916, 1368, 42988, 1215, 26061, 1215, 298, 10232, 4839, 2055, 49907, 36, 29916, 885, 5408, 1215, 48211, 1215, 298, 10232, 4839, 25606, 29916, 2972, 1215, 43637, 1009, 2972, 428, 25606, 39023, 251, 86, 1215, 6960, 25606, 6979, 5494, 5457, 321, 25606, 114, 36, 23184, 43839, 23184, 1215, 46760, 359, 30227, 1215, 4154, 7205, 13644, 534, 1691, 4839, 671, 321, 25606, 2972, 428, 5457, 42793, 1215, 7771, 428, 36, 471, 4294, 2055, 49099, 1215, 8476, 2156, 272, 9763, 1215, 2571, 3765, 2371, 4839, 25606, 114, 36, 27785, 2972, 428, 4839, 671, 111, 13245, 3765, 5330, 25606, 2972, 428, 1215, 1535, 14477, 36, 2972, 428, 2156, 471, 4294, 4839, 25606, 114, 36, 49099, 1215, 8476, 49333, 321, 48200, 49099, 1215, 48939, 49333, 48955, 4839, 25522, 2972, 428, 1215, 9179, 1215, 23687, 36, 2972, 428, 2156, 49099, 1215, 48939, 2156, 49099, 1215, 8476, 4839, 25606, 35524, 16119, 3463, 1215, 8292, 36, 359, 885, 5408, 43839, 5963, 1215, 26121, 3463, 4839, 25606, 114, 36, 3752, 36, 885, 5408, 43839, 2294, 4839, 4839, 25522, 5494, 5457, 111, 381, 4454, 33770, 25606, 49325, 66, 25606, 35524, 885, 5408, 43839, 49099, 1215, 338, 4182, 1215, 48939, 5457, 910, 4182, 1215, 48939, 25606, 885, 5408, 43839, 49099, 1215, 338, 4182, 1215, 8476, 5457, 910, 4182, 1215, 8476, 25606, 5494, 5457, 43556, 466, 330, 1215, 605, 5408, 1215, 48211, 1215, 25268, 36, 885, 5408, 2156, 2972, 428, 2156, 49099, 1215, 808, 2156, 49099, 1215, 8476, 4839, 25606, 114, 36, 5494, 4839, 49325, 66, 25606, 86, 1215, 6960, 5457, 2067, 1215, 1990, 1215, 175, 37189, 1215, 49109, 36, 359, 885, 5408, 43839, 49099, 1215, 37405, 2156, 25386, 4839, 25606, 114, 36, 27785, 86, 1215, 6960, 4839, 25522, 43556, 1215, 33845, 571, 36, 1537, 2156, 305, 7539, 2156, 22, 49405, 50267, 2739, 2838, 50267, 1990, 50267, 771, 7539, 50267, 41483, 35, 50267, 207, 29, 48669, 282, 113, 2156, 885, 5408, 1215, 48211, 1215, 560, 1215, 13650, 36, 49099, 1215, 808, 4839, 4839, 25606, 16119, 3463, 1215, 879, 8292, 36, 359, 885, 5408, 43839, 5963, 1215, 26121, 3463, 4839, 25606, 1437, 50265, 671, 111, 4799, 3755, 1691, 29891, 25606, 1437, 50266, 35524, 16119, 3463, 1215, 879, 8292, 36, 359, 885, 5408, 43839, 5963, 1215, 26121, 3463, 4839, 25606, 671, 321, 25606, 66, 4832, 43556, 1215, 33845, 571, 36, 1537, 2156, 305, 7539, 2156, 22, 771, 7539, 50267, 37694, 2407, 50267, 1990, 35, 50267, 207, 29, 48669, 282, 113, 2156, 885, 5408, 1215, 48211, 1215, 560, 2]

üîπ Input Tokens:
<s>CWE-401 int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , "Timeout <S2SV_blank> waiting <S2SV_blank> for <S2SV_blank> WMI <S2SV_blank> command: <S2SV_blank> %s\\n" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ;  <S2SV_StartBug>  return - ETIMEDOUT ;  <S2SV_EndBug>  } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , "WMI <S2SV_blank> failure <S2SV_blank> for: <S2SV_blank> %s\\n" , wmi_cmd_to</s>

üîπ Decoder Input IDs:
[0, 50268, 5963, 1215, 26121, 3463, 4839, 25606, 449, 3743, 1215, 7771, 428, 36, 2972, 428, 4839, 25606, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  op_mutex ) ; kfree_skb ( skb ) ;
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Prediction:
<S2SV_ModStart>  ww ) ; spin_lock_irq ( & bh ) ;

üîπ Ground Truth:
<S2SV_ModStart>  op_mutex ) ; kfree_skb ( skb ) ;
============================================================
