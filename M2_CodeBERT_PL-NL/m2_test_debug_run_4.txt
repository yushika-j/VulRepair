Training/evaluation parameters Namespace(output_dir='./saved_models', model_type='t5', encoder_block_size=512, decoder_block_size=256, beam_size=50, model_name='model.bin', checkpoint_model_name='non_domain_model.bin', model_name_or_path='../codebert-base', config_name='', use_non_pretrained_model=False, tokenizer_name='../codebert-base', code_length=256, do_train=False, do_eval=False, do_test=True, load_model_from_checkpoint=False, evaluate_during_training=False, do_local_explanation=False, reasoning_method=None, train_batch_size=4, eval_batch_size=1, gradient_accumulation_steps=1, learning_rate=5e-05, weight_decay=0.0, adam_epsilon=1e-08, max_grad_norm=1.0, max_steps=-1, warmup_steps=0, seed=42, epochs=1, n_gpu=1, device=device(type='cuda', index=0))
***** Debugging Inference on Small Sample *****
============================================================
Sample #1
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 11338, 25156, 6979, 910, 1178, 1215, 47974, 1215, 26559, 36, 10759, 29916, 910, 1178, 1215, 24419, 1009, 910, 1178, 298, 2156, 10759, 29916, 36180, 1009, 36180, 2156, 6979, 2414, 2156, 6979, 2881, 1215, 90, 1009, 5963, 20414, 4839, 25522, 6979, 939, 25606, 29916, 910, 1178, 1215, 47974, 1215, 12595, 1009, 910, 1178, 1342, 25606, 49315, 2881, 1215, 90, 7200, 25606, 49315, 2881, 1215, 90, 19998, 25606, 2604, 2118, 30596, 1691, 1215, 448, 5330, 7496, 975, 36, 359, 7200, 2156, 359, 36180, 43839, 36180, 1215, 417, 620, 2156, 49907, 36, 49315, 2881, 1215, 90, 4839, 4839, 25606, 2604, 2118, 30596, 1691, 1215, 448, 5330, 7496, 975, 36, 359, 19998, 2156, 359, 36180, 43839, 36180, 1215, 45692, 2156, 49907, 36, 49315, 2881, 1215, 90, 4839, 4839, 25606, 939, 5457, 910, 1178, 1215, 47974, 1215, 298, 2544, 25606, 109, 25522, 910, 1178, 1342, 5457, 359, 910, 1178, 1215, 47974, 646, 939, 27779, 25606, 114, 36, 910, 1178, 1342, 43839, 486, 42666, 45994, 10649, 6997, 13709, 1215, 2881, 5871, 104, 36, 359, 910, 1178, 298, 43839, 486, 43623, 4839, 48200, 910, 1178, 1342, 43839, 3653, 479, 579, 1215, 49439, 45994, 7200, 48200, 910, 1178, 1342, 43839, 10228, 479, 579, 1215, 49439, 45994, 19998, 48200, 1437, 50265, 910, 1178, 1342, 43839, 544, 28081, 45994, 10649, 6997, 13709, 1215, 2881, 5871, 104, 36, 359, 910, 1178, 298, 43839, 544, 28081, 4839, 48200, 1437, 50266, 910, 1178, 1342, 43839, 385, 3427, 45994, 2414, 4839, 25522, 910, 1178, 1215, 47974, 1215, 298, 2544, 5457, 939, 25606, 1009, 5963, 20414, 5457, 910, 1178, 1342, 43839, 5963, 20414, 25606, 671, 36, 112, 4839, 25606, 35524, 114, 36, 48793, 939, 49095, 31946, 1215, 347, 2562, 17779, 1215, 49340, 4839, 939, 5457, 321, 25606, 35524, 150, 36, 939, 49333, 910, 1178, 1215, 47974, 1215, 298, 2544, 4839, 25606, 671, 36, 321, 4839, 25606, 35524, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Input Tokens:
<s>CWE-125 static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip &&  <S2SV_StartBug>  rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) &&  <S2SV_EndBug>  rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Decoder Input IDs:
[0, 50268, 43839, 544, 28081, 45994, 10649, 6997, 13709, 1215, 1549, 5871, 104, 1437, 50269, 36, 359, 910, 1178, 298, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  -> serviceId == EXTRACT_16BITS  <S2SV_ModEnd>  ( & rxh
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Prediction:
<S2SV_ModStart>  ] ) ;  <S2SV_ModEnd>  if ( xdr

üîπ Ground Truth:
<S2SV_ModStart>  -> serviceId == EXTRACT_16BITS  <S2SV_ModEnd>  ( & rxh
============================================================
============================================================
Sample #2
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 38444, 305, 11200, 2881, 1437, 3181, 26343, 1043, 417, 1215, 42290, 1215, 260, 337, 1215, 506, 10325, 36, 1437, 493, 1215, 293, 3809, 1215, 298, 1610, 1215, 43820, 11474, 254, 1215, 25384, 1009, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 4839, 25522, 305, 11200, 2881, 13561, 1178, 25606, 305, 11200, 2881, 26363, 1215, 10799, 5457, 132, 1009, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 38668, 1215, 10799, 25606, 305, 11200, 2881, 234, 5457, 36, 158, 1009, 26363, 1215, 10799, 4839, 25606, 13, 36, 13561, 1178, 5457, 321, 25606, 13561, 1178, 28696, 36, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 117, 1215, 428, 1344, 8488, 112, 4839, 25606, 13561, 1178, 48793, 4839, 25522, 305, 11200, 2881, 939, 2156, 1236, 2156, 449, 2156, 784, 25606, 8854, 673, 2571, 2881, 2931, 1215, 46234, 646, 37101, 27779, 25606, 8854, 673, 2571, 2881, 1717, 646, 13950, 27779, 2156, 1717, 1215, 179, 646, 22078, 27779, 2156, 1717, 1215, 995, 646, 22078, 27779, 25606, 8854, 673, 2571, 2881, 7678, 257, 1215, 338, 2156, 7678, 257, 1215, 118, 25606, 10759, 8854, 673, 2571, 2881, 1009, 11, 642, 1215, 13033, 337, 25606, 8854, 673, 2571, 2881, 1009, 26363, 1215, 48939, 25606, 8854, 673, 2571, 2881, 1009, 23815, 1215, 16254, 1215, 20338, 1215, 34108, 5457, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 23815, 1215, 16254, 1215, 20338, 1215, 34108, 25606, 10759, 8854, 673, 2571, 2881, 1009, 3222, 642, 1215, 42996, 1215, 876, 29678, 5457, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 23815, 1215, 9428, 1215, 876, 29678, 25606, 8854, 673, 2571, 2881, 1009, 3023, 5457, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 23815, 1215, 48939, 25606, 26012, 8738, 36, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 2231, 119, 506, 1215, 179, 1215, 48939, 646, 13561, 1178, 2055, 289, 8827, 1215, 35918, 1215, 28974, 1215, 574, 2796, 111, 112, 27779, 2156, 321, 2156, 17535, 9292, 1215, 1864, 41583, 1215, 21134, 487, 3732, 1215, 3764, 15118, 16416, 1215, 46758, 1009, 49907, 36, 8854, 673, 2571, 2881, 4839, 4839, 25606, 11, 642, 1215, 13033, 337, 5457, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 49892, 1215, 46797, 1215, 48939, 2055, 13561, 1178, 1009, 132, 1009, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 38668, 1215, 10799, 2055, 112, 25606, 26363, 1215, 48939, 5457, 359, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 2231, 119, 506, 1215, 179, 1215, 48939, 646, 13561, 1178, 2055, 289, 8827, 1215, 35918, 1215, 28974, 1215, 574, 2796, 111, 112, 27779, 646, 204, 1009, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 449, 1215, 13124, 27779, 25606, 13, 36, 939, 5457, 234, 111, 112, 25606, 939, 49095, 26363, 1215, 10799, 25606, 939, 480, 4839, 25522, 3023, 646, 939, 27779, 5457, 3023, 646, 939, 111, 26363, 1215, 10799, 27779, 25606, 35524, 13, 36, 939, 5457, 26363, 1215, 10799, 111, 112, 25606, 939, 49095, 321, 25606, 939, 480, 4839, 25522, 3023, 646, 939, 27779, 5457, 11, 642, 1215, 13033, 337, 646, 26363, 1215, 10799, 111, 112, 111, 939, 27779, 25606, 35524, 2]

üîπ Input Tokens:
<s>CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; }</s>

üîπ Decoder Input IDs:
[0, 50268, 35524, 114, 36, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 1437, 50268, 4839, 36, 1009, 36, 49892, 1215, 298, 1610, 1215, 43820, 11474, 254, 43839, 1437, 3181, 26343, 1043, 417, 1215, 13753, 2911, 1178, 1215, 260, 337, 1215, 3145, 90, 4839, 4839, 1437, 50269, 36, 1717, 1215, 179, 2156, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  } if ( ptr_hbe_txposer ->  <S2SV_ModStart>  ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) )  <S2SV_ModEnd>  ( u_in ,
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Prediction:
<S2SV_ModStart>  ; } } else {  <S2SV_ModStart>  ) ; }

üîπ Ground Truth:
<S2SV_ModStart>  } if ( ptr_hbe_txposer ->  <S2SV_ModStart>  ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) )  <S2SV_ModEnd>  ( u_in ,
============================================================
============================================================
Sample #3
Correct Prediction? ‚ùå NO

üîπ Input IDs:
[0, 347, 9112, 12, 38444, 25156, 6979, 821, 90, 5320, 10706, 37729, 29585, 36, 255, 7025, 5499, 534, 3813, 8532, 1009, 48599, 2156, 49315, 2881, 1009, 910, 8831, 2156, 49315, 2881, 885, 2156, 49315, 2881, 1368, 4839, 25522, 255, 24377, 1009, 326, 1594, 5457, 48599, 43839, 326, 1594, 25606, 29939, 37729, 29585, 500, 35543, 342, 5457, 48599, 43839, 342, 479, 2559, 25606, 39023, 16224, 1009, 49125, 5457, 48955, 25606, 39023, 16224, 1009, 181, 288, 5457, 48955, 2156, 1009, 181, 134, 5457, 48955, 2156, 1009, 181, 176, 5457, 48955, 2156, 1009, 6044, 5457, 48955, 25606, 49315, 2881, 3236, 2156, 1423, 2156, 295, 4610, 2156, 3236, 8005, 625, 25606, 326, 4339, 2072, 1215, 90, 8593, 25606, 326, 4339, 2072, 1215, 90, 14194, 1902, 25606, 49315, 2881, 22162, 1741, 34216, 2156, 6147, 1215, 4610, 25606, 49315, 2881, 26031, 2753, 47309, 5457, 48599, 43839, 22523, 25606, 326, 4339, 2072, 1215, 90, 22395, 2072, 25606, 326, 4339, 2072, 1215, 90, 49125, 10799, 25606, 6979, 2881, 31, 29, 1071, 605, 2156, 7, 29, 1071, 605, 25606, 6979, 32756, 5457, 48599, 43839, 32756, 25606, 6979, 5494, 5457, 112, 2156, 11113, 25606, 49315, 1549, 3195, 611, 34735, 25606, 22395, 2072, 5457, 255, 24377, 5320, 10706, 45698, 36, 326, 1594, 4839, 25606, 49125, 10799, 5457, 18134, 565, 24377, 45287, 1588, 352, 8108, 2072, 36, 326, 1594, 2156, 32756, 17487, 204, 4832, 155, 2156, 22395, 2072, 2156, 22, 19377, 5320, 10706, 37729, 29585, 113, 4839, 25606, 114, 36, 49125, 10799, 45994, 321, 4839, 25522, 671, 36, 321, 4839, 25606, 35524, 11113, 5457, 278, 29458, 1258, 36, 48599, 4839, 25606, 114, 36, 11113, 359, 8854, 3808, 1215, 43857, 2371, 32191, 4839, 25522, 1423, 5457, 1368, 111, 112, 25606, 7, 29, 1071, 605, 5457, 111, 36, 6979, 2881, 4839, 36, 885, 2055, 885, 4839, 25606, 35524, 1493, 25522, 1423, 5457, 321, 25606, 7, 29, 1071, 605, 5457, 111, 36, 6979, 2881, 4839, 36, 885, 111, 885, 4839, 25606, 35524, 5405, 36, 48599, 43839, 17190, 22356, 4839, 25522, 403, 9715, 3293, 3765, 3935, 36570, 1215, 24765, 1729, 26369, 12946, 4832, 403, 9715, 3293, 3765, 3935, 36570, 1215, 24765, 1729, 7976, 14940, 4832, 403, 9715, 3293, 3765, 3935, 36570, 1215, 510, 2118, 3935, 6433, 4832, 3195, 611, 34735, 5457, 112, 25606, 1108, 25606, 6814, 4832, 3195, 611, 34735, 5457, 155, 25606, 1108, 25606, 35524, 255, 24377, 14181, 27780, 48398, 196, 36, 326, 1594, 2156, 255, 7025, 11615, 3450, 1215, 500, 4581, 4186, 2076, 30549, 3808, 2156, 359, 22162, 1741, 34216, 4839, 25606, 14194, 1902, 5457, 255, 24377, 42450, 1902, 45698, 36, 326, 1594, 4839, 25606, 31, 29, 1071, 605, 5457, 36, 885, 28696, 26031, 2753, 47309, 17487, 26031, 2753, 47309, 111, 885, 4832, 321, 4839, 25606, 13, 36, 3236, 5457, 321, 25606, 3236, 28696, 1368, 25606, 3236, 49371, 295, 4610, 4839, 25522, 1437, 50265, 3236, 8005, 625, 5457, 22162, 1741, 34216, 111, 36, 3236, 2055, 48599, 43839, 3236, 1215, 48025, 4839, 7606, 22162, 1741, 34216, 25606, 1437, 50266, 295, 4610, 5457, 36, 3236, 2055, 3236, 8005, 625, 8061, 1368, 17487, 1368, 111, 3236, 4832, 3236, 8005, 625, 4839, 25606, 6147, 1215, 4610, 5457, 3236, 2055, 2]

üîπ Input Tokens:
<s>CWE-787 static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , "gtStripSeparate" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) {  <S2SV_StartBug>  rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ;  <S2SV_EndBug>  nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row +</s>

üîπ Decoder Input IDs:
[0, 50268, 295, 4610, 4839, 25522, 49315, 2881, 32196, 25606, 1437, 50268, 43839, 3236, 1215, 48025, 25606, 32196, 5457, 36, 3236, 2055, 48599, 43839, 3236, 1215, 48025, 4839, 7606, 22162, 1741, 34216, 2055, 295, 4610, 25606, 114, 36, 14194, 1902, 8061, 321, 48200, 32196, 8061, 36, 1836, 1215, 90, 4839, 36, 255, 24377, 1215, 565, 6222, 41697, 1215, 565, 1215, 30187, 1589, 14194, 1902, 4839, 4839, 25522, 255, 24377, 30192, 40884, 36, 326, 1594, 43839, 326, 1594, 1215, 38557, 23687, 2156, 255, 7025, 7389, 1848, 31723, 36, 326, 1594, 4839, 2156, 22, 49740, 50267, 2137, 19322, 50267, 179, 50267, 19377, 5320, 10706, 37729, 29585, 113, 4839, 25606, 671, 321, 25606, 35524, 1437, 50268, 2156, 49125, 10799, 2156, 32196, 1437, 50269, 1009, 14194, 1902, 4839, 1437, 50268, 2156, 181, 288, 2156, 32196, 1437, 50269, 1009, 14194, 1902, 4839, 1437, 50268, 2156, 181, 134, 2156, 32196, 1437, 50269, 1009, 14194, 1902, 4839, 1437, 50268, 2156, 181, 176, 2156, 32196, 1437, 50269, 1009, 14194, 1902, 4839, 1437, 50268, 2156, 6044, 2156, 32196, 1437, 50269, 1009, 14194, 1902, 4839, 50121, 50118, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

üîπ Decoder Input Tokens:
<s> <S2SV_ModStart>  nrow ) { uint32 temp ;  <S2SV_ModStart>  -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , "Integer <S2SV_blank> overflow <S2SV_blank> in <S2SV_blank> gtStripSeparate" ) ; return 0 ; }  <S2SV_ModStart>  , bufsize , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p0 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p1 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p2 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , pa , temp  <S2SV_ModEnd>  * scanline )
</s><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>

üîπ Prediction:
<S2SV_ModStart>  ; uint32 stripsize ;  <S2SV_ModEnd>  temp = (

üîπ Ground Truth:
<S2SV_ModStart>  nrow ) { uint32 temp ;  <S2SV_ModStart>  -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , "Integer <S2SV_blank> overflow <S2SV_blank> in <S2SV_blank> gtStripSeparate" ) ; return 0 ; }  <S2SV_ModStart>  , bufsize , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p0 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p1 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , p2 , temp  <S2SV_ModEnd>  * scanline )  <S2SV_ModStart>  , pa , temp  <S2SV_ModEnd>  * scanline )
============================================================
