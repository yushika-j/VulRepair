[
  {
    "raw_input": "CWE-119 void vp8_cal_sad ( VP8_COMP * cpi , MACROBLOCKD * xd , MACROBLOCK * x , int recon_yoffset , int near_sadidx [ ] ) { int near_sad [ 8 ] = { 0 } ; BLOCK * b = & x -> block [ 0 ] ; unsigned char * src_y_ptr = * ( b -> base_src ) ; if ( xd -> mb_to_top_edge == 0 && xd -> mb_to_left_edge == 0 ) { near_sad [ 0 ] = near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; } else if ( xd -> mb_to_top_edge == 0 ) { near_sad [ 0 ] = near_sad [ 2 ] = INT_MAX ;  <S2SV_StartBug>  near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;  <S2SV_EndBug>  } else if ( xd -> mb_to_left_edge == 0 ) { near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ;  <S2SV_StartBug>  near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;  <S2SV_EndBug>  } else {  <S2SV_StartBug>  near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ;  <S2SV_EndBug>   <S2SV_StartBug>  near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ;  <S2SV_EndBug>   <S2SV_StartBug>  near_sad [ 2 ] = cpi -> fn_ptr",
    "beam_candidates": [
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  src , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> y_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  src , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> y_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> y_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModStart>  src . y_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModEnd>  ( xd ->",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memcpy  <S2SV_ModStart>  src_stride , src_stride ,",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  dst_stride ) ; src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModStart>  src_stride + src_stride ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; } else { memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memcpy  <S2SV_ModStart>  src_stride , src_stride , src_stride ,",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) ; memset  <S2SV_ModStart>  src_stride = 0 ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ; src_stride",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; }",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , src_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , src_stride , dst_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , dst_stride , src_stride ) ; src_stride",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ; src_stride",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , src_stride , dst_stride , src_stride ) ; src_stride",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , src_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , dst_stride , src_stride ) ;",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , dst_stride , src_stride , src_stride ) ; src_stride",
      "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memcpy  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memcpy  <S2SV_ModStart>  dst_stride ) { if ( xd -> src_stride , dst_stride , src_stride , dst_stride , src_stride ) ;"
    ],
    "final_prediction": "<S2SV_ModStart>  . y_stride ; ( void ) cpi ;  <S2SV_ModStart>  src_mv ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_HIGHBITDEPTH if ( xd -> flags & YV12_FLAG_HIGHBITDEPTH ) { YV12_HIGHBITDEPTH ) ; int i = 0 ; memset  <S2SV_ModEnd>  ( xd ->  <S2SV_ModStart>  dst_stride , src_stride , src_stride ) ; memset  <S2SV_ModStart>  src_stride ) ; memset ( xd -> src_stride , dst_stride , src_stride ) ; } else { memset  <S2SV_ModStart>  dst_stride ) ; } memset  <S2SV_ModEnd>  ( xd ->",
    "correct_solution": "<S2SV_ModStart>  dst . y_stride  <S2SV_ModEnd>  ) ; }  <S2SV_ModStart>  dst . y_stride  <S2SV_ModEnd>  ) ; }  <S2SV_ModStart>  dst . y_stride  <S2SV_ModEnd>  ) ; near_sad  <S2SV_ModStart>  dst . y_stride  <S2SV_ModEnd>  ) ; near_sad  <S2SV_ModStart>  dst . y_stride  <S2SV_ModEnd>  ) ; }  <S2SV_ModStart>  16 , pre_y_stride  <S2SV_ModEnd>  ) ; if  <S2SV_ModStart>  16 , pre_y_stride  <S2SV_ModEnd>  ) ; near_sad  <S2SV_ModStart>  pre_y_buffer , pre_y_stride  <S2SV_ModEnd>  ) ; if  <S2SV_ModStart>  16 , pre_y_stride  <S2SV_ModEnd>  ) ; if  <S2SV_ModStart>  16 , pre_y_stride  <S2SV_ModEnd>  ) ; }",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 , 0 , & tp ) ; if ( error ) goto out_dqrele ; xfs_ilock ( ip , XFS_ILOCK_EXCL ) ; xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask",
    "beam_candidates": [
      "<S2SV_ModStart>  tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;"
    ],
    "final_prediction": "<S2SV_ModStart>  tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;",
    "correct_solution": "<S2SV_ModStart>  tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-119 static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , \"invalid <S2SV_blank> descriptor <S2SV_blank> for <S2SV_blank> config <S2SV_blank> index <S2SV_blank> %d: <S2SV_blank> \" \"type <S2SV_blank> = <S2SV_blank> 0x%X, <S2SV_blank> length <S2SV_blank> = <S2SV_blank> %d\\\\n\" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , \"config <S2SV_blank> %d <S2SV_blank> has <S2SV_blank> too <S2SV_blank> many <S2SV_blank> interfaces: <S2SV_blank> %d, <S2SV_blank> \" \"using <S2SV_blank> maximum <S2SV_blank> allowed: <S2SV_blank> %d\\\\n\" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , \"config <S2SV_blank> %d <S2SV_blank> descriptor <S2SV_blank> has <S2SV_blank> %d <S2SV_blank> excess <S2SV_blank> \" \"byte%s, <S2SV_blank> ignoring\\\\n\" , cfgno , size2 ,",
    "beam_candidates": [
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  - sizeof ( * ) ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  - sizeof ( * ) ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"too <S2SV_ModStart>  EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - ENODEV ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  - sizeof ( * ) ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - ENODEV ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - ENODEV ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"too <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - ENODEV ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  - sizeof ( * ) ) ; n = n ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> data [ 1 ] . bNumEndpoints = - 1",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"Invalid <S2SV_ModStart>  - sizeof ( * ) ) ; n = n ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints - sizeof ( * ) ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModEnd>  ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints - sizeof ( * ) ) ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"too <S2SV_ModStart>  EINVAL ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( ! n ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; goto fail3 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( ! n ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & intf -> dev , \"invalid <S2SV_ModStart>  - sizeof ( * ) ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return ; }",
      "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) { if ( n > 0 ) { dev_err ( & hid -> dev , \"Invalid <S2SV_ModStart>  EINVAL ) ; return - 1 ; }"
    ],
    "final_prediction": "<S2SV_ModStart>  ) & n -> bNumEndpoints - 1  <S2SV_ModStart>  -> bNumEndpoints < 1 ) || ( n > 0 ) { dev_err ( & hid -> dev , \"invalid <S2SV_ModStart>  EINVAL ; }",
    "correct_solution": "<S2SV_ModStart>  USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , \"config <S2SV_blank> %d <S2SV_blank> has <S2SV_blank> an <S2SV_blank> invalid <S2SV_blank> interface <S2SV_blank> association <S2SV_blank> descriptor <S2SV_blank> of <S2SV_blank> length <S2SV_blank> %d, <S2SV_blank> skipping\\\\n\" , cfgno , d -> bLength ) ; continue ; }  <S2SV_ModStart>  iad_num ] = d  <S2SV_ModEnd>  ; iad_num ++",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-190 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ;  <S2SV_StartBug>  if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS )  <S2SV_EndBug>   <S2SV_StartBug>  return - ENOMEM ;  <S2SV_EndBug>  if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) k",
    "beam_candidates": [
      "<S2SV_ModStart>  ; ue -> card = card ; ue ->",
      "<S2SV_ModStart>  ; ue -> count = card ; ue ->",
      "<S2SV_ModStart>  ; ue -> count = card ->",
      "<S2SV_ModEnd>  ; ue -> card = card ; ue ->",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_CTL_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_CTL_ELEM_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_ELEM_CTL_ELEM_ELEM_ACCESS",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ELEM_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_CTL_ELEM_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_ELEM_ACCESS_CTL_ELEM_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ACCESS_CTL_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CTL_ACCESS_ACCESS_",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_ELEM",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_ELEM_CTL_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_READWRITE | SNDRV_CTL_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_ELEM_CTL_ELEM_ELEM_E",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_ELEM_CTL_ELEM_ELEM_CT",
      "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE : ( info -> access & ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_CTL_ELEM_CTL_ELEM_ACCESS_READWRITE | SNDRV_READWRITE | SNDRV_CTL_CTL_ELEM_CTL_ELEM_CTL_ELEM_CTL_ELEM_READWRITE | SNDRV_ELEM_READWRITE | SNDRV_CTL_ELEM_CTL_CTL_ELEM_CTL_ELEM_ELEM_ELEM_E"
    ],
    "final_prediction": "<S2SV_ModStart>  ; ue -> card = card ; ue ->",
    "correct_solution": "<S2SV_ModStart>  ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if (  <S2SV_ModEnd>  card -> user_ctl_count  <S2SV_ModStart>  return - ENOMEM  <S2SV_ModEnd>  ; memcpy (",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-285 static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) {  <S2SV_StartBug>  exit_client ( client_p , client_p , client_p , \"Mixing <S2SV_blank> client <S2SV_blank> and <S2SV_blank> server <S2SV_blank> protocol\" ) ;  <S2SV_EndBug>  return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , \":%s <S2SV_blank> ENCAP <S2SV_blank> %s <S2SV_blank> SASL <S2SV_blank> %s <S2SV_blank> %s <S2SV_blank> H <S2SV_blank> %s <S2SV_blank> %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost )",
    "beam_candidates": [
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return - EINVAL ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> static intS2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( result == NULL ) return - EINVAL ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static intS2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return - 1 ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int client_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return - EINVAL ; }",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( client -> pE == NULL ) return - EINVAL ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static  <S2SV_ModStart>  client_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int namep_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int namep_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return TRUE ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( client -> pE == NULL ) return - EINVAL ; }",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( result == NULL ) return - 1 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null>  <S2SV_ModStart>  client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int namep_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( result == NULL ) return TRUE ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ! client -> name [ 1 ] == NULL ) return - EINVAL ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return - 1 ; }",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( client -> pE == NULL ) return - 1 ; }",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( client -> pE == NULL ) return - 1 ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ! client -> name [ 1 ] ) return - 1 ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int ipc_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static  <S2SV_ModEnd>  client_null>",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int client_null> static",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModEnd>  client_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ! client -> name [ 1 ] ) return - EINVAL ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ! client -> name [ 1 ] == NULL ) return - 1 ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null>",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( ( result == NULL ) return - 1 ; } # endif",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int client_null> static",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  == 0 ) { if ( result == NULL ) return - EINVAL ; } else if ( client -> pE == NULL ) return TRUE ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static",
      "<S2SV_null> <S2SV_null> <S2SV_null> static  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  : 0 ) ; } return - 1 ;",
      "<S2SV_null> <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null>"
    ],
    "final_prediction": "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null> static int  <S2SV_ModStart>  client_null> <S2SV_null>",
    "correct_solution": "<S2SV_ModStart>  client_p , \"Mixing <S2SV_blank> client <S2SV_blank> and <S2SV_blank> server <S2SV_blank> protocol\" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' <S2SV_blank> ' ) ) { exit_client ( client_p , client_p , client_p , \"Malformed <S2SV_blank> AUTHENTICATE\"",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-000  <S2SV_StartBug>  static void parse_input ( h2o_http2_conn_t * conn )  <S2SV_EndBug>  { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ; if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) perform_early_exit = 1 ; while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { if ( perform_early_exit == 1 && conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) goto EarlyExit ; const char * err_desc = NULL ; ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { break ; } else if ( ret < 0 ) { if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { enqueue_goaway ( conn , ( int ) ret , err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; }  <S2SV_StartBug>  close_connection ( conn ) ;  <S2SV_EndBug>  return ; } h2o_buffer_consume ( & conn -> sock -> input , ret ) ; } if ( ! h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_start ( conn -> sock , on_read ) ;  <S2SV_StartBug>  return ;  <S2SV_EndBug>  EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock ) ;  <S2SV_StartBug>  }  <S2SV_EndBug> \n",
    "beam_candidates": [
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModEnd>  ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModEnd>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModEnd>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModStart>  ) ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;"
    ],
    "final_prediction": "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
    "correct_solution": "<S2SV_ModStart>  <S2SV_null> <S2SV_null> static int  <S2SV_ModEnd>  parse_input ( h2o_http2_conn_t  <S2SV_ModStart>  ) ; } return  <S2SV_ModStart>  ( conn )  <S2SV_ModEnd>  ; } h2o_buffer_consume  <S2SV_ModStart>  ) ; return 0  <S2SV_ModStart>  sock ) ; return 0 ;",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  <S2SV_StartBug>  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  <S2SV_EndBug>  NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset ,  <S2SV_StartBug>  offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags ,  <S2SV_EndBug>  NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string ; callback_args . context = context ; callback_args . data = data ; callback_args .",
    "beam_candidates": [
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModEnd>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModEnd>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  flags , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModEnd>  offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModEnd>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModEnd>  offset , offset ,  <S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  , offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , data + offset , data_size -",
      "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -"
    ],
    "final_prediction": "<S2SV_ModStart>  offset , offset , offset ,  <S2SV_ModStart>  offset , offset , NULL  <S2SV_ModStart>  offset , offset , data + offset , data_size -",
    "correct_solution": "<S2SV_ModStart>  offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  offset , offset ,  <S2SV_ModEnd>  flags , NULL  <S2SV_ModStart>  , data + offset , data_size -",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-200 static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , AVDictionary * opts , AVDictionary * opts2 , int * is_http ) { HLSContext * c = s -> priv_data ; AVDictionary * tmp = NULL ; const char * proto_name = NULL ; int ret ; av_dict_copy ( & tmp , opts , 0 ) ; av_dict_copy ( & tmp , opts2 , 0 ) ; if ( av_strstart ( url , \"crypto\" , NULL ) ) { if ( url [ 6 ] == '+' || url [ 6 ] == ':' ) proto_name = avio_find_protocol_name ( url + 7 ) ; } if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ; if ( ! proto_name ) return AVERROR_INVALIDDATA ;  <S2SV_StartBug>  if ( ! av_strstart ( proto_name , \"http\" , NULL ) && ! av_strstart ( proto_name , \"file\" , NULL ) )  <S2SV_EndBug>  return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ':' ) ; else if ( av_strstart ( url , \"crypto\" , NULL ) && ! strncmp ( proto_name , url + 7 , strlen ( proto_name ) ) && url [ 7 + strlen ( proto_name ) ] == ':' ) ; else if ( strcmp ( proto_name , \"file\" ) || ! strncmp ( url , \"file,\" , 5 ) ) return AVERROR_INVALIDDATA ; ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp ) ; if ( ret >= 0 ) { char * new_cookies = NULL ; if ( ! ( s -> flags & AVFMT_FLAG_CUSTOM_IO ) ) av_opt_get ( * pb , \"cookies\" , AV_OPT_SEARCH_CHILDREN , ( uint8_t * * ) & new_cookies ) ; if ( new_cookies ) { av_free ( c -> cookies ) ; c -> cookies = new_cookies ; } av_dict_set ( & opts , \"cookies\" , c -> cookies , 0 )",
    "beam_candidates": [
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"io\" ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"Error: <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , AV_LOG_ERROR , \"um\" ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" return AVERROR_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; } if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { ret = NULL ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { av_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { av_LOG_INVALIDDATA ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" return AVERROR_INVALIDDATA ; } else  <S2SV_ModStart>  ( s -> name , & name_name ) ; if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { ret = - 1 ; }  <S2SV_ModEnd>  if (",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if (  <S2SV_ModStart>  ) ) { if ( ! av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { av_log ( s -> avctx , \"Invalid <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return AVERROR_INVALIDDATA ; } if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"io\" ) ; return AVERROR_INVALIDDATA ; }  <S2SV_ModEnd>  if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , AV_LOG_ERROR , \"um\" ) ; return AVERROR_INVALIDDATA ; }  <S2SV_ModEnd>  if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; } if (",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"io\" ) ; return AVERROR_INVALIDDATA ; }  <S2SV_ModStart>  ) { if ( result == AV_LOG_ERROR ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Failed <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret == NULL ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Error: <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( ret ) ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModStart>  ) ; } else if ( ret ) { ret = - 1 ; goto out ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \" , AV_LOG_ERROR: <S2SV_ModEnd>  ) ; return - 1 ; }  <S2SV_ModStart>  ) ) { if ( ret == AVERROR_INVALIDDATA ) { ret = - 1 ; goto end ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> file ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; return - 1 ; }",
      "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"io\" ) ; return AVERROR_INVALIDDATA ; }  <S2SV_ModStart>  ) { if ( result == AV_LOG_ERROR ) { ret = - 1 ; }",
      "<S2SV_ModStart>  , s -> filesize == NULL || strncpy ( i + 1 ) ; if ( ! av_assert0 ( s -> value ) ) { av_log ( s , AV_LOG_ERROR , \"Invalid <S2SV_ModEnd>  ) ; } else"
    ],
    "final_prediction": "<S2SV_ModStart>  ( ret ) ; if ( ! s -> name_name ) { av_log ( s , \"io\" ) ; return AVERROR_INVALIDDATA ; }",
    "correct_solution": "<S2SV_ModStart>  ; if (  <S2SV_ModEnd>  av_strstart ( proto_name  <S2SV_ModStart>  ( proto_name , \"file\" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , \"ALL\" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , \"Filename <S2SV_blank> extension <S2SV_blank> of <S2SV_blank> \\\\\\'%s\\\\\\' <S2SV_blank> is <S2SV_blank> not <S2SV_blank> a <S2SV_blank> common <S2SV_blank> multimedia <S2SV_blank> extension, <S2SV_blank> blocked <S2SV_blank> for <S2SV_blank> security <S2SV_blank> reasons.\\\\n\" \"If <S2SV_blank> you <S2SV_blank> wish <S2SV_blank> to <S2SV_blank> override <S2SV_blank> this <S2SV_blank> adjust <S2SV_blank> allowed_extensions, <S2SV_blank> you <S2SV_blank> can <S2SV_blank> set <S2SV_blank> it <S2SV_blank> to <S2SV_blank> \\\\\\'ALL\\\\\\' <S2SV_blank> to <S2SV_blank> allow <S2SV_blank> all\\\\n\" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name ,  <S2SV_ModStart>  , NULL ) ) { ; } else  <S2SV_ModEnd>  return AVERROR_INVALIDDATA ;",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , \"Missing <S2SV_blank> descriptor <S2SV_blank> data\\\\n\" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , \"Zero <S2SV_blank> length <S2SV_blank> descriptor\\\\n\" ) ; return NULL ; }  <S2SV_StartBug>  while ( buflen > 0 ) {  <S2SV_EndBug>  union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , \"Found <S2SV_blank> union <S2SV_blank> header\\\\n\" ) ;  <S2SV_StartBug>  return union_desc ;  <S2SV_EndBug>  } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , \"Missing <S2SV_blank> CDC <S2SV_blank> union <S2SV_blank> descriptor\\\\n\" ) ; return NULL ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  , & buf -> bLength , sizeof ( * )",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & buflen ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) return - EINVAL",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buflen ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & buflen ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bNumEndpoints < 2 ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & buflen ) ; return - EIO ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & buflen ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_size = buf -> dev_size ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & buflen ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & buflen ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = - ENOMEM ; goto fail ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & buflen ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = - ENOMEM ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & bLength ) ; return - ENOMEM ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) { dev -> dev_err ( & buf ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buf -> bLength < 2 ) { dev -> dev_err ( & buflen ) ; return - EIO ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bNumEndpoints < 2 ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bNumEndpoints ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = - 1 ; goto fail ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } kfree ( & bLength <S2SV_ModStart>  ) ; return - 1 ;",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_size = buf -> dev_size ; }  <S2SV_ModStart>  -> bLength ) ; if ( ! buf ) return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( buf ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( buflen < 2 ) return - EINVAL ;",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( len < 2 ) { dev -> dev_err ( & buflen ) ; dev -> dev_size = min ( & bLength ) ; }  <S2SV_ModStart>  ) ; if ( ! buf ) { dev -> buf_size = - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bNumEndpoints ) ; return - 1 ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = kfree ( buf ) ; return - ENOMEM ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) return - EIO ;",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - EINVAL ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } else if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bNumEndpoints ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_size = buf -> dev_size ; }  <S2SV_ModStart>  -> bLength ) ; if ( ! buf ) return - EINVAL ;",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf ) return - EINVAL ;",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bLength ) ; return - EIO ; }",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> dev_err ( & buf -> dev , \"invalid <S2SV_ModStart>  bLength <S2SV_ModStart>  bLength <S2SV_ModStart>  bNumEndpoints < 2 ) ; } if ( buflen < 2 ) { dev -> dev_err <S2SV_ModStart>  bLength ) ; kfree ( & bNumEndpoints ) ; return - ENODEV",
      "<S2SV_ModStart>  , & buf -> size  <S2SV_ModStart>  bLength ) ; if ( ! buf ) { dev -> buflen = true ; }  <S2SV_ModStart>  bLength ) ; if ( ! buf -> bLength ) return - ENOMEM ;"
    ],
    "final_prediction": "<S2SV_ModStart>  , & buf -> bLength , sizeof ( * )",
    "correct_solution": "<S2SV_ModStart>  while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , \"Too <S2SV_blank> large <S2SV_blank> descriptor\\\\n\" ) ; return NULL ; }  <S2SV_ModEnd>  if ( union_desc  <S2SV_ModStart>  \"Found <S2SV_blank> union <S2SV_blank> header\\\\n\" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , \"Union <S2SV_blank> descriptor <S2SV_blank> to <S2SV_blank> short <S2SV_blank> (%d <S2SV_blank> vs <S2SV_blank> %zd\\\\n)\" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL  <S2SV_ModEnd>  ; } buflen",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL",
    "beam_candidates": [
      "<S2SV_ModStart>  ; if ( i < NCH ( n ) &&",
      "<S2SV_ModEnd>  ; if ( i < NCH ( n ) &&",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( i ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( i ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; if ( i < NCH ( CHILD ( n ) ) return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { c -> type_type ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; if ( i < NCH ( CHILD ( n ) ) return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { ch = 1 ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; } } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { i = 1 ; return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; if ( i < NCH ( i ) ) { i ++ i ; if ( i < NCH ( CHILD ( n ) ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { i = 1 ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; } if ( i < NCH ( CHILD ( n ) ) return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; if ( i < NCH ( CHILD ( n ) ) return NULL ; } } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; if ( i < NCH ( CHILD ( n ) ) { i ++ ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) return NULL ; } if (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH ( CHILD ( n ) ) { c -> type_comment ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { i ++ ; if ( i < NCH ( CHILD ( n ) ) ) { ch = 1 ; return NULL ; } }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) i += 1 ; break ; case NCH ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; }",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i += 1 ; break ; } if ( !",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) { - 1 ; goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) ; if ( ! arg -> type_comment ) goto error ; } else { i = NULL ; } if ( i < NCH ( CHILD ( n ) ) { kfree ( i ) ; return NULL ; } if ( i < NCH (",
      "<S2SV_ModStart>  ; if ( TYPE ( CHILD ( n , 1 ) ) == NULL ) { i += 1 ; break ; } if ( ! arg -> type_comment ) goto error ; } else { i += 1 ; } if ( CHILD ( n , i ) ) ; if ( ! arg -> type_comment ) goto error ; } for ( i = 0 ; i < NCH ( CHILD ( n ) ) { i ++ ; i ++ ; if ( !"
    ],
    "final_prediction": "<S2SV_ModStart>  ; if ( i < NCH ( n ) &&",
    "correct_solution": "<S2SV_ModStart>  ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1  <S2SV_ModEnd>  ; break ;  <S2SV_ModStart>  n ) && (  <S2SV_ModStart>  ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT )  <S2SV_ModStart>  += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , \"bare <S2SV_blank> * <S2SV_blank> has <S2SV_blank> associated <S2SV_blank> type <S2SV_blank> comment\" ) ; return NULL ; }  <S2SV_ModStart>  ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; }  <S2SV_ModEnd>  if ( i  <S2SV_ModStart>  ; i += 2 ; if ( TYPE ( CHILD ( n , i )",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-284 int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt ->",
    "beam_candidates": [
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModEnd>  if ( ctxt  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModEnd>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModEnd>  if ( ctxt  <S2SV_ModEnd>  ctxt -> _eip  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModEnd>  OpMask ) ;  <S2SV_ModEnd>  if ( ctxt  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return rc ;",
      "<S2SV_ModEnd>  OpMask ) ;  <S2SV_ModEnd>  if ( ctxt  <S2SV_ModEnd>  ctxt -> _eip  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  OpMask ) ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ;",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = X86EMUL_CONTINUE ;  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ;  <S2SV_ModStart>  -> _eip = assign_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt ,  <S2SV_ModStart>  OpMask ) ; if ( rc != X86EMUL_CONTINUE ) return rc ;",
      "<S2SV_ModEnd>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; ctxt -> _eip = ctxt -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip == NULL ) return rc =",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return ctxt",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( rc != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt ,  <S2SV_ModStart>  -> _eip , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return rc = assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  OpMask ) ; if ( rc != X86EMUL_CONTINUE ) return rc ;",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  OpMask ) ; if ( ctxt -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt ,  <S2SV_ModStart>  -> _eip ) ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return rc",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMEMUL_CONTINUE ) return assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  ctxt -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip == NULL ) return rc = assign_eip_near ( ctxt , ctxt -> _eip , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = X86EMUL_CONTINUE ;  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> _eip = assign_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt ,  <S2SV_ModStart>  ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt ,  <S2SV_ModStart>  OpMask ) ; if ( rc != X86EMUL_CONTINUE ) return assign_eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  OpMask ) ; if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_near ( ctxt , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , NULL , ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return assign_eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; ctxt -> _eip = ctxt -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return rc ;",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return ctxt -> _eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return X86EMUL_CONTINUE",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return assign_eip_near ( ctxt ,  <S2SV_ModEnd>  ) ; done",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc =  <S2SV_ModStart>  -> _eip ; if ( ctxt -> _eip != X86EMUL_CONTINUE ) return rc  <S2SV_ModStart>  -> _eip ; done :",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  , & EINVAL ) ; if ( rc != X86EMUL_CONTINUE ) return rc ;  <S2SV_ModStart>  -> _eip = assign_near ( ctxt , eip",
      "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> _eip  <S2SV_ModStart>  OpMask ) ; if ( rc != X86EMUL_CONTINUE ) return assign_eip"
    ],
    "final_prediction": "<S2SV_ModStart>  OpMask ) ;  <S2SV_ModStart>  -> _eip ; done :",
    "correct_solution": "<S2SV_ModStart>  ctxt -> rip_relative && likely ( ctxt -> memopp )",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-358 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ;  <S2SV_StartBug>  int is_udplite = IS_UDPLITE ( sk ) ;  <S2SV_EndBug>  int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) {  <S2SV_StartBug>  if ( udp_lib_checksum_complete ( skb ) )  <S2SV_EndBug>  goto csum_copy_err ; }  <S2SV_StartBug>  if ( skb_csum_unnecessary ( skb ) )  <S2SV_EndBug>  err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peek",
    "beam_candidates": [
      "<S2SV_ModStart>  slow ) ; cond_resched ( )  <S2SV_ModStart>  ) ; msg -> msg_namelen = sizeof ( * sin6 ) ;",
      "<S2SV_ModEnd>  slow ) ; cond_resched ( )  <S2SV_ModStart>  ) ; msg -> msg_namelen = sizeof ( * sin6 ) ;",
      "<S2SV_ModStart>  slow ) ; cond_resched ( )  <S2SV_ModEnd>  ; msg ->  <S2SV_ModStart>  ) ; msg_namelen = sizeof ( * sin6 ) ;",
      "<S2SV_ModStart>  ( sk ) ; bool checksum_valid = false  <S2SV_ModStart>  partial_cov ) { checksum_valid = !  <S2SV_ModEnd>  udp_lib_complete ( skb  <S2SV_ModStart>  ( skb ) ; if ( ! checksum_valid  <S2SV_ModStart>  } if ( checksum_valid ||",
      "<S2SV_ModStart>  ( sk ) ; bool checksum_valid = false  <S2SV_ModStart>  partial_cov ) { checksum_valid = !  <S2SV_ModStart>  ( skb ) ; if ( ! checksum_valid  <S2SV_ModStart>  } if ( checksum_valid ||",
      "<S2SV_ModStart>  slow ) ; bool slow  <S2SV_ModStart>  slow ) ; cond_resched ( )  <S2SV_ModStart>  ) ; msg -> msg_namelen = sizeof ( * sin6 ) ;",
      "<S2SV_ModStart>  slow ) ; cond_resched ( )  <S2SV_ModStart>  ) ; msg -> msg_namelen = 0 ;",
      "<S2SV_ModStart>  ( sk ) ; bool checksum_valid = false  <S2SV_ModStart>  partial_cov ) { checksum_valid = !  <S2SV_ModEnd>  udp_lib_checksum_complete ( skb  <S2SV_ModStart>  ( skb ) ; if ( ! checksum_valid  <S2SV_ModStart>  } if ( checksum_valid ||"
    ],
    "final_prediction": "<S2SV_ModStart>  ( sk ) ; bool checksum_valid = false  <S2SV_ModStart>  partial_cov ) { checksum_valid = !  <S2SV_ModEnd>  udp_lib_checksum_complete ( skb  <S2SV_ModStart>  ( skb ) ; if ( ! checksum_valid  <S2SV_ModStart>  } if ( checksum_valid ||",
    "correct_solution": "<S2SV_ModStart>  ( sk ) ; bool checksum_valid = false  <S2SV_ModStart>  partial_cov ) { checksum_valid = !  <S2SV_ModEnd>  udp_lib_checksum_complete ( skb  <S2SV_ModStart>  ( skb ) ; if ( ! checksum_valid  <S2SV_ModStart>  } if ( checksum_valid ||",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-787 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) )  <S2SV_StartBug>  return ( 0 ) ;  <S2SV_EndBug>  tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  0 ) ; if ( !  <S2SV_ModStart>  ( tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_mode ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_mode ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_mode ) ) return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" ,  <S2SV_ModEnd>  ) ) return 0",
      "<S2SV_ModStart>  0 ) ; if ( !  <S2SV_ModStart>  , tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata  <S2SV_ModStart>  , tif_clientdata , & tif_size ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , 4 ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata  <S2SV_ModStart>  , tif_clientdata , tif_size ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata ) ; return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , tif -> tif_clientdata , \"%s\" ,  <S2SV_ModEnd>  ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_mode ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata , tif_clientdata ) ; return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_mode ) ) return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata , 4 ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata ) ) return 0 ;  <S2SV_ModStart>  ) ; return 1 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_mode ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata , tif_size ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , \"(cc%(4 ) ) return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , tif_clientdata , & tif_clientdata -> tif_clientdata , 0 ) ) return 0 ;",
      "<S2SV_ModEnd>  ; if ( !  <S2SV_ModStart>  ( tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_clientdata ) ; return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata , tif_clientdata -> tif_clientdata , tif_clientdata ) ; return 0 ;",
      "<S2SV_ModStart>  0 ) ; if ( !  <S2SV_ModStart>  ( tif -> tif_clientdata , \"%s\" ,  <S2SV_ModEnd>  ) ) return 0",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_mode ) { TIFFError ( tif_clientdata , \"Invalid <S2SV_ModStart>  ) ; return 0 ; }",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_clientdata -> tif_mode ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_clientdata -> tif_mode ) ; return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata , & tif_clientdata -> tif_clientdata , tif_clientdata ) ; return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata ,  <S2SV_ModStart>  ) ) return 0",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_mode ) { TIFFError ( tif_clientdata , \"Invalid <S2SV_ModStart>  ) ) ; return 0 ; }",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata ,  <S2SV_ModEnd>  ) ) return 0",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata ,  <S2SV_ModStart>  ) ) return 0 ;",
      "<S2SV_ModStart>  ; if ( !  <S2SV_ModStart>  ( tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_read ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_size ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata , tif_read ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata , tif_clientdata -> tif_mode ) ) return 0 ;",
      "<S2SV_ModStart>  0 ) { if ( ! tif -> tif_mode ) { TIFFError ( tif_clientdata , \"Invalid <S2SV_ModStart>  , tif_clientdata\" , \"%s\" , tif_clientdata -> tif_type ) ; return 0 ; }",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata , 4 ) ) return 0 ;",
      "<S2SV_ModStart>  , 0 ) ; if ( !  <S2SV_ModStart>  , tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  ) ) return 0",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata ) ; return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( !  <S2SV_ModStart>  , cc -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata  <S2SV_ModStart>  ) ; return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata  <S2SV_ModStart>  , tif_clientdata ) ) return 0 ;",
      "<S2SV_null> <S2SV_null> static int  <S2SV_ModStart>  0 ) { if ( ! tif -> tif_clientdata , \"%s\" , tif_clientdata -> tif_clientdata . tif_mode ) ) return 0 ;"
    ],
    "final_prediction": "<S2SV_ModStart>  0 ) ; if ( !  <S2SV_ModStart>  ( tif -> tif_clientdata , \"%s\" ,  <S2SV_ModStart>  0 ) ) return 0",
    "correct_solution": "<S2SV_ModStart>  tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ;  <S2SV_ModStart>  0 ) ; }",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-20 static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ;  <S2SV_StartBug>  ASSERT ( redir_index < IOAPIC_NUM_PINS ) ;  <S2SV_EndBug>   <S2SV_StartBug>  redir_content = ioapic -> redirtbl [ redir_index ] . bits ;  <S2SV_EndBug>  result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
      "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModEnd>  ( redir_index <  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
      "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModEnd>  redir_content = ioapic  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
      "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModStart>  ] . bits ; else redir_content = ioapic  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
      "<S2SV_ModEnd>  u64 redir_content ; if  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
      "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModEnd>  ( redir_index <  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModEnd>  redir_content = ioapic  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL"
    ],
    "final_prediction": "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModEnd>  ( redir_index <  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModEnd>  redir_content = ioapic  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
    "correct_solution": "<S2SV_ModStart>  u64 redir_content ; if  <S2SV_ModEnd>  ( redir_index <  <S2SV_ModStart>  < IOAPIC_NUM_PINS )  <S2SV_ModEnd>  redir_content = ioapic  <S2SV_ModStart>  ] . bits ; else redir_content = ~ 0ULL",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-119 static void update_golden_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( cm -> refresh_golden_frame ) { if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) { cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ; } cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; }  <S2SV_StartBug>  vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ;  <S2SV_EndBug>  cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cm -> refresh_golden_frame = 0 ; cpi -> frames_since_golden = 0 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) { cpi -> source_alt_ref_pending = 1 ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; } if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ; if ( cp",
    "beam_candidates": [
      "<S2SV_ModStart>  frames_till_gf_update_due ; } memset  <S2SV_ModStart>  ) ; } memset  <S2SV_ModEnd>  ( cpi ->",
      "<S2SV_ModStart>  frames_till_gf_update_due ; } memset  <S2SV_ModStart>  ) ; } memset  <S2SV_ModStart>  ) ; } memset  <S2SV_ModEnd>  ( cpi ->",
      "<S2SV_ModStart>  frames_till_gf_update_due ; } memset  <S2SV_ModEnd>  ( cpi ->"
    ],
    "final_prediction": "<S2SV_ModStart>  frames_till_gf_update_due ; } memset  <S2SV_ModEnd>  ( cpi ->",
    "correct_solution": "<S2SV_ModStart>  frames_till_gf_update_due ; } memset  <S2SV_ModEnd>  ( cpi ->",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_blank> parameter <S2SV_blank> must <S2SV_blank> be <S2SV_blank> greater <S2SV_blank> than <S2SV_blank> 0\" ) ; RETURN_FALSE ; }  <S2SV_StartBug>  Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;  <S2SV_EndBug>  Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length\" ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModEnd>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE ) ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , E_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE <S2SV_ModEnd>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN\" ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_WARNING , \"Length <S2SV_ModStart>  ) ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , \"Length <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , E_WARNING , \"Length <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length ( NULL TSRMLS_WARNING <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length ( NULL TSRMLS_CC <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_WARNING <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length\" ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_WARNING , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  RETURN_FALSE ; } else { php_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE NULL TSRMLS_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN_FALSE - 1 ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length < INT_MAX ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModEnd>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  RETURN <S2SV_ModEnd>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  TSRMLS_WARNING <S2SV_ModStart>  RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; RETURN_FALSE ; }",
      "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_CC , E_WARNING , \"Length <S2SV_ModStart>  ) ; }"
    ],
    "final_prediction": "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_ModEnd>  ) ; RETURN_FALSE ; }",
    "correct_solution": "<S2SV_ModStart>  RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length <S2SV_blank> parameter <S2SV_blank> must <S2SV_blank> be <S2SV_blank> no <S2SV_blank> more <S2SV_blank> than <S2SV_blank> %d\" , INT_MAX ) ; RETURN_FALSE ; }",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-400 static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event ,  <S2SV_StartBug>  mmap_event -> event_id . header . size , 0 , 0 ) ;  <S2SV_EndBug>  if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  header . size  <S2SV_ModStart>  , 0 )",
      "<S2SV_ModStart>  size , 0  <S2SV_ModStart>  ) ; if",
      "<S2SV_ModEnd>  size , 0  <S2SV_ModStart>  ) ; if",
      "<S2SV_ModStart>  header . size  <S2SV_ModEnd>  , 0 )"
    ],
    "final_prediction": "<S2SV_ModStart>  header . size  <S2SV_ModEnd>  , 0 )",
    "correct_solution": "<S2SV_ModStart>  header . size  <S2SV_ModEnd>  , 0 )",
    "is_correct": 1
  },
  {
    "raw_input": "CWE-284 static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ;  <S2SV_StartBug>  if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) {  <S2SV_EndBug>  error = - EOPNOTSUPP ; goto out_errno ;  <S2SV_StartBug>  }  <S2SV_EndBug>  error = fh_want_write ( fh ) ; if ( error )  <S2SV_StartBug>  goto out_errno ;  <S2SV_EndBug>  error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ;  <S2SV_StartBug>  error = inode -> i_op -> set_acl ( inode , argp -> acl_default ,  <S2SV_EndBug>  ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh )  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_access ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModEnd>  goto out_errno ;  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default )  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default )  <S2SV_ModStart>  argp -> acl_default ) goto out_drop_lock ; fh_unlock ( fh )  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default )  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , ACL_TYPE_ACCESS  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  argp -> acl_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  fh_drop_write ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_write ( fh",
      "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default )  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModStart>  return nfserr ; out_drop_drop_write ( fh"
    ],
    "final_prediction": "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModStart>  argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
    "correct_solution": "<S2SV_ModStart>  fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error )  <S2SV_ModEnd>  goto out_errno ;  <S2SV_ModStart>  goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access  <S2SV_ModEnd>  ) ; if  <S2SV_ModStart>  error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT  <S2SV_ModEnd>  , argp ->  <S2SV_ModStart>  argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ;  <S2SV_ModEnd>  fh_drop_write ( fh",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-190  <S2SV_StartBug>  jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len )  <S2SV_EndBug>  { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_ulonglong  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  } if ( JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  ; } if ( jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModEnd>  buf [ JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar )",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  error ) { jas_uchar",
      "<S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  error ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  ; jas_uchar ( jas_uchar",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModEnd>  , jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  ; } if ( jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  error ) { jas_uchar  <S2SV_ModStart>  }",
      "<S2SV_ModStart>  JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  long n ; jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModEnd>  , jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>",
      "<S2SV_ModStart>  cmsg ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  error ) { jas_eprintf ( \"negative <S2SV_ModStart>  }",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar",
      "<S2SV_ModStart>  len ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  bufsize ) ; if ( ! jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  bufsize ) ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_CAST ( jas_uchar  <S2SV_ModStart>",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  bufsize ) ; jas_uchar",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  jas_uchar ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar )",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  jas_uchar ( bufsize , ( JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar )",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModEnd>  , (",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  jas_uchar ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>",
      "<S2SV_ModStart>  int m ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModEnd>  , jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  bufsize ) ; if ( jas_uchar",
      "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  int i ; jas_uchar  <S2SV_ModStart>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  jas_uchar ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar",
      "<S2SV_ModEnd>  JAS_CAST ( jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModStart>  in ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar  <S2SV_ModStart>  } if ( ! jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModStart>  jas_uchar ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar",
      "<S2SV_ModEnd>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
      "<S2SV_ModEnd>  bufsize ) { jas_uchar  <S2SV_ModStart>  } if ( jas_uchar  <S2SV_ModStart>  : JAS_CAST ( jas_uchar  <S2SV_ModEnd>  , jas_uchar"
    ],
    "final_prediction": "<S2SV_ModStart>  val ) { jas_uchar  <S2SV_ModStart>  * buf ; jas_uchar",
    "correct_solution": "<S2SV_ModStart>  * jas_iccprof_createfrombuf ( jas_uchar  <S2SV_ModEnd>  * buf ,",
    "is_correct": 0
  },
  {
    "raw_input": "CWE-200 int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ;  <S2SV_StartBug>  pvc . sap_family = AF_ATMPVC ;  <S2SV_EndBug>  pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc -> dev -> ops -> getsockopt ) return - EINVAL ; return vcc -> dev -> ops -> getsockopt ( vcc , level , optname , optval , len ) ; }\n",
    "beam_candidates": [
      "<S2SV_ModStart>  - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;"
    ],
    "final_prediction": "<S2SV_ModStart>  - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;",
    "correct_solution": "<S2SV_ModStart>  - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;",
    "is_correct": 1
  }
]