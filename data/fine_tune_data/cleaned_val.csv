cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-119,"CWE-119 ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { size_t ss = CDF_SHORT_SEC_SIZE ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > CDF_SEC_SIZE ( h ) * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_StartBug> pos , CDF_SEC_SIZE ( h ) * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
","<S2SV_ModStart> if ( pos + len <S2SV_ModStart> ""u\\n"" , pos + len
",file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z
CWE-119,"CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , ""excluded_channels():<S2SV_blank>exclude_mask"" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , ""excluded_channels():<S2SV_blank>additional_excluded_chns"" ) ) ) == 1 ) { <S2SV_StartBug> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <S2SV_EndBug> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , ""excluded_channels():<S2SV_blank>exclude_mask"" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }
","<S2SV_ModStart> 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
",knik0@faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174,CVE-2019-15296,https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174,2019-08-21T07:15Z
CWE-119,"CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , <S2SV_EndBug> va_list args ) { <S2SV_StartBug> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <S2SV_EndBug> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { vpx_decrypt_init <S2SV_ModEnd> * init = <S2SV_ModStart> ( args , vpx_decrypt_init <S2SV_ModEnd> * ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-295,"CWE-295 <S2SV_StartBug> void unbind_ports ( void ) { <S2SV_EndBug> SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; <S2SV_StartBug> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_EndBug> opt = service_options . next ; <S2SV_StartBug> service_options . next = NULL ; <S2SV_EndBug> service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , ""Unbinding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } <S2SV_StartBug> if ( opt -> ctx ) <S2SV_EndBug> SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , ""Service<S2SV_blank>[%s]<S2SV_blank>closed"" , opt -> servname ) ; <S2SV_StartBug> { <S2SV_EndBug> SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT <S2SV_ModStart> 1 ) ; for ( <S2SV_ModEnd> opt = service_options <S2SV_ModStart> . next ; opt ; opt = opt -> next <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> 0 ; } <S2SV_ModEnd> s_log ( LOG_DEBUG <S2SV_ModStart> servname ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-415,"CWE-415 SPL_METHOD ( SplDoublyLinkedList , offsetSet ) { zval * zindex , * value ; spl_dllist_object * intern ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""zz"" , & zindex , & value ) == FAILURE ) { return ; } intern = Z_SPLDLLIST_P ( getThis ( ) ) ; if ( Z_TYPE_P ( zindex ) == IS_NULL ) { spl_ptr_llist_push ( intern -> llist , value ) ; } else { zend_long index ; spl_ptr_llist_element * element ; index = spl_offset_convert_to_long ( zindex ) ; if ( index < 0 || index >= intern -> llist -> count ) { <S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ; return ; } element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ; if ( element != NULL ) { if ( intern -> llist -> dtor ) { intern -> llist -> dtor ( element ) ; } zval_ptr_dtor ( & element -> data ) ; ZVAL_COPY_VALUE ( & element -> data , value ) ; if ( intern -> llist -> ctor ) { intern -> llist -> ctor ( element ) ; } } else { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid"" , 0 ) ; return ; } } }
","<S2SV_ModStart> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException
",php@php-src/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5,CVE-2016-3132,https://github.com/php/php-src/commit/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5?w=1,2016-08-07T10:59Z
CWE-000,"CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ; <S2SV_StartBug> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <S2SV_EndBug> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }
","<S2SV_ModStart> -> o_arg . fmode , data -> o_arg . open_flags <S2SV_ModEnd> ) ) goto
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-200,"CWE-200 static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p,<S2SV_blank>opt<S2SV_blank>%d"" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : { <S2SV_StartBug> struct hci_filter * f = & hci_pi ( sk ) -> filter ; <S2SV_EndBug> uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
",torvalds@linux/e15ca9a0ef9a86f0477530b0f44a725d67f889ee,CVE-2012-6544,https://github.com/torvalds/linux/commit/e15ca9a0ef9a86f0477530b0f44a725d67f889ee,2013-03-15T20:55Z
CWE-119,"CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }
","
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-119,"CWE-119 void vp8_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
","<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknown<S2SV_blank>format<S2SV_blank>`%s\'"" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , "","" ) ) != NULL ) { if ( * p == '\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Missing<S2SV_blank>number"" ) ; return ARCHIVE_WARN ; } <S2SV_StartBug> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <S2SV_EndBug> <S2SV_StartBug> if ( argc > MAX_PACK_ARGS ) { <S2SV_EndBug> archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Not<S2SV_blank>enough<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""%s"" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }
","<S2SV_ModStart> ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Too<S2SV_blank>many<S2SV_blank>arguments"" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> p ) ; <S2SV_ModEnd> } if (
",libarchive@libarchive/a550daeecf6bc689ade371349892ea17b5b97c77,CVE-2016-4301,https://github.com/libarchive/libarchive/commit/a550daeecf6bc689ade371349892ea17b5b97c77,2016-09-21T14:25Z
CWE-125,"CWE-125 int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , ""\\n"" , 1 ) ; return 1 ; }
","<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , ""%s\\n"" , obj_txt <S2SV_ModEnd> ) ; return
",openssl@openssl/0ed26acce328ec16a3aa635f1ca37365e8c7403a,CVE-2016-2180,https://github.com/openssl/openssl/commit/0ed26acce328ec16a3aa635f1ca37365e8c7403a,2016-08-01T02:59Z
CWE-787,"CWE-787 int main ( int argc , char * argv [ ] ) { int32_t ret = GPMF_OK ; GPMF_stream metadata_stream , * ms = & metadata_stream ; double metadatalength ; uint32_t * payload = NULL ; if ( argc != 2 ) { printf ( ""usage:<S2SV_blank>%s<S2SV_blank><file_with_GPMF>\\n"" , argv [ 0 ] ) ; return - 1 ; } size_t mp4 = OpenMP4Source ( argv [ 1 ] , MOV_GPMF_TRAK_TYPE , MOV_GPMF_TRAK_SUBTYPE ) ; <S2SV_StartBug> metadatalength = GetDuration ( mp4 ) ; <S2SV_EndBug> if ( metadatalength > 0.0 ) { uint32_t index , payloads = GetNumberPayloads ( mp4 ) ; # if 1 if ( payloads == 1 ) { uint32_t payloadsize = GetPayloadSize ( mp4 , 0 ) ; payload = GetPayload ( mp4 , payload , 0 ) ; if ( payload == NULL ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Validate ( ms , GPMF_RECURSE_LEVELS ) ; if ( GPMF_OK != ret ) { printf ( ""Invalid<S2SV_blank>Structure\\n"" ) ; goto cleanup ; } GPMF_ResetState ( ms ) ; do { PrintGPMF ( ms ) ; } while ( GPMF_OK == GPMF_Next ( ms , GPMF_RECURSE_LEVELS ) ) ; GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif for ( index = 0 ; index < payloads ; index ++ ) { uint32_t payloadsize = GetPayloadSize ( mp4 , index ) ; <S2SV_StartBug> float in = 0.0 , out = 0.0 ; <S2SV_EndBug> payload = GetPayload ( mp4 , payload , index ) ; if ( payload == NULL ) goto cleanup ; ret = GetPayloadTime ( mp4 , index , & in , & out ) ; if ( ret != GPMF_OK ) goto cleanup ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; # if 1 if ( index == 0 ) { ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; while ( GPMF_OK == ret ) { ret = GPMF_SeekToSamples ( ms ) ; if ( GPMF_OK == ret ) { uint32_t key = GPMF_Key ( ms ) ; GPMF_SampleType type = GPMF_Type ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; if ( samples ) { printf ( ""<S2SV_blank><S2SV_blank>STRM<S2SV_blank>of<S2SV_blank>%c%c%c%c<S2SV_blank>"" , PRINTF_4CC ( key ) ) ; if ( type == GPMF_TYPE_COMPLEX ) { GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TYPE , GPMF_CURRENT_LEVEL ) ) { char tmp [ 64 ] ; char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int size = GPMF_RawDataSize ( & find_stream ) ; if ( size < sizeof ( tmp ) ) { memcpy ( tmp , data , size ) ; tmp [ size ] = 0 ; printf ( ""of<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>"" , tmp ) ; } } } else { printf ( ""of<S2SV_blank>type<S2SV_blank>%c<S2SV_blank>"" , type ) ; } printf ( ""with<S2SV_blank>%d<S2SV_blank>sample%s<S2SV_blank>"" , samples , samples > 1 ? ""s"" : """" ) ; if ( elements > 1 ) printf ( ""--<S2SV_blank>%d<S2SV_blank>elements<S2SV_blank>per<S2SV_blank>sample"" , elements ) ; printf ( ""\\n"" ) ; } ret = GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ; } else { if ( ret == GPMF_ERROR_BAD_STRUCTURE ) { ret = GPMF_Next ( ms , GPMF_CURRENT_LEVEL ) ; } } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif # if 1 if ( index == 0 ) { if ( GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPS5"" ) , GPMF_RECURSE_LEVELS ) || GPMF_OK == GPMF_FindNext ( ms , STR2FOURCC ( ""GPRI"" ) , GPMF_RECURSE_LEVELS ) ) { uint32_t key = GPMF_Key ( ms ) ; uint32_t samples = GPMF_Repeat ( ms ) ; uint32_t elements = GPMF_ElementsInStruct ( ms ) ; uint32_t buffersize = samples * elements * sizeof ( double ) ; GPMF_stream find_stream ; double * ptr , * tmpbuffer = malloc ( buffersize ) ; char units [ 10 ] [ 6 ] = { """" } ; uint32_t unit_samples = 1 ; printf ( ""MP4<S2SV_blank>Payload<S2SV_blank>time<S2SV_blank>%.3f<S2SV_blank>to<S2SV_blank>%.3f<S2SV_blank>seconds\\n"" , in , out ) ; if ( tmpbuffer && samples ) { uint32_t i , j ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_SI_UNITS , GPMF_CURRENT_LEVEL ) || GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_UNITS , GPMF_CURRENT_LEVEL ) ) { char * data = ( char * ) GPMF_RawData ( & find_stream ) ; int ssize = GPMF_StructSize ( & find_stream ) ; unit_samples = GPMF_Repeat ( & find_stream ) ; for ( i = 0 ; i < unit_samples ; i ++ ) { memcpy ( units [ i ] , data , ssize ) ; units [ i ] [ ssize ] = 0 ; data += ssize ; } } GPMF_ScaledData ( ms , tmpbuffer , buffersize , 0 , samples , GPMF_TYPE_DOUBLE ) ; ptr = tmpbuffer ; for ( i = 0 ; i < samples ; i ++ ) { printf ( ""%c%c%c%c<S2SV_blank>"" , PRINTF_4CC ( key ) ) ; for ( j = 0 ; j < elements ; j ++ ) printf ( ""%.3f%s,<S2SV_blank>"" , * ptr ++ , units [ j % unit_samples ] ) ; printf ( ""\\n"" ) ; } free ( tmpbuffer ) ; } } GPMF_ResetState ( ms ) ; printf ( ""\\n"" ) ; } # endif } # if 1 while ( GPMF_OK == GPMF_FindNext ( ms , GPMF_KEY_STREAM , GPMF_RECURSE_LEVELS ) ) { if ( GPMF_OK == GPMF_SeekToSamples ( ms ) ) { <S2SV_StartBug> uint32_t fourcc = GPMF_Key ( ms ) ; <S2SV_EndBug> <S2SV_StartBug> double rate = GetGPMFSampleRate ( mp4 , fourcc , GPMF_SAMPLE_RATE_PRECISE ) ; <S2SV_EndBug> <S2SV_StartBug> printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz\\n"" , PRINTF_4CC ( fourcc ) , rate ) ; <S2SV_EndBug> } } # endif cleanup : if ( payload ) FreePayload ( payload ) ; payload = NULL ; CloseSource ( mp4 ) ; } return ret ; }
","<S2SV_ModStart> MOV_GPMF_TRAK_SUBTYPE ) ; if ( mp4 == 0 ) { printf ( ""error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n"" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> index ) ; double <S2SV_ModEnd> in = 0.0 <S2SV_ModStart> ) ) { double in = 0.0 , out = 0.0 ; <S2SV_ModStart> fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( ""%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n"" <S2SV_ModEnd> , PRINTF_4CC ( <S2SV_ModStart> ) , rate , in , out
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z
CWE-119,"CWE-119 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; <S2SV_StartBug> context . Xtogo = i -> width ; <S2SV_EndBug> context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p32 = context . line_p . p32 + i -> posX ; # else context . frbuff_p . p32 = i -> parent -> frbuff . p32 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } # endif npix = ( long ) i -> width * i -> height ; flags = GetByte ( i -> parent ) ; i -> interlaced = ( flags & 64 ) >> 6 ; context . pass = i -> interlaced ? 1 : 0 ; i -> sort_flag = ( flags & 32 ) >> 5 ; i -> localpalbits = ( flags & 7 ) + 1 ; if ( flags & 128 ) { int k ; int localpalsize = 1 << i -> localpalbits ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Local<S2SV_blank>palette\\n"" ) ; # endif i -> palette = ( struct ngiflib_rgb * ) ngiflib_malloc ( sizeof ( struct ngiflib_rgb ) * localpalsize ) ; for ( k = 0 ; k < localpalsize ; k ++ ) { i -> palette [ k ] . r = GetByte ( i -> parent ) ; i -> palette [ k ] . g = GetByte ( i -> parent ) ; i -> palette [ k ] . b = GetByte ( i -> parent ) ; } # ifdef NGIFLIB_ENABLE_CALLBACKS if ( i -> parent -> palette_cb ) i -> parent -> palette_cb ( i -> parent , i -> palette , localpalsize ) ; # endif } else { i -> palette = i -> parent -> palette ; i -> localpalbits = i -> parent -> imgbits ; } i -> ncolors = 1 << i -> localpalbits ; i -> imgbits = GetByte ( i -> parent ) ; # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) { if ( i -> interlaced ) fprintf ( i -> parent -> log , ""interlaced<S2SV_blank>"" ) ; fprintf ( i -> parent -> log , ""img<S2SV_blank>pos(%hu,%hu)<S2SV_blank>size<S2SV_blank>%hux%hu<S2SV_blank>palbits=%hhu<S2SV_blank>imgbits=%hhu<S2SV_blank>ncolors=%hu\\n"" , i -> posX , i -> posY , i -> width , i -> height , i -> localpalbits , i -> imgbits , i -> ncolors ) ; } # endif if ( i -> imgbits == 1 ) { i -> imgbits = 2 ; } clr = 1 << i -> imgbits ; eof = clr + 1 ; free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; stackp = stack_top = ab_stack + 4096 ; context . restbits = 0 ; context . restbyte = 0 ; context . lbyte = 0 ; for ( ; ; ) { act_code = GetGifWord ( i , & context ) ; if ( act_code == eof ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""End<S2SV_blank>of<S2SV_blank>image<S2SV_blank>code\\n"" ) ; # endif return 0 ; } if ( npix == 0 ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""assez<S2SV_blank>de<S2SV_blank>pixels,<S2SV_blank>On<S2SV_blank>se<S2SV_blank>casse<S2SV_blank>!\\n"" ) ; # endif return 1 ; } if ( act_code == clr ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent && i -> parent -> log ) fprintf ( i -> parent -> log , ""Code<S2SV_blank>clear<S2SV_blank>(free=%hu)<S2SV_blank>npix=%ld\\n"" , free , npix ) ; # endif free = clr + 2 ; context . nbbit = i -> imgbits + 1 ; context . max = clr + clr - 1 ; act_code = GetGifWord ( i , & context ) ; casspecial = ( u8 ) act_code ; old_code = act_code ; WritePixel ( i , & context , casspecial ) ; npix -- ; } else { read_byt = act_code ; if ( act_code >= free ) { * ( -- stackp ) = casspecial ; act_code = old_code ; } while ( act_code > clr ) { * ( -- stackp ) = ab_suffx [ act_code ] ; act_code = ab_prfx [ act_code ] ; } casspecial = ( u8 ) act_code ; * ( -- stackp ) = casspecial ; WritePixels ( i , & context , stackp , stack_top - stackp ) ; npix -= ( stack_top - stackp ) ; stackp = stack_top ; if ( free < 4096 ) { ab_prfx [ free ] = old_code ; ab_suffx [ free ] = ( u8 ) act_code ; free ++ ; if ( ( free > context . max ) && ( context . nbbit < 12 ) ) { context . nbbit ++ ; context . max += context . max + 1 ; } } old_code = read_byt ; } } return 0 ; }
","<S2SV_ModStart> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n"" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n"" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n"" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
",miniupnp@ngiflib/b588a2249c7abbfc52173e32ee11d6facef82f89,CVE-2018-10677,https://github.com/miniupnp/ngiflib/commit/b588a2249c7abbfc52173e32ee11d6facef82f89,2018-05-02T19:29Z
CWE-000,"CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; <S2SV_StartBug> cur_logical ++ ; <S2SV_EndBug> pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }
","<S2SV_ModStart> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-362,"CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , ""tty_ioctl"" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }
","<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
",torvalds@linux/5c17c861a357e9458001f021a7afa7aab9937439,CVE-2016-0723,https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439,2016-02-08T03:59Z
CWE-125,"CWE-125 struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; <S2SV_StartBug> uint32_t track_size ; <S2SV_EndBug> uint8_t * * tracks ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 4 ; if ( tmp_val != 6 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , NULL , 0 ) ; return ( NULL ) ; } tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val > 2 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } midi_type = tmp_val ; tmp_val = * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size -= 2 ; if ( tmp_val < 1 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(no<S2SV_blank>tracks)"" , 0 ) ; return ( NULL ) ; } no_tracks = tmp_val ; if ( ( midi_type == 0 ) && ( no_tracks > 1 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , ""(expected<S2SV_blank>1<S2SV_blank>track<S2SV_blank>for<S2SV_blank>type<S2SV_blank>0<S2SV_blank>midi<S2SV_blank>file,<S2SV_blank>found<S2SV_blank>more)"" , 0 ) ; return ( NULL ) ; } divisions = * midi_data ++ << 8 ; divisions |= * midi_data ++ ; midi_size -= 2 ; if ( divisions & 0x00008000 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_INVALID , NULL , 0 ) ; return ( NULL ) ; } samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( mdi , divisions ) ; tracks = malloc ( sizeof ( uint8_t * ) * no_tracks ) ; <S2SV_StartBug> track_delta = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_EndBug> track_end = malloc ( sizeof ( uint8_t ) * no_tracks ) ; running_event = malloc ( sizeof ( uint8_t ) * no_tracks ) ; smallest_delta = 0xffffffff ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( midi_size < 8 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } if ( memcmp ( midi_data , ""MTrk"" , 4 ) != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>track<S2SV_blank>header)"" , 0 ) ; goto _end ; } midi_data += 4 ; midi_size -= 4 ; <S2SV_StartBug> track_size = * midi_data ++ << 24 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 16 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ << 8 ; <S2SV_EndBug> <S2SV_StartBug> track_size |= * midi_data ++ ; <S2SV_EndBug> midi_size -= 4 ; <S2SV_StartBug> if ( midi_size < track_size ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( track_size < 3 ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(bad<S2SV_blank>track<S2SV_blank>size)"" , 0 ) ; goto _end ; } <S2SV_StartBug> if ( ( midi_data [ track_size - 3 ] != 0xFF ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 2 ] != 0x2F ) <S2SV_EndBug> <S2SV_StartBug> || ( midi_data [ track_size - 1 ] != 0x00 ) ) { <S2SV_EndBug> _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(missing<S2SV_blank>EOT)"" , 0 ) ; goto _end ; } tracks [ i ] = midi_data ; <S2SV_StartBug> midi_data += track_size ; <S2SV_EndBug> <S2SV_StartBug> midi_size -= track_size ; <S2SV_EndBug> track_end [ i ] = 0 ; running_event [ i ] = 0 ; track_delta [ i ] = 0 ; while ( * tracks [ i ] > 0x7F ) { track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; tracks [ i ] ++ ; <S2SV_StartBug> } <S2SV_EndBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> if ( midi_type == 1 ) { if ( track_delta [ i ] < smallest_delta ) { smallest_delta = track_delta [ i ] ; } } else { if ( i == 0 ) smallest_delta = track_delta [ i ] ; } } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; if ( midi_type == 1 ) { while ( end_of_tracks != no_tracks ) { smallest_delta = 0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { if ( track_end [ i ] ) continue ; if ( track_delta [ i ] ) { track_delta [ i ] -= subtract_delta ; if ( track_delta [ i ] ) { if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } continue ; } } do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { end_of_tracks ++ ; track_end [ i ] = 1 ; tracks [ i ] += 3 ; <S2SV_StartBug> goto NEXT_TRACK ; <S2SV_EndBug> } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> if ( * tracks [ i ] > 0x7f ) { <S2SV_EndBug> do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> } while ( ! track_delta [ i ] ) ; if ( ( ! smallest_delta ) || ( smallest_delta > track_delta [ i ] ) ) { smallest_delta = track_delta [ i ] ; } NEXT_TRACK : continue ; } subtract_delta = smallest_delta ; sample_count_f = ( ( ( float ) smallest_delta * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; } } else { if ( midi_type == 2 ) { mdi -> is_type2 = 1 ; } sample_remainder = 0.0 ; for ( i = 0 ; i < no_tracks ; i ++ ) { running_event [ i ] = 0 ; do { <S2SV_StartBug> setup_ret = _WM_SetupMidiEvent ( mdi , tracks [ i ] , running_event [ i ] ) ; <S2SV_EndBug> if ( setup_ret == 0 ) { goto _end ; } if ( tracks [ i ] [ 0 ] > 0x7f ) { if ( tracks [ i ] [ 0 ] < 0xf0 ) { running_event [ i ] = tracks [ i ] [ 0 ] ; } else if ( ( tracks [ i ] [ 0 ] == 0xf0 ) || ( tracks [ i ] [ 0 ] == 0xf7 ) ) { running_event [ i ] = 0 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x2f ) && ( tracks [ i ] [ 2 ] == 0x00 ) ) { track_end [ i ] = 1 ; goto NEXT_TRACK2 ; } else if ( ( tracks [ i ] [ 0 ] == 0xff ) && ( tracks [ i ] [ 1 ] == 0x51 ) && ( tracks [ i ] [ 2 ] == 0x03 ) ) { tempo = ( tracks [ i ] [ 3 ] << 16 ) + ( tracks [ i ] [ 4 ] << 8 ) + tracks [ i ] [ 5 ] ; if ( ! tempo ) tempo = 500000 ; samples_per_delta_f = _WM_GetSamplesPerTick ( divisions , tempo ) ; } } tracks [ i ] += setup_ret ; <S2SV_StartBug> track_delta [ i ] = 0 ; <S2SV_EndBug> if ( * tracks [ i ] > 0x7f ) { do { <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> tracks [ i ] ++ ; <S2SV_StartBug> } while ( * tracks [ i ] > 0x7f ) ; <S2SV_EndBug> } <S2SV_StartBug> track_delta [ i ] = ( track_delta [ i ] << 7 ) + ( * tracks [ i ] & 0x7F ) ; <S2SV_EndBug> <S2SV_StartBug> tracks [ i ] ++ ; <S2SV_EndBug> sample_count_f = ( ( ( float ) track_delta [ i ] * samples_per_delta_f ) + sample_remainder ) ; sample_count = ( uint32_t ) sample_count_f ; sample_remainder = sample_count_f - ( float ) sample_count ; mdi -> events [ mdi -> event_count - 1 ] . samples_to_next += sample_count ; mdi -> extra_info . approx_total_samples += sample_count ; NEXT_TRACK2 : smallest_delta = track_delta [ i ] ; UNUSED ( smallest_delta ) ; } while ( track_end [ i ] == 0 ) ; } } if ( ( mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _end ; } mdi -> extra_info . current_sample = 0 ; mdi -> current_event = & mdi -> events [ 0 ] ; mdi -> samples_to_mix = 0 ; mdi -> note = NULL ; _WM_ResetToStart ( mdi ) ; _end : free ( sysex_store ) ; free ( track_end ) ; free ( track_delta ) ; free ( running_event ) ; free ( tracks ) ; <S2SV_StartBug> if ( mdi -> reverb ) return ( mdi ) ; <S2SV_EndBug> _WM_freeMDI ( mdi ) ; return ( NULL ) ; }
","<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(too<S2SV_blank>short)"" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
",Mindwerks@wildmidi/660b513d99bced8783a4a5984ac2f742c74ebbdd,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/660b513d99bced8783a4a5984ac2f742c74ebbdd,2017-08-17T16:29Z
CWE-264,"CWE-264 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cpus ; } if ( flags & PERF_FLAG_PID_CGROUP ) { err = perf_cgroup_connect ( pid , event , & attr , group_leader ) ; if ( err ) { __free_event ( event ) ; goto err_cpus ; } } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - ENOTSUPP ; goto err_alloc ; } } account_event ( event ) ; pmu = event -> pmu ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_flags & PERF_GROUP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event -> cpu ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( task ) { put_task_struct ( task ) ; task = NULL ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( move_group ) { <S2SV_StartBug> if ( group_leader -> ctx -> type != ctx -> type ) <S2SV_EndBug> goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( ""[perf_event]"" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; goto err_context ; } if ( move_group ) { struct perf_event_context * gctx = group_leader -> ctx ; mutex_lock ( & gctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } mutex_unlock ( & gctx -> mutex ) ; put_ctx ( gctx ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; mutex_lock ( & ctx -> mutex ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; mutex_unlock ( & ctx -> mutex ) ; put_online_cpus ( ) ; event -> owner = current ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : free_event ( event ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }
","<S2SV_ModStart> -> ctx -> task <S2SV_ModEnd> != ctx -> <S2SV_ModStart> != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context
",torvalds@linux/c3c87e770458aa004bd7ed3f29945ff436fd6511,CVE-2015-9004,https://github.com/torvalds/linux/commit/c3c87e770458aa004bd7ed3f29945ff436fd6511,2017-05-02T21:59Z
CWE-119,"CWE-119 char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f,2018-02-26T14:29Z
CWE-682,"CWE-682 WORD32 ihevcd_decode ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { WORD32 ret = IV_SUCCESS ; codec_t * ps_codec = ( codec_t * ) ( ps_codec_obj -> pv_codec_handle ) ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; WORD32 proc_idx = 0 ; WORD32 prev_proc_idx = 0 ; ps_codec -> i4_error_code = 0 ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } if ( ps_codec -> i4_init_done != 1 ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_INIT_NOT_DONE ; return IV_FAIL ; } if ( ps_codec -> u4_pic_cnt >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED ; return IV_FAIL ; } if ( ps_codec -> i4_reset_flag ) { ps_codec -> i4_flush_mode = 1 ; } if ( 0 == ps_codec -> i4_flush_mode ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= MIN_START_CODE_LEN ) { if ( ( WORD32 ) ps_dec_ip -> u4_num_Bytes > 0 ) ps_dec_op -> u4_num_bytes_consumed = ps_dec_ip -> u4_num_Bytes ; else ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } # ifdef APPLY_CONCEALMENT { WORD32 num_mbs ; num_mbs = ( ps_codec -> i4_wd * ps_codec -> i4_ht + 255 ) >> 8 ; ps_codec -> mb_count = 0 ; memset ( ps_codec -> mb_map , 0 , ( ( num_mbs + 7 ) >> 3 ) ) ; } # endif if ( 0 == ps_codec -> i4_share_disp_buf && ps_codec -> i4_header_mode == 0 ) { UWORD32 i ; if ( ps_dec_ip -> s_out_buffer . u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec_ip -> s_out_buffer . u4_num_bufs ; i ++ ) { if ( ps_dec_ip -> s_out_buffer . pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> s_out_buffer . u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } ps_codec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_codec -> u4_ts = ps_dec_ip -> u4_ts ; if ( ps_codec -> i4_flush_mode ) { ps_dec_op -> u4_pic_wd = ps_codec -> i4_disp_wd ; ps_dec_op -> u4_pic_ht = ps_codec -> i4_disp_ht ; ps_dec_op -> u4_new_seq = 0 ; ps_codec -> ps_disp_buf = ( pic_buf_t * ) ihevc_disp_mgr_get ( ( disp_mgr_t * ) ps_codec -> pv_disp_buf_mgr , & ps_codec -> i4_disp_buf_id ) ; if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ prev_proc_idx ] ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } ret = ihevcd_check_out_buf_size ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ret = ihevcd_fmt_conv ( ps_codec , & ps_codec -> as_process [ prev_proc_idx ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , 0 , ps_codec -> i4_disp_ht ) ; ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ; } ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; if ( 1 == ps_dec_op -> u4_output_present ) { WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ; WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ; if ( ypos < 0 ) ypos = 0 ; if ( xpos < 0 ) xpos = 0 ; INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } if ( NULL == ps_codec -> ps_disp_buf ) { if ( ps_codec -> i4_reset_flag ) { ihevcd_init ( ps_codec ) ; } return ( IV_FAIL ) ; } return ( IV_SUCCESS ) ; } if ( ( 0 == ps_codec -> i4_header_mode ) && ( 1 == ps_codec -> i4_share_disp_buf ) ) { WORD32 buf_status ; buf_status = 1 ; if ( ps_codec -> pv_pic_buf_mgr ) buf_status = ihevc_buf_mgr_check_free ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr ) ; if ( 0 == buf_status ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return IV_FAIL ; } } ps_codec -> i4_bytes_remaining = ps_dec_ip -> u4_num_Bytes ; ps_codec -> pu1_inp_bitsbuf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer ; ps_codec -> s_parse . i4_end_of_frame = 0 ; ps_codec -> i4_pic_present = 0 ; ps_codec -> i4_slice_error = 0 ; ps_codec -> ps_disp_buf = NULL ; if ( ps_codec -> i4_num_cores > 1 ) { ithread_set_affinity ( 0 ) ; } while ( MIN_START_CODE_LEN < ps_codec -> i4_bytes_remaining ) { WORD32 nal_len ; WORD32 nal_ofst ; WORD32 bits_len ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_codec -> s_parse . ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) ps_codec -> i4_slice_error = 0 ; } if ( ps_codec -> pu1_bitsbuf_dynamic ) { ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_dynamic ; ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_dynamic ; } else { ps_codec -> pu1_bitsbuf = ps_codec -> pu1_bitsbuf_static ; ps_codec -> u4_bitsbuf_size = ps_codec -> u4_bitsbuf_size_static ; } nal_ofst = ihevcd_nal_search_start_code ( ps_codec -> pu1_inp_bitsbuf , ps_codec -> i4_bytes_remaining ) ; ps_codec -> i4_nal_ofst = nal_ofst ; { WORD32 bytes_remaining = ps_codec -> i4_bytes_remaining - nal_ofst ; bytes_remaining = MIN ( ( UWORD32 ) bytes_remaining , ps_codec -> u4_bitsbuf_size ) ; ihevcd_nal_remv_emuln_bytes ( ps_codec -> pu1_inp_bitsbuf + nal_ofst , ps_codec -> pu1_bitsbuf , bytes_remaining , & nal_len , & bits_len ) ; if ( bits_len < ( WORD32 ) ( ps_codec -> u4_bitsbuf_size - 8 ) ) { memset ( ps_codec -> pu1_bitsbuf + bits_len , 0 , 2 * sizeof ( UWORD32 ) ) ; } } ps_codec -> i4_num_emln_bytes = nal_len - bits_len ; ps_codec -> i4_nal_len = nal_len ; ihevcd_bits_init ( & ps_codec -> s_parse . s_bitstrm , ps_codec -> pu1_bitsbuf , bits_len ) ; ret = ihevcd_nal_unit ( ps_codec ) ; if ( ps_codec -> i4_pic_present && ( ps_codec -> s_parse . i4_next_ctb_indx != ps_codec -> s_parse . ps_sps -> i4_pic_size_in_ctb ) ) { if ( ( ps_codec -> i4_bytes_remaining - ( nal_len + nal_ofst ) <= MIN_START_CODE_LEN ) || ( ps_codec -> i4_header_in_slice_mode ) ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; ps_codec -> i4_slice_error = 1 ; continue ; } } if ( IHEVCD_IGNORE_SLICE == ret ) { <S2SV_StartBug> ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; <S2SV_EndBug> ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ; continue ; } if ( ( IVD_RES_CHANGED == ret ) || ( IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret ) ) { break ; } if ( ret != IHEVCD_SLICE_IN_HEADER_MODE ) { if ( ( 0 == ps_codec -> i4_slice_error ) || ( ps_codec -> i4_bytes_remaining - ( nal_len + nal_ofst ) <= MIN_START_CODE_LEN ) ) { ps_codec -> pu1_inp_bitsbuf += ( nal_ofst + nal_len ) ; ps_codec -> i4_bytes_remaining -= ( nal_ofst + nal_len ) ; } if ( ret != IHEVCD_SUCCESS ) break ; if ( ps_codec -> s_parse . i4_end_of_frame ) break ; } else { ret = IHEVCD_SUCCESS ; break ; } if ( ( ps_codec -> u4_allocate_dynamic_done == 0 ) && ps_codec -> i4_sps_done ) { WORD32 ret ; ret = ihevcd_allocate_dynamic_bufs ( ps_codec ) ; if ( ret != IV_SUCCESS ) { ihevcd_free_dynamic_bufs ( ps_codec ) ; ps_codec -> i4_error_code = IVD_MEM_ALLOC_FAILED ; ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IVD_MEM_ALLOC_FAILED ; return IV_FAIL ; } } BREAK_AFTER_SLICE_NAL ( ) ; } if ( ( ps_codec -> u4_pic_cnt == 0 ) && ( ret != IHEVCD_SUCCESS ) ) { ps_codec -> i4_error_code = ret ; ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; return IV_FAIL ; } if ( 1 == ps_codec -> i4_pic_present ) { WORD32 i ; sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> i4_first_pic_done = 1 ; if ( ps_codec -> i4_num_cores > 1 && ps_codec -> s_parse . i4_end_of_frame ) { process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ps_codec -> i4_num_cores - 1 ] ; if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) { if ( ( 0 == ps_codec -> u4_enable_fmt_conv_ahead ) || ( ps_codec -> i4_disp_buf_id == ps_proc -> i4_cur_pic_buf_id ) ) for ( i = 0 ; i < ps_sps -> i2_pic_ht_in_ctb ; i ++ ) { proc_job_t s_job ; IHEVCD_ERROR_T ret ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i2_ctb_cnt = 0 ; s_job . i2_ctb_x = 0 ; s_job . i2_ctb_y = i ; s_job . i2_slice_idx = 0 ; s_job . i4_tu_coeff_data_ofst = 0 ; ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) return ( WORD32 ) ret ; } } ret = ihevcd_jobq_terminate ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq ) ; while ( 1 ) { IHEVCD_ERROR_T ret ; proc_job_t s_job ; process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ps_codec -> i4_num_cores - 1 ] ; ret = ihevcd_jobq_dequeue ( ( jobq_t * ) ps_proc -> pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS != ret ) break ; ps_proc -> i4_ctb_cnt = s_job . i2_ctb_cnt ; ps_proc -> i4_ctb_x = s_job . i2_ctb_x ; ps_proc -> i4_ctb_y = s_job . i2_ctb_y ; ps_proc -> i4_cur_slice_idx = s_job . i2_slice_idx ; if ( CMD_PROCESS == s_job . i4_cmd ) { ihevcd_init_proc_ctxt ( ps_proc , s_job . i4_tu_coeff_data_ofst ) ; ihevcd_process ( ps_proc ) ; } else if ( CMD_FMTCONV == s_job . i4_cmd ) { sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; WORD32 num_rows = 1 << ps_sps -> i1_log2_ctb_size ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } num_rows = MIN ( num_rows , ( ps_codec -> i4_disp_ht - ( s_job . i2_ctb_y << ps_sps -> i1_log2_ctb_size ) ) ) ; if ( num_rows < 0 ) num_rows = 0 ; ihevcd_fmt_conv ( ps_codec , ps_proc , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , s_job . i2_ctb_y << ps_sps -> i1_log2_ctb_size , num_rows ) ; } } } else if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) && ( ps_codec -> s_parse . i4_end_of_frame ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ proc_idx ] ; ps_codec -> s_fmt_conv . i4_num_rows = ps_codec -> i4_disp_ht - ps_codec -> s_fmt_conv . i4_cur_row ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } if ( ps_codec -> s_fmt_conv . i4_num_rows < 0 ) ps_codec -> s_fmt_conv . i4_num_rows = 0 ; ret = ihevcd_fmt_conv ( ps_codec , ps_proc , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> s_fmt_conv . i4_cur_row , ps_codec -> s_fmt_conv . i4_num_rows ) ; ps_codec -> s_fmt_conv . i4_cur_row += ps_codec -> s_fmt_conv . i4_num_rows ; } DEBUG_DUMP_MV_MAP ( ps_codec ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_mv_bank_buf_id , BUF_MGR_REF ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id , BUF_MGR_REF ) ; ihevc_buf_mgr_set_status ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id , BUF_MGR_DISP ) ; ihevc_dpb_mgr_insert_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ps_codec -> as_process [ proc_idx ] . ps_cur_pic , ps_codec -> as_process [ proc_idx ] . i4_cur_pic_buf_id ) ; if ( ( 0 == ps_codec -> i4_share_disp_buf ) && ( ps_codec -> ps_disp_buf ) ) ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ; for ( i = 0 ; i < ( ps_codec -> i4_num_cores - 1 ) ; i ++ ) { if ( ps_codec -> ai4_process_thread_created [ i ] ) { ithread_join ( ps_codec -> apv_process_thread_handle [ i ] , NULL ) ; ps_codec -> ai4_process_thread_created [ i ] = 0 ; } } DEBUG_VALIDATE_PADDED_REGION ( & ps_codec -> as_process [ proc_idx ] ) ; if ( ps_codec -> u4_pic_cnt > 0 ) { DEBUG_DUMP_PIC_PU ( ps_codec ) ; } DEBUG_DUMP_PIC_BUFFERS ( ps_codec ) ; ps_codec -> u4_pic_cnt ++ ; } ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; if ( 1 == ps_dec_op -> u4_output_present ) { WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ; WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ; if ( ypos < 0 ) ypos = 0 ; if ( xpos < 0 ) xpos = 0 ; INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } return ret ; }
","<S2SV_ModStart> { ps_codec -> <S2SV_ModEnd> pu1_inp_bitsbuf += (
",external@libhevc/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9,CVE-2017-0819,https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9,2017-10-04T01:29Z
CWE-399,"CWE-399 void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { <S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }
","<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
",torvalds@linux/c085c49920b2f900ba716b4ca1c1a55ece9872cc,CVE-2013-2636,https://github.com/torvalds/linux/commit/c085c49920b2f900ba716b4ca1c1a55ece9872cc,2013-03-22T11:59Z
CWE-264,"CWE-264 int perf_event_task_disable ( void ) <S2SV_StartBug> { <S2SV_EndBug> struct perf_event * event ; mutex_lock ( & current -> perf_event_mutex ) ; <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; }
","<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
",torvalds@linux/f63a8daa5812afef4f06c962351687e1ff9ccb2b,CVE-2016-6787,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,2016-12-28T07:59Z
CWE-416,"CWE-416 static int updateDevice ( const struct header * headers , time_t t ) { struct device * * pp = & devlist ; struct device * p = * pp ; while ( p ) { if ( p -> headers [ HEADER_NT ] . l == headers [ HEADER_NT ] . l && ( 0 == memcmp ( p -> headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . p , headers [ HEADER_NT ] . l ) ) && p -> headers [ HEADER_USN ] . l == headers [ HEADER_USN ] . l && ( 0 == memcmp ( p -> headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . p , headers [ HEADER_USN ] . l ) ) ) { syslog ( LOG_DEBUG , ""device<S2SV_blank>updated<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; p -> t = t ; if ( headers [ HEADER_LOCATION ] . l > p -> headers [ HEADER_LOCATION ] . l ) { struct device * tmp ; tmp = realloc ( p , sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! tmp ) { syslog ( LOG_ERR , ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; <S2SV_StartBug> free ( p ) ; <S2SV_EndBug> return 0 ; } p = tmp ; * pp = p ; } memcpy ( p -> data + p -> headers [ 0 ] . l + p -> headers [ 1 ] . l , headers [ 2 ] . p , headers [ 2 ] . l ) ; return 0 ; } pp = & p -> next ; p = * pp ; } syslog ( LOG_INFO , ""new<S2SV_blank>device<S2SV_blank>discovered<S2SV_blank>:<S2SV_blank>%.*s"" , headers [ HEADER_USN ] . l , headers [ HEADER_USN ] . p ) ; { char * pc ; int i ; p = malloc ( sizeof ( struct device ) + headers [ 0 ] . l + headers [ 1 ] . l + headers [ 2 ] . l ) ; if ( ! p ) { syslog ( LOG_ERR , ""updateDevice():<S2SV_blank>cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; return - 1 ; } p -> next = devlist ; p -> t = t ; pc = p -> data ; for ( i = 0 ; i < 3 ; i ++ ) { p -> headers [ i ] . p = pc ; p -> headers [ i ] . l = headers [ i ] . l ; memcpy ( pc , headers [ i ] . p , headers [ i ] . l ) ; pc += headers [ i ] . l ; } devlist = p ; sendNotifications ( NOTIF_NEW , p , NULL ) ; } return 1 ; }
","<S2SV_ModStart> ""updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; * pp = p -> next ;
",miniupnp@miniupnp/cd506a67e174a45c6a202eff182a712955ed6d6f,CVE-2019-12106,https://github.com/miniupnp/miniupnp/commit/cd506a67e174a45c6a202eff182a712955ed6d6f,2019-05-15T23:29Z
CWE-399,"CWE-399 static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( ""%d<S2SV_blank>tickets\\n"" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }
","<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/c27a3e4d667fdcad3db7b104f75659478e0c68d8,CVE-2014-6418,https://github.com/torvalds/linux/commit/c27a3e4d667fdcad3db7b104f75659478e0c68d8,2014-09-28T10:55Z
CWE-000,"CWE-000 <S2SV_StartBug> int fit_config_verify_required_sigs ( const void * fit , int conf_noffset , <S2SV_EndBug> const void * sig_blob ) { <S2SV_StartBug> int noffset ; <S2SV_EndBug> int sig_node ; int verified = 0 ; int reqd_sigs = 0 ; bool reqd_policy_all = true ; <S2SV_StartBug> const char * reqd_mode ; <S2SV_EndBug> sig_node = fdt_subnode_offset ( sig_blob , 0 , FIT_SIG_NODENAME ) ; if ( sig_node < 0 ) { debug ( ""%s:<S2SV_blank>No<S2SV_blank>signature<S2SV_blank>node<S2SV_blank>found:<S2SV_blank>%s\\n"" , __func__ , fdt_strerror ( sig_node ) ) ; return 0 ; } reqd_mode = fdt_getprop ( sig_blob , sig_node , ""required-mode"" , NULL ) ; if ( reqd_mode && ! strcmp ( reqd_mode , ""any"" ) ) reqd_policy_all = false ; debug ( ""%s:<S2SV_blank>required-mode<S2SV_blank>policy<S2SV_blank>set<S2SV_blank>to<S2SV_blank>\'%s\'\\n"" , __func__ , reqd_policy_all ? ""all"" : ""any"" ) ; fdt_for_each_subnode ( noffset , sig_blob , sig_node ) { const char * required ; int ret ; required = fdt_getprop ( sig_blob , noffset , FIT_KEY_REQUIRED , NULL ) ; if ( ! required || strcmp ( required , ""conf"" ) ) continue ; reqd_sigs ++ ; ret = fit_config_verify_sig ( fit , conf_noffset , sig_blob , noffset ) ; if ( ret ) { if ( reqd_policy_all ) { printf ( ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>required<S2SV_blank>signature<S2SV_blank>\'%s\'\\n"" , fit_get_name ( sig_blob , noffset , NULL ) ) ; return ret ; } } else { verified ++ ; if ( ! reqd_policy_all ) break ; } } if ( reqd_sigs && ! verified ) { printf ( ""Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>\'any\'<S2SV_blank>of<S2SV_blank>the<S2SV_blank>required<S2SV_blank>signature(s)\\n"" ) ; return - EPERM ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> sig_blob ) { const char * name = fit_get_name ( fit , conf_noffset , NULL ) ; <S2SV_ModStart> * reqd_mode ; if ( strchr ( name , '@' ) ) { printf ( ""Configuration<S2SV_blank>node<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>\'@\'\\n"" , name ) ; return - EPERM ; }
",u-boot@u-boot/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,CVE-2021-27138,https://github.com/u-boot/u-boot/commit/79af75f7776fc20b0d7eb6afe1e27c00fdb4b9b4,2021-02-17T23:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_rc_init_minq_luts ( ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < QINDEX_RANGE ; i ++ ) { const double maxq = vp9_convert_qindex_to_q ( i ) ; kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.15 ) ; kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ; gf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.32 ) ; gf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ; afq_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.33 ) ; afq_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.55 ) ; inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.75 ) ; } }
","<S2SV_ModStart> void vp9_rc_init_minq_luts ( void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-295,"CWE-295 void log_flush ( LOG_MODE new_mode ) { CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_LOG_MODE ] ) ; <S2SV_StartBug> if ( log_mode != LOG_MODE_CONFIGURED || new_mode != LOG_MODE_ERROR ) <S2SV_EndBug> log_mode = new_mode ; if ( new_mode != LOG_MODE_BUFFER ) { CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_LOG_BUFFER ] ) ; while ( head ) { struct LIST * tmp = head ; head = head -> next ; log_raw ( tmp -> opt , tmp -> level , tmp -> stamp , tmp -> id , tmp -> text ) ; str_free ( tmp ) ; } head = tail = NULL ; CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_LOG_BUFFER ] ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_LOG_MODE ] ) ; }
","<S2SV_ModStart> ] ) ; <S2SV_ModEnd> log_mode = new_mode
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-269,"CWE-269 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
",iortcw@iortcw/b248763e4878ef12d5835ece6600be8334f67da1,CVE-2017-6903,https://github.com/iortcw/iortcw/commit/b248763e4878ef12d5835ece6600be8334f67da1,2017-03-14T22:59Z
CWE-189,"CWE-189 int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ; <S2SV_StartBug> if ( args -> buffer_count < 1 ) { <S2SV_EndBug> DRM_DEBUG ( ""execbuf2<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>exec<S2SV_blank>list<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>buffers\\n"" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( ""copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>failed<S2SV_blank>%d\\n"" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( ""failed<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>%d<S2SV_blank>exec<S2SV_blank>entries<S2SV_blank>"" ""back<S2SV_blank>to<S2SV_blank>user<S2SV_blank>(%d)\\n"" , args -> buffer_count , ret ) ; } } drm_free_large ( exec2_list ) ; return ret ; }
","<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
",torvalds@linux/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,CVE-2012-2383,https://github.com/torvalds/linux/commit/ed8cd3b2cd61004cab85380c52b1817aca1ca49b,2012-06-13T10:24Z
CWE-284,"CWE-284 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <S2SV_StartBug> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; <S2SV_EndBug> list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , & unmounted ) ; <S2SV_EndBug> if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; <S2SV_StartBug> umount_mnt ( p ) ; <S2SV_EndBug> } <S2SV_StartBug> change_mnt_propagation ( p , MS_PRIVATE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }
",torvalds@linux/ce07d891a0891d3c0d0c2d73d577490486b809e1,CVE-2014-9717,https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1,2016-05-02T10:59Z
CWE-119,"CWE-119 php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , ""awx+"" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections"" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , ""%s://%s:%d"" , use_ssl ? ""ssl"" : ""tcp"" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\r\\n"" , sizeof ( ""<S2SV_blank>HTTP/1.0\\r\\n"" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , ""<S2SV_blank>"" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , ""/"" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , ""?"" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , ""\\r\\n"" , scratch_len ) ; } else { strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\r\\n"" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , ""content-length:"" ) ; strip_header ( user_headers , tmp , ""content-type:"" ) ; } if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , "":"" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n"" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\r\\n"" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\r\\n"" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\r\\n"" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\r\\n"" ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\r\\n"" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" , sizeof ( ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ; } php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } } <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> -- tmp_line_len ; <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) { if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( ""/"" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s"" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }
","<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
",php@php-src/523f230c831d7b33353203fa34aee4e92ac12bba,CVE-2018-7584,https://github.com/php/php-src/commit/523f230c831d7b33353203fa34aee4e92ac12bba,2018-03-01T19:29Z
CWE-416,"CWE-416 void comps_objrtree_unite ( COMPS_ObjRTree * rt1 , COMPS_ObjRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data != NULL ) { comps_objrtree_set ( rt1 , pair -> key , ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_ObjRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
",rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z
CWE-908,"CWE-908 INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,!,"" , r , d ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
CWE-119,"CWE-119 static grub_err_t read_foo ( struct grub_disk * disk , grub_disk_addr_t sector , grub_size_t size , char * buf ) { <S2SV_StartBug> if ( disk != NULL ) { <S2SV_EndBug> <S2SV_StartBug> const int blocksize = 512 ; <S2SV_EndBug> int ret ; RIOBind * iob = disk -> data ; <S2SV_StartBug> if ( bio ) iob = bio ; <S2SV_EndBug> <S2SV_StartBug> ret = iob -> read_at ( iob -> io , delta + ( blocksize * sector ) , <S2SV_EndBug> <S2SV_StartBug> ( ut8 * ) buf , size * blocksize ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == - 1 ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> } else eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> { if ( ! disk ) { eprintf ( ""oops.<S2SV_blank>no<S2SV_blank>disk\\n"" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
CWE-200,"CWE-200 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , ""tty_ioctl"" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }
","<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
",torvalds@linux/5c17c861a357e9458001f021a7afa7aab9937439,CVE-2016-0723,https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439,2016-02-08T03:59Z
CWE-362,"CWE-362 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <S2SV_StartBug> start = vma -> vm_start ; <S2SV_EndBug> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }
","<S2SV_ModStart> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-20,"CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; ( void ) memset ( & info , 0 , sizeof ( info ) ) ; data = ( unsigned char * ) NULL ; graymap = ( int * ) NULL ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MagickPathExtent ) ; info . bits_allocated = 8 ; info . bytes_per_pixel = 1 ; info . depth = 8 ; info . mask = 0xffff ; info . max_value = 255UL ; info . samples_per_pixel = 1 ; info . signed_data = ( ~ 0UL ) ; info . rescale_slope = 1.0 ; data = ( unsigned char * ) NULL ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; number_scenes = 1 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; while ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) break ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , ""xs"" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , ""!!"" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , ""OB"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""UN"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( explicit_vr , ""SQ"" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , ""OW"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SS"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""US"" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , ""FL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""OF"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""SL"" , 2 ) == 0 ) || ( strncmp ( implicit_vr , ""UL"" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , ""FD"" , 2 ) == 0 ) quantum = 8 ; else quantum = 1 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } if ( ( ( ( unsigned int ) group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = ( ssize_t ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; if ( count < 1 ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { info . samples_per_pixel = ( size_t ) datum ; if ( ( info . samples_per_pixel == 0 ) || ( info . samples_per_pixel > 4 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; } case 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; info . polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { info . bits_allocated = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( datum > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . bits_allocated ; if ( ( info . depth == 0 ) || ( info . depth > 32 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . bits_allocated ) - 1 ; image -> depth = info . depth ; break ; } case 0x0101 : { info . significant_bits = ( size_t ) datum ; info . bytes_per_pixel = 1 ; if ( info . significant_bits > 8 ) info . bytes_per_pixel = 2 ; info . depth = info . significant_bits ; if ( ( info . depth == 0 ) || ( info . depth > 16 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; info . max_value = ( 1UL << info . significant_bits ) - 1 ; info . mask = ( size_t ) GetQuantumRange ( info . significant_bits ) ; image -> depth = info . depth ; break ; } case 0x0102 : { break ; } case 0x0103 : { info . signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) info . window_center = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) info . window_width = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) info . rescale_intercept = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) info . rescale_slope = StringToDouble ( ( char * ) data , ( char * * ) NULL ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / info . bytes_per_pixel ) ; datum = ( int ) colors ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; graymap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( graymap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * graymap ) ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( info . bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; redmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( redmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * redmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; greenmap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( greenmap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * greenmap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; bluemap = ( int * ) AcquireQuantumMemory ( MagickMax ( colors , 65536 ) , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( bluemap , 0 , MagickMax ( colors , 65536 ) * sizeof ( * bluemap ) ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) info . polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( group == 0xfffc ) && ( element == 0xfffc ) ) { Image * last ; last = RemoveLastImageFromList ( & image ) ; if ( last != ( Image * ) NULL ) last = DestroyImage ( last ) ; break ; } if ( ( width == 0 ) || ( height == 0 ) ) ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( info . signed_data == 0xffff ) info . signed_data = ( size_t ) ( info . significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ( ( ( ssize_t ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( tag == 0xFFFEE0DD ) <S2SV_EndBug> break ; if ( tag != 0xFFFEE000 ) { read_info = DestroyImageInfo ( read_info ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( c = EOF ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( fputc ( c , file ) != c ) break ; } ( void ) fclose ( file ) ; if ( c == EOF ) break ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; image = DestroyImageList ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( info . depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; length = ( size_t ) ( GetQuantumRange ( info . depth ) + 1 ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; info . scale = ( Quantum * ) AcquireQuantumMemory ( MagickMax ( length , 256 ) , sizeof ( * info . scale ) ) ; if ( info . scale == ( Quantum * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) memset ( info . scale , 0 , MagickMax ( length , 256 ) * sizeof ( * info . scale ) ) ; range = GetQuantumRange ( info . depth ) ; for ( i = 0 ; i <= ( ssize_t ) GetQuantumRange ( info . depth ) ; i ++ ) info . scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) { stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; } offset = TellBlob ( image ) + 8 ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = info . depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; ( void ) SetImageBackgroundColor ( image , exception ) ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( info . samples_per_pixel == 1 ) ) { int index ; size_t one ; one = 1 ; if ( colors == 0 ) colors = one << info . depth ; if ( AcquireImageColormap ( image , colors , exception ) == MagickFalse ) ThrowDCMException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( info . scale != ( Quantum * ) NULL ) && ( index >= 0 ) && ( index <= ( int ) info . max_value ) ) index = ( int ) info . scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } tag = ( ( unsigned int ) ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) { if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; ThrowDCMException ( CorruptImageError , ""ImproperImageHeader"" ) ; } stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; if ( stream_info -> segment_count > 1 ) { info . bytes_per_pixel = 1 ; info . depth = 8 ; if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 0 ] , SEEK_SET ) ; } } if ( ( info . samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { register ssize_t x ; register Quantum * q ; ssize_t y ; for ( i = 0 ; i < ( ssize_t ) info . samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) info . window_width = 0 ; } option = GetImageOption ( image_info , ""dcm:window"" ) ; if ( option != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( option , & geometry_info ) ; if ( flags & RhoValue ) info . window_center = geometry_info . rho ; if ( flags & SigmaValue ) info . window_width = geometry_info . sigma ; info . rescale = MagickTrue ; } option = GetImageOption ( image_info , ""dcm:rescale"" ) ; if ( option != ( char * ) NULL ) info . rescale = IsStringTrue ( option ) ; if ( ( info . window_center != 0 ) && ( info . window_width == 0 ) ) info . window_width = info . window_center ; status = ReadDCMPixels ( image , & info , stream_info , MagickTrue , exception ) ; if ( ( status != MagickFalse ) && ( stream_info -> segment_count > 1 ) ) { if ( stream_info -> offset_count > 0 ) ( void ) SeekBlob ( image , ( MagickOffsetType ) stream_info -> offsets [ 0 ] + stream_info -> segments [ 1 ] , SEEK_SET ) ; ( void ) ReadDCMPixels ( image , & info , stream_info , MagickFalse , exception ) ; } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( TellBlob ( image ) < ( MagickOffsetType ) GetBlobSize ( image ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( image == ( Image * ) NULL ) return ( image ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if (
",ImageMagick@ImageMagick/16916c8979c32765c542e216b31cee2671b7afe7,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/16916c8979c32765c542e216b31cee2671b7afe7,2018-09-06T22:29Z
CWE-20,"CWE-20 error_t coapClientReadBody ( CoapClientRequest * request , void * data , size_t size , size_t * received ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; * received = 0 ; while ( * received < size ) { responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientReadPayload ( responseMsg , data , size - * received , & n ) ; if ( error == NO_ERROR ) { data = ( uint8_t * ) data + n ; * received += n ; } else if ( error == ERROR_END_OF_STREAM ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapClientGetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> rxBlockSzx ; } error = coapClientGetUintOption ( responseMsg , COAP_OPT_BLOCK2 , 0 , & value ) ; if ( ! error ) { if ( COAP_GET_BLOCK_SZX ( value ) >= COAP_BLOCK_SIZE_RESERVED ) { error = ERROR_FAILURE ; break ; } if ( COAP_GET_BLOCK_POS ( value ) != blockPos ) { error = ERROR_FAILURE ; break ; } if ( ! COAP_GET_BLOCK_M ( value ) ) { error = ERROR_END_OF_STREAM ; break ; } error = coapClientGetPayload ( responseMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( payloadLen != COAP_GET_BLOCK_SIZE ( value ) ) { error = ERROR_FAILURE ; break ; } if ( blockSzx > COAP_GET_BLOCK_SZX ( value ) ) blockSzx = COAP_GET_BLOCK_SZX ( value ) ; blockPos += COAP_GET_BLOCK_SIZE ( value ) ; COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; COAP_SET_BLOCK_M ( value , 0 ) ; COAP_SET_BLOCK_SZX ( value , blockSzx ) ; error = coapClientSetUintOption ( requestMsg , COAP_OPT_BLOCK2 , 0 , value ) ; if ( error ) break ; error = coapClientSendRequest ( request , NULL , NULL ) ; if ( error ) break ; responseMsg = coapClientGetResponseMessage ( request ) ; error = coapClientGetResponseCode ( responseMsg , & responseCode ) ; if ( error ) break ; if ( COAP_GET_CODE_CLASS ( responseCode ) != COAP_CODE_CLASS_SUCCESS ) { error = ERROR_INVALID_STATUS ; break ; } } else { if ( blockPos == 0 ) <S2SV_StartBug> error = ERROR_END_OF_STREAM ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> error = ERROR_FAILURE ; <S2SV_EndBug> break ; } } else { break ; } } if ( * received > 0 ) { if ( error == ERROR_END_OF_STREAM ) error = NO_ERROR ; } return error ; }
","<S2SV_ModStart> == 0 ) { <S2SV_ModStart> = ERROR_END_OF_STREAM ; } else { <S2SV_ModEnd> error = ERROR_FAILURE <S2SV_ModStart> = ERROR_FAILURE ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-354,"CWE-354 void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
","<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , ""Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode"" ) ; layoutHome ( ) ; return ; }
",keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z
CWE-119,"CWE-119 static size_t encode_tiles ( VP9_COMP * cpi , uint8_t * data_ptr ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> vp9_writer residual_bc ; <S2SV_EndBug> int tile_row , tile_col ; <S2SV_StartBug> TOKENEXTRA * tok [ 4 ] [ 1 << 6 ] , * tok_end ; <S2SV_EndBug> size_t total_size = 0 ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * <S2SV_EndBug> mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ; <S2SV_StartBug> tok [ 0 ] [ 0 ] = cpi -> tok ; <S2SV_EndBug> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { if ( tile_row ) tok [ tile_row ] [ 0 ] = tok [ tile_row - 1 ] [ tile_cols - 1 ] + cpi -> tok_count [ tile_row - 1 ] [ tile_cols - 1 ] ; for ( tile_col = 1 ; tile_col < tile_cols ; tile_col ++ ) tok [ tile_row ] [ tile_col ] = tok [ tile_row ] [ tile_col - 1 ] + cpi -> tok_count [ tile_row ] [ tile_col - 1 ] ; } for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { TileInfo tile ; vp9_tile_init ( & tile , cm , tile_row , tile_col ) ; <S2SV_StartBug> tok_end = tok [ tile_row ] [ tile_col ] + cpi -> tok_count [ tile_row ] [ tile_col ] ; <S2SV_EndBug> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_start_encode ( & residual_bc , data_ptr + total_size ) ; <S2SV_EndBug> <S2SV_StartBug> write_modes ( cpi , & tile , & residual_bc , & tok [ tile_row ] [ tile_col ] , tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( tok [ tile_row ] [ tile_col ] == tok_end ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_stop_encode ( & residual_bc ) ; <S2SV_EndBug> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) { mem_put_be32 ( data_ptr + total_size , residual_bc . pos ) ; total_size += 4 ; } total_size += residual_bc . pos ; } } return total_size ; }
","<S2SV_ModStart> -> common ; vpx_writer <S2SV_ModEnd> residual_bc ; int <S2SV_ModStart> tile_col ; TOKENEXTRA <S2SV_ModEnd> * tok_end ; <S2SV_ModStart> -> log2_tile_rows ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> ) ) ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] <S2SV_ModEnd> ; tok_end = <S2SV_ModStart> ; tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] + <S2SV_ModEnd> cpi -> tok_count <S2SV_ModStart> - 1 ) vpx_start_encode <S2SV_ModEnd> ( & residual_bc <S2SV_ModStart> ) ; else vpx_start_encode <S2SV_ModEnd> ( & residual_bc <S2SV_ModStart> cpi , & cpi -> tile_data [ tile_idx ] . tile_info , <S2SV_ModEnd> & residual_bc , <S2SV_ModStart> , & tok <S2SV_ModEnd> , tok_end ) <S2SV_ModStart> assert ( tok <S2SV_ModEnd> == tok_end ) <S2SV_ModStart> tok_end ) ; vpx_stop_encode <S2SV_ModEnd> ( & residual_bc
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static void opl3_setup_voice ( int dev , int voice , int chn ) { <S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> & synth_devs [ dev ] -> chn_info [ chn ] ; opl3_set_instr ( dev , voice , info -> pgm_num ) ; devc -> voc [ voice ] . bender = 0 ; devc -> voc [ voice ] . bender_range = info -> bender_range ; devc -> voc [ voice ] . volume = info -> controllers [ CTL_MAIN_VOLUME ] ; devc -> voc [ voice ] . panning = ( info -> controllers [ CTL_PAN ] * 2 ) - 128 ; }
","<S2SV_ModStart> channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
",torvalds@linux/4d00135a680727f6c3be78f8befaac009030e4df,CVE-2011-1477,https://github.com/torvalds/linux/commit/4d00135a680727f6c3be78f8befaac009030e4df,2012-06-21T23:55Z
CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR ) { <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; while ( ( npages - i ) >= HPAGE_PMD_NR ) { struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; <S2SV_StartBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) <S2SV_EndBug> if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( ""Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n"" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
","<S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j < <S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j <
",torvalds@linux/ac1e516d5a4c56bf0cb4a3dfc0672f689131cfd4,CVE-2019-19927,https://github.com/torvalds/linux/commit/ac1e516d5a4c56bf0cb4a3dfc0672f689131cfd4,2019-12-31T02:15Z
CWE-200,"CWE-200 static int l2tp_ip_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }
","<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
",torvalds@linux/bceaa90240b6019ed73b49965eac7d167610be69,CVE-2013-7281,https://github.com/torvalds/linux/commit/bceaa90240b6019ed73b49965eac7d167610be69,2014-01-08T16:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static void reset_fpf_position ( struct twopass_rc * p , <S2SV_EndBug> const FIRSTPASS_STATS * position ) { p -> stats_in = position ; }
","<S2SV_ModStart> void reset_fpf_position ( TWO_PASS <S2SV_ModEnd> * p ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
","<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-787,"CWE-787 void exif_data_load_data ( ExifData * data , const unsigned char * d_orig , unsigned int ds ) { unsigned int l ; ExifLong offset ; ExifShort n ; const unsigned char * d = d_orig ; unsigned int len , fullds ; if ( ! data || ! data -> priv || ! d || ! ds ) return ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Parsing<S2SV_blank>%i<S2SV_blank>byte(s)<S2SV_blank>EXIF<S2SV_blank>data...\\n"" , ds ) ; if ( ds < 6 ) { LOG_TOO_SMALL ; return ; } if ( ! memcmp ( d , ExifHeader , 6 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Found<S2SV_blank>EXIF<S2SV_blank>header<S2SV_blank>at<S2SV_blank>start."" ) ; } else { while ( ds >= 3 ) { while ( ds && ( d [ 0 ] == 0xff ) ) { d ++ ; ds -- ; } if ( ds && d [ 0 ] == JPEG_MARKER_SOI ) { d ++ ; ds -- ; continue ; } if ( ds && d [ 0 ] == JPEG_MARKER_APP1 ) break ; if ( ds >= 3 && d [ 0 ] >= 0xe0 && d [ 0 ] <= 0xef ) { d ++ ; ds -- ; l = ( d [ 0 ] << 8 ) | d [ 1 ] ; if ( l > ds ) return ; d += l ; ds -= l ; continue ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""EXIF<S2SV_blank>marker<S2SV_blank>not<S2SV_blank>found."" ) ) ; return ; } if ( ds < 3 ) { LOG_TOO_SMALL ; return ; } d ++ ; ds -- ; len = ( d [ 0 ] << 8 ) | d [ 1 ] ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""We<S2SV_blank>have<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%i<S2SV_blank>byte(s)<S2SV_blank>of<S2SV_blank>EXIF<S2SV_blank>data."" , len ) ; d += 2 ; ds -= 2 ; } if ( ds < 6 ) { LOG_TOO_SMALL ; return ; } if ( memcmp ( d , ExifHeader , 6 ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""EXIF<S2SV_blank>header<S2SV_blank>not<S2SV_blank>found."" ) ) ; return ; } exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""Found<S2SV_blank>EXIF<S2SV_blank>header."" ) ; if ( ds < 14 ) return ; fullds = ds ; if ( ds > 0xfffe ) ds = 0xfffe ; if ( ! memcmp ( d + 6 , ""II"" , 2 ) ) data -> priv -> order = EXIF_BYTE_ORDER_INTEL ; else if ( ! memcmp ( d + 6 , ""MM"" , 2 ) ) data -> priv -> order = EXIF_BYTE_ORDER_MOTOROLA ; else { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , _ ( ""Unknown<S2SV_blank>encoding."" ) ) ; return ; } if ( exif_get_short ( d + 8 , data -> priv -> order ) != 0x002a ) return ; offset = exif_get_long ( d + 10 , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""IFD<S2SV_blank>0<S2SV_blank>at<S2SV_blank>%i."" , ( int ) offset ) ; if ( offset > ds || offset + 6 + 2 > ds ) return ; exif_data_load_data_content ( data , EXIF_IFD_0 , d + 6 , ds - 6 , offset , 0 ) ; n = exif_get_short ( d + 6 + offset , data -> priv -> order ) ; if ( offset + 6 + 2 + 12 * n + 4 > ds ) return ; offset = exif_get_long ( d + 6 + offset + 2 + 12 * n , data -> priv -> order ) ; if ( offset ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , ""ExifData"" , ""IFD<S2SV_blank>1<S2SV_blank>at<S2SV_blank>%i."" , ( int ) offset ) ; <S2SV_StartBug> if ( offset > ds || offset + 6 > ds ) { <S2SV_EndBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifData"" , ""Bogus<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>IFD1."" ) ; } else { exif_data_load_data_content ( data , EXIF_IFD_1 , d + 6 , ds - 6 , offset , 0 ) ; } } interpret_maker_note ( data , d , fullds ) ; if ( data -> priv -> options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION ) exif_data_fix ( data ) ; }
","<S2SV_ModStart> offset > ds - 6 <S2SV_ModEnd> ) { exif_log
",libexif@libexif/75aa73267fdb1e0ebfbc00369e7312bac43d0566,CVE-2019-9278,https://github.com/libexif/libexif/commit/75aa73267fdb1e0ebfbc00369e7312bac43d0566,2019-09-27T19:15Z
CWE-264,"CWE-264 struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; <S2SV_StartBug> opt2 -> tot_len = tot_len ; <S2SV_EndBug> p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> srcrt : NULL , newopt , newoptlen , newtype != IPV6_RTHDR , ( struct ipv6_opt_hdr * * ) & opt2 -> srcrt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst1opt : NULL , newopt , newoptlen , newtype != IPV6_DSTOPTS , & opt2 -> dst1opt , & p ) ; if ( err ) goto out ; opt2 -> opt_nflen = ( opt2 -> hopopt ? ipv6_optlen ( opt2 -> hopopt ) : 0 ) + ( opt2 -> dst0opt ? ipv6_optlen ( opt2 -> dst0opt ) : 0 ) + ( opt2 -> srcrt ? ipv6_optlen ( opt2 -> srcrt ) : 0 ) ; opt2 -> opt_flen = ( opt2 -> dst1opt ? ipv6_optlen ( opt2 -> dst1opt ) : 0 ) ; return opt2 ; out : sock_kfree_s ( sk , opt2 , opt2 -> tot_len ) ; return ERR_PTR ( err ) ; }
","<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-125,"CWE-125 static wStream * rdg_receive_packet ( rdpRdg * rdg ) { wStream * s ; const size_t header = sizeof ( RdgPacketHeader ) ; size_t packetLength ; assert ( header <= INT_MAX ) ; s = Stream_New ( NULL , 1024 ) ; if ( ! s ) return NULL ; if ( ! rdg_read_all ( rdg -> tlsOut , Stream_Buffer ( s ) , header ) ) { Stream_Free ( s , TRUE ) ; return NULL ; } Stream_Seek ( s , 4 ) ; Stream_Read_UINT32 ( s , packetLength ) ; <S2SV_StartBug> if ( ( packetLength > INT_MAX ) || ! Stream_EnsureCapacity ( s , packetLength ) ) <S2SV_EndBug> { Stream_Free ( s , TRUE ) ; return NULL ; } if ( ! rdg_read_all ( rdg -> tlsOut , Stream_Buffer ( s ) + header , ( int ) packetLength - ( int ) header ) ) { Stream_Free ( s , TRUE ) ; return NULL ; } Stream_SetLength ( s , packetLength ) ; return s ; }
","<S2SV_ModStart> , packetLength ) || ( packetLength < header )
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-399,"CWE-399 <S2SV_StartBug> static struct fsnotify_group * inotify_new_group ( struct user_struct * user , unsigned int max_events ) <S2SV_EndBug> { struct fsnotify_group * group ; group = fsnotify_alloc_group ( & inotify_fsnotify_ops ) ; if ( IS_ERR ( group ) ) return group ; group -> max_events = max_events ; spin_lock_init ( & group -> inotify_data . idr_lock ) ; idr_init ( & group -> inotify_data . idr ) ; group -> inotify_data . last_wd = 0 ; <S2SV_StartBug> group -> inotify_data . user = user ; <S2SV_EndBug> <S2SV_StartBug> group -> inotify_data . fa = NULL ; <S2SV_EndBug> return group ; }
","<S2SV_ModStart> * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events <S2SV_ModStart> -> inotify_data . fa = NULL <S2SV_ModEnd> ; group -> <S2SV_ModStart> -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ;
",torvalds@linux/d0de4dc584ec6aa3b26fffea320a8457827768fc,CVE-2011-1479,https://github.com/torvalds/linux/commit/d0de4dc584ec6aa3b26fffea320a8457827768fc,2012-06-21T23:55Z
CWE-476,"CWE-476 void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; <S2SV_StartBug> asoc -> peer . i = new -> peer . i ; <S2SV_EndBug> sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_tsn - 1 ; asoc -> adv_peer_ack_point = asoc -> ctsn_ack_point ; if ( ! asoc -> ssnmap ) { asoc -> ssnmap = new -> ssnmap ; new -> ssnmap = NULL ; } if ( ! asoc -> assoc_id ) { sctp_assoc_set_id ( asoc , GFP_ATOMIC ) ; } } kfree ( asoc -> peer . peer_random ) ; asoc -> peer . peer_random = new -> peer . peer_random ; new -> peer . peer_random = NULL ; kfree ( asoc -> peer . peer_chunks ) ; asoc -> peer . peer_chunks = new -> peer . peer_chunks ; new -> peer . peer_chunks = NULL ; kfree ( asoc -> peer . peer_hmacs ) ; asoc -> peer . peer_hmacs = new -> peer . peer_hmacs ; new -> peer . peer_hmacs = NULL ; sctp_auth_key_put ( asoc -> asoc_shared_key ) ; sctp_auth_asoc_init_active_key ( asoc , GFP_ATOMIC ) ; }
","<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
",torvalds@linux/1be9a950c646c9092fb3618197f7b6bfb50e82aa,CVE-2014-5077,https://github.com/torvalds/linux/commit/1be9a950c646c9092fb3618197f7b6bfb50e82aa,2014-08-01T11:13Z
CWE-125,"CWE-125 static void l2tp_q931_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) <S2SV_StartBug> { <S2SV_EndBug> print_16bits_val ( ndo , ( const uint16_t * ) dat ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%02x"" , dat [ 2 ] ) ) ; <S2SV_StartBug> if ( length > 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , dat + 3 , length - 3 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> length ) { if ( length < 3 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ) ) ; dat += 3 ; length -= 3 ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo , dat , length <S2SV_ModEnd> ) ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-617,"CWE-617 static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = ""INVALID_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
","<S2SV_ModStart> ( code ) { * status = ""DECODE_PA_S4U_X509_USER"" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
CWE-125,"CWE-125 static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) , exception ) ; SetPixelIndex ( image , index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image , exception ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MagickPathExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MagickPathExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
",ImageMagick@ImageMagick/6d202a0514fb6a406456b8b728cde776becb25f8,CVE-2016-7537,https://github.com/ImageMagick/ImageMagick/commit/6d202a0514fb6a406456b8b728cde776becb25f8,2017-04-19T14:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void fdct16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fdct16_8col ( in0 ) ; fdct16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-755,"CWE-755 void acpi_ns_terminate ( void ) { acpi_status status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( ns_terminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { union acpi_operand_object * prev ; <S2SV_StartBug> union acpi_operand_object * next ; <S2SV_EndBug> next = acpi_gbl_module_code_list ; while ( next ) { prev = next ; next = next -> method . mutex ; prev -> method . mutex = NULL ; acpi_ut_remove_reference ( prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( status ) ) { return_VOID ; } acpi_ns_delete_node ( acpi_gbl_root_node ) ; ( void ) acpi_ut_release_mutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespace<S2SV_blank>freed\\n"" ) ) ; return_VOID ; }
","<S2SV_ModStart> acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * <S2SV_ModStart> acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node
",torvalds@linux/3b2d69114fefa474fca542e51119036dceb4aa6f,CVE-2017-11472,https://github.com/torvalds/linux/commit/3b2d69114fefa474fca542e51119036dceb4aa6f,2017-07-20T04:29Z
CWE-416,"CWE-416 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } <S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
",miniupnp@miniupnp/140ee8d2204b383279f854802b27bdb41c1d5d1a,CVE-2016-3179,https://github.com/miniupnp/miniupnp/commit/140ee8d2204b383279f854802b27bdb41c1d5d1a,2017-03-24T15:59Z
CWE-119,"CWE-119 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }
","<S2SV_ModStart> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> 0 ) ; }
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9537,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a,2016-11-22T19:59Z
CWE-119,"CWE-119 static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) { free ( ctx -> cx_data ) ; vp9_remove_compressor ( ctx -> cpi ) ; <S2SV_StartBug> free ( ctx ) ; <S2SV_EndBug> return VPX_CODEC_OK ; }
","<S2SV_ModStart> cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) { <S2SV_StartBug> WORD32 i ; <S2SV_EndBug> WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_after [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_curr_before [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_st_foll [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_list_temp0 [ MAX_DPB_SIZE ] , * as_ref_pic_list_temp1 [ MAX_DPB_SIZE ] ; UWORD32 u4_num_rps_curr_temp_list0 , u4_num_rps_curr_temp_list1 ; WORD32 i4_pic_order_cnt_val ; WORD32 i4_poc_lt ; UNUSED ( as_ref_pic_lt_foll ) ; UNUSED ( as_ref_pic_st_foll ) ; UNUSED ( ps_pps ) ; RETURN_IF_NAL_INFO ; u4_max_poc_lsb = ( 1 << ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; i4_pic_order_cnt_val = ps_slice_hdr -> i4_abs_pic_order_cnt ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; pi2_delta_poc = ps_sps -> as_stref_picset [ st_rps_idx ] . ai2_delta_poc ; } else { st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; pi2_delta_poc = ps_slice_hdr -> s_stref_picset . ai2_delta_poc ; } u4_num_st_curr_before = 0 ; u4_num_st_foll = 0 ; for ( i = 0 ; i < num_neg_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_before [ u4_num_st_curr_before ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_before ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_st_curr_after = 0 ; for ( i = num_neg_pics ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { ai4_poc_st_curr_after [ u4_num_st_curr_after ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_curr_after ++ ; } else { ai4_poc_st_foll [ u4_num_st_foll ] = i4_pic_order_cnt_val + pi2_delta_poc [ i ] ; u4_num_st_foll ++ ; } } u4_num_lt_curr = 0 ; u4_num_lt_foll = 0 ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { i4_poc_lt = ps_slice_hdr -> ai4_poc_lsb_lt [ i ] ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { i4_poc_lt += i4_pic_order_cnt_val - ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] * u4_max_poc_lsb - ps_slice_hdr -> i4_pic_order_cnt_lsb ; } if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { ai4_poc_lt_curr [ u4_num_lt_curr ] = i4_poc_lt ; ai1_curr_delta_poc_msb_present_flag [ u4_num_lt_curr ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_curr ++ ; } else { ai4_poc_lt_foll [ u4_num_lt_foll ] = i4_poc_lt ; ai1_foll_delta_poc_msb_present_flag [ u4_num_lt_foll ] = ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ; u4_num_lt_foll ++ ; } } u4_num_total_curr = u4_num_lt_curr + u4_num_st_curr_after + u4_num_st_curr_before ; if ( 0 == ps_codec -> i4_pic_present ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref = UNUSED_FOR_REF ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_curr ; i ++ ) { if ( 0 == ai1_curr_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_curr [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_lt_foll ; i ++ ) { if ( 0 == ai1_foll_delta_poc_msb_present_flag [ i ] ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc_lsb ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } else { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_lt_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = LONG_TERM_REF ; as_ref_pic_lt_foll [ i ] = ps_pic_buf ; } } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_before ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_before [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_curr_after ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_curr_after [ i ] = ps_pic_buf ; } for ( i = 0 ; i < ( WORD32 ) u4_num_st_foll ; i ++ ) { ps_pic_buf = ihevc_dpb_mgr_get_ref_by_poc ( ps_dpb_mgr , ai4_poc_st_foll [ i ] ) ; if ( NULL != ps_pic_buf ) ps_pic_buf -> u1_used_as_ref = SHORT_TERM_REF ; as_ref_pic_st_foll [ i ] = ps_pic_buf ; } u4_num_rps_curr_temp_list0 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l0_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { while ( r_idx < u4_num_rps_curr_temp_list0 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list0 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp0 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 ? ( void * ) as_ref_pic_list_temp0 [ ps_slice_hdr -> s_rplm . i1_list_entry_l0 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp0 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } if ( ps_slice_hdr -> i1_slice_type == BSLICE ) { u4_num_rps_curr_temp_list1 = ( WORD32 ) u4_num_total_curr > ps_slice_hdr -> i1_num_ref_idx_l1_active ? ( WORD32 ) u4_num_total_curr : ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx = 0 ; while ( r_idx < u4_num_rps_curr_temp_list1 ) { for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_after ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_after [ i ] ) { as_ref_pic_st_curr_after [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_after [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_after [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_st_curr_before ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_st_curr_before [ i ] ) { as_ref_pic_st_curr_before [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_st_curr_before [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_st_curr_before [ i ] ; } for ( i = 0 ; ( i < ( WORD32 ) u4_num_lt_curr ) && ( r_idx < u4_num_rps_curr_temp_list1 ) ; r_idx ++ , i ++ ) { if ( NULL == as_ref_pic_lt_curr [ i ] ) { as_ref_pic_lt_curr [ i ] = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ai4_poc_lt_curr [ i ] ) ; } as_ref_pic_list_temp1 [ r_idx ] = as_ref_pic_lt_curr [ i ] ; } } for ( r_idx = 0 ; ( WORD32 ) r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { pic_buf_t * ps_pic_buf ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 ? ( void * ) as_ref_pic_list_temp1 [ ps_slice_hdr -> s_rplm . i1_list_entry_l1 [ r_idx ] ] : ( void * ) as_ref_pic_list_temp1 [ r_idx ] ; ps_pic_buf = ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ; if ( ps_pic_buf == NULL ) return IHEVCD_REF_PIC_NOT_FOUND ; ps_mv_buf = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ps_mv_buf ; } } } DEBUG_PRINT_REF_LIST_POCS ( i4_pic_order_cnt_val , ps_slice_hdr , ps_dpb_mgr , u4_num_st_curr_before , u4_num_st_curr_after , u4_num_st_foll , u4_num_lt_curr , u4_num_lt_foll , ai4_poc_st_curr_before , ai4_poc_st_curr_after , ai4_poc_st_foll , ai4_poc_lt_curr , ai4_poc_lt_foll ) ; for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) && ( UNUSED_FOR_REF == ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf -> u1_used_as_ref ) ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ps_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> break ; } ps_mv_buf ++ ; } } } return IHEVCD_SUCCESS ; }
","<S2SV_ModStart> { WORD32 i , j <S2SV_ModStart> ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> -> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF )
",external@libhevc/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,CVE-2017-0642,https://android.googlesource.com/platform/external/libhevc/+/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,2017-06-14T13:29Z
CWE-119,"CWE-119 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ; <S2SV_StartBug> bool is_drop_n_account = false ; <S2SV_EndBug> BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned int maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) <S2SV_EndBug> netoff += sizeof ( struct virtio_net_hdr ) ; <S2SV_StartBug> macoff = netoff - maclen ; <S2SV_EndBug> } if ( po -> tp_version <= TPACKET_V2 ) { if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) < sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; <S2SV_StartBug> if ( ( int ) snaplen < 0 ) <S2SV_EndBug> <S2SV_StartBug> snaplen = 0 ; <S2SV_EndBug> } } else if ( unlikely ( macoff + snaplen > GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ) ) { u32 nval ; nval = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len - macoff ; pr_err_once ( ""tpacket_rcv:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>big,<S2SV_blank>clamped<S2SV_blank>from<S2SV_blank>%u<S2SV_blank>to<S2SV_blank>%u.<S2SV_blank>macoff=%u\\n"" , snaplen , nval , macoff ) ; snaplen = nval ; if ( unlikely ( ( int ) snaplen < 0 ) ) { snaplen = 0 ; macoff = GET_PBDQC_FROM_RB ( & po -> rx_ring ) -> max_frame_len ; <S2SV_StartBug> } <S2SV_EndBug> } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_rx_frame ( po , skb , TP_STATUS_KERNEL , ( macoff + snaplen ) ) ; if ( ! h . raw ) goto drop_n_account ; if ( po -> tp_version <= TPACKET_V2 ) { packet_increment_rx_head ( po , & po -> rx_ring ) ; if ( po -> stats . stats1 . tp_drops ) status |= TP_STATUS_LOSING ; } po -> stats . stats1 . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } spin_unlock ( & sk -> sk_receive_queue . lock ) ; <S2SV_StartBug> if ( po -> has_vnet_hdr ) { <S2SV_EndBug> if ( virtio_net_hdr_from_skb ( skb , h . raw + macoff - sizeof ( struct virtio_net_hdr ) , vio_le ( ) , true ) ) { spin_lock ( & sk -> sk_receive_queue . lock ) ; goto drop_n_account ; } } skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; if ( ! ( ts_status = tpacket_get_timestamp ( skb , & ts , po -> tp_tstamp ) ) ) getnstimeofday ( & ts ) ; status |= ts_status ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; h . h1 -> tp_sec = ts . tv_sec ; h . h1 -> tp_usec = ts . tv_nsec / NSEC_PER_USEC ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( skb_vlan_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = skb_vlan_tag_get ( skb ) ; h . h2 -> tp_vlan_tpid = ntohs ( skb -> vlan_proto ) ; status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; h . h2 -> tp_vlan_tpid = 0 ; } memset ( h . h2 -> tp_padding , 0 , sizeof ( h . h2 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h2 ) ; break ; case TPACKET_V3 : h . h3 -> tp_status |= status ; h . h3 -> tp_len = skb -> len ; h . h3 -> tp_snaplen = snaplen ; h . h3 -> tp_mac = macoff ; h . h3 -> tp_net = netoff ; h . h3 -> tp_sec = ts . tv_sec ; h . h3 -> tp_nsec = ts . tv_nsec ; memset ( h . h3 -> tp_padding , 0 , sizeof ( h . h3 -> tp_padding ) ) ; hdrlen = sizeof ( * h . h3 ) ; break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if ( po -> tp_version <= TPACKET_V2 ) { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } smp_wmb ( ) ; # endif if ( po -> tp_version <= TPACKET_V2 ) { __packet_set_status ( po , h . raw , status ) ; sk -> sk_data_ready ( sk ) ; } else { prb_clear_blk_fill_status ( & po -> rx_ring ) ; } drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : if ( ! is_drop_n_account ) consume_skb ( skb ) ; else kfree_skb ( skb ) ; return 0 ; drop_n_account : is_drop_n_account = true ; po -> stats . stats1 . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
","<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
",torvalds@linux/edbd58be15a957f6a760c4a514cd475217eb97fd,CVE-2017-14497,https://github.com/torvalds/linux/commit/edbd58be15a957f6a760c4a514cd475217eb97fd,2017-09-15T18:29Z
CWE-426,"CWE-426 static void set_own_dir ( const char * argv0 ) { size_t l = strlen ( argv0 ) ; while ( l && argv0 [ l - 1 ] != '/' ) l -- ; if ( l == 0 ) <S2SV_StartBug> memcpy ( own_dir , ""."" , 2 ) ; <S2SV_EndBug> else { memcpy ( own_dir , argv0 , l - 1 ) ; own_dir [ l ] = 0 ; } }
","<S2SV_ModStart> == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , ""/dev/null/"" , 2 ) ; # else <S2SV_ModStart> 2 ) ; # endif
",rofl0r@proxychains-ng/9ab7dbeb3baff67a51d0c5e71465c453be0890b5,CVE-2015-3887,https://github.com/rofl0r/proxychains-ng/commit/9ab7dbeb3baff67a51d0c5e71465c453be0890b5,2017-09-21T16:29Z
CWE-264,"CWE-264 long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA : <S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; # endif # ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; # endif # ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; # endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }
","<S2SV_ModStart> ) -> tp_value [ 0 ]
",torvalds@linux/a4780adeefd042482f624f5e0d577bf9cdcbb760,CVE-2014-9870,https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760,2016-08-06T10:59Z
CWE-125,"CWE-125 arg_ty <S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { arg_ty p ; if ( ! arg ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg"" ) ; return NULL ; } p = ( arg_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> arg = arg ; p -> annotation = annotation ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
","<S2SV_ModStart> expr_ty annotation , string type_comment , <S2SV_ModStart> ; p -> type_comment = type_comment ; p ->
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-000,"CWE-000 <S2SV_StartBug> static int can_open_delegated ( struct nfs_delegation * delegation , mode_t open_flags ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( delegation -> type & open_flags ) != open_flags ) <S2SV_EndBug> return 0 ; if ( test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) ) return 0 ; nfs_mark_delegation_referenced ( delegation ) ; return 1 ; }
","<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) return 0
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-000,"CWE-000 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <S2SV_StartBug> unsigned short sel ; <S2SV_EndBug> memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <S2SV_StartBug> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <S2SV_EndBug> if ( rc != X86EMUL_CONTINUE ) return rc ; <S2SV_StartBug> ctxt -> _eip = 0 ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
","<S2SV_ModStart> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModStart> return rc ; rc = assign_eip_far ( ctxt <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * corrupted = va_arg ( args , int * ) ; VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( corrupted && pbi ) { <S2SV_StartBug> * corrupted = pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> pbi ) { const YV12_BUFFER_CONFIG * const frame <S2SV_ModEnd> = pbi -> <S2SV_ModStart> common . frame_to_show ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; <S2SV_StartBug> int hdrlen ; <S2SV_EndBug> uint16_t fc ; uint8_t seq ; <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ; return caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( fc ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; if ( hdrlen == - 1 ) { ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ; return caplen ; } if ( ! ndo -> ndo_vflag ) { p += hdrlen ; caplen -= hdrlen ; } else { uint16_t panid = 0 ; <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case 0x02 : panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> p += 2 ; break ; <S2SV_StartBug> case 0x03 : <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; <S2SV_StartBug> case 0x01 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> -> caplen ; u_int <S2SV_ModEnd> hdrlen ; uint16_t <S2SV_ModStart> uint8_t seq ; <S2SV_ModEnd> uint16_t panid = <S2SV_ModStart> = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ndo , p + 2 <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> ) { case <S2SV_ModStart> ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> 0 ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/9be4e0b5938b705e7e36cfcb110a740c6ff0cb97,CVE-2017-13000,https://github.com/the-tcpdump-group/tcpdump/commit/9be4e0b5938b705e7e36cfcb110a740c6ff0cb97,2017-09-14T06:29Z
CWE-787,"CWE-787 char * uwsgi_expand_path ( char * dir , int dir_len , char * ptr ) { <S2SV_StartBug> char src [ PATH_MAX + 1 ] ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( src , dir , dir_len ) ; <S2SV_EndBug> src [ dir_len ] = 0 ; char * dst = ptr ; if ( ! dst ) dst = uwsgi_malloc ( PATH_MAX + 1 ) ; if ( ! realpath ( src , dst ) ) { uwsgi_error_realpath ( src ) ; if ( ! ptr ) free ( dst ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return dst ; }
","<S2SV_ModStart> ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( ""invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n"" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> dir , dir_len <S2SV_ModStart> dir , dir_len , """" , 0 ) <S2SV_ModEnd> ; char * <S2SV_ModStart> dst ) ; free ( src ) ; <S2SV_ModStart> NULL ; } free ( src ) ;
",unbit@uwsgi/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe,CVE-2018-6758,https://github.com/unbit/uwsgi/commit/cb4636f7c0af2e97a4eef7a3cdcbd85a71247bfe,2018-02-06T18:29Z
CWE-200,"CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
","<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
",torvalds@linux/250c6c49e3b68756b14983c076183568636e2bde,CVE-2018-6412,https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde,2018-01-31T07:29Z
CWE-362,"CWE-362 static long __mptctl_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { mpt_ioctl_header __user * uhdr = ( void __user * ) arg ; mpt_ioctl_header khdr ; int iocnum ; unsigned iocnumX ; int nonblock = ( file -> f_flags & O_NONBLOCK ) ; int ret ; MPT_ADAPTER * iocp = NULL ; if ( copy_from_user ( & khdr , uhdr , sizeof ( khdr ) ) ) { printk ( KERN_ERR MYNAM ""%s::mptctl_ioctl()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>mpt_ioctl_header<S2SV_blank>data<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uhdr ) ; return - EFAULT ; } ret = - ENXIO ; iocnumX = khdr . iocnum & 0xFF ; if ( ( ( iocnum = mpt_verify_adapter ( iocnumX , & iocp ) ) < 0 ) || ( iocp == NULL ) ) return - ENODEV ; if ( ! iocp -> active ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_ioctl()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>Controller<S2SV_blank>disabled.\\n"" , __FILE__ , __LINE__ ) ; return - EFAULT ; } if ( ( cmd & ~ IOCSIZE_MASK ) == ( MPTIOCINFO & ~ IOCSIZE_MASK ) ) { <S2SV_StartBug> return mptctl_getiocinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> } else if ( cmd == MPTTARGETINFO ) { <S2SV_StartBug> return mptctl_gettargetinfo ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTTEST ) { <S2SV_StartBug> return mptctl_readtest ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTQUERY ) { <S2SV_StartBug> return mptctl_eventquery ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTENABLE ) { <S2SV_StartBug> return mptctl_eventenable ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTEVENTREPORT ) { <S2SV_StartBug> return mptctl_eventreport ( arg ) ; <S2SV_EndBug> } else if ( cmd == MPTFWREPLACE ) { <S2SV_StartBug> return mptctl_replace_fw ( arg ) ; <S2SV_EndBug> } if ( ( ret = mptctl_syscall_down ( iocp , nonblock ) ) != 0 ) return ret ; if ( cmd == MPTFWDOWNLOAD ) <S2SV_StartBug> ret = mptctl_fw_download ( arg ) ; <S2SV_EndBug> else if ( cmd == MPTCOMMAND ) <S2SV_StartBug> ret = mptctl_mpt_command ( arg ) ; <S2SV_EndBug> else if ( cmd == MPTHARDRESET ) <S2SV_StartBug> ret = mptctl_do_reset ( arg ) ; <S2SV_EndBug> else if ( ( cmd & ~ IOCSIZE_MASK ) == ( HP_GETHOSTINFO & ~ IOCSIZE_MASK ) ) <S2SV_StartBug> ret = mptctl_hp_hostinfo ( arg , _IOC_SIZE ( cmd ) ) ; <S2SV_EndBug> else if ( cmd == HP_GETTARGETINFO ) <S2SV_StartBug> ret = mptctl_hp_targetinfo ( arg ) ; <S2SV_EndBug> else ret = - EINVAL ; mutex_unlock ( & iocp -> ioctl_cmds . mutex ) ; return ret ; }
","<S2SV_ModStart> return mptctl_getiocinfo ( iocp , <S2SV_ModStart> return mptctl_gettargetinfo ( iocp , <S2SV_ModStart> return mptctl_readtest ( iocp , <S2SV_ModStart> return mptctl_eventquery ( iocp , <S2SV_ModStart> return mptctl_eventenable ( iocp , <S2SV_ModStart> return mptctl_eventreport ( iocp , <S2SV_ModStart> return mptctl_replace_fw ( iocp , <S2SV_ModStart> = mptctl_fw_download ( iocp , <S2SV_ModStart> = mptctl_mpt_command ( iocp , <S2SV_ModStart> = mptctl_do_reset ( iocp , <S2SV_ModStart> = mptctl_hp_hostinfo ( iocp , <S2SV_ModStart> = mptctl_hp_targetinfo ( iocp ,
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-264,"CWE-264 <S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }
","<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z
CWE-20,"CWE-20 static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND ) <S2SV_StartBug> goto end ; <S2SV_EndBug> msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }
","<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-617,"CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; <S2SV_StartBug> assert ( bidx <= PCI_BARMAX ) ; <S2SV_EndBug> <S2SV_StartBug> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <S2SV_EndBug> <S2SV_StartBug> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <S2SV_EndBug> assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , 4 ) ; val_lo = bar_value ( 4 , val_lo ) ; val_hi = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 ) ; * val = val_lo | ( val_hi << 32 ) ; } else { * val = ( * ops -> vdev_barread ) ( ctx , vcpu , pdi , bidx , offset , size ) ; * val = bar_value ( size , * val ) ; } } return 0 ; }
","<S2SV_ModStart> ) arg2 ; if ( addr + size > <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . addr + <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . size ) { pr_err ( ""%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\n"" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> offset = addr
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-190,"CWE-190 <S2SV_StartBug> void jas_seq2d_bindsub ( jas_matrix_t * s , jas_matrix_t * s1 , int xstart , <S2SV_EndBug> int ystart , int xend , int yend ) { jas_matrix_bindsub ( s , s1 , ystart - s1 -> ystart_ , xstart - s1 -> xstart_ , yend - s1 -> ystart_ - 1 , xend - s1 -> xstart_ - 1 ) ; }
","<S2SV_ModStart> * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-362,"CWE-362 int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; <S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , ""card%d"" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n"" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n"" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }
","<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
",torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,CVE-2014-4652,https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,2014-07-03T04:22Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> const int ref_frame_flags = va_arg ( args , int ) ; vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void setup_features ( VP8_COMP * cpi ) { if ( cpi -> mb . e_mbd . segmentation_enabled ) { cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; } else { cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; } cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . last_mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> set_default_lf_deltas ( cpi ) ; }
","<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-404,"CWE-404 static int omninet_open ( struct tty_struct * tty , struct usb_serial_port * port ) { <S2SV_StartBug> struct usb_serial * serial = port -> serial ; <S2SV_EndBug> struct usb_serial_port * wport ; wport = serial -> port [ 1 ] ; tty_port_tty_set ( & wport -> port , tty ) ; return usb_serial_generic_open ( tty , port ) ; }
","<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
",torvalds@linux/30572418b445d85fcfe6c8fe84c947d2606767d8,CVE-2017-8925,https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8,2017-05-12T21:29Z
CWE-787,"CWE-787 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , ""BitmapUpdate:<S2SV_blank>%"" PRIu32 """" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) { <S2SV_StartBug> UINT16 count ; <S2SV_EndBug> BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ; <S2SV_StartBug> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <S2SV_EndBug> sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }
","<S2SV_ModStart> count ) { UINT32 <S2SV_ModEnd> count = bitmapUpdate <S2SV_ModStart> * 2 ; BITMAP_DATA *
",FreeRDP@FreeRDP/445a5a42c500ceb80f8fa7f2c11f3682538033f3,CVE-2018-8786,https://github.com/FreeRDP/FreeRDP/commit/445a5a42c500ceb80f8fa7f2c11f3682538033f3,2018-11-29T18:29Z
CWE-119,"CWE-119 static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( cc % ( bps * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""cc%(bps*stride))!=0"" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; return 1 ; }
","<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
",vadz@libtiff/6a984bf7905c6621281588431f384e79d11a2e33,CVE-2016-9535,https://github.com/vadz/libtiff/commit/6a984bf7905c6621281588431f384e79d11a2e33,2016-11-22T19:59Z
CWE-388,"CWE-388 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; <S2SV_StartBug> goto fail ; <S2SV_EndBug> } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; ret = - EINVAL ;
",torvalds@linux/6b8ac63847bc2f958dd93c09edc941a0118992d9,CVE-2017-5577,https://github.com/torvalds/linux/commit/6b8ac63847bc2f958dd93c09edc941a0118992d9,2017-02-06T06:59Z
CWE-908,"CWE-908 static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; <S2SV_StartBug> if ( ext_depth ( inode ) ) <S2SV_EndBug> goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } <S2SV_StartBug> memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , <S2SV_EndBug> <S2SV_StartBug> sizeof ( EXT4_I ( inode ) -> i_data ) ) ; <S2SV_EndBug> neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; ext4_extent_block_csum_set ( inode , neh ) ; set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto out ; neh = ext_inode_hdr ( inode ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; ext4_idx_store_pblock ( EXT_FIRST_INDEX ( neh ) , newblock ) ; if ( neh -> eh_depth == 0 ) { neh -> eh_max = cpu_to_le16 ( ext4_ext_space_root_idx ( inode , 0 ) ) ; EXT_FIRST_INDEX ( neh ) -> ei_block = EXT_FIRST_EXTENT ( neh ) -> ee_block ; } ext_debug ( ""new<S2SV_blank>root:<S2SV_blank>num<S2SV_blank>%d(%d),<S2SV_blank>lblock<S2SV_blank>%d,<S2SV_blank>ptr<S2SV_blank>%llu\\n"" , le16_to_cpu ( neh -> eh_entries ) , le16_to_cpu ( neh -> eh_max ) , le32_to_cpu ( EXT_FIRST_INDEX ( neh ) -> ei_block ) , ext4_idx_pblock ( EXT_FIRST_INDEX ( neh ) ) ) ; le16_add_cpu ( & neh -> eh_depth , 1 ) ; ext4_mark_inode_dirty ( handle , inode ) ; out : brelse ( bh ) ; return err ; }
","<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
",torvalds@linux/592acbf16821288ecdc4192c47e3774a4c48bb64,CVE-2019-11833,https://github.com/torvalds/linux/commit/592acbf16821288ecdc4192c47e3774a4c48bb64,2019-05-15T13:29Z
CWE-362,"CWE-362 static struct sock * tcp_v6_syn_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * treq ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; struct ipv6_txoptions * opt ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } treq = inet6_rsk ( req ) ; opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , req ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & treq -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & treq -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & treq -> loc_addr ) ; newsk -> sk_bound_dev_if = treq -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( treq -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( treq -> pktopts , GFP_ATOMIC ) ; kfree_skb ( treq -> pktopts ) ; treq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; tcp_mtup_init ( newsk ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = dst_metric_advmss ( dst ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG if ( ( key = tcp_v6_md5_do_lookup ( sk , & newnp -> daddr ) ) != NULL ) { char * newkey = kmemdup ( key -> key , key -> keylen , GFP_ATOMIC ) ; if ( newkey != NULL ) tcp_v6_md5_do_add ( newsk , & newnp -> daddr , newkey , key -> keylen ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : if ( opt && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-264,"CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }
","<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
",torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e,CVE-2011-4127,https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e,2012-07-03T16:40Z
CWE-476,"CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
","<S2SV_ModStart> service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
",torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_SYNC_MASK ) { ND_PRINT ( ( ndo , ""S"" ) ) ; } }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static char * print_object ( cJSON * item , int depth , int fmt ) <S2SV_EndBug> { char * * entries = 0 , * * names = 0 ; char * out = 0 , * ptr , * ret , * str ; int len = 7 , i = 0 , j ; cJSON * child = item -> child ; int numentries = 0 , fail = 0 ; <S2SV_StartBug> while ( child ) { <S2SV_EndBug> ++ numentries ; child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; ++ depth ; if ( fmt ) len += depth ; while ( child ) { <S2SV_StartBug> names [ i ] = str = print_string_ptr ( child -> string ) ; <S2SV_EndBug> <S2SV_StartBug> entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ; <S2SV_EndBug> if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ; else fail = 1 ; child = child -> next ; } <S2SV_StartBug> if ( ! fail ) { <S2SV_EndBug> out = ( char * ) cJSON_malloc ( len ) ; if ( ! out ) fail = 1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( fail ) { <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> if ( names [ i ] ) cJSON_free ( names [ i ] ) ; if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; return 0 ; } * out = '{' ; ptr = out + 1 ; <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> * ptr ++ = '\\n' ; * ptr = 0 ; <S2SV_StartBug> for ( i = 0 ; i < numentries ; ++ i ) { <S2SV_EndBug> if ( fmt ) <S2SV_StartBug> for ( j = 0 ; j < depth ; ++ j ) <S2SV_EndBug> * ptr ++ = '\\t' ; <S2SV_StartBug> strcpy ( ptr , names [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> ptr += strlen ( names [ i ] ) ; <S2SV_EndBug> * ptr ++ = ':' ; <S2SV_StartBug> if ( fmt ) <S2SV_EndBug> * ptr ++ = '\\t' ; strcpy ( ptr , entries [ i ] ) ; ptr += strlen ( entries [ i ] ) ; if ( i != numentries - 1 ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; cJSON_free ( names [ i ] ) ; cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; if ( fmt ) <S2SV_StartBug> for ( i = 0 ; i < depth - 1 ; ++ i ) <S2SV_EndBug> * ptr ++ = '\\t' ; * ptr ++ = '}' ; <S2SV_StartBug> * ptr ++ = 0 ; <S2SV_EndBug> return out ; }
","<S2SV_ModStart> , int fmt , printbuffer * p <S2SV_ModStart> = 0 ; size_t tmplen = 0 ; <S2SV_ModStart> ( child ) numentries ++ , child = child -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ; else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ; if ( ! out ) return 0 ; ptr = out ; * ptr ++ = '{' ; if ( fmt ) { * ptr ++ = '\\n' ; for ( i = 0 ; i < depth ; i ++ ) * ptr ++ = '\\t' ; } * ptr ++ = '}' ; * ptr ++ = 0 ; return out ; } if ( p ) { i = p -> offset ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = '{' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = item -> child ; depth ++ ; while ( child ) { if ( fmt ) { ptr = ensure ( p , depth ) ; if ( ! ptr ) return 0 ; for ( j = 0 ; j < depth ; j ++ ) * ptr ++ = '\\t' ; p -> offset += depth ; } print_string_ptr ( child -> string , p ) ; p -> offset = update ( p ) ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len ) ; if ( ! ptr ) return 0 ; * ptr ++ = ':' ; if ( fmt ) * ptr ++ = '\\t' ; p -> offset += len ; print_value ( child , depth , fmt , p ) ; p -> offset = update ( p ) ; len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; if ( child -> next ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = child -> next ; } ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ; if ( ! ptr ) return 0 ; if ( fmt ) for ( i = 0 ; i < depth - 1 ; i ++ ) * ptr ++ = '\\t' ; * ptr ++ = '}' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! names ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; depth ++ ; if ( fmt ) len += depth ; while ( child && ! fail ) <S2SV_ModEnd> { names [ <S2SV_ModStart> child -> string , 0 <S2SV_ModStart> depth , fmt , 0 <S2SV_ModStart> ! fail ) <S2SV_ModEnd> out = ( <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( fail <S2SV_ModStart> < numentries ; i ++ <S2SV_ModEnd> ) { if <S2SV_ModStart> + 1 ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> < numentries ; i ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> < depth ; j ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '\\t' ; tmplen = strlen ( <S2SV_ModEnd> names [ i <S2SV_ModStart> ] ) ; memcpy ( ptr , <S2SV_ModEnd> names [ i <S2SV_ModStart> [ i ] , tmplen ) ; ptr += tmplen <S2SV_ModEnd> ; * ptr <S2SV_ModStart> = ':' ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> - 1 ; i ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '}' ; * ptr ++ = 0 ; } <S2SV_ModEnd> return out ;
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-119,"CWE-119 void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int filt_mid <S2SV_ModEnd> ; int filt_low <S2SV_ModStart> -> frame_to_show ; memset <S2SV_ModEnd> ( ss_err ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { <S2SV_StartBug> struct ikev2_id id ; <S2SV_EndBug> int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , id . h . critical ) ; id_len = ntohs ( id . h . len ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d"" , id_len - 4 ) ) ; if ( 2 < ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : ND_PRINT ( ( ndo , ""<S2SV_blank>dn:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_GN : ND_PRINT ( ( ndo , ""<S2SV_blank>gn:"" ) ) ; dumphex = 1 ; break ; case ID_KEY_ID : ND_PRINT ( ( ndo , ""<S2SV_blank>keyid:"" ) ) ; dumphex = 1 ; break ; } if ( dumpascii ) { ND_TCHECK2 ( * typedata , idtype_len ) ; for ( i = 0 ; i < idtype_len ; i ++ ) { if ( ND_ISPRINT ( typedata [ i ] ) ) { ND_PRINT ( ( ndo , ""%c"" , typedata [ i ] ) ) ; } else { ND_PRINT ( ( ndo , ""."" ) ) ; } } } if ( dumphex ) { if ( ! rawprint ( ndo , ( const uint8_t * ) typedata , idtype_len ) ) goto trunc ; } return ( const u_char * ) ext + id_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
",the-tcpdump-group@tcpdump/8dca25d26c7ca2caf6138267f6f17111212c156e,CVE-2017-13690,https://github.com/the-tcpdump-group/tcpdump/commit/8dca25d26c7ca2caf6138267f6f17111212c156e,2017-09-14T06:29Z
CWE-617,"CWE-617 int ff_h263_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MpegEncContext * s = avctx -> priv_data ; int ret ; int slice_ret = 0 ; AVFrame * pict = data ; if ( buf_size == 0 ) { if ( s -> low_delay == 0 && s -> next_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> next_picture_ptr -> f ) ) < 0 ) return ret ; s -> next_picture_ptr = NULL ; * got_frame = 1 ; } return 0 ; } if ( s -> avctx -> flags & AV_CODEC_FLAG_TRUNCATED ) { int next ; if ( CONFIG_MPEG4_DECODER && s -> codec_id == AV_CODEC_ID_MPEG4 ) { next = ff_mpeg4_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263_DECODER && s -> codec_id == AV_CODEC_ID_H263 ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else if ( CONFIG_H263P_DECODER && s -> codec_id == AV_CODEC_ID_H263P ) { next = ff_h263_find_frame_end ( & s -> parse_context , buf , buf_size ) ; } else { av_log ( s -> avctx , AV_LOG_ERROR , ""this<S2SV_blank>codec<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>truncated<S2SV_blank>bitstreams\\n"" ) ; return AVERROR ( ENOSYS ) ; } if ( ff_combine_frame ( & s -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) return buf_size ; } retry : if ( s -> divx_packed && s -> bitstream_buffer_size ) { int i ; for ( i = 0 ; i < buf_size - 3 ; i ++ ) { if ( buf [ i ] == 0 && buf [ i + 1 ] == 0 && buf [ i + 2 ] == 1 ) { if ( buf [ i + 3 ] == 0xB0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Discarding<S2SV_blank>excessive<S2SV_blank>bitstream<S2SV_blank>in<S2SV_blank>packed<S2SV_blank>xvid\\n"" ) ; s -> bitstream_buffer_size = 0 ; } break ; } } } if ( s -> bitstream_buffer_size && ( s -> divx_packed || buf_size <= MAX_NVOP_SIZE ) ) ret = init_get_bits8 ( & s -> gb , s -> bitstream_buffer , s -> bitstream_buffer_size ) ; else ret = init_get_bits8 ( & s -> gb , buf , buf_size ) ; s -> bitstream_buffer_size = 0 ; if ( ret < 0 ) return ret ; if ( ! s -> context_initialized ) ff_mpv_idct_init ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_picture_header ( s ) ; } else if ( CONFIG_MSMPEG4_DECODER && s -> msmpeg4_version ) { ret = ff_msmpeg4_decode_picture_header ( s ) ; } else if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( s -> avctx -> extradata_size && s -> picture_number == 0 ) { GetBitContext gb ; if ( init_get_bits8 ( & gb , s -> avctx -> extradata , s -> avctx -> extradata_size ) >= 0 ) ff_mpeg4_decode_picture_header ( avctx -> priv_data , & gb ) ; } ret = ff_mpeg4_decode_picture_header ( avctx -> priv_data , & s -> gb ) ; } else if ( CONFIG_H263I_DECODER && s -> codec_id == AV_CODEC_ID_H263I ) { ret = ff_intel_h263_decode_picture_header ( s ) ; } else if ( CONFIG_FLV_DECODER && s -> h263_flv ) { ret = ff_flv_decode_picture_header ( s ) ; } else { ret = ff_h263_decode_picture_header ( s ) ; } if ( ret < 0 || ret == FRAME_SKIPPED ) { if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Reverting<S2SV_blank>picture<S2SV_blank>dimensions<S2SV_blank>change<S2SV_blank>due<S2SV_blank>to<S2SV_blank>header<S2SV_blank>decoding<S2SV_blank>failure\\n"" ) ; s -> width = avctx -> coded_width ; s -> height = avctx -> coded_height ; } } if ( ret == FRAME_SKIPPED ) return get_consumed_bytes ( s , buf_size ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""header<S2SV_blank>damaged\\n"" ) ; return ret ; } if ( ! s -> context_initialized ) { avctx -> pix_fmt = h263_get_format ( avctx ) ; if ( ( ret = ff_mpv_common_init ( s ) ) < 0 ) return ret ; } if ( ! s -> current_picture_ptr || s -> current_picture_ptr -> f -> data [ 0 ] ) { int i = ff_find_unused_picture ( s -> avctx , s -> picture , 0 ) ; if ( i < 0 ) return i ; s -> current_picture_ptr = & s -> picture [ i ] ; } avctx -> has_b_frames = ! s -> low_delay ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) { if ( ff_mpeg4_workaround_bugs ( avctx ) == 1 ) goto retry ; if ( s -> studio_profile != ( s -> idsp . idct == NULL ) ) ff_mpv_idct_init ( s ) ; } if ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height || s -> context_reinit ) { s -> context_reinit = 0 ; ret = ff_set_dimensions ( avctx , s -> width , s -> height ) ; if ( ret < 0 ) return ret ; ff_set_sar ( avctx , avctx -> sample_aspect_ratio ) ; if ( ( ret = ff_mpv_common_frame_size_change ( s ) ) ) return ret ; if ( avctx -> pix_fmt != h263_get_format ( avctx ) ) { av_log ( avctx , AV_LOG_ERROR , ""format<S2SV_blank>change<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; avctx -> pix_fmt = AV_PIX_FMT_NONE ; return AVERROR_UNKNOWN ; } } if ( s -> codec_id == AV_CODEC_ID_H263 || s -> codec_id == AV_CODEC_ID_H263P || s -> codec_id == AV_CODEC_ID_H263I ) s -> gob_index = H263_GOB_HEIGHT ( s -> height ) ; s -> current_picture . f -> pict_type = s -> pict_type ; s -> current_picture . f -> key_frame = s -> pict_type == AV_PICTURE_TYPE_I ; if ( ! s -> last_picture_ptr && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) return get_consumed_bytes ( s , buf_size ) ; if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) return get_consumed_bytes ( s , buf_size ) ; if ( s -> next_p_frame_damaged ) { if ( s -> pict_type == AV_PICTURE_TYPE_B ) return get_consumed_bytes ( s , buf_size ) ; else s -> next_p_frame_damaged = 0 ; } if ( ( ! s -> no_rounding ) || s -> pict_type == AV_PICTURE_TYPE_B ) { s -> me . qpel_put = s -> qdsp . put_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } else { s -> me . qpel_put = s -> qdsp . put_no_rnd_qpel_pixels_tab ; s -> me . qpel_avg = s -> qdsp . avg_qpel_pixels_tab ; } if ( ( ret = ff_mpv_frame_start ( s , avctx ) ) < 0 ) return ret ; if ( ! s -> divx_packed ) ff_thread_finish_setup ( avctx ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> start_frame ( avctx , s -> gb . buffer , s -> gb . buffer_end - s -> gb . buffer ) ; if ( ret < 0 ) return ret ; } ff_mpeg_er_frame_start ( s ) ; if ( CONFIG_WMV2_DECODER && s -> msmpeg4_version == 5 ) { ret = ff_wmv2_decode_secondary_picture_header ( s ) ; if ( ret < 0 ) return ret ; if ( ret == 1 ) goto frame_end ; } s -> mb_x = 0 ; s -> mb_y = 0 ; slice_ret = decode_slice ( s ) ; while ( s -> mb_y < s -> mb_height ) { if ( s -> msmpeg4_version ) { if ( s -> slice_height == 0 || s -> mb_x != 0 || slice_ret < 0 || ( s -> mb_y % s -> slice_height ) != 0 || get_bits_left ( & s -> gb ) < 0 ) break ; } else { int prev_x = s -> mb_x , prev_y = s -> mb_y ; if ( ff_h263_resync ( s ) < 0 ) break ; if ( prev_y * s -> mb_width + prev_x < s -> mb_y * s -> mb_width + s -> mb_x ) s -> er . error_occurred = 1 ; } if ( s -> msmpeg4_version < 4 && s -> h263_pred ) ff_mpeg4_clean_buffers ( s ) ; if ( decode_slice ( s ) < 0 ) slice_ret = AVERROR_INVALIDDATA ; } if ( s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) if ( ! CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header ( s , buf_size ) < 0 ) s -> er . error_status_table [ s -> mb_num - 1 ] = ER_MB_ERROR ; av_assert1 ( s -> bitstream_buffer_size == 0 ) ; <S2SV_StartBug> frame_end : <S2SV_EndBug> ff_er_frame_end ( & s -> er ) ; if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> end_frame ( avctx ) ; if ( ret < 0 ) return ret ; } ff_mpv_frame_end ( s ) ; if ( CONFIG_MPEG4_DECODER && avctx -> codec_id == AV_CODEC_ID_MPEG4 ) ff_mpeg4_frame_end ( avctx , buf , buf_size ) ; if ( ! s -> divx_packed && avctx -> hwaccel ) ff_thread_finish_setup ( avctx ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> current_picture_ptr -> f -> pict_type ) ; av_assert1 ( s -> current_picture . f -> pict_type == s -> pict_type ) ; if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) { if ( ( ret = av_frame_ref ( pict , s -> current_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> current_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> current_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } else if ( s -> last_picture_ptr ) { if ( ( ret = av_frame_ref ( pict , s -> last_picture_ptr -> f ) ) < 0 ) return ret ; ff_print_debug_info ( s , s -> last_picture_ptr , pict ) ; ff_mpv_export_qp_table ( s , pict , s -> last_picture_ptr , FF_QSCALE_TYPE_MPEG1 ) ; } if ( s -> last_picture_ptr || s -> low_delay ) { if ( pict -> format == AV_PIX_FMT_YUV420P && ( s -> codec_tag == AV_RL32 ( ""GEOV"" ) || s -> codec_tag == AV_RL32 ( ""GEOX"" ) ) ) { int x , y , p ; av_frame_make_writable ( pict ) ; for ( p = 0 ; p < 3 ; p ++ ) { int w = AV_CEIL_RSHIFT ( pict -> width , ! ! p ) ; int h = AV_CEIL_RSHIFT ( pict -> height , ! ! p ) ; int linesize = pict -> linesize [ p ] ; for ( y = 0 ; y < ( h >> 1 ) ; y ++ ) for ( x = 0 ; x < w ; x ++ ) FFSWAP ( int , pict -> data [ p ] [ x + y * linesize ] , pict -> data [ p ] [ x + ( h - 1 - y ) * linesize ] ) ; } } * got_frame = 1 ; } if ( slice_ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return slice_ret ; else return get_consumed_bytes ( s , buf_size ) ; }
","<S2SV_ModStart> ; frame_end : if ( ! s -> studio_profile )
",FFmpeg@FFmpeg/bd27a9364ca274ca97f1df6d984e88a0700fb235,CVE-2018-13304,https://github.com/FFmpeg/FFmpeg/commit/bd27a9364ca274ca97f1df6d984e88a0700fb235,2018-07-05T17:29Z
CWE-125,"CWE-125 INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; <S2SV_StartBug> RAnalOp next_op ; <S2SV_EndBug> avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""!,"" : ""!,!,"" ) ; ESIL_A ( ""?{,%"" PFMT64d "",pc,=,},"" , op -> jump ) ; }
","<S2SV_ModStart> ; RAnalOp next_op = { 0 }
",radare@radare2/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,CVE-2018-11377,https://github.com/radare/radare2/commit/25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4,2018-05-22T19:29Z
CWE-119,"CWE-119 <S2SV_StartBug> int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) { <S2SV_EndBug> int start_index = rc -> worst_quality ; int target_index = rc -> worst_quality ; int i ; for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { start_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qstart ) <S2SV_EndBug> break ; } for ( i = rc -> best_quality ; i < rc -> worst_quality ; ++ i ) { target_index = i ; <S2SV_StartBug> if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) <S2SV_EndBug> break ; } return target_index - start_index ; }
","<S2SV_ModStart> , double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( i , bit_depth
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-362,"CWE-362 struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) { int error ; struct dentry * dentry = NULL , * trap ; <S2SV_StartBug> const char * old_name ; <S2SV_EndBug> trap = lock_rename ( new_dir , old_dir ) ; if ( d_really_is_negative ( old_dir ) || d_really_is_negative ( new_dir ) ) goto exit ; if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ; dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ; if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ; <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { fsnotify_oldname_free ( old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ; <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> unlock_rename ( new_dir , old_dir ) ; dput ( dentry ) ; return old_dentry ; exit : if ( dentry && ! IS_ERR ( dentry ) ) dput ( dentry ) ; unlock_rename ( new_dir , old_dir ) ; return NULL ; }
","<S2SV_ModStart> * trap ; struct name_snapshot <S2SV_ModEnd> old_name ; trap <S2SV_ModStart> goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> , d_is_dir ( <S2SV_ModStart> old_dentry ) ; release_dentry_name_snapshot ( & <S2SV_ModEnd> old_name ) ;
",torvalds@linux/49d31c2f389acfe83417083e1208422b4091cd9e,CVE-2017-7533,https://github.com/torvalds/linux/commit/49d31c2f389acfe83417083e1208422b4091cd9e,2017-08-05T16:29Z
CWE-787,"CWE-787 RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
","<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
CWE-834,"CWE-834 <S2SV_StartBug> static unsigned int XBMInteger ( Image * image , short int * hex_digits ) <S2SV_EndBug> { int c ; unsigned int value ; do { c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } while ( ( c == '<S2SV_blank>' ) || ( c == '\\t' ) || ( c == '\\n' ) || ( c == '\\r' ) ) ; value = 0 ; do { if ( value > ( unsigned int ) ( INT_MAX / 10 ) ) break ; value *= 16 ; c &= 0xff ; if ( value > ( unsigned int ) ( INT_MAX - hex_digits [ c ] ) ) break ; value += hex_digits [ c ] ; c = ReadBlobByte ( image ) ; if ( c == EOF ) <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } while ( hex_digits [ c ] >= 0 ) ; <S2SV_StartBug> return ( value ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; return ( ( int )
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z
CWE-190,"CWE-190 uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>"" ""empty<S2SV_blank>extents<S2SV_blank>btree\\n"" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>"" ""root<S2SV_blank>node<S2SV_blank>%"" PRIu32 "";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%"" PRIu16 ""\\n"" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file"" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid"" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>@<S2SV_blank>%"" PRIu64 ""<S2SV_blank>has<S2SV_blank>%"" PRIu16 ""<S2SV_blank>records\\n"" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%"" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d"" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node"" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; <S2SV_StartBug> uint16_t keylen ; <S2SV_EndBug> rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%"" PRIu16 "")"" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( ""hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error"" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , ""hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf"" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( ""hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(%"" PRIu64 "")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%"" PRIu8 "")"" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
","<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off
",sleuthkit@sleuthkit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b,CVE-2019-1010065,https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b,2019-07-18T17:15Z
CWE-20,"CWE-20 static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { sco_conn_defer_accept ( pi -> conn -> hcon , pi -> setting ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
","<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-190,"CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; <S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
",torvalds@linux/0f2ff82e11c86c05d051cae32b58226392d33bbf,CVE-2017-5576,https://github.com/torvalds/linux/commit/0f2ff82e11c86c05d051cae32b58226392d33bbf,2017-02-06T06:59Z
CWE-119,"CWE-119 void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/712f4aad406bb1ed67f3f98d04c044191f0ff593,CVE-2013-4312,https://github.com/torvalds/linux/commit/712f4aad406bb1ed67f3f98d04c044191f0ff593,2016-02-08T03:59Z
CWE-362,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-119,"CWE-119 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; <S2SV_StartBug> dtls1_process_buffered_records ( s ) ; <S2SV_EndBug> if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] == SSL3_MT_CLIENT_HELLO ) && ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; <S2SV_EndBug> } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <S2SV_StartBug> return ( 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
CWE-264,"CWE-264 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; <S2SV_StartBug> } <S2SV_EndBug> return opt2 ; }
","<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-189,"CWE-189 Pairs * hstoreArrayToPairs ( ArrayType * a , int * npairs ) { Datum * key_datums ; bool * key_nulls ; int key_count ; Pairs * key_pairs ; int bufsiz ; int i , j ; deconstruct_array ( a , TEXTOID , - 1 , false , 'i' , & key_datums , & key_nulls , & key_count ) ; if ( key_count == 0 ) { * npairs = 0 ; return NULL ; } <S2SV_StartBug> key_pairs = palloc ( sizeof ( Pairs ) * key_count ) ; <S2SV_EndBug> for ( i = 0 , j = 0 ; i < key_count ; i ++ ) { if ( ! key_nulls [ i ] ) { key_pairs [ j ] . key = VARDATA ( key_datums [ i ] ) ; key_pairs [ j ] . keylen = VARSIZE ( key_datums [ i ] ) - VARHDRSZ ; key_pairs [ j ] . val = NULL ; key_pairs [ j ] . vallen = 0 ; key_pairs [ j ] . needfree = 0 ; key_pairs [ j ] . isnull = 1 ; j ++ ; } } * npairs = hstoreUniquePairs ( key_pairs , j , & bufsiz ) ; return key_pairs ; }
","<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-119,"CWE-119 static void nonrd_use_partition ( VP9_COMP * cpi , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled , <S2SV_StartBug> int * totrate , int64_t * totdist ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> const int mis = cm -> mi_stride ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_StartBug> int rate = INT_MAX ; <S2SV_EndBug> int64_t dist = INT64_MAX ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_StartBug> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; <S2SV_EndBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> case PARTITION_NONE : <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , <S2SV_EndBug> & rate , & dist , subsize ) ; get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_HORZ : <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , <S2SV_EndBug> & rate , & dist , subsize ) ; <S2SV_StartBug> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; <S2SV_EndBug> <S2SV_StartBug> if ( rate != INT_MAX && dist != INT64_MAX && <S2SV_EndBug> * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } } break ; case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> * get_sb_index ( x , subsize ) = 0 ; <S2SV_EndBug> <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , <S2SV_EndBug> <S2SV_StartBug> subsize , output_enabled , totrate , totdist ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , <S2SV_EndBug> mi_row , mi_col + hbs , subsize , output_enabled , <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , <S2SV_EndBug> <S2SV_StartBug> mi_row + hbs , mi_col , subsize , output_enabled , <S2SV_EndBug> <S2SV_StartBug> & rate , & dist ) ; <S2SV_EndBug> if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } * get_sb_index ( x , subsize ) = 3 ; nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis + hbs , tp , mi_row + hbs , mi_col + hbs , subsize , output_enabled , & rate , & dist ) ; if ( rate != INT_MAX && dist != INT64_MAX && * totrate != INT_MAX && * totdist != INT64_MAX ) { * totrate += rate ; * totdist += dist ; } break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( bsize == BLOCK_64X64 && output_enabled ) { <S2SV_EndBug> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , * totrate , * totdist ) ; encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , 1 , bsize ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , TOKENEXTRA * <S2SV_ModStart> int output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> -> common ; TileInfo * tile_info = & tile_data -> tile_info ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> BLOCK_SIZE subsize ; <S2SV_ModEnd> if ( mi_row <S2SV_ModStart> BLOCK_8X8 ) ? mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } <S2SV_ModStart> case PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) <S2SV_ModStart> case PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> -> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; <S2SV_ModEnd> } break ; <S2SV_ModStart> case PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes ( <S2SV_ModStart> ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> ] -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ( cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . mbmi <S2SV_ModStart> . mbmi = xd -> mi <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> -> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> } break ; <S2SV_ModStart> PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> nonrd_use_partition ( cpi <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> , tp , <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; nonrd_use_partition ( <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> + hbs , <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; nonrd_use_partition ( <S2SV_ModStart> ( cpi , td , tile_data , mi <S2SV_ModEnd> + hbs * <S2SV_ModStart> hbs * mis + hbs <S2SV_ModStart> hbs , mi_col + hbs <S2SV_ModStart> , output_enabled , dummy_cost , pc_tree -> split [ 3 ] ) <S2SV_ModEnd> ; } break <S2SV_ModStart> : assert ( 0 && <S2SV_ModStart> ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break ; <S2SV_ModStart> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize <S2SV_ModEnd> , bsize ) <S2SV_ModStart> bsize ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static int next_state_class ( CClassNode * cc , OnigCodePoint * vs , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; if ( * state == CCS_RANGE ) return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE ; if ( * state == CCS_VALUE && * type != CCV_CLASS ) { if ( * type == CCV_SB ) BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } } <S2SV_StartBug> * state = CCS_VALUE ; <S2SV_EndBug> * type = CCV_CLASS ; return 0 ; }
","<S2SV_ModStart> ; } } if ( * state != CCS_START )
",kkos@oniguruma/3b63d12038c8d8fc278e81c942fa9bec7c704c8b,CVE-2017-9228,https://github.com/kkos/oniguruma/commit/3b63d12038c8d8fc278e81c942fa9bec7c704c8b,2017-05-24T15:29Z
CWE-20,"CWE-20 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re"" , <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-000,"CWE-000 int jpc_bitstream_putbits ( jpc_bitstream_t * bitstream , int n , long v ) { int m ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> assert ( ! ( v & ( ~ JAS_ONES ( n ) ) ) ) ; m = n - 1 ; while ( -- n >= 0 ) { if ( jpc_bitstream_putbit ( bitstream , ( v >> m ) & 1 ) == EOF ) { return EOF ; } v <<= 1 ; } return 0 ; }
","<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z
CWE-000,"CWE-000 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-835,"CWE-835 static Status accept_xsmp_connection ( SmsConn sms_conn , GsmXsmpServer * server , unsigned long * mask_ret , SmsCallbacks * callbacks_ret , char * * failure_reason_ret ) { IceConn ice_conn ; <S2SV_StartBug> GsmXSMPClient * client ; <S2SV_EndBug> if ( server -> priv -> xsmp_sockets == NULL ) { g_debug ( ""GsmXsmpServer:<S2SV_blank>In<S2SV_blank>shutdown,<S2SV_blank>rejecting<S2SV_blank>new<S2SV_blank>client"" ) ; * failure_reason_ret = strdup ( _ ( ""Refusing<S2SV_blank>new<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>because<S2SV_blank>the<S2SV_blank>session<S2SV_blank>is<S2SV_blank>currently<S2SV_blank>being<S2SV_blank>shut<S2SV_blank>down\\n"" ) ) ; return FALSE ; } ice_conn = SmsGetIceConnection ( sms_conn ) ; <S2SV_StartBug> client = ice_conn -> context ; <S2SV_EndBug> <S2SV_StartBug> g_return_val_if_fail ( client != NULL , TRUE ) ; <S2SV_EndBug> <S2SV_StartBug> gsm_xsmp_client_connect ( client , sms_conn , mask_ret , callbacks_ret ) ; <S2SV_EndBug> return TRUE ; }
","<S2SV_ModStart> IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( <S2SV_ModStart> sms_conn ) ; data <S2SV_ModEnd> = ice_conn -> <S2SV_ModStart> -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; gsm_xsmp_client_connect <S2SV_ModStart> ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn ,
",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
CWE-125,"CWE-125 static MagickBooleanType Get8BIMProperty ( const Image * image , const char * key , ExceptionInfo * exception ) { char * attribute , format [ MagickPathExtent ] , name [ MagickPathExtent ] , * resource ; const StringInfo * profile ; const unsigned char * info ; long start , stop ; MagickBooleanType status ; register ssize_t i ; size_t length ; ssize_t count , id , sub_number ; profile = GetImageProfile ( image , ""8bim"" ) ; if ( profile == ( StringInfo * ) NULL ) return ( MagickFalse ) ; count = ( ssize_t ) sscanf ( key , ""8BIM:%ld,%ld:%1024[^\\n]\\n%1024[^\\n]"" , & start , & stop , name , format ) ; if ( ( count != 2 ) && ( count != 3 ) && ( count != 4 ) ) return ( MagickFalse ) ; if ( count < 4 ) ( void ) CopyMagickString ( format , ""SVG"" , MagickPathExtent ) ; if ( count < 3 ) * name = '\\0' ; sub_number = 1 ; if ( * name == '#' ) sub_number = ( ssize_t ) StringToLong ( & name [ 1 ] ) ; sub_number = MagickMax ( sub_number , 1L ) ; resource = ( char * ) NULL ; status = MagickFalse ; length = GetStringInfoLength ( profile ) ; info = GetStringInfoDatum ( profile ) ; while ( ( length > 0 ) && ( status == MagickFalse ) ) { if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) '8' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'B' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'I' ) continue ; if ( ReadPropertyByte ( & info , & length ) != ( unsigned char ) 'M' ) continue ; id = ( ssize_t ) ReadPropertyMSBShort ( & info , & length ) ; if ( id < ( ssize_t ) start ) continue ; if ( id > ( ssize_t ) stop ) continue ; if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; count = ( ssize_t ) ReadPropertyByte ( & info , & length ) ; if ( ( count != 0 ) && ( ( size_t ) count <= length ) ) { resource = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) resource = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * resource ) ) ; if ( resource != ( char * ) NULL ) { for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) resource [ i ] = ( char ) ReadPropertyByte ( & info , & length ) ; resource [ count ] = '\\0' ; } } if ( ( count & 0x01 ) == 0 ) ( void ) ReadPropertyByte ( & info , & length ) ; count = ( ssize_t ) ReadPropertyMSBLong ( & info , & length ) ; <S2SV_StartBug> if ( ( * name != '\\0' ) && ( * name != '#' ) ) <S2SV_EndBug> if ( ( resource == ( char * ) NULL ) || ( LocaleCompare ( name , resource ) != 0 ) ) { info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } if ( ( * name == '#' ) && ( sub_number != 1 ) ) { sub_number -- ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; continue ; } attribute = ( char * ) NULL ; if ( ~ ( ( size_t ) count ) >= ( MagickPathExtent - 1 ) ) attribute = ( char * ) AcquireQuantumMemory ( ( size_t ) count + MagickPathExtent , sizeof ( * attribute ) ) ; if ( attribute != ( char * ) NULL ) { ( void ) CopyMagickMemory ( attribute , ( char * ) info , ( size_t ) count ) ; attribute [ count ] = '\\0' ; info += count ; length -= MagickMin ( count , ( ssize_t ) length ) ; if ( ( id <= 1999 ) || ( id >= 2999 ) ) ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) attribute , exception ) ; else { char * path ; if ( LocaleCompare ( format , ""svg"" ) == 0 ) path = TraceSVGClippath ( ( unsigned char * ) attribute , ( size_t ) count , image -> columns , image -> rows ) ; else path = TracePSClippath ( ( unsigned char * ) attribute , ( size_t ) count ) ; ( void ) SetImageProperty ( ( Image * ) image , key , ( const char * ) path , exception ) ; path = DestroyString ( path ) ; } attribute = DestroyString ( attribute ) ; status = MagickTrue ; } } if ( resource != ( char * ) NULL ) resource = DestroyString ( resource ) ; return ( status ) ; }
","<S2SV_ModStart> if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
",ImageMagick@ImageMagick/dd84447b63a71fa8c3f47071b09454efc667767b,CVE-2016-6491,https://github.com/ImageMagick/ImageMagick/commit/dd84447b63a71fa8c3f47071b09454efc667767b,2016-12-13T15:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void fadst4 ( const int16_t * input , int16_t * output ) { <S2SV_EndBug> <S2SV_StartBug> int x0 , x1 , x2 , x3 ; <S2SV_EndBug> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; x0 = input [ 0 ] ; x1 = input [ 1 ] ; x2 = input [ 2 ] ; x3 = input [ 3 ] ; if ( ! ( x0 | x1 | x2 | x3 ) ) { output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ; return ; } s0 = sinpi_1_9 * x0 ; s1 = sinpi_4_9 * x0 ; s2 = sinpi_2_9 * x1 ; s3 = sinpi_1_9 * x1 ; s4 = sinpi_3_9 * x2 ; s5 = sinpi_4_9 * x3 ; s6 = sinpi_2_9 * x3 ; s7 = x0 + x1 - x3 ; x0 = s0 + s2 + s5 ; x1 = sinpi_3_9 * s7 ; x2 = s1 - s3 + s6 ; x3 = s4 ; s0 = x0 + x3 ; s1 = x1 ; s2 = x2 - x3 ; s3 = x2 - x0 + x3 ; <S2SV_StartBug> output [ 0 ] = fdct_round_shift ( s0 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 1 ] = fdct_round_shift ( s1 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 2 ] = fdct_round_shift ( s2 ) ; <S2SV_EndBug> <S2SV_StartBug> output [ 3 ] = fdct_round_shift ( s3 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> fadst4 ( const tran_low_t * input , tran_low_t <S2SV_ModEnd> * output ) <S2SV_ModStart> output ) { tran_high_t x0 , x1 , x2 , x3 ; tran_high_t <S2SV_ModEnd> s0 , s1 <S2SV_ModStart> 0 ] = ( tran_low_t ) <S2SV_ModStart> 1 ] = ( tran_low_t ) <S2SV_ModStart> 2 ] = ( tran_low_t ) <S2SV_ModStart> 3 ] = ( tran_low_t )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , ""ssa"" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , ""msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format"" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , ""Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed"" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }
","<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
",php@php-src/6d55ba265637d6adf0ba7e9c9ef11187d1ec2f5b,CVE-2016-7416,https://github.com/php/php-src/commit/6d55ba265637d6adf0ba7e9c9ef11187d1ec2f5b,2016-09-17T21:59Z
CWE-119,"CWE-119 static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map"" ) ; }
","<S2SV_ModStart> map = { 0 , 0 ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
","<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
",xkbcommon@libxkbcommon/38e1766bc6e20108948aec8a0b222a4bad0254e9,CVE-2018-15861,https://github.com/xkbcommon/libxkbcommon/commit/38e1766bc6e20108948aec8a0b222a4bad0254e9,2018-08-25T21:29Z
CWE-20,"CWE-20 error_t udpSendDatagram ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; <S2SV_StartBug> NetTxAncillary ancillary ; <S2SV_EndBug> buffer = udpAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( ! error ) { ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif <S2SV_StartBug> error = udpSendBuffer ( socket -> interface , & message -> srcIpAddr , <S2SV_EndBug> socket -> localPort , & message -> destIpAddr , message -> destPort , buffer , offset , & ancillary ) ; } netBufferFree ( buffer ) ; return error ; }
","<S2SV_ModStart> * buffer ; NetInterface * interface ; <S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModStart> = udpSendBuffer ( <S2SV_ModEnd> interface , &
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; skb -> ip_summed = CHECKSUM_NONE ; if ( ! skb -> encap_hdr_csum ) features |= NETIF_F_HW_CSUM ; tnl_hlen = skb_tnl_header_len ( skb ) ; if ( skb -> mac_header < ( tnl_hlen + frag_hdr_sz ) ) { if ( gso_pskb_expand_head ( skb , tnl_hlen + frag_hdr_sz ) ) goto out ; } unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> nexthdr = * prevhdr ; <S2SV_EndBug> * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = ( skb_network_header ( skb ) - skb_mac_header ( skb ) ) + unfrag_ip6hlen + tnl_hlen ; packet_start = ( u8 * ) skb -> head + SKB_GSO_CB ( skb ) -> mac_offset ; memmove ( packet_start - frag_hdr_sz , packet_start , unfrag_len ) ; SKB_GSO_CB ( skb ) -> mac_offset -= frag_hdr_sz ; skb -> mac_header -= frag_hdr_sz ; skb -> network_header -= frag_hdr_sz ; fptr = ( struct frag_hdr * ) ( skb_network_header ( skb ) + unfrag_ip6hlen ) ; fptr -> nexthdr = nexthdr ; fptr -> reserved = 0 ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; fptr -> identification = skb_shinfo ( skb ) -> ip6_frag_id ; segs = skb_segment ( skb , features ) ; } out : return segs ; }
","<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z
CWE-404,"CWE-404 int nfs3svc_decode_readdirplusargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { int len ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> count = min ( args -> count , max_blocksize ) ; <S2SV_EndBug> while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; if ( ! args -> buffer ) args -> buffer = page_address ( p ) ; len -= PAGE_SIZE ; } <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ; } return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-399,"CWE-399 static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; <S2SV_StartBug> if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { <S2SV_EndBug> kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }
","<S2SV_ModStart> , size - skb_out <S2SV_ModEnd> -> len ,
",torvalds@linux/5b6698b0e4a37053de35cc24ee695b98a7eb712b,CVE-2014-9428,https://github.com/torvalds/linux/commit/5b6698b0e4a37053de35cc24ee695b98a7eb712b,2015-01-02T21:59Z
CWE-20,"CWE-20 <S2SV_StartBug> void exit_io_context ( void ) <S2SV_EndBug> { struct io_context * ioc ; <S2SV_StartBug> task_lock ( current ) ; <S2SV_EndBug> <S2SV_StartBug> ioc = current -> io_context ; <S2SV_EndBug> <S2SV_StartBug> current -> io_context = NULL ; <S2SV_EndBug> <S2SV_StartBug> task_unlock ( current ) ; <S2SV_EndBug> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
","<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
",torvalds@linux/b69f2292063d2caf37ca9aec7d63ded203701bf3,CVE-2012-0879,https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3,2012-05-17T11:00Z
CWE-400,"CWE-400 static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }
","<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
",nghttp2@nghttp2/336a98feb0d56b9ac54e12736b18785c27f75090,CVE-2020-11080,https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090,2020-06-03T23:15Z
CWE-399,"CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; <S2SV_StartBug> set_exception_intercept ( svm , MC_VECTOR ) ; <S2SV_EndBug> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm , INTERCEPT_STGI ) ; set_intercept ( svm , INTERCEPT_CLGI ) ; set_intercept ( svm , INTERCEPT_SKINIT ) ; set_intercept ( svm , INTERCEPT_WBINVD ) ; set_intercept ( svm , INTERCEPT_MONITOR ) ; set_intercept ( svm , INTERCEPT_MWAIT ) ; set_intercept ( svm , INTERCEPT_XSETBV ) ; control -> iopm_base_pa = iopm_base ; control -> msrpm_base_pa = __pa ( svm -> msrpm ) ; control -> int_ctl = V_INTR_MASKING_MASK ; init_seg ( & save -> es ) ; init_seg ( & save -> ss ) ; init_seg ( & save -> ds ) ; init_seg ( & save -> fs ) ; init_seg ( & save -> gs ) ; save -> cs . selector = 0xf000 ; save -> cs . base = 0xffff0000 ; save -> cs . attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK ; save -> cs . limit = 0xffff ; save -> gdtr . limit = 0xffff ; save -> idtr . limit = 0xffff ; init_sys_seg ( & save -> ldtr , SEG_TYPE_LDT ) ; init_sys_seg ( & save -> tr , SEG_TYPE_BUSY_TSS16 ) ; svm_set_efer ( & svm -> vcpu , 0 ) ; save -> dr6 = 0xffff0ff0 ; kvm_set_rflags ( & svm -> vcpu , 2 ) ; save -> rip = 0x0000fff0 ; svm -> vcpu . arch . regs [ VCPU_REGS_RIP ] = save -> rip ; svm_set_cr0 ( & svm -> vcpu , X86_CR0_NW | X86_CR0_CD | X86_CR0_ET ) ; kvm_mmu_reset_context ( & svm -> vcpu ) ; save -> cr4 = X86_CR4_PAE ; if ( npt_enabled ) { control -> nested_ctl = 1 ; clr_intercept ( svm , INTERCEPT_INVLPG ) ; clr_exception_intercept ( svm , PF_VECTOR ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; clr_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; save -> g_pat = svm -> vcpu . arch . pat ; save -> cr3 = 0 ; save -> cr4 = 0 ; } svm -> asid_generation = 0 ; svm -> nested . vmcb = 0 ; svm -> vcpu . arch . hflags = 0 ; if ( boot_cpu_has ( X86_FEATURE_PAUSEFILTER ) ) { control -> pause_filter_count = 3000 ; set_intercept ( svm , INTERCEPT_PAUSE ) ; } mark_all_dirty ( svm -> vmcb ) ; enable_gif ( svm ) ; }
","<S2SV_ModStart> svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
",torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed,CVE-2015-5307,https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed,2015-11-16T11:59Z
CWE-200,"CWE-200 int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
","<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
",torvalds@linux/0d0138ebe24b94065580bd2601f8bb7eb6152f56,CVE-2011-2707,https://github.com/torvalds/linux/commit/0d0138ebe24b94065580bd2601f8bb7eb6152f56,2012-05-24T23:55Z
CWE-119,"CWE-119 static OM_uint32 kg_unseal_v1_iov ( krb5_context context , OM_uint32 * minor_status , krb5_gss_ctx_id_rec * ctx , gss_iov_buffer_desc * iov , int iov_count , size_t token_wrapper_len , int * conf_state , gss_qop_t * qop_state , int toktype ) { OM_uint32 code ; gss_iov_buffer_t header ; gss_iov_buffer_t trailer ; unsigned char * ptr ; int sealalg ; int signalg ; krb5_checksum cksum ; krb5_checksum md5cksum ; size_t cksum_len = 0 ; size_t conflen = 0 ; int direction ; krb5_ui_4 seqnum ; OM_uint32 retval ; size_t sumlen ; krb5_keyusage sign_usage = KG_USAGE_SIGN ; md5cksum . length = cksum . length = 0 ; md5cksum . contents = cksum . contents = NULL ; header = kg_locate_header_iov ( iov , iov_count , toktype ) ; assert ( header != NULL ) ; trailer = kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_TRAILER ) ; if ( trailer != NULL && trailer -> buffer . length != 0 ) { <S2SV_StartBug> * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; } <S2SV_StartBug> if ( header -> buffer . length < token_wrapper_len + 14 ) { <S2SV_EndBug> * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ptr = ( unsigned char * ) header -> buffer . value + token_wrapper_len ; signalg = ptr [ 0 ] ; signalg |= ptr [ 1 ] << 8 ; sealalg = ptr [ 2 ] ; sealalg |= ptr [ 3 ] << 8 ; if ( ptr [ 4 ] != 0xFF || ptr [ 5 ] != 0xFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype == KG_TOK_WRAP_MSG && ! ( sealalg == 0xFFFF || sealalg == ctx -> sealalg ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ( ctx -> sealalg == SEAL_ALG_NONE && signalg > 1 ) || ( ctx -> sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3 ) || ( ctx -> sealalg == SEAL_ALG_DES3KD && signalg != SGN_ALG_HMAC_SHA1_DES3_KD ) || ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 && signalg != SGN_ALG_HMAC_MD5 ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_HMAC_MD5 : cksum_len = 8 ; if ( toktype != KG_TOK_WRAP_MSG ) sign_usage = 15 ; break ; case SGN_ALG_3 : cksum_len = 16 ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : cksum_len = 20 ; break ; default : * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } code = kg_get_seq_num ( context , ctx -> seq , ptr + 14 , ptr + 6 , & direction , & seqnum ) ; if ( code != 0 ) { * minor_status = code ; return GSS_S_BAD_SIG ; } if ( toktype == KG_TOK_WRAP_MSG ) { if ( sealalg != 0xFFFF ) { if ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 ) { unsigned char bigend_seqnum [ 4 ] ; krb5_keyblock * enc_key ; size_t i ; store_32_be ( seqnum , bigend_seqnum ) ; code = krb5_k_key_keyblock ( context , ctx -> enc , & enc_key ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } assert ( enc_key -> length == 16 ) ; for ( i = 0 ; i < enc_key -> length ; i ++ ) ( ( char * ) enc_key -> contents ) [ i ] ^= 0xF0 ; code = kg_arcfour_docrypt_iov ( context , enc_key , 0 , & bigend_seqnum [ 0 ] , 4 , iov , iov_count ) ; krb5_free_keyblock ( context , enc_key ) ; } else { code = kg_decrypt_iov ( context , 0 , ( ( ctx -> gss_flags & GSS_C_DCE_STYLE ) != 0 ) , 0 , 0 , ctx -> enc , KG_USAGE_SEAL , NULL , iov , iov_count ) ; } if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } } conflen = kg_confounder_size ( context , ctx -> enc -> keyblock . enctype ) ; } if ( header -> buffer . length != token_wrapper_len + 14 + cksum_len + conflen ) { retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_DES_MAC : case SGN_ALG_3 : md5cksum . checksum_type = CKSUMTYPE_RSA_MD5 ; break ; case SGN_ALG_HMAC_MD5 : md5cksum . checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : md5cksum . checksum_type = CKSUMTYPE_HMAC_SHA1_DES3 ; break ; default : abort ( ) ; } code = krb5_c_checksum_length ( context , md5cksum . checksum_type , & sumlen ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } md5cksum . length = sumlen ; code = kg_make_checksum_iov_v1 ( context , md5cksum . checksum_type , cksum_len , ctx -> seq , ctx -> enc , sign_usage , iov , iov_count , toktype , & md5cksum ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_3 : code = kg_encrypt_inplace ( context , ctx -> seq , KG_USAGE_SEAL , ( g_OID_equal ( ctx -> mech_used , gss_mech_krb5_old ) ? ctx -> seq -> keyblock . contents : NULL ) , md5cksum . contents , 16 ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } cksum . length = cksum_len ; cksum . contents = md5cksum . contents + 16 - cksum . length ; code = k5_bcmp ( cksum . contents , ptr + 14 , cksum . length ) ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : case SGN_ALG_HMAC_MD5 : code = k5_bcmp ( md5cksum . contents , ptr + 14 , cksum_len ) ; break ; default : code = 0 ; retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; break ; } if ( code != 0 ) { code = 0 ; retval = GSS_S_BAD_SIG ; goto cleanup ; } if ( toktype == KG_TOK_WRAP_MSG && ( ctx -> gss_flags & GSS_C_DCE_STYLE ) == 0 ) { retval = kg_fixup_padding_iov ( & code , iov , iov_count ) ; if ( retval != GSS_S_COMPLETE ) goto cleanup ; } if ( conf_state != NULL ) * conf_state = ( sealalg != 0xFFFF ) ; if ( qop_state != NULL ) * qop_state = GSS_C_QOP_DEFAULT ; if ( ( ctx -> initiate && direction != 0xff ) || ( ! ctx -> initiate && direction != 0 ) ) { * minor_status = ( OM_uint32 ) G_BAD_DIRECTION ; retval = GSS_S_BAD_SIG ; } code = 0 ; retval = g_order_check ( & ctx -> seqstate , ( gssint_uint64 ) seqnum ) ; cleanup : krb5_free_checksum_contents ( context , & md5cksum ) ; * minor_status = code ; return retval ; }
","<S2SV_ModStart> OM_uint32 ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> < token_wrapper_len + 22 <S2SV_ModEnd> ) { *
",krb5@krb5/e6ae703ae597d798e310368d52b8f38ee11c6a73,CVE-2014-4342,https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73,2014-07-20T11:12Z
CWE-400,"CWE-400 static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; <S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> } else { mntput ( m ) ; } return new_ns ; }
","<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
CWE-119,"CWE-119 void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }
","<S2SV_ModStart> ) return ; if ( ! cfg -> rc_target_bitrate ) return ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static vpx_codec_err_t validate_img ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img ) { switch ( img -> fmt ) { case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_I420 : <S2SV_StartBug> case VPX_IMG_FMT_I422 : <S2SV_EndBug> <S2SV_StartBug> case VPX_IMG_FMT_I444 : <S2SV_EndBug> break ; default : ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" <S2SV_StartBug> ""supported."" ) ; <S2SV_EndBug> } if ( img -> d_w != ctx -> cfg . g_w || img -> d_h != ctx -> cfg . g_h ) ERROR ( ""Image<S2SV_blank>size<S2SV_blank>must<S2SV_blank>match<S2SV_blank>encoder<S2SV_blank>init<S2SV_blank>configuration<S2SV_blank>size"" ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I42016 : break ; case <S2SV_ModStart> case VPX_IMG_FMT_I444 : case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) { ERROR ( ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile."" ) ; } <S2SV_ModStart> ""Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>Only<S2SV_blank>YV12,<S2SV_blank>I420,<S2SV_blank>I422,<S2SV_blank>I444<S2SV_blank>images<S2SV_blank>are<S2SV_blank>"" ""supported."" ) ; break
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-400,"CWE-400 static int read_packet ( int fd , gss_buffer_t buf , int timeout , int first ) { int ret ; static uint32_t len = 0 ; static char len_buf [ 4 ] ; static int len_buf_pos = 0 ; static char * tmpbuf = 0 ; static int tmpbuf_pos = 0 ; if ( first ) { len_buf_pos = 0 ; return - 2 ; } if ( len_buf_pos < 4 ) { ret = timed_read ( fd , & len_buf [ len_buf_pos ] , 4 - len_buf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( ""%s"" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { if ( len_buf_pos == 0 ) return 0 ; LOG ( LOG_INFO , ( ""EOF<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>len"" ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } len_buf_pos += ret ; } if ( len_buf_pos != 4 ) return - 2 ; len = ntohl ( * ( uint32_t * ) len_buf ) ; if ( len > GSTD_MAXPACKETCONTENTS + 512 ) { LOG ( LOG_ERR , ( ""ridiculous<S2SV_blank>length,<S2SV_blank>%ld"" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ! tmpbuf ) { if ( ( tmpbuf = malloc ( len ) ) == NULL ) { LOG ( LOG_CRIT , ( ""malloc<S2SV_blank>failure,<S2SV_blank>%ld<S2SV_blank>bytes"" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } } ret = timed_read ( fd , tmpbuf + tmpbuf_pos , len - tmpbuf_pos , timeout ) ; if ( ret == - 1 ) { if ( errno == EINTR || errno == EAGAIN ) return - 2 ; LOG ( LOG_ERR , ( ""%s"" , strerror ( errno ) ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } if ( ret == 0 ) { LOG ( LOG_ERR , ( ""EOF<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>packet<S2SV_blank>(len=%d)"" , len ) ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } tmpbuf_pos += ret ; if ( tmpbuf_pos == len ) { buf -> length = len ; buf -> value = tmpbuf ; len = len_buf_pos = tmpbuf_pos = 0 ; tmpbuf = NULL ; LOG ( LOG_DEBUG , ( ""read<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d"" , buf -> length ) ) ; return 1 ; } return - 2 ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } len_buf_pos <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } tmpbuf_pos <S2SV_ModStart> - 2 ; bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ;
",elric1@knc/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,CVE-2017-9732,https://github.com/elric1/knc/commit/f237f3e09ecbaf59c897f5046538a7b1a3fa40c1,2018-12-20T23:29Z
CWE-401,"CWE-401 static int nl80211_get_ftm_responder_stats ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct wireless_dev * wdev = dev -> ieee80211_ptr ; struct cfg80211_ftm_responder_stats ftm_stats = { } ; struct sk_buff * msg ; void * hdr ; struct nlattr * ftm_stats_attr ; int err ; if ( wdev -> iftype != NL80211_IFTYPE_AP || ! wdev -> beacon_interval ) return - EOPNOTSUPP ; err = rdev_get_ftm_responder_stats ( rdev , dev , & ftm_stats ) ; if ( err ) return err ; if ( ! ftm_stats . filled ) return - ENODATA ; msg = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! msg ) return - ENOMEM ; hdr = nl80211hdr_put ( msg , info -> snd_portid , info -> snd_seq , 0 , NL80211_CMD_GET_FTM_RESPONDER_STATS ) ; if ( ! hdr ) <S2SV_StartBug> return - ENOBUFS ; <S2SV_EndBug> if ( nla_put_u32 ( msg , NL80211_ATTR_IFINDEX , dev -> ifindex ) ) goto nla_put_failure ; ftm_stats_attr = nla_nest_start_noflag ( msg , NL80211_ATTR_FTM_RESPONDER_STATS ) ; if ( ! ftm_stats_attr ) goto nla_put_failure ; # define SET_FTM ( field , name , type ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_ ## type ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field ) ) goto nla_put_failure ; } while ( 0 ) # define SET_FTM_U64 ( field , name ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_u64_64bit ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field , NL80211_FTM_STATS_PAD ) ) goto nla_put_failure ; } while ( 0 ) SET_FTM ( success_num , SUCCESS_NUM , u32 ) ; SET_FTM ( partial_num , PARTIAL_NUM , u32 ) ; SET_FTM ( failed_num , FAILED_NUM , u32 ) ; SET_FTM ( asap_num , ASAP_NUM , u32 ) ; SET_FTM ( non_asap_num , NON_ASAP_NUM , u32 ) ; SET_FTM_U64 ( total_duration_ms , TOTAL_DURATION_MSEC ) ; SET_FTM ( unknown_triggers_num , UNKNOWN_TRIGGERS_NUM , u32 ) ; SET_FTM ( reschedule_requests_num , RESCHEDULE_REQUESTS_NUM , u32 ) ; SET_FTM ( out_of_window_triggers_num , OUT_OF_WINDOW_TRIGGERS_NUM , u32 ) ; # undef SET_FTM nla_nest_end ( msg , ftm_stats_attr ) ; genlmsg_end ( msg , hdr ) ; return genlmsg_reply ( msg , info ) ; nla_put_failure : nlmsg_free ( msg ) ; return - ENOBUFS ; }
","<S2SV_ModStart> ! hdr ) goto nla_put_failure <S2SV_ModEnd> ; if (
",torvalds@linux/1399c59fa92984836db90538cf92397fe7caaa57,CVE-2019-19055,https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57,2019-11-18T06:15Z
CWE-617,"CWE-617 int lldp_decode ( struct lldpd * cfg , char * frame , int s , struct lldpd_hardware * hardware , struct lldpd_chassis * * newchassis , struct lldpd_port * * newport ) { struct lldpd_chassis * chassis ; struct lldpd_port * port ; const char lldpaddr [ ] = LLDP_MULTICAST_ADDR ; const char dot1 [ ] = LLDP_TLV_ORG_DOT1 ; const char dot3 [ ] = LLDP_TLV_ORG_DOT3 ; const char med [ ] = LLDP_TLV_ORG_MED ; const char dcbx [ ] = LLDP_TLV_ORG_DCBX ; unsigned char orgid [ 3 ] ; int length , gotend = 0 , ttl_received = 0 ; int tlv_size , tlv_type , tlv_subtype ; u_int8_t * pos , * tlv ; char * b ; # ifdef ENABLE_DOT1 struct lldpd_vlan * vlan = NULL ; int vlan_len ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi = NULL ; # endif struct lldpd_mgmt * mgmt ; int af ; u_int8_t addr_str_length , addr_str_buffer [ 32 ] ; u_int8_t addr_family , addr_length , * addr_ptr , iface_subtype ; u_int32_t iface_number , iface ; # ifdef ENABLE_CUSTOM struct lldpd_custom * custom = NULL ; # endif log_debug ( ""lldp"" , ""receive<S2SV_blank>LLDP<S2SV_blank>PDU<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; if ( ( chassis = calloc ( 1 , sizeof ( struct lldpd_chassis ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ; return - 1 ; } TAILQ_INIT ( & chassis -> c_mgmt ) ; if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ; free ( chassis ) ; return - 1 ; } # ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ; TAILQ_INIT ( & port -> p_ppvids ) ; TAILQ_INIT ( & port -> p_pids ) ; # endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ; # endif length = s ; pos = ( u_int8_t * ) frame ; if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) { log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_DISCARD ( ETHER_ADDR_LEN ) ; if ( PEEK_UINT16 != ETHERTYPE_LLDP ) { log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } while ( length && ( ! gotend ) ) { if ( length < 2 ) { log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } tlv_size = PEEK_UINT16 ; tlv_type = tlv_size >> 9 ; tlv_size = tlv_size & 0x1ff ; ( void ) PEEK_SAVE ( tlv ) ; if ( length < tlv_size ) { log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } switch ( tlv_type ) { case LLDP_TLV_END : if ( tlv_size != 0 ) { log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; gotend = 1 ; break ; case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ; tlv_subtype = PEEK_UINT8 ; if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) { log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 1 ) ; if ( tlv_type == LLDP_TLV_PORT_ID ) { port -> p_id_subtype = tlv_subtype ; port -> p_id = b ; port -> p_id_len = tlv_size - 1 ; } else { chassis -> c_id_subtype = tlv_subtype ; chassis -> c_id = b ; chassis -> c_id_len = tlv_size - 1 ; } break ; case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ; chassis -> c_ttl = PEEK_UINT16 ; ttl_received = 1 ; break ; case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) { log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size ) ; if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ; else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ; else chassis -> c_descr = b ; break ; case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ; chassis -> c_cap_available = PEEK_UINT16 ; chassis -> c_cap_enabled = PEEK_UINT16 ; break ; case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ; addr_str_length = PEEK_UINT8 ; if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ; PEEK_BYTES ( addr_str_buffer , addr_str_length ) ; addr_length = addr_str_length - 1 ; addr_family = addr_str_buffer [ 0 ] ; addr_ptr = & addr_str_buffer [ 1 ] ; CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ; iface_subtype = PEEK_UINT8 ; iface_number = PEEK_UINT32 ; af = lldpd_af_from_lldp_proto ( addr_family ) ; if ( af == LLDPD_AF_UNSPEC ) break ; if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ; else iface = 0 ; mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ; if ( mgmt == NULL ) { <S2SV_StartBug> assert ( errno == ENOMEM ) ; <S2SV_EndBug> log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" <S2SV_StartBug> ""for<S2SV_blank>management<S2SV_blank>address"" ) ; <S2SV_EndBug> goto malformed ; } TAILQ_INSERT_TAIL ( & chassis -> c_mgmt , mgmt , m_entries ) ; break ; case LLDP_TLV_ORG : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) , ""Organisational"" ) ; PEEK_BYTES ( orgid , sizeof ( orgid ) ) ; tlv_subtype = PEEK_UINT8 ; if ( memcmp ( dot1 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT1 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT1_VLANNAME : CHECK_TLV_SIZE ( 7 , ""VLAN"" ) ; if ( ( vlan = ( struct lldpd_vlan * ) calloc ( 1 , sizeof ( struct lldpd_vlan ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } vlan -> v_vid = PEEK_UINT16 ; vlan_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 7 + vlan_len , ""VLAN"" ) ; if ( ( vlan -> v_name = ( char * ) calloc ( 1 , vlan_len + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( vlan -> v_name , vlan_len ) ; TAILQ_INSERT_TAIL ( & port -> p_vlans , vlan , v_entries ) ; vlan = NULL ; break ; case LLDP_TLV_DOT1_PVID : CHECK_TLV_SIZE ( 6 , ""PVID"" ) ; port -> p_pvid = PEEK_UINT16 ; break ; case LLDP_TLV_DOT1_PPVID : CHECK_TLV_SIZE ( 7 , ""PPVID"" ) ; if ( ( ppvid = ( struct lldpd_ppvid * ) calloc ( 1 , sizeof ( struct lldpd_ppvid ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>ppvid<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } ppvid -> p_cap_status = PEEK_UINT8 ; ppvid -> p_ppvid = PEEK_UINT16 ; TAILQ_INSERT_TAIL ( & port -> p_ppvids , ppvid , p_entries ) ; break ; case LLDP_TLV_DOT1_PI : CHECK_TLV_SIZE ( 5 , ""PI"" ) ; if ( ( pi = ( struct lldpd_pi * ) calloc ( 1 , sizeof ( struct lldpd_pi ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>PI<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } pi -> p_pi_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 5 + pi -> p_pi_len , ""PI"" ) ; if ( ( pi -> p_pi = ( char * ) calloc ( 1 , pi -> p_pi_len ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>pid<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( pi -> p_pi , pi -> p_pi_len ) ; TAILQ_INSERT_TAIL ( & port -> p_pids , pi , p_entries ) ; pi = NULL ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dot3 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT3 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT3_MAC : CHECK_TLV_SIZE ( 9 , ""MAC/PHY"" ) ; port -> p_macphy . autoneg_support = PEEK_UINT8 ; port -> p_macphy . autoneg_enabled = ( port -> p_macphy . autoneg_support & 0x2 ) >> 1 ; port -> p_macphy . autoneg_support = port -> p_macphy . autoneg_support & 0x1 ; port -> p_macphy . autoneg_advertised = PEEK_UINT16 ; port -> p_macphy . mau_type = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_LA : CHECK_TLV_SIZE ( 9 , ""Link<S2SV_blank>aggregation"" ) ; PEEK_DISCARD_UINT8 ; port -> p_aggregid = PEEK_UINT32 ; break ; case LLDP_TLV_DOT3_MFS : CHECK_TLV_SIZE ( 6 , ""MFS"" ) ; port -> p_mfs = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_POWER : CHECK_TLV_SIZE ( 7 , ""Power"" ) ; port -> p_power . devicetype = PEEK_UINT8 ; port -> p_power . supported = ( port -> p_power . devicetype & 0x2 ) >> 1 ; port -> p_power . enabled = ( port -> p_power . devicetype & 0x4 ) >> 2 ; port -> p_power . paircontrol = ( port -> p_power . devicetype & 0x8 ) >> 3 ; port -> p_power . devicetype = ( port -> p_power . devicetype & 0x1 ) ? LLDP_DOT3_POWER_PSE : LLDP_DOT3_POWER_PD ; port -> p_power . pairs = PEEK_UINT8 ; port -> p_power . class = PEEK_UINT8 ; if ( tlv_size >= 12 ) { port -> p_power . powertype = PEEK_UINT8 ; port -> p_power . source = ( port -> p_power . powertype & ( 1 << 5 | 1 << 4 ) ) >> 4 ; port -> p_power . priority = ( port -> p_power . powertype & ( 1 << 1 | 1 << 0 ) ) ; port -> p_power . powertype = ( port -> p_power . powertype & ( 1 << 7 ) ) ? LLDP_DOT3_POWER_8023AT_TYPE1 : LLDP_DOT3_POWER_8023AT_TYPE2 ; port -> p_power . requested = PEEK_UINT16 ; port -> p_power . allocated = PEEK_UINT16 ; } else port -> p_power . powertype = LLDP_DOT3_POWER_8023AT_OFF ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( med , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_LLDPMED hardware -> h_rx_unrecognized_cnt ++ ; # else u_int32_t policy ; unsigned loctype ; unsigned power ; switch ( tlv_subtype ) { case LLDP_TLV_MED_CAP : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>capabilities"" ) ; chassis -> c_med_cap_available = PEEK_UINT16 ; chassis -> c_med_type = PEEK_UINT8 ; port -> p_med_cap_enabled |= LLDP_MED_CAP_CAP ; break ; case LLDP_TLV_MED_POLICY : CHECK_TLV_SIZE ( 8 , ""LLDP-MED<S2SV_blank>policy"" ) ; policy = PEEK_UINT32 ; if ( ( ( policy >> 24 ) < 1 ) || ( ( policy >> 24 ) > LLDP_MED_APPTYPE_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>policy<S2SV_blank>field<S2SV_blank>%d<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , policy , hardware -> h_ifname ) ; break ; } port -> p_med_policy [ ( policy >> 24 ) - 1 ] . type = ( policy >> 24 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . unknown = ( ( policy & 0x800000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . tagged = ( ( policy & 0x400000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . vid = ( policy & 0x001FFE00 ) >> 9 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . priority = ( policy & 0x1C0 ) >> 6 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . dscp = policy & 0x3F ; port -> p_med_cap_enabled |= LLDP_MED_CAP_POLICY ; break ; case LLDP_TLV_MED_LOCATION : CHECK_TLV_SIZE ( 5 , ""LLDP-MED<S2SV_blank>Location"" ) ; loctype = PEEK_UINT8 ; if ( ( loctype < 1 ) || ( loctype > LLDP_MED_LOCFORMAT_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>location<S2SV_blank>type<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( port -> p_med_location [ loctype - 1 ] . data = ( char * ) malloc ( tlv_size - 5 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>LLDP-MED<S2SV_blank>location<S2SV_blank>for<S2SV_blank>"" ""frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( port -> p_med_location [ loctype - 1 ] . data , tlv_size - 5 ) ; port -> p_med_location [ loctype - 1 ] . data_len = tlv_size - 5 ; port -> p_med_location [ loctype - 1 ] . format = loctype ; port -> p_med_cap_enabled |= LLDP_MED_CAP_LOCATION ; break ; case LLDP_TLV_MED_MDI : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>PoE-MDI"" ) ; power = PEEK_UINT8 ; switch ( power & 0xC0 ) { case 0x0 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PSE ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PSE ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PRIMARY ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BACKUP ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_RESERVED ; } break ; case 0x40 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PD ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PD ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PSE ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_LOCAL ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BOTH ; } break ; default : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_RESERVED ; } if ( ( power & 0x0F ) > LLDP_MED_POW_PRIO_LOW ) port -> p_med_power . priority = LLDP_MED_POW_PRIO_UNKNOWN ; else port -> p_med_power . priority = power & 0x0F ; port -> p_med_power . val = PEEK_UINT16 ; break ; case LLDP_TLV_MED_IV_HW : case LLDP_TLV_MED_IV_SW : case LLDP_TLV_MED_IV_FW : case LLDP_TLV_MED_IV_SN : case LLDP_TLV_MED_IV_MANUF : case LLDP_TLV_MED_IV_MODEL : case LLDP_TLV_MED_IV_ASSET : if ( tlv_size <= 4 ) b = NULL ; else { if ( ( b = ( char * ) malloc ( tlv_size - 3 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>"" ""memory<S2SV_blank>for<S2SV_blank>LLDP-MED<S2SV_blank>"" ""inventory<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 4 ) ; b [ tlv_size - 4 ] = '\\0' ; } switch ( tlv_subtype ) { case LLDP_TLV_MED_IV_HW : chassis -> c_med_hw = b ; break ; case LLDP_TLV_MED_IV_FW : chassis -> c_med_fw = b ; break ; case LLDP_TLV_MED_IV_SW : chassis -> c_med_sw = b ; break ; case LLDP_TLV_MED_IV_SN : chassis -> c_med_sn = b ; break ; case LLDP_TLV_MED_IV_MANUF : chassis -> c_med_manuf = b ; break ; case LLDP_TLV_MED_IV_MODEL : chassis -> c_med_model = b ; break ; case LLDP_TLV_MED_IV_ASSET : chassis -> c_med_asset = b ; break ; } port -> p_med_cap_enabled |= LLDP_MED_CAP_IV ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dcbx , orgid , sizeof ( orgid ) ) == 0 ) { log_debug ( ""lldp"" , ""unsupported<S2SV_blank>DCBX<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>ignore"" , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; } else { log_debug ( ""lldp"" , ""unknown<S2SV_blank>org<S2SV_blank>tlv<S2SV_blank>[%02x:%02x:%02x]<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , orgid [ 0 ] , orgid [ 1 ] , orgid [ 2 ] , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; # ifdef ENABLE_CUSTOM custom = ( struct lldpd_custom * ) calloc ( 1 , sizeof ( struct lldpd_custom ) ) ; if ( ! custom ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV"" ) ; goto malformed ; } custom -> oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0 ; memcpy ( custom -> oui , orgid , sizeof ( custom -> oui ) ) ; custom -> subtype = tlv_subtype ; if ( custom -> oui_info_len > 0 ) { custom -> oui_info = malloc ( custom -> oui_info_len ) ; if ( ! custom -> oui_info ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV<S2SV_blank>data"" ) ; goto malformed ; } PEEK_BYTES ( custom -> oui_info , custom -> oui_info_len ) ; } TAILQ_INSERT_TAIL ( & port -> p_custom_list , custom , next ) ; custom = NULL ; # endif } break ; default : log_warnx ( ""lldp"" , ""unknown<S2SV_blank>tlv<S2SV_blank>(%d)<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , tlv_type , hardware -> h_ifname ) ; goto malformed ; } if ( pos > tlv + tlv_size ) { log_warnx ( ""lldp"" , ""BUG:<S2SV_blank>already<S2SV_blank>past<S2SV_blank>TLV!"" ) ; goto malformed ; } PEEK_DISCARD ( tlv + tlv_size - pos ) ; } if ( ( chassis -> c_id == NULL ) || ( port -> p_id == NULL ) || ( ! ttl_received ) || ( gotend == 0 ) ) { log_warnx ( ""lldp"" , ""some<S2SV_blank>mandatory<S2SV_blank>tlv<S2SV_blank>are<S2SV_blank>missing<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } * newchassis = chassis ; * newport = port ; return 1 ; malformed : # ifdef ENABLE_CUSTOM free ( custom ) ; # endif # ifdef ENABLE_DOT1 free ( vlan ) ; free ( pi ) ; # endif lldpd_chassis_cleanup ( chassis , 1 ) ; lldpd_port_cleanup ( port , 1 ) ; free ( port ) ; return - 1 ; }
","<S2SV_ModStart> NULL ) { if <S2SV_ModEnd> ( errno == <S2SV_ModStart> == ENOMEM ) <S2SV_ModEnd> log_warn ( ""lldp"" <S2SV_ModStart> , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ; else log_warn ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname
",vincentbernat@lldpd/9221b5c249f9e4843f77c7f888d5705348d179c0,CVE-2015-8012,https://github.com/vincentbernat/lldpd/commit/9221b5c249f9e4843f77c7f888d5705348d179c0,2020-01-28T19:15Z
CWE-416,"CWE-416 void comps_objmrtree_unite ( COMPS_ObjMRTree * rt1 , COMPS_ObjMRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; COMPS_ObjListIt * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <S2SV_StartBug> pair -> added = 0 ; <S2SV_EndBug> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first != NULL ) { for ( it2 = ( ( COMPS_ObjMRTreeData * ) it -> data ) -> data -> first ; it2 != NULL ; it2 = it2 -> next ) { comps_objmrtree_set ( rt1 , pair -> key , it2 -> comps_obj ) ; } if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } else { if ( ( ( COMPS_ObjMRTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
","<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
",rpm-software-management@libcomps/e3a5d056633677959ad924a51758876d415e7046,CVE-2019-3817,https://github.com/rpm-software-management/libcomps/commit/e3a5d056633677959ad924a51758876d415e7046,2019-03-27T13:29Z
CWE-119,"CWE-119 static uint32_t color_string_to_rgba ( const char * p , int len ) { uint32_t ret = 0xFF000000 ; const ColorEntry * entry ; char color_name [ 100 ] ; <S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> p ++ ; len -- ; if ( len == 3 ) { ret |= ( hex_char_to_number ( p [ 2 ] ) << 4 ) | ( hex_char_to_number ( p [ 1 ] ) << 12 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 4 ) { ret = ( hex_char_to_number ( p [ 3 ] ) << 4 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 20 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } else if ( len == 6 ) { ret |= hex_char_to_number ( p [ 5 ] ) | ( hex_char_to_number ( p [ 4 ] ) << 4 ) | ( hex_char_to_number ( p [ 3 ] ) << 8 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 16 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 8 ) { ret = hex_char_to_number ( p [ 7 ] ) | ( hex_char_to_number ( p [ 6 ] ) << 4 ) | ( hex_char_to_number ( p [ 5 ] ) << 8 ) | ( hex_char_to_number ( p [ 4 ] ) << 12 ) | ( hex_char_to_number ( p [ 3 ] ) << 16 ) | ( hex_char_to_number ( p [ 2 ] ) << 20 ) | ( hex_char_to_number ( p [ 1 ] ) << 24 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } } else { strncpy ( color_name , p , len ) ; color_name [ len ] = '\\0' ; entry = bsearch ( color_name , color_table , FF_ARRAY_ELEMS ( color_table ) , sizeof ( ColorEntry ) , color_table_compare ) ; if ( ! entry ) return ret ; ret = entry -> rgb_color ; } return ret ; }
","<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
",FFmpeg@FFmpeg/cb243972b121b1ae6b60a78ff55a0506c69f3879,CVE-2017-9990,https://github.com/FFmpeg/FFmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879,2017-06-28T06:29Z
CWE-119,"CWE-119 int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
","<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
",torvalds@linux/0926f91083f34d047abc74f1ca4fa6a9c161f7db,CVE-2010-5332,https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db,2019-07-27T22:15Z
CWE-119,"CWE-119 static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
",torvalds@linux/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,CVE-2016-4998,https://github.com/torvalds/linux/commit/6e94e0cfb0887e4013b3b930fa6ab1fe6bb6ba91,2016-07-03T21:59Z
CWE-000,"CWE-000 <S2SV_StartBug> void nfs4_close_sync ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> { <S2SV_StartBug> __nfs4_close ( path , state , mode , 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 1 )
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-119,"CWE-119 static vpx_codec_err_t image2yuvconfig ( const vpx_image_t * img , YV12_BUFFER_CONFIG * yv12 ) { <S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ; yv12 -> u_buffer = img -> planes [ VPX_PLANE_U ] ; yv12 -> v_buffer = img -> planes [ VPX_PLANE_V ] ; <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_crop_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_width = img -> d_w ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> y_height = img -> d_h ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_width = ( 1 + yv12 -> y_width ) / 2 ; <S2SV_EndBug> <S2SV_StartBug> yv12 -> uv_height = ( 1 + yv12 -> y_height ) / 2 ; <S2SV_EndBug> yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> w ) / 2 ; return res ; }
","<S2SV_ModStart> yv12 ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> -> y_crop_width = y_w <S2SV_ModEnd> ; yv12 -> <S2SV_ModStart> -> y_crop_height = y_h <S2SV_ModEnd> ; yv12 -> <S2SV_ModStart> -> y_width = y_w <S2SV_ModEnd> ; yv12 -> <S2SV_ModStart> -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h <S2SV_ModEnd> ; yv12 -> <S2SV_ModStart> -> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> w <S2SV_ModEnd> ) / 2 <S2SV_ModStart> / 2 ; <S2SV_ModEnd> return res ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> { vp9_ref_frame_t * const <S2SV_ModStart> YV12_BUFFER_CONFIG * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> cpi <S2SV_ModStart> ctx -> cpi -> common <S2SV_ModStart> frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-59,"CWE-59 void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( ""TMPDIR"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TMP"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TEMP"" ) ) == NULL || * tmp_dir == '\\0' ) ) tmp_dir = ""/tmp"" ; <S2SV_StartBug> create_option_search_table ( ) ; <S2SV_EndBug> goto open_rc ; }
","<S2SV_ModStart> = ""/tmp"" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , ""/w3m-XXXXXX"" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
",tats@w3m/18dcbadf2771cdb0c18509b14e4e73505b242753,CVE-2018-6198,https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753,2018-01-25T03:29Z
CWE-399,"CWE-399 long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n"" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ; <S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> put_ioctx ( ctx ) ; return i ? i : ret ; }
","<S2SV_ModStart> ; kiocb_batch_free ( ctx ,
",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z
CWE-125,"CWE-125 static int lldp_mgmt_addr_tlv_print ( netdissect_options * ndo , const u_char * pptr , u_int len ) { uint8_t mgmt_addr_len , intf_num_subtype , oid_len ; const u_char * tptr ; u_int tlen ; char * mgmt_addr ; tlen = len ; tptr = pptr ; if ( tlen < 1 ) { return 0 ; } mgmt_addr_len = * tptr ++ ; tlen -- ; if ( tlen < mgmt_addr_len ) { return 0 ; } mgmt_addr = lldp_network_addr_print ( ndo , tptr , mgmt_addr_len ) ; if ( mgmt_addr == NULL ) { return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>%s"" , mgmt_addr_len , mgmt_addr ) ) ; tptr += mgmt_addr_len ; tlen -= mgmt_addr_len ; if ( tlen < LLDP_INTF_NUM_LEN ) { return 0 ; } intf_num_subtype = * tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Interface<S2SV_blank>Numbering<S2SV_blank>(%u):<S2SV_blank>%u"" , tok2str ( lldp_intf_numb_subtype_values , ""Unknown"" , intf_num_subtype ) , intf_num_subtype , EXTRACT_32BITS ( tptr + 1 ) ) ) ; tptr += LLDP_INTF_NUM_LEN ; tlen -= LLDP_INTF_NUM_LEN ; if ( tlen ) { oid_len = * tptr ; <S2SV_StartBug> if ( tlen < oid_len ) { <S2SV_EndBug> return 0 ; } if ( oid_len ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>OID<S2SV_blank>length<S2SV_blank>%u"" , oid_len ) ) ; safeputs ( ndo , tptr + 1 , oid_len ) ; } } return 1 ; }
","<S2SV_ModStart> ( tlen < 1U +
",the-tcpdump-group@tcpdump/a77ff09c46560bc895dea11dc9fe643486b056ac,CVE-2017-13027,https://github.com/the-tcpdump-group/tcpdump/commit/a77ff09c46560bc895dea11dc9fe643486b056ac,2017-09-14T06:29Z
CWE-264,"CWE-264 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! arp_checkentry ( & e -> arp ) ) return - EINVAL ; <S2SV_StartBug> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <S2SV_EndBug> if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
","<S2SV_ModStart> , e -> elems , e ->
",torvalds@linux/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,CVE-2016-4997,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,2016-07-03T21:59Z
CWE-20,"CWE-20 WORD32 ih264d_read_mmco_commands ( struct _DecStruct * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; <S2SV_StartBug> dpb_commands_t * ps_dpb_cmds = ps_dec -> ps_dpb_cmds ; <S2SV_EndBug> dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; WORD32 j ; UWORD8 u1_buf_mode ; struct MMCParams * ps_mmc_params ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst ; ps_slice -> u1_mmco_equalto5 = 0 ; { if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_slice -> u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>no_output_of_prior_pics_flag"" , ps_slice -> u1_no_output_of_prior_pics_flag ) ; ps_slice -> u1_long_term_reference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>long_term_reference_flag"" , ps_slice -> u1_long_term_reference_flag ) ; ps_dpb_cmds -> u1_idr_pic = 1 ; ps_dpb_cmds -> u1_no_output_of_prior_pics_flag = ps_slice -> u1_no_output_of_prior_pics_flag ; ps_dpb_cmds -> u1_long_term_reference_flag = ps_slice -> u1_long_term_reference_flag ; } else { u1_buf_mode = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>adaptive_ref_pic_buffering_flag"" , u1_buf_mode ) ; ps_dpb_cmds -> u1_buf_mode = u1_buf_mode ; j = 0 ; if ( u1_buf_mode == 1 ) { UWORD32 u4_mmco ; UWORD32 u4_diff_pic_num ; UWORD32 u4_lt_idx , u4_max_lt_idx ; u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; while ( u4_mmco != END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { # ifdef __ANDROID__ ALOGE ( ""b/25818142"" ) ; android_errorWriteLog ( 0x534e4554 , ""25818142"" ) ; # endif ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; } ps_mmc_params = & ps_dpb_cmds -> as_mmc_params [ j ] ; ps_mmc_params -> u4_mmco = u4_mmco ; switch ( u4_mmco ) { case MARK_ST_PICNUM_AS_NONREF : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; break ; case MARK_LT_INDEX_AS_NONREF : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case MARK_ST_PICNUM_AS_LT_INDEX : u4_diff_pic_num = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_diff_pic_num = u4_diff_pic_num ; u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; case SET_MAX_LT_INDEX : { u4_max_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_max_lt_idx_plus1 = u4_max_lt_idx ; break ; } case RESET_REF_PICTURES : { ps_slice -> u1_mmco_equalto5 = 1 ; break ; } case SET_LT_INDEX : u4_lt_idx = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_mmc_params -> u4_lt_idx = u4_lt_idx ; break ; default : break ; } u4_mmco = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; j ++ ; } ps_dpb_cmds -> u1_num_of_commands = j ; } } ps_dpb_cmds -> u1_dpb_commands_read = 1 ; ps_dpb_cmds -> u1_dpb_commands_read_slc = 1 ; } u4_bit_ofst = ps_dec -> ps_bitstrm -> u4_ofst - u4_bit_ofst ; return u4_bit_ofst ; }
","<S2SV_ModStart> * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t *
",external@libavc/6c327afb263837bc90760c55c6605b26161a4eb9,CVE-2017-13186,https://android.googlesource.com/platform/external/libavc/+/6c327afb263837bc90760c55c6605b26161a4eb9,2018-01-12T23:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , ""STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>"" ""(according<S2SV_blank>to<S2SV_blank>driver)\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , ""Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;
",torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4,CVE-2012-6712,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,2019-07-27T22:15Z
CWE-476,"CWE-476 static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct rtmsg * rtm ; struct nlattr * tb [ RTA_MAX + 1 ] ; struct fib_result res = { } ; struct rtable * rt = NULL ; struct flowi4 fl4 ; __be32 dst = 0 ; __be32 src = 0 ; u32 iif ; int err ; int mark ; struct sk_buff * skb ; u32 table_id = RT_TABLE_MAIN ; kuid_t uid ; err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , extack ) ; if ( err < 0 ) goto errout ; rtm = nlmsg_data ( nlh ) ; skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; if ( ! skb ) { err = - ENOBUFS ; goto errout ; } skb_reset_mac_header ( skb ) ; skb_reset_network_header ( skb ) ; src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; if ( tb [ RTA_UID ] ) uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; else uid = ( iif ? INVALID_UID : current_uid ( ) ) ; ip_hdr ( skb ) -> protocol = IPPROTO_UDP ; ip_hdr ( skb ) -> saddr = src ; ip_hdr ( skb ) -> daddr = dst ; skb_reserve ( skb , MAX_HEADER + sizeof ( struct iphdr ) ) ; memset ( & fl4 , 0 , sizeof ( fl4 ) ) ; fl4 . daddr = dst ; fl4 . saddr = src ; fl4 . flowi4_tos = rtm -> rtm_tos ; fl4 . flowi4_oif = tb [ RTA_OIF ] ? nla_get_u32 ( tb [ RTA_OIF ] ) : 0 ; fl4 . flowi4_mark = mark ; fl4 . flowi4_uid = uid ; rcu_read_lock ( ) ; if ( iif ) { struct net_device * dev ; dev = dev_get_by_index_rcu ( net , iif ) ; if ( ! dev ) { err = - ENODEV ; goto errout_free ; } skb -> protocol = htons ( ETH_P_IP ) ; skb -> dev = dev ; skb -> mark = mark ; err = ip_route_input_rcu ( skb , dst , src , rtm -> rtm_tos , dev , & res ) ; rt = skb_rtable ( skb ) ; if ( err == 0 && rt -> dst . error ) err = - rt -> dst . error ; } else { rt = ip_route_output_key_hash_rcu ( net , & fl4 , & res , skb ) ; err = 0 ; if ( IS_ERR ( rt ) ) err = PTR_ERR ( rt ) ; else skb_dst_set ( skb , & rt -> dst ) ; } if ( err ) goto errout_free ; if ( rtm -> rtm_flags & RTM_F_NOTIFY ) rt -> rt_flags |= RTCF_NOTIFY ; if ( rtm -> rtm_flags & RTM_F_LOOKUP_TABLE ) table_id = rt -> rt_table_id ; if ( rtm -> rtm_flags & RTM_F_FIB_MATCH ) <S2SV_StartBug> err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , <S2SV_EndBug> nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; else err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; if ( err < 0 ) goto errout_free ; <S2SV_StartBug> rcu_read_unlock ( ) ; <S2SV_EndBug> err = rtnl_unicast ( skb , net , NETLINK_CB ( in_skb ) . portid ) ; errout : return err ; errout_free : rcu_read_unlock ( ) ; kfree_skb ( skb ) ; goto errout ; }
","<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;
",torvalds@linux/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,CVE-2017-13686,https://github.com/torvalds/linux/commit/bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205,2017-08-24T22:29Z
CWE-284,"CWE-284 void bta_hl_co_put_rx_data ( UINT8 app_id , tBTA_HL_MDL_HANDLE mdl_handle , UINT16 data_size , UINT8 * p_data , UINT16 evt ) { UINT8 app_idx , mcl_idx , mdl_idx ; btif_hl_mdl_cb_t * p_dcb ; tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL ; int r ; BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>app_id=%d<S2SV_blank>mdl_handle=0x%x<S2SV_blank>data_size=%d"" , __FUNCTION__ , app_id , mdl_handle , data_size ) ; if ( btif_hl_find_mdl_idx_using_handle ( mdl_handle , & app_idx , & mcl_idx , & mdl_idx ) ) { p_dcb = BTIF_HL_GET_MDL_CB_PTR ( app_idx , mcl_idx , mdl_idx ) ; if ( ( p_dcb -> p_rx_pkt = ( UINT8 * ) btif_hl_get_buf ( data_size ) ) != NULL ) { memcpy ( p_dcb -> p_rx_pkt , p_data , data_size ) ; if ( p_dcb -> p_scb ) { BTIF_TRACE_DEBUG ( ""app_idx=%d<S2SV_blank>mcl_idx=0x%x<S2SV_blank>mdl_idx=0x%x<S2SV_blank>data_size=%d"" , app_idx , mcl_idx , mdl_idx , data_size ) ; <S2SV_StartBug> r = send ( p_dcb -> p_scb -> socket_id [ 1 ] , p_dcb -> p_rx_pkt , data_size , 0 ) ; <S2SV_EndBug> if ( r == data_size ) { BTIF_TRACE_DEBUG ( ""socket<S2SV_blank>send<S2SV_blank>success<S2SV_blank>data_size=%d"" , data_size ) ; status = BTA_HL_STATUS_OK ; } else { BTIF_TRACE_ERROR ( ""socket<S2SV_blank>send<S2SV_blank>failed<S2SV_blank>r=%d<S2SV_blank>data_size=%d"" , r , data_size ) ; } } btif_hl_free_buf ( ( void * * ) & p_dcb -> p_rx_pkt ) ; } } bta_hl_ci_put_rx_data ( mdl_handle , status , evt ) ; }
","<S2SV_ModStart> ; r = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-284,"CWE-284 static int tcp_v6_rcv ( struct sk_buff * skb ) { const struct tcphdr * th ; const struct ipv6hdr * hdr ; bool refcounted ; struct sock * sk ; int ret ; struct net * net = dev_net ( skb -> dev ) ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) ; lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; tcp_v6_restore_cb ( skb ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v6_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( hdr -> hop_limit < inet6_sk ( sk ) -> min_hopcount ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v6_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v6_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ? - 1 : 0 ; no_tcp_socket : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v6_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 ; sk2 = inet6_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , & ipv6_hdr ( skb ) -> saddr , th -> source , & ipv6_hdr ( skb ) -> daddr , ntohs ( th -> dest ) , tcp_v6_iif ( skb ) ) ; if ( sk2 ) { struct inet_timewait_sock * tw = inet_twsk ( sk ) ; inet_twsk_deschedule_put ( tw ) ; sk = sk2 ; tcp_v6_restore_cb ( skb ) ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v6_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v6_restore_cb ( skb ) ; tcp_v6_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }
","<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb )
",torvalds@linux/ac6e780070e30e4c35bd395acfe9191e6268bdd3,CVE-2016-8645,https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3,2016-11-28T03:59Z
CWE-264,"CWE-264 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }
","<S2SV_ModStart> new_parent ) { <S2SV_ModEnd> __ptrace_link ( child <S2SV_ModStart> , new_parent , current_cred ( ) <S2SV_ModEnd> ) ; }
",torvalds@linux/6994eefb0053799d2e07cd140df6c2ea106c41ee,CVE-2019-13272,https://github.com/torvalds/linux/commit/6994eefb0053799d2e07cd140df6c2ea106c41ee,2019-07-17T13:15Z
CWE-284,"CWE-284 int sock_send_fd ( int sock_fd , const uint8_t * buf , int len , int send_fd ) { ssize_t ret ; struct msghdr msg ; unsigned char * buffer = ( unsigned char * ) buf ; memset ( & msg , 0 , sizeof ( msg ) ) ; struct cmsghdr * cmsg ; char msgbuf [ CMSG_SPACE ( 1 ) ] ; asrt ( send_fd != - 1 ) ; if ( sock_fd == - 1 || send_fd == - 1 ) return - 1 ; msg . msg_control = msgbuf ; msg . msg_controllen = sizeof msgbuf ; cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof send_fd ) ; memcpy ( CMSG_DATA ( cmsg ) , & send_fd , sizeof send_fd ) ; int ret_len = len ; while ( len > 0 ) { struct iovec iv ; memset ( & iv , 0 , sizeof ( iv ) ) ; iv . iov_base = buffer ; iv . iov_len = len ; msg . msg_iov = & iv ; msg . msg_iovlen = 1 ; do { <S2SV_StartBug> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <S2SV_EndBug> } while ( ret < 0 && errno == EINTR ) ; if ( ret < 0 ) { BTIF_TRACE_ERROR ( ""fd:%d,<S2SV_blank>send_fd:%d,<S2SV_blank>sendmsg<S2SV_blank>ret:%d,<S2SV_blank>errno:%d,<S2SV_blank>%s"" , sock_fd , send_fd , ( int ) ret , errno , strerror ( errno ) ) ; ret_len = - 1 ; break ; } buffer += ret ; len -= ret ; memset ( & msg , 0 , sizeof ( msg ) ) ; } BTIF_TRACE_DEBUG ( ""close<S2SV_blank>fd:%d<S2SV_blank>after<S2SV_blank>sent"" , send_fd ) ; close ( send_fd ) ; return ret_len ; }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> msg , MSG_NOSIGNAL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-404,"CWE-404 int nfssvc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-264,"CWE-264 int fpm_unix_resolve_socket_premissions ( struct fpm_worker_pool_s * wp ) { struct fpm_worker_pool_config_s * c = wp -> config ; wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> if ( ! c ) { return 0 ; } if ( c -> listen_owner && * c -> listen_owner ) { struct passwd * pwd ; pwd = getpwnam ( c -> listen_owner ) ; if ( ! pwd ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_owner ) ; return - 1 ; } wp -> socket_uid = pwd -> pw_uid ; wp -> socket_gid = pwd -> pw_gid ; } if ( c -> listen_group && * c -> listen_group ) { struct group * grp ; grp = getgrnam ( c -> listen_group ) ; if ( ! grp ) { zlog ( ZLOG_SYSERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'"" , wp -> config -> name , c -> listen_group ) ; return - 1 ; } wp -> socket_gid = grp -> gr_gid ; } if ( c -> listen_mode && * c -> listen_mode ) { wp -> socket_mode = strtoul ( c -> listen_mode , 0 , 8 ) ; } return 0 ; }
","<S2SV_ModStart> -> socket_mode = 0660 <S2SV_ModEnd> ; if (
",php@php-src/35ceea928b12373a3b1e3eecdc32ed323223a40d,CVE-2014-0185,https://github.com/php/php-src/commit/35ceea928b12373a3b1e3eecdc32ed323223a40d,2014-05-06T10:44Z
CWE-119,"CWE-119 void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHED<S2SV_blank>STRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHED<S2SV_blank>REGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHED<S2SV_blank>COMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""!=\\0"" ""!==\\0"" ""<=\\0"" ""<<\\0"" ""<<=\\0"" "">=\\0"" "">>\\0"" "">>>\\0"" "">>=\\0"" "">>>=\\0"" ""+=\\0"" ""-=\\0"" ""++\\0"" ""--\\0"" ""*=\\0"" ""/=\\0"" ""%=\\0"" ""&=\\0"" ""&&\\0"" ""|=\\0"" ""||\\0"" ""^=\\0"" ""=>\\0"" ""if\\0"" ""else\\0"" ""do\\0"" ""while\\0"" ""for\\0"" ""return\\0"" ""continue\\0"" ""function\\0"" ""return\\0"" ""var\\0"" ""let\\0"" ""const\\0"" ""this\\0"" ""throw\\0"" ""try\\0"" ""catch\\0"" ""finally\\0"" ""true\\0"" ""false\\0"" ""null\\0"" ""undefined\\0"" ""new\\0"" ""in\\0"" ""instanceof\\0"" ""switch\\0"" ""case\\0"" ""default\\0"" ""delete\\0"" ""typeof\\0"" ""void\\0"" ""debugger\\0"" ""class\\0"" ""extends\\0"" ""super\\0"" ""static\\0"" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; <S2SV_StartBug> strncpy ( str , ""?["" , len ) ; <S2SV_EndBug> itostr ( token , & str [ 2 ] , 10 ) ; strncat ( str , ""]"" , len ) ; }
","<S2SV_ModStart> 10 ) ; espruino_snprintf ( str , len , ""?[%d]"" , token <S2SV_ModEnd> ) ; }
",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
CWE-20,"CWE-20 static int kvm_vm_ioctl_create_vcpu ( struct kvm * kvm , u32 id ) { int r ; struct kvm_vcpu * vcpu , * v ; <S2SV_StartBug> vcpu = kvm_arch_vcpu_create ( kvm , id ) ; <S2SV_EndBug> if ( IS_ERR ( vcpu ) ) return PTR_ERR ( vcpu ) ; preempt_notifier_init ( & vcpu -> preempt_notifier , & kvm_preempt_ops ) ; r = kvm_arch_vcpu_setup ( vcpu ) ; if ( r ) goto vcpu_destroy ; mutex_lock ( & kvm -> lock ) ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if ( atomic_read ( & kvm -> online_vcpus ) == KVM_MAX_VCPUS ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } kvm_for_each_vcpu ( r , v , kvm ) if ( v -> vcpu_id == id ) { r = - EEXIST ; goto unlock_vcpu_destroy ; } BUG_ON ( kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] ) ; kvm_get_kvm ( kvm ) ; r = create_vcpu_fd ( vcpu ) ; if ( r < 0 ) { kvm_put_kvm ( kvm ) ; goto unlock_vcpu_destroy ; } kvm -> vcpus [ atomic_read ( & kvm -> online_vcpus ) ] = vcpu ; smp_wmb ( ) ; atomic_inc ( & kvm -> online_vcpus ) ; mutex_unlock ( & kvm -> lock ) ; kvm_arch_vcpu_postcreate ( vcpu ) ; return r ; unlock_vcpu_destroy : mutex_unlock ( & kvm -> lock ) ; vcpu_destroy : kvm_arch_vcpu_destroy ( vcpu ) ; return r ; }
","<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
",torvalds@linux/338c7dbadd2671189cec7faf64c84d01071b3f96,CVE-2013-4587,https://github.com/torvalds/linux/commit/338c7dbadd2671189cec7faf64c84d01071b3f96,2013-12-14T18:08Z
CWE-189,"CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
","<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
CWE-476,"CWE-476 void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; }
","<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
",FreeRDP@FreeRDP/0773bb9303d24473fe1185d85a424dfe159aff53,CVE-2013-4119,https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53,2016-10-03T21:59Z
CWE-362,"CWE-362 hsm_com_errno_t hcom_client_init ( OUT p_hsm_com_client_hdl_t * p_hdl , IN char * server_path , IN char * client_path , IN int max_data_len ) { hsm_com_client_hdl_t * hdl = NULL ; hsm_com_errno_t res = HSM_COM_OK ; if ( ( strlen ( server_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( server_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( strlen ( client_path ) > ( HSM_COM_SVR_MAX_PATH - 1 ) ) || ( strlen ( client_path ) == 0 ) ) { res = HSM_COM_PATH_ERR ; goto cleanup ; } if ( ( hdl = calloc ( 1 , sizeof ( hsm_com_client_hdl_t ) ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> scr . scratch = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> recv_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } if ( ( hdl -> send_buf = malloc ( max_data_len ) ) == NULL ) { res = HSM_COM_NO_MEM ; goto cleanup ; } hdl -> scr . scratch_fill = 0 ; hdl -> scr . scratch_len = max_data_len ; hdl -> buf_len = max_data_len ; hdl -> trans_id = 1 ; strcpy ( hdl -> s_path , server_path ) ; strcpy ( hdl -> c_path , client_path ) ; <S2SV_StartBug> hdl -> client_state = HSM_COM_C_STATE_IN ; <S2SV_EndBug> * p_hdl = hdl ; return res ; cleanup : if ( hdl ) { if ( hdl -> scr . scratch ) { free ( hdl -> scr . scratch ) ; } if ( hdl -> recv_buf ) { free ( hdl -> recv_buf ) ; } free ( hdl ) ; } return res ; }
","<S2SV_ModStart> client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
",01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869,CVE-2015-5232,https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869,2017-06-07T20:29Z
CWE-200,"CWE-200 int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p<S2SV_blank>len<S2SV_blank>%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; <S2SV_EndBug> if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) sock_recv_ts_and_drops ( msg , sk , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
","<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> err ; } <S2SV_ModEnd> copied = skb
",torvalds@linux/4683f42fde3977bdb4e8a09622788cc8b5313778,CVE-2013-3224,https://github.com/torvalds/linux/commit/4683f42fde3977bdb4e8a09622788cc8b5313778,2013-04-22T11:41Z
CWE-20,"CWE-20 int yyparse ( void ) # else int yyparse ( ) # endif # endif { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yyn == YYPACT_NINF ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = YYLEX ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yyn == 0 || yyn == YYTABLE_NINF ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; * ++ yyvsp = yylval ; goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 5 : # line 320 ""ntp_parser.y"" { msyslog ( LOG_ERR , ""syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%d,<S2SV_blank>column<S2SV_blank>%d"" , ip_file -> fname , ip_file -> err_line_no , ip_file -> err_col_no ) ; } break ; case 19 : # line 354 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 20 : # line 360 ""ntp_parser.y"" { struct peer_node * my_node = create_peer_node ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ; if ( my_node ) enqueue ( cfgt . peers , my_node ) ; } break ; case 27 : # line 377 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET ) ; } break ; case 28 : # line 378 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) , AF_INET6 ) ; } break ; case 29 : # line 382 ""ntp_parser.y"" { ( yyval . Address_node ) = create_address_node ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) , 0 ) ; } break ; case 30 : # line 386 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 31 : # line 387 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 32 : # line 391 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 33 : # line 392 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 34 : # line 393 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 35 : # line 394 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 36 : # line 395 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 37 : # line 396 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 38 : # line 397 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 39 : # line 398 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 40 : # line 399 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 41 : # line 400 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 42 : # line 401 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 43 : # line 402 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 44 : # line 403 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 45 : # line 404 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 46 : # line 405 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 47 : # line 415 ""ntp_parser.y"" { struct unpeer_node * my_node = create_unpeer_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; if ( my_node ) enqueue ( cfgt . unpeers , my_node ) ; } break ; case 50 : # line 434 ""ntp_parser.y"" { cfgt . broadcastclient = 1 ; } break ; case 51 : # line 436 ""ntp_parser.y"" { append_queue ( cfgt . manycastserver , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 52 : # line 438 ""ntp_parser.y"" { append_queue ( cfgt . multicastclient , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 53 : # line 449 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 54 : # line 451 ""ntp_parser.y"" { cfgt . auth . control_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 55 : # line 453 ""ntp_parser.y"" { cfgt . auth . cryptosw ++ ; append_queue ( cfgt . auth . crypto_cmd_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 56 : # line 458 ""ntp_parser.y"" { cfgt . auth . keys = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 57 : # line 460 ""ntp_parser.y"" { cfgt . auth . keysdir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 58 : # line 462 ""ntp_parser.y"" { cfgt . auth . request_key = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 59 : # line 464 ""ntp_parser.y"" { cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; } break ; case 60 : # line 466 ""ntp_parser.y"" { cfgt . auth . trusted_key_list = ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ; } break ; case 61 : # line 468 ""ntp_parser.y"" { cfgt . auth . ntp_signd_socket = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; } break ; case 63 : # line 474 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 64 : # line 479 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 65 : # line 486 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 66 : # line 496 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 67 : # line 498 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 68 : # line 500 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 69 : # line 502 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 70 : # line 504 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 71 : # line 506 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 72 : # line 508 ""ntp_parser.y"" { ( yyval . Attr_val ) = NULL ; cfgt . auth . revoke = ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ; msyslog ( LOG_WARNING , ""\'crypto<S2SV_blank>revoke<S2SV_blank>%d\'<S2SV_blank>is<S2SV_blank>deprecated,<S2SV_blank>"" ""please<S2SV_blank>use<S2SV_blank>\'revoke<S2SV_blank>%d\'<S2SV_blank>instead."" , cfgt . auth . revoke , cfgt . auth . revoke ) ; } break ; case 73 : # line 525 ""ntp_parser.y"" { append_queue ( cfgt . orphan_cmds , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 74 : # line 529 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 75 : # line 530 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 76 : # line 535 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 77 : # line 537 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 78 : # line 539 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 79 : # line 541 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 80 : # line 543 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 81 : # line 545 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 82 : # line 547 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 83 : # line 549 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 84 : # line 551 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 85 : # line 553 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 86 : # line 555 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( double ) ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 87 : # line 565 ""ntp_parser.y"" { append_queue ( cfgt . stats_list , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 88 : # line 567 ""ntp_parser.y"" { if ( input_from_file ) cfgt . stats_dir = ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""statsdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 89 : # line 576 ""ntp_parser.y"" { enqueue ( cfgt . filegen_opts , create_filegen_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 90 : # line 583 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 91 : # line 584 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 100 : # line 600 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 101 : # line 607 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 102 : # line 617 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; else { ( yyval . Attr_val ) = NULL ; free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""filegen<S2SV_blank>file<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 103 : # line 627 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>type<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 104 : # line 636 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>link<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 105 : # line 645 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""filegen<S2SV_blank>nolink<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 106 : # line 653 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 107 : # line 654 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 115 : # line 674 ""ntp_parser.y"" { append_queue ( cfgt . discard_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 116 : # line 678 ""ntp_parser.y"" { append_queue ( cfgt . mru_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 117 : # line 682 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 118 : # line 687 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( ( yyvsp [ ( 2 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 5 ) - ( 5 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 119 : # line 692 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 120 : # line 697 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , create_address_node ( estrdup ( ""0.0.0.0"" ) , AF_INET ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 121 : # line 710 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , create_address_node ( estrdup ( ""::"" ) , AF_INET6 ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Queue ) , ip_file -> line_no ) ) ; } break ; case 122 : # line 723 ""ntp_parser.y"" { enqueue ( cfgt . restrict_opts , create_restrict_node ( NULL , NULL , enqueue ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) , ip_file -> line_no ) ) ; } break ; case 123 : # line 734 ""ntp_parser.y"" { ( yyval . Queue ) = create_queue ( ) ; } break ; case 124 : # line 736 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 139 : # line 758 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 140 : # line 760 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 141 : # line 764 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 142 : # line 765 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 143 : # line 766 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 144 : # line 771 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 145 : # line 773 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 146 : # line 777 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 147 : # line 778 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 148 : # line 779 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 149 : # line 780 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 150 : # line 781 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 151 : # line 782 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 152 : # line 783 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 153 : # line 784 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 154 : # line 793 ""ntp_parser.y"" { enqueue ( cfgt . fudge , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 155 : # line 798 ""ntp_parser.y"" { enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 156 : # line 800 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 157 : # line 804 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 158 : # line 805 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 159 : # line 806 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 160 : # line 807 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; } break ; case 161 : # line 808 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 162 : # line 809 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 163 : # line 810 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 164 : # line 811 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 165 : # line 820 ""ntp_parser.y"" { append_queue ( cfgt . enable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 166 : # line 822 ""ntp_parser.y"" { append_queue ( cfgt . disable_opts , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 167 : # line 827 ""ntp_parser.y"" { if ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) ; } break ; case 168 : # line 834 ""ntp_parser.y"" { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) != NULL ) ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; else ( yyval . Queue ) = create_queue ( ) ; } break ; case 169 : # line 843 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 170 : # line 844 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 171 : # line 845 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 172 : # line 846 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 173 : # line 847 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 174 : # line 848 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 175 : # line 850 ""ntp_parser.y"" { if ( input_from_file ) ( yyval . Attr_val ) = create_attr_ival ( T_Flag , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; else { ( yyval . Attr_val ) = NULL ; yyerror ( ""enable/disable<S2SV_blank>stats<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 176 : # line 865 ""ntp_parser.y"" { append_queue ( cfgt . tinker , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 177 : # line 869 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 178 : # line 870 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 179 : # line 874 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 180 : # line 875 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 181 : # line 876 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 182 : # line 877 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 183 : # line 878 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 184 : # line 879 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 185 : # line 880 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ; } break ; case 187 : # line 891 ""ntp_parser.y"" { if ( curr_include_level >= MAXINCLUDELEVEL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Maximum<S2SV_blank>include<S2SV_blank>file<S2SV_blank>level<S2SV_blank>exceeded."" ) ; } else { fp [ curr_include_level + 1 ] = F_OPEN ( FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) , ""r"" ) ; if ( fp [ curr_include_level + 1 ] == NULL ) { fprintf ( stderr , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>\\n"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; msyslog ( LOG_ERR , ""getconfig:<S2SV_blank>Couldn\'t<S2SV_blank>open<S2SV_blank><%s>"" , FindConfig ( ( yyvsp [ ( 2 ) - ( 3 ) ] . String ) ) ) ; } else ip_file = fp [ ++ curr_include_level ] ; } } break ; case 188 : # line 907 ""ntp_parser.y"" { while ( curr_include_level != - 1 ) FCLOSE ( fp [ curr_include_level -- ] ) ; } break ; case 189 : # line 913 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 190 : # line 915 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 191 : # line 917 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; } break ; case 192 : # line 919 ""ntp_parser.y"" { } break ; case 193 : # line 921 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 194 : # line 924 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 195 : # line 926 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""logfile<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 196 : # line 937 ""ntp_parser.y"" { append_queue ( cfgt . logconfig , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 197 : # line 939 ""ntp_parser.y"" { append_queue ( cfgt . phone , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 198 : # line 941 ""ntp_parser.y"" { if ( input_from_file ) enqueue ( cfgt . vars , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; else { free ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ; yyerror ( ""saveconfigdir<S2SV_blank>remote<S2SV_blank>configuration<S2SV_blank>ignored"" ) ; } } break ; case 199 : # line 951 ""ntp_parser.y"" { enqueue ( cfgt . setvar , ( yyvsp [ ( 2 ) - ( 2 ) ] . Set_var ) ) ; } break ; case 200 : # line 953 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) , NULL ) ) ; } break ; case 201 : # line 955 ""ntp_parser.y"" { enqueue ( cfgt . trap , create_addr_opts_node ( ( yyvsp [ ( 2 ) - ( 3 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Queue ) ) ) ; } break ; case 202 : # line 957 ""ntp_parser.y"" { append_queue ( cfgt . ttl , ( yyvsp [ ( 2 ) - ( 2 ) ] . Queue ) ) ; } break ; case 203 : # line 959 ""ntp_parser.y"" { enqueue ( cfgt . qos , create_attr_sval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 204 : # line 964 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 205 : # line 966 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_dval ( T_WanderThreshold , ( yyvsp [ ( 2 ) - ( 2 ) ] . Double ) ) ) ; enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ( yyvsp [ ( 1 ) - ( 2 ) ] . String ) ) ) ; } break ; case 206 : # line 969 ""ntp_parser.y"" { enqueue ( cfgt . vars , create_attr_sval ( T_Driftfile , ""\\0"" ) ) ; } break ; case 207 : # line 974 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 4 ) ] . String ) , ( yyvsp [ ( 4 ) - ( 4 ) ] . Integer ) ) ; } break ; case 208 : # line 976 ""ntp_parser.y"" { ( yyval . Set_var ) = create_setvar_node ( ( yyvsp [ ( 1 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , 0 ) ; } break ; case 209 : # line 981 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 210 : # line 982 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 211 : # line 986 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ; } break ; case 212 : # line 987 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_pval ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Integer ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 213 : # line 991 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 214 : # line 992 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 215 : # line 997 ""ntp_parser.y"" { <S2SV_StartBug> char prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> char * type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( prefix != '+' && prefix != '-' && prefix != '=' ) { <S2SV_EndBug> yyerror ( ""Logconfig<S2SV_blank>prefix<S2SV_blank>is<S2SV_blank>not<S2SV_blank>\'+\',<S2SV_blank>\'-\'<S2SV_blank>or<S2SV_blank>\'=\'\\n"" ) ; } else ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; <S2SV_StartBug> YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; <S2SV_EndBug> } break ; case 216 : # line 1012 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1017 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1048 ""ntp_parser.y"" <S2SV_StartBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } <S2SV_EndBug> break ; case 228 : # line 1049 ""ntp_parser.y"" <S2SV_StartBug> { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } <S2SV_EndBug> break ; case 229 : # line 1054 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1056 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1061 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1067 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1071 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 ) ] . String ) ) ) ; } break ; case 235 : # line 1072 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1076 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; <S2SV_StartBug> case 237 : <S2SV_EndBug> # line 1077 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Address_node ) ) ; } break ; case 238 : <S2SV_StartBug> # line 1082 ""ntp_parser.y"" <S2SV_EndBug> { if ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 0 && ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) != 1 ) { yyerror ( ""Integer<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>boolean<S2SV_blank>(0<S2SV_blank>or<S2SV_blank>1).<S2SV_blank>Assuming<S2SV_blank>1"" ) ; ( yyval . Integer ) = 1 ; } else ( yyval . Integer ) = ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 239 : <S2SV_StartBug> # line 1090 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Integer ) = 1 ; } break ; case 240 : <S2SV_StartBug> # line 1091 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Integer ) = 0 ; } break ; case 241 : <S2SV_StartBug> # line 1095 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Double ) = ( double ) ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ; } break ; case 243 : <S2SV_StartBug> # line 1106 ""ntp_parser.y"" <S2SV_EndBug> { cfgt . sim_details = create_sim_node ( ( yyvsp [ ( 3 ) - ( 5 ) ] . Queue ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; old_config_style = 1 ; } break ; case 244 : <S2SV_StartBug> # line 1120 ""ntp_parser.y"" <S2SV_EndBug> { old_config_style = 0 ; } break ; case 245 : <S2SV_StartBug> # line 1124 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 246 : <S2SV_StartBug> # line 1125 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 247 : <S2SV_StartBug> # line 1129 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 248 : <S2SV_StartBug> # line 1130 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 249 : <S2SV_StartBug> # line 1134 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_server ) ) ; } break ; case 250 : <S2SV_StartBug> # line 1135 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_server ) ) ; } break ; case 251 : <S2SV_StartBug> # line 1140 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Sim_server ) = create_sim_server ( ( yyvsp [ ( 1 ) - ( 5 ) ] . Address_node ) , ( yyvsp [ ( 3 ) - ( 5 ) ] . Double ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Queue ) ) ; } break ; case 252 : <S2SV_StartBug> # line 1144 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Double ) = ( yyvsp [ ( 3 ) - ( 4 ) ] . Double ) ; } break ; case 253 : <S2SV_StartBug> # line 1148 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Address_node ) = ( yyvsp [ ( 3 ) - ( 3 ) ] . Address_node ) ; } break ; case 254 : <S2SV_StartBug> # line 1152 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Sim_script ) ) ; } break ; case 255 : <S2SV_StartBug> # line 1153 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Sim_script ) ) ; } break ; case 256 : <S2SV_StartBug> # line 1158 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Sim_script ) = create_sim_script_info ( ( yyvsp [ ( 3 ) - ( 6 ) ] . Double ) , ( yyvsp [ ( 5 ) - ( 6 ) ] . Queue ) ) ; } break ; case 257 : <S2SV_StartBug> # line 1162 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Attr_val ) ) ; } break ; case 258 : <S2SV_StartBug> # line 1163 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 259 : <S2SV_StartBug> # line 1168 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 260 : <S2SV_StartBug> # line 1170 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 261 : <S2SV_StartBug> # line 1172 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 262 : <S2SV_StartBug> # line 1174 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; case 263 : <S2SV_StartBug> # line 1176 ""ntp_parser.y"" <S2SV_EndBug> { ( yyval . Attr_val ) = create_attr_dval ( ( yyvsp [ ( 1 ) - ( 3 ) ] . Integer ) , ( yyvsp [ ( 3 ) - ( 3 ) ] . Double ) ) ; } break ; <S2SV_StartBug> # line 3826 ""ntp_parser.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else { YYSIZE_T yysize = yysyntax_error ( 0 , yystate , yychar ) ; if ( yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM ) { YYSIZE_T yyalloc = 2 * yysize ; if ( ! ( yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM ) ) yyalloc = YYSTACK_ALLOC_MAXIMUM ; if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yyalloc ) ; if ( yymsg ) yymsg_alloc = yyalloc ; else { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; } } if ( 0 < yysize && yysize <= yymsg_alloc ) { ( void ) yysyntax_error ( yymsg , yystate , yychar ) ; yyerror ( yymsg ) ; } else { yyerror ( YY_ ( ""syntax<S2SV_blank>error"" ) ) ; if ( yysize != 0 ) goto yyexhaustedlab ; } } # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( yyn != YYPACT_NINF ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } * ++ yyvsp = yylval ; YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined ( yyoverflow ) || YYERROR_VERBOSE yyexhaustedlab : yyerror ( YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval ) ; YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return YYID ( yyresult ) ; }
","<S2SV_ModStart> { char prefix <S2SV_ModEnd> ; char * <S2SV_ModStart> char * type ; switch ( <S2SV_ModEnd> ( yyvsp [ <S2SV_ModStart> . String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> + 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 ""ntp_parser.y"" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 ""ntp_parser.y"" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> ) ] . <S2SV_ModStart> String ) ) ) ; } break ; case 235 : # line 1082 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 ""ntp_parser.y"" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 ""ntp_parser.y"" { ( yyval <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) <S2SV_ModEnd> = enqueue_in_new_queue ( <S2SV_ModStart> = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] . <S2SV_ModStart> break ; case <S2SV_ModEnd> 238 : # <S2SV_ModStart> : # line 1092 <S2SV_ModEnd> ""ntp_parser.y"" { if <S2SV_ModStart> : # line 1100 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1101 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1105 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1116 <S2SV_ModEnd> ""ntp_parser.y"" { cfgt <S2SV_ModStart> : # line 1130 <S2SV_ModEnd> ""ntp_parser.y"" { old_config_style <S2SV_ModStart> : # line 1134 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1135 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1139 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1140 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1144 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1145 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1150 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1154 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1158 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1162 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1163 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1168 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1172 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1173 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1178 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1180 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1182 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1184 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> : # line 1186 <S2SV_ModEnd> ""ntp_parser.y"" { ( <S2SV_ModStart> ; # line 3836 <S2SV_ModEnd> ""ntp_parser.c"" default :
",ntp-project@ntp/553f2fa65865c31c5e3c48812cfd46176cffdd27,CVE-2015-5194,https://github.com/ntp-project/ntp/commit/553f2fa65865c31c5e3c48812cfd46176cffdd27,2017-07-21T14:29Z
CWE-20,"CWE-20 static void dissect_rpcap_packet ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * top_tree , proto_tree * parent_tree , gint offset , proto_item * top_item ) { proto_tree * tree ; proto_item * ti ; nstime_t ts ; tvbuff_t * new_tvb ; guint caplen , len , frame_no ; <S2SV_StartBug> gint reported_length_remaining ; <S2SV_EndBug> ti = proto_tree_add_item ( parent_tree , hf_packet , tvb , offset , 20 , ENC_NA ) ; tree = proto_item_add_subtree ( ti , ett_packet ) ; ts . secs = tvb_get_ntohl ( tvb , offset ) ; ts . nsecs = tvb_get_ntohl ( tvb , offset + 4 ) * 1000 ; proto_tree_add_time ( tree , hf_timestamp , tvb , offset , 8 , & ts ) ; offset += 8 ; caplen = tvb_get_ntohl ( tvb , offset ) ; ti = proto_tree_add_item ( tree , hf_caplen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; len = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_len , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; frame_no = tvb_get_ntohl ( tvb , offset ) ; proto_tree_add_item ( tree , hf_npkt , tvb , offset , 4 , ENC_BIG_ENDIAN ) ; offset += 4 ; proto_item_append_text ( ti , "",<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; proto_item_append_text ( top_item , ""<S2SV_blank>Frame<S2SV_blank>%u"" , frame_no ) ; reported_length_remaining = tvb_reported_length_remaining ( tvb , offset ) ; if ( caplen > ( guint ) reported_length_remaining ) { expert_add_info ( pinfo , ti , & ei_caplen_too_big ) ; return ; } new_tvb = tvb_new_subset ( tvb , offset , caplen , len ) ; if ( decode_content && linktype != WTAP_ENCAP_UNKNOWN ) { <S2SV_StartBug> dissector_try_uint ( wtap_encap_dissector_table , linktype , new_tvb , pinfo , top_tree ) ; <S2SV_EndBug> if ( ! info_added ) { col_prepend_fence_fstr ( pinfo -> cinfo , COL_PROTOCOL , ""R|"" ) ; col_prepend_fence_fstr ( pinfo -> cinfo , COL_INFO , ""Remote<S2SV_blank>|<S2SV_blank>"" ) ; info_added = TRUE ; register_frame_end_routine ( pinfo , rpcap_frame_end ) ; } } else { if ( linktype == WTAP_ENCAP_UNKNOWN ) { proto_item_append_text ( ti , "",<S2SV_blank>Unknown<S2SV_blank>link-layer<S2SV_blank>type"" ) ; } call_dissector ( data_handle , new_tvb , pinfo , top_tree ) ; } }
","<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr
",wireshark@wireshark/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,CVE-2016-5358,https://github.com/wireshark/wireshark/commit/2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7,2016-08-07T16:59Z
CWE-362,"CWE-362 int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , <S2SV_StartBug> const char * name , int rep_quick ) <S2SV_EndBug> { int got_error ; uint i ; ulong length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM sort_param ; MYISAM_SHARE * share = info -> s ; HA_KEYSEG * keyseg ; ulong * rec_per_key_part ; char llbuff [ 22 ] ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; DBUG_ENTER ( ""mi_repair_by_sort"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-<S2SV_blank>recovering<S2SV_blank>(with<S2SV_blank>sort)<S2SV_blank>MyISAM-table<S2SV_blank>\'%s\'\\n"" , name ) ; printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ; sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ; info -> opt_flag |= WRITE_CACHE_USED ; info -> rec_cache . file = info -> dfile ; if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) { mi_check_print_error ( param , ""Not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>extra<S2SV_blank>record"" ) ; goto err ; } if ( ! rep_quick ) { if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , """" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) { mi_check_print_error ( param , ""Can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>tempfile:<S2SV_blank>\'%s\'"" , param -> temp_filename ) ; goto err ; } if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , ""datafile-header"" ) ) goto err ; if ( param -> testflag & T_UNPACK ) { share -> options &= ~ HA_OPTION_COMPRESS_RECORD ; mi_int2store ( share -> state . header . options , share -> options ) ; } share -> state . dellink = HA_OFFSET_ERROR ; info -> rec_cache . file = new_file ; } info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ; mi_drop_all_indexes ( param , info , FALSE ) ; key_map = share -> state . key_map ; if ( param -> testflag & T_CREATE_MISSING_KEYS ) { key_map = ~ key_map ; } sort_info . info = info ; sort_info . param = param ; set_data_file_type ( & sort_info , share ) ; sort_param . filepos = new_header_length ; sort_info . dupp = 0 ; sort_info . buff = 0 ; param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ; sort_param . wordlist = NULL ; init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ; if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ; else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ; else length = share -> base . pack_reclength ; sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ; sort_param . key_cmp = sort_key_cmp ; sort_param . lock_in_memory = lock_memory ; sort_param . tmpdir = param -> tmpdir ; sort_param . sort_info = & sort_info ; sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ; sort_param . master = 1 ; del = info -> state -> del ; param -> glob_crc = 0 ; if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ; rec_per_key_part = param -> rec_per_key_part ; for ( sort_param . key = 0 ; sort_param . key < share -> base . keys ; rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) { sort_param . read_cache = param -> read_cache ; sort_param . keyinfo = share -> keyinfo + sort_param . key ; sort_param . seg = sort_param . keyinfo -> seg ; if ( ! mi_is_key_active ( key_map , sort_param . key ) ) { memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ; DBUG_PRINT ( ""repair"" , ( ""skipping<S2SV_blank>seemingly<S2SV_blank>disabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; continue ; } if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( ""-<S2SV_blank>Fixing<S2SV_blank>index<S2SV_blank>%d\\n"" , sort_param . key + 1 ) ; sort_param . max_pos = sort_param . pos = share -> pack . header_length ; keyseg = sort_param . seg ; bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ; sort_param . key_length = share -> rec_reflength ; for ( i = 0 ; keyseg [ i ] . type != HA_KEYTYPE_END ; i ++ ) { sort_param . key_length += keyseg [ i ] . length ; if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ; if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ; if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ; } info -> state -> records = info -> state -> del = share -> state . split = 0 ; info -> state -> empty = 0 ; if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) { uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ; sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ; if ( sort_param . keyinfo -> parser == & ft_default_parser ) { sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ; } else { sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ; } sort_param . key_read = sort_ft_key_read ; sort_param . key_write = sort_ft_key_write ; } else { sort_param . key_read = sort_key_read ; sort_param . key_write = sort_key_write ; } if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) { param -> retry_repair = 1 ; goto err ; } sort_param . calc_checksum = 0 ; free_root ( & sort_param . wordroot , MYF ( 0 ) ) ; sort_info . max_records = ( ha_rows ) info -> state -> records ; if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ; mi_set_key_active ( share -> state . key_map , sort_param . key ) ; DBUG_PRINT ( ""repair"" , ( ""set<S2SV_blank>enabled<S2SV_blank>index<S2SV_blank>#:<S2SV_blank>%u"" , sort_param . key ) ) ; if ( sort_param . fix_datafile ) { param -> read_cache . end_of_file = sort_param . filepos ; if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ; if ( param -> testflag & T_SAFE_REPAIR ) { if ( info -> state -> records + 1 < start_records ) { info -> state -> records = start_records ; goto err ; } } share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ; share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ; mysql_file_close ( info -> dfile , MYF ( 0 ) ) ; info -> dfile = new_file ; share -> data_file_type = sort_info . new_data_file_type ; share -> pack . header_length = ( ulong ) new_header_length ; sort_param . fix_datafile = 0 ; } else info -> state -> data_file_length = sort_param . max_pos ; param -> read_cache . file = info -> dfile ; reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ; } if ( param -> testflag & T_WRITE_LOOP ) { ( void ) fputs ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\r"" , stdout ) ; ( void ) fflush ( stdout ) ; } if ( rep_quick && del + sort_info . dupp != info -> state -> del ) { mi_check_print_error ( param , ""Couldn\'t<S2SV_blank>fix<S2SV_blank>table<S2SV_blank>with<S2SV_blank>quick<S2SV_blank>recovery:<S2SV_blank>Found<S2SV_blank>wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>deleted<S2SV_blank>records"" ) ; mi_check_print_error ( param , ""Run<S2SV_blank>recovery<S2SV_blank>again<S2SV_blank>without<S2SV_blank>-q"" ) ; got_error = 1 ; param -> retry_repair = 1 ; param -> testflag |= T_RETRY_WITHOUT_QUICK ; goto err ; } if ( rep_quick & T_FORCE_UNIQUENESS ) { my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ; # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ; # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>datafile,<S2SV_blank><S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; } if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ; if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , ""Can\'t<S2SV_blank>change<S2SV_blank>size<S2SV_blank>of<S2SV_blank>indexfile,<S2SV_blank>error:<S2SV_blank>%d"" , my_errno ) ; if ( ! ( param -> testflag & T_SILENT ) ) { if ( start_records != info -> state -> records ) printf ( ""Data<S2SV_blank>records:<S2SV_blank>%s\\n"" , llstr ( info -> state -> records , llbuff ) ) ; if ( sort_info . dupp ) mi_check_print_warning ( param , ""%s<S2SV_blank>records<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed"" , llstr ( sort_info . dupp , llbuff ) ) ; } got_error = 0 ; if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ; err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ; ( void ) end_io_cache ( & info -> rec_cache ) ; if ( ! got_error ) { if ( new_file >= 0 ) { <S2SV_StartBug> mysql_file_close ( new_file , MYF ( 0 ) ) ; <S2SV_EndBug> info -> dfile = new_file = - 1 ; if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , <S2SV_StartBug> ( param -> testflag & T_BACKUP_DATA ? <S2SV_EndBug> MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ; } } if ( got_error ) { if ( ! param -> error_printed ) mi_check_print_error ( param , ""%d<S2SV_blank>when<S2SV_blank>fixing<S2SV_blank>table"" , my_errno ) ; if ( new_file >= 0 ) { ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ; ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ; if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ; } mi_mark_crashed_on_repair ( info ) ; } else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ; share -> state . changed |= STATE_NOT_SORTED_PAGES ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ; my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ; my_free ( sort_info . key_block ) ; my_free ( sort_info . ft_buf ) ; my_free ( sort_info . buff ) ; ( void ) end_io_cache ( & param -> read_cache ) ; info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ; if ( ! got_error && ( param -> testflag & T_UNPACK ) ) { share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ; share -> pack . header_length = 0 ; } DBUG_RETURN ( got_error ) ; }
","<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
",MariaDB@server/4e5473862e6852b0f3802b0cd0c6fa10b5253291,CVE-2016-6663,https://github.com/MariaDB/server/commit/4e5473862e6852b0f3802b0cd0c6fa10b5253291,2016-12-13T21:59Z
CWE-000,"CWE-000 static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ; <S2SV_StartBug> # if uECC_VLI_NATIVE_LITTLE_ENDIAN <S2SV_EndBug> uECC_word_t * p = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ; <S2SV_StartBug> EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; <S2SV_EndBug> if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; # if uECC_VLI_NATIVE_LITTLE_ENDIAN == 0 uECC_vli_nativeToBytes ( signature , curve -> num_bytes , p ) ; # endif # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # else uECC_vli_bytesToNative ( tmp , private_key , BITS_TO_BYTES ( curve -> num_n_bits ) ) ; # endif s [ num_n_words - 1 ] = 0 ; uECC_vli_set ( s , p , num_words ) ; uECC_vli_modMult ( s , tmp , s , curve -> n , num_n_words ) ; bits2int ( tmp , message_hash , hash_size , curve ) ; uECC_vli_modAdd ( s , tmp , s , curve -> n , num_n_words ) ; uECC_vli_modMult ( s , s , k , curve -> n , num_n_words ) ; if ( uECC_vli_numBits ( s , num_n_words ) > ( bitcount_t ) curve -> num_bytes * 8 ) { return 0 ; } # if uECC_VLI_NATIVE_LITTLE_ENDIAN bcopy ( ( uint8_t * ) signature + curve -> num_bytes , ( uint8_t * ) s , curve -> num_bytes ) ; # else uECC_vli_nativeToBytes ( signature + curve -> num_bytes , curve -> num_bytes , s ) ; # endif return 1 ; }
","<S2SV_ModStart> s } ; uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> curve ) ; if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> carry ] , initial_Z <S2SV_ModEnd> , num_n_bits +
",kmackay@micro-ecc/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,CVE-2020-27209,https://github.com/kmackay/micro-ecc/commit/1b5f5cea5145c96dd8791b9b2c41424fc74c2172,2021-05-20T21:15Z
CWE-125,"CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
CWE-119,"CWE-119 void vp9_xform_quant ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblock_plane * const p = & x -> plane [ plane ] ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const scan_order * const scan_order = & vp9_default_scan_orders [ tx_size ] ; <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <S2SV_EndBug> <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> uint16_t * const eob = & p -> eobs [ block ] ; const int diff_stride = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; int i , j ; const int16_t * src_diff ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> case TX_32X32 : <S2SV_StartBug> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> <S2SV_StartBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_EndBug> <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , scan_order -> scan , <S2SV_EndBug> scan_order -> iscan ) ; break ; case TX_16X16 : <S2SV_StartBug> vp9_fdct16x16 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> vp9_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : <S2SV_StartBug> vp9_fdct8x8 ( src_diff , coeff , diff_stride ) ; <S2SV_EndBug> vp9_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; <S2SV_StartBug> vp9_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , <S2SV_EndBug> p -> quant , p -> quant_shift , qcoeff , dqcoeff , <S2SV_StartBug> pd -> dequant , p -> zbin_extra , eob , <S2SV_EndBug> scan_order -> scan , scan_order -> iscan ) ; break ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> tx_size ] ; tran_low_t <S2SV_ModEnd> * const coeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const qcoeff <S2SV_ModStart> block ) ; tran_low_t <S2SV_ModEnd> * const dqcoeff <S2SV_ModStart> ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> case TX_32X32 : highbd_fdct32x32 <S2SV_ModEnd> ( x -> <S2SV_ModStart> diff_stride ) ; vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> ( coeff , <S2SV_ModStart> , qcoeff , dqcoeff , <S2SV_ModEnd> pd -> dequant <S2SV_ModStart> -> dequant , eob , <S2SV_ModEnd> scan_order -> scan <S2SV_ModStart> case TX_16X16 : vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> pd -> dequant <S2SV_ModEnd> , eob , <S2SV_ModStart> case TX_8X8 : vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> pd -> dequant <S2SV_ModEnd> , eob , <S2SV_ModStart> diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff , <S2SV_ModStart> -> dequant , <S2SV_ModEnd> eob , scan_order <S2SV_ModStart> ( 0 ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-362,"CWE-362 int insn_get_code_seg_params ( struct pt_regs * regs ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( ! ( desc -> type & BIT ( 3 ) ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> switch ( ( desc -> l << 1 ) | desc -> d ) { <S2SV_EndBug> case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }
","<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> return sel ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> ! ( desc . <S2SV_ModEnd> type & BIT <S2SV_ModStart> ( ( desc . <S2SV_ModEnd> l << 1 <S2SV_ModStart> ) | desc . <S2SV_ModEnd> d ) {
",torvalds@linux/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,CVE-2019-13233,https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323,2019-07-04T13:15Z
CWE-787,"CWE-787 static void handle_rx ( struct vhost_net * net ) { struct vhost_net_virtqueue * nvq = & net -> vqs [ VHOST_NET_VQ_RX ] ; struct vhost_virtqueue * vq = & nvq -> vq ; unsigned uninitialized_var ( in ) , log ; struct vhost_log * vq_log ; struct msghdr msg = { . msg_name = NULL , . msg_namelen = 0 , . msg_control = NULL , . msg_controllen = 0 , . msg_iov = vq -> iov , . msg_flags = MSG_DONTWAIT , } ; struct virtio_net_hdr_mrg_rxbuf hdr = { . hdr . flags = 0 , . hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE } ; size_t total_len = 0 ; int err , mergeable ; s16 headcount ; size_t vhost_hlen , sock_hlen ; size_t vhost_len , sock_len ; struct socket * sock ; mutex_lock ( & vq -> mutex ) ; sock = vq -> private_data ; if ( ! sock ) goto out ; vhost_disable_notify ( & net -> dev , vq ) ; vhost_hlen = nvq -> vhost_hlen ; sock_hlen = nvq -> sock_hlen ; vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ; mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ; while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { sock_len += sock_hlen ; vhost_len = sock_len + vhost_hlen ; headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ; if ( unlikely ( headcount < 0 ) ) break ; <S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> err = sock -> ops -> recvmsg ( NULL , sock , & msg , <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\n"" , err , sock_len ) ; vhost_discard_vq_desc ( vq , headcount ) ; continue ; } if ( unlikely ( vhost_hlen ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , vhost_hlen ) ) { vq_err ( vq , ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>vnet_hdr<S2SV_blank>at<S2SV_blank>addr<S2SV_blank>%p\\n"" , vq -> iov -> iov_base ) ; break ; } if ( likely ( mergeable ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , offsetof ( typeof ( hdr ) , num_buffers ) , sizeof hdr . num_buffers ) ) { vq_err ( vq , ""Failed<S2SV_blank>num_buffers<S2SV_blank>write"" ) ; vhost_discard_vq_desc ( vq , headcount ) ; break ; } vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , headcount ) ; if ( unlikely ( vq_log ) ) vhost_log_write ( vq , vq_log , log , vhost_len ) ; total_len += vhost_len ; if ( unlikely ( total_len >= VHOST_NET_WEIGHT ) ) { vhost_poll_queue ( & vq -> poll ) ; break ; } } out : mutex_unlock ( & vq -> mutex ) ; }
","<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z
CWE-125,"CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
","<S2SV_ModStart> } if ( strlen ( token ) > 4 &&
",radareorg@radare2/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,CVE-2018-20459,https://github.com/radareorg/radare2/commit/e5c14c167b0dcf0a53d76bd50bacbbcc0dfc1ae7,2018-12-25T19:29Z
CWE-125,"CWE-125 int archive_wstring_append_from_mbs ( struct archive_wstring * dest , const char * p , size_t len ) { size_t r ; int ret_val = 0 ; <S2SV_StartBug> size_t wcs_length = len ; <S2SV_EndBug> size_t mbs_length = len ; const char * mbs = p ; wchar_t * wcs ; # if HAVE_MBRTOWC mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # endif <S2SV_StartBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) <S2SV_EndBug> return ( - 1 ) ; wcs = dest -> s + dest -> length ; while ( * mbs && mbs_length > 0 ) { <S2SV_StartBug> if ( wcs_length == 0 ) { <S2SV_EndBug> dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\\0' ; <S2SV_StartBug> wcs_length = mbs_length ; <S2SV_EndBug> if ( NULL == archive_wstring_ensure ( dest , dest -> length + wcs_length + 1 ) ) return ( - 1 ) ; wcs = dest -> s + dest -> length ; } # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , wcs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , wcs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; if ( errno == EILSEQ ) { ++ mbs ; -- mbs_length ; continue ; } else break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; wcs_length -- ; mbs += r ; mbs_length -= r ; } dest -> length = wcs - dest -> s ; dest -> s [ dest -> length ] = L'\\0' ; return ( ret_val ) ; }
","<S2SV_ModStart> 0 ; size_t <S2SV_ModEnd> mbs_length = len <S2SV_ModStart> -> length + len <S2SV_ModEnd> + 1 ) <S2SV_ModStart> 0 ) { # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , mbs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; mbs += r ; mbs_length -= r ; } <S2SV_ModEnd> dest -> length <S2SV_ModStart> = L'\\0' ; <S2SV_ModEnd> return ( ret_val
",libarchive@libarchive/22b1db9d46654afc6f0c28f90af8cdc84a199f41,CVE-2019-19221,https://github.com/libarchive/libarchive/commit/22b1db9d46654afc6f0c28f90af8cdc84a199f41,2019-11-21T23:15Z
CWE-190,"CWE-190 static void common_hrtimer_rearm ( struct k_itimer * timr ) { struct hrtimer * timer = & timr -> it . real . timer ; if ( ! timr -> it_interval ) return ; <S2SV_StartBug> timr -> it_overrun += ( unsigned int ) hrtimer_forward ( timer , <S2SV_EndBug> timer -> base -> get_time ( ) , timr -> it_interval ) ; hrtimer_restart ( timer ) ; }
","<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
",torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z
CWE-000,"CWE-000 static struct sock * tcp_v6_syn_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct tcp6_sock * newtcp6sk ; struct inet_sock * newinet ; struct tcp_sock * newtp ; struct sock * newsk ; # ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key * key ; # endif struct flowi6 fl6 ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = tcp_v4_syn_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( ! newsk ) return NULL ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; newtp = tcp_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & ipv6_mapped ; newsk -> sk_backlog_rcv = tcp_v4_do_rcv ; # ifdef CONFIG_TCP_MD5SIG newtp -> af_specific = & tcp_sock_ipv6_mapped_specific ; # endif <S2SV_StartBug> newnp -> ipv6_ac_list = NULL ; <S2SV_EndBug> newnp -> ipv6_fl_list = NULL ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; tcp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } ireq = inet_rsk ( req ) ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_TCP ) ; if ( ! dst ) goto out ; } newsk = tcp_create_openreq_child ( sk , req , skb ) ; if ( ! newsk ) goto out_nonewsk ; newsk -> sk_gso_type = SKB_GSO_TCPV6 ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; inet6_sk_rx_dst_set ( newsk , skb ) ; newtcp6sk = ( struct tcp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newtcp6sk -> inet6 ; newtp = tcp_sk ( newsk ) ; newinet = inet_sk ( newsk ) ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; <S2SV_StartBug> newinet -> inet_opt = NULL ; <S2SV_EndBug> newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = tcp_v6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; newnp -> rcv_flowinfo = ip6_flowinfo ( ipv6_hdr ( skb ) ) ; if ( np -> repflow ) newnp -> flow_label = ip6_flowlabel ( ipv6_hdr ( skb ) ) ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; tcp_ca_openreq_child ( newsk , dst ) ; tcp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newtp -> advmss = tcp_mss_clamp ( tcp_sk ( sk ) , dst_metric_advmss ( dst ) ) ; tcp_initialize_rcv_mss ( newsk ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; # ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup ( sk , & newsk -> sk_v6_daddr ) ; if ( key ) { tcp_md5_do_add ( newsk , ( union tcp_md5_addr * ) & newsk -> sk_v6_daddr , AF_INET6 , key -> key , key -> keylen , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; } # endif if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; tcp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req ) { tcp_move_syn ( newtp , req ) ; if ( ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , sk_gfp_mask ( sk , GFP_ATOMIC ) ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) { tcp_v6_restore_cb ( newnp -> pktoptions ) ; skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } } } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : tcp_listendrop ( sk ) ; return NULL ; }
","<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list
",torvalds@linux/83eaddab4378db256d00d295bda6ca997cd13a52,CVE-2017-9077,https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52,2017-05-19T14:29Z
CWE-125,"CWE-125 static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { <S2SV_StartBug> int alt ; <S2SV_EndBug> alt = uas_find_uas_alt_setting ( intf ) ; <S2SV_StartBug> if ( alt < 0 ) <S2SV_EndBug> return alt ; return usb_set_interface ( udev , <S2SV_StartBug> intf -> altsetting [ 0 ] . desc . bInterfaceNumber , alt ) ; <S2SV_EndBug> }
","<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
",torvalds@linux/786de92b3cb26012d3d0f00ee37adf14527f35c4,CVE-2017-16530,https://github.com/torvalds/linux/commit/786de92b3cb26012d3d0f00ee37adf14527f35c4,2017-11-04T01:29Z
CWE-284,"CWE-284 static reactor_status_t run_reactor ( reactor_t * reactor , int iterations ) { assert ( reactor != NULL ) ; reactor -> run_thread = pthread_self ( ) ; reactor -> is_running = true ; struct epoll_event events [ MAX_EVENTS ] ; for ( int i = 0 ; iterations == 0 || i < iterations ; ++ i ) { pthread_mutex_lock ( & reactor -> list_lock ) ; list_clear ( reactor -> invalidation_list ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; int ret ; do { <S2SV_StartBug> ret = epoll_wait ( reactor -> epoll_fd , events , MAX_EVENTS , - 1 ) ; <S2SV_EndBug> } while ( ret == - 1 && errno == EINTR ) ; if ( ret == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>error<S2SV_blank>in<S2SV_blank>epoll_wait:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; reactor -> is_running = false ; return REACTOR_STATUS_ERROR ; } for ( int j = 0 ; j < ret ; ++ j ) { if ( events [ j ] . data . ptr == NULL ) { eventfd_t value ; eventfd_read ( reactor -> event_fd , & value ) ; reactor -> is_running = false ; return REACTOR_STATUS_STOP ; } reactor_object_t * object = ( reactor_object_t * ) events [ j ] . data . ptr ; pthread_mutex_lock ( & reactor -> list_lock ) ; if ( list_contains ( reactor -> invalidation_list , object ) ) { pthread_mutex_unlock ( & reactor -> list_lock ) ; continue ; } pthread_mutex_lock ( & object -> lock ) ; pthread_mutex_unlock ( & reactor -> list_lock ) ; reactor -> object_removed = false ; if ( events [ j ] . events & ( EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR ) && object -> read_ready ) object -> read_ready ( object -> context ) ; if ( ! reactor -> object_removed && events [ j ] . events & EPOLLOUT && object -> write_ready ) object -> write_ready ( object -> context ) ; pthread_mutex_unlock ( & object -> lock ) ; if ( reactor -> object_removed ) { pthread_mutex_destroy ( & object -> lock ) ; osi_free ( object ) ; } } } reactor -> is_running = false ; return REACTOR_STATUS_DONE ; }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-000,"CWE-000 static enum ofperr decode_bundle ( bool load , const struct nx_action_bundle * nab , const struct vl_mff_map * vl_mff_map , uint64_t * tlv_bitmap , struct ofpbuf * ofpacts ) { static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT ( 1 , 5 ) ; struct ofpact_bundle * bundle ; uint32_t slave_type ; size_t slaves_size , i ; enum ofperr error ; bundle = ofpact_put_BUNDLE ( ofpacts ) ; bundle -> n_slaves = ntohs ( nab -> n_slaves ) ; bundle -> basis = ntohs ( nab -> basis ) ; bundle -> fields = ntohs ( nab -> fields ) ; bundle -> algorithm = ntohs ( nab -> algorithm ) ; slave_type = ntohl ( nab -> slave_type ) ; slaves_size = ntohs ( nab -> len ) - sizeof * nab ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; if ( ! flow_hash_fields_valid ( bundle -> fields ) ) { VLOG_WARN_RL ( & rl , ""unsupported<S2SV_blank>fields<S2SV_blank>%d"" , ( int ) bundle -> fields ) ; } else if ( bundle -> n_slaves > BUNDLE_MAX_SLAVES ) { VLOG_WARN_RL ( & rl , ""too<S2SV_blank>many<S2SV_blank>slaves"" ) ; } else if ( bundle -> algorithm != NX_BD_ALG_HRW && bundle -> algorithm != NX_BD_ALG_ACTIVE_BACKUP ) { VLOG_WARN_RL ( & rl , ""unsupported<S2SV_blank>algorithm<S2SV_blank>%d"" , ( int ) bundle -> algorithm ) ; } else if ( slave_type != mf_nxm_header ( MFF_IN_PORT ) ) { VLOG_WARN_RL ( & rl , ""unsupported<S2SV_blank>slave<S2SV_blank>type<S2SV_blank>%"" PRIu16 , slave_type ) ; } else { error = 0 ; } if ( ! is_all_zeros ( nab -> zero , sizeof nab -> zero ) ) { VLOG_WARN_RL ( & rl , ""reserved<S2SV_blank>field<S2SV_blank>is<S2SV_blank>nonzero"" ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } if ( load ) { bundle -> dst . ofs = nxm_decode_ofs ( nab -> ofs_nbits ) ; bundle -> dst . n_bits = nxm_decode_n_bits ( nab -> ofs_nbits ) ; error = mf_vl_mff_mf_from_nxm_header ( ntohl ( nab -> dst ) , vl_mff_map , & bundle -> dst . field , tlv_bitmap ) ; if ( error ) { return error ; } if ( bundle -> dst . n_bits < 16 ) { VLOG_WARN_RL ( & rl , ""bundle_load<S2SV_blank>action<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>16<S2SV_blank>bit<S2SV_blank>"" ""destination."" ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } } else { if ( nab -> ofs_nbits || nab -> dst ) { VLOG_WARN_RL ( & rl , ""bundle<S2SV_blank>action<S2SV_blank>has<S2SV_blank>nonzero<S2SV_blank>reserved<S2SV_blank>fields"" ) ; error = OFPERR_OFPBAC_BAD_ARGUMENT ; } } if ( slaves_size < bundle -> n_slaves * sizeof ( ovs_be16 ) ) { VLOG_WARN_RL ( & rl , ""Nicira<S2SV_blank>action<S2SV_blank>%s<S2SV_blank>only<S2SV_blank>has<S2SV_blank>%"" PRIuSIZE ""<S2SV_blank>bytes<S2SV_blank>"" ""allocated<S2SV_blank>for<S2SV_blank>slaves.<S2SV_blank><S2SV_blank>%"" PRIuSIZE ""<S2SV_blank>bytes<S2SV_blank>are<S2SV_blank>required<S2SV_blank>"" ""for<S2SV_blank>%"" PRIu16 ""<S2SV_blank>slaves."" , load ? ""bundle_load"" : ""bundle"" , slaves_size , bundle -> n_slaves * sizeof ( ovs_be16 ) , bundle -> n_slaves ) ; error = OFPERR_OFPBAC_BAD_LEN ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < bundle -> n_slaves ; i ++ ) { ofp_port_t ofp_port = u16_to_ofp ( ntohs ( ( ( ovs_be16 * ) ( nab + 1 ) ) [ i ] ) ) ; ofpbuf_put ( ofpacts , & ofp_port , sizeof ofp_port ) ; bundle = ofpacts -> header ; } <S2SV_StartBug> ofpact_finish_BUNDLE ( ofpacts , & bundle ) ; <S2SV_EndBug> if ( ! error ) { error = bundle_check ( bundle , OFPP_MAX , NULL ) ; } return error ; }
","<S2SV_ModStart> OFPERR_OFPBAC_BAD_LEN ; } else { <S2SV_ModStart> header ; } }
",openvswitch@ovs/9237a63c47bd314b807cda0bd2216264e82edbe8,CVE-2018-17206,https://github.com/openvswitch/ovs/commit/9237a63c47bd314b807cda0bd2216264e82edbe8,2018-09-19T16:29Z
CWE-20,"CWE-20 static int dispatch_discard_io ( struct xen_blkif * blkif , struct blkif_request * req ) { int err = 0 ; int status = BLKIF_RSP_OKAY ; struct block_device * bdev = blkif -> vbd . bdev ; unsigned long secure ; <S2SV_StartBug> blkif -> st_ds_req ++ ; <S2SV_EndBug> xen_blkif_get ( blkif ) ; secure = ( blkif -> vbd . discard_secure && ( req -> u . discard . flag & BLKIF_DISCARD_SECURE ) ) ? BLKDEV_DISCARD_SECURE : 0 ; err = blkdev_issue_discard ( bdev , req -> u . discard . sector_number , req -> u . discard . nr_sectors , GFP_KERNEL , secure ) ; <S2SV_StartBug> if ( err == - EOPNOTSUPP ) { <S2SV_EndBug> pr_debug ( DRV_PFX ""discard<S2SV_blank>op<S2SV_blank>failed,<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; status = BLKIF_RSP_EOPNOTSUPP ; } else if ( err ) status = BLKIF_RSP_ERROR ; make_response ( blkif , req -> u . discard . id , req -> operation , status ) ; xen_blkif_put ( blkif ) ; return err ; }
","<S2SV_ModStart> long secure ; struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX ""access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n"" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> secure ) ; fail_response :
",torvalds@linux/604c499cbbcc3d5fe5fb8d53306aa0fae1990109,CVE-2013-2140,https://github.com/torvalds/linux/commit/604c499cbbcc3d5fe5fb8d53306aa0fae1990109,2013-09-25T10:31Z
CWE-190,"CWE-190 int sqlite3Fts3InitTokenizer ( Fts3Hash * pHash , const char * zArg , sqlite3_tokenizer * * ppTok , char * * pzErr ) { int rc ; char * z = ( char * ) zArg ; int n = 0 ; char * zCopy ; char * zEnd ; sqlite3_tokenizer_module * m ; zCopy = sqlite3_mprintf ( ""%s"" , zArg ) ; if ( ! zCopy ) return SQLITE_NOMEM ; zEnd = & zCopy [ strlen ( zCopy ) ] ; z = ( char * ) sqlite3Fts3NextToken ( zCopy , & n ) ; if ( z == 0 ) { assert ( n == 0 ) ; z = zCopy ; } z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; m = ( sqlite3_tokenizer_module * ) sqlite3Fts3HashFind ( pHash , z , ( int ) strlen ( z ) + 1 ) ; if ( ! m ) { sqlite3Fts3ErrMsg ( pzErr , ""unknown<S2SV_blank>tokenizer:<S2SV_blank>%s"" , z ) ; rc = SQLITE_ERROR ; } else { char const * * aArg = 0 ; int iArg = 0 ; z = & z [ n + 1 ] ; while ( z < zEnd && ( NULL != ( z = ( char * ) sqlite3Fts3NextToken ( z , & n ) ) ) ) { <S2SV_StartBug> int nNew = sizeof ( char * ) * ( iArg + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> char const * * aNew = ( const char * * ) sqlite3_realloc ( ( void * ) aArg , nNew ) ; <S2SV_EndBug> if ( ! aNew ) { sqlite3_free ( zCopy ) ; sqlite3_free ( ( void * ) aArg ) ; return SQLITE_NOMEM ; } aArg = aNew ; aArg [ iArg ++ ] = z ; z [ n ] = '\\0' ; sqlite3Fts3Dequote ( z ) ; z = & z [ n + 1 ] ; } rc = m -> xCreate ( iArg , aArg , ppTok ) ; assert ( rc != SQLITE_OK || * ppTok ) ; if ( rc != SQLITE_OK ) { sqlite3Fts3ErrMsg ( pzErr , ""unknown<S2SV_blank>tokenizer"" ) ; } else { ( * ppTok ) -> pModule = m ; } sqlite3_free ( ( void * ) aArg ) ; } sqlite3_free ( zCopy ) ; return rc ; }
","<S2SV_ModStart> ) ) { sqlite3_int64 <S2SV_ModEnd> nNew = sizeof <S2SV_ModStart> * * ) sqlite3_realloc64 <S2SV_ModEnd> ( ( void
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-119,"CWE-119 SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
","<S2SV_ModStart> -> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f,2018-02-26T14:29Z
CWE-000,"CWE-000 static int ext4_get_block_write ( struct inode * inode , sector_t iblock , struct buffer_head * bh_result , int create ) { <S2SV_StartBug> handle_t * handle = NULL ; <S2SV_EndBug> int ret = 0 ; unsigned max_blocks = bh_result -> b_size >> inode -> i_blkbits ; int dio_credits ; <S2SV_StartBug> ext4_debug ( ""ext4_get_block_write:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>create<S2SV_blank>flag<S2SV_blank>%d\\n"" , <S2SV_EndBug> inode -> i_ino , create ) ; <S2SV_StartBug> create = EXT4_GET_BLOCKS_IO_CREATE_EXT ; <S2SV_EndBug> if ( max_blocks > DIO_MAX_BLOCKS ) max_blocks = DIO_MAX_BLOCKS ; dio_credits = ext4_chunk_trans_blocks ( inode , max_blocks ) ; handle = ext4_journal_start ( inode , dio_credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; goto out ; } <S2SV_StartBug> ret = ext4_get_blocks ( handle , inode , iblock , max_blocks , bh_result , <S2SV_EndBug> create ) ; if ( ret > 0 ) { bh_result -> b_size = ( ret << inode -> i_blkbits ) ; ret = 0 ; <S2SV_StartBug> } <S2SV_EndBug> ext4_journal_stop ( handle ) ; out : return ret ; }
","<S2SV_ModStart> * handle = ext4_journal_current_handle ( ) <S2SV_ModEnd> ; int ret <S2SV_ModStart> int dio_credits ; int started = 0 ; <S2SV_ModStart> = EXT4_GET_BLOCKS_IO_CREATE_EXT ; if ( ! handle ) { <S2SV_ModStart> out ; } started = 1 ; } <S2SV_ModStart> 0 ; } if ( started )
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-200,"CWE-200 int vmw_gb_surface_define_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct vmw_private * dev_priv = vmw_priv ( dev ) ; struct vmw_user_surface * user_srf ; struct vmw_surface * srf ; struct vmw_resource * res ; struct vmw_resource * tmp ; union drm_vmw_gb_surface_create_arg * arg = ( union drm_vmw_gb_surface_create_arg * ) data ; struct drm_vmw_gb_surface_create_req * req = & arg -> req ; struct drm_vmw_gb_surface_create_rep * rep = & arg -> rep ; struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; int ret ; uint32_t size ; <S2SV_StartBug> uint32_t backup_handle ; <S2SV_EndBug> if ( req -> multisample_count != 0 ) return - EINVAL ; if ( req -> mip_levels > DRM_VMW_MAX_MIP_LEVELS ) return - EINVAL ; if ( unlikely ( vmw_user_surface_size == 0 ) ) vmw_user_surface_size = ttm_round_pot ( sizeof ( * user_srf ) ) + 128 ; size = vmw_user_surface_size + 128 ; ret = vmw_surface_gb_priv_define ( dev , size , req -> svga3d_flags , req -> format , req -> drm_surface_flags & drm_vmw_surface_flag_scanout , req -> mip_levels , req -> multisample_count , req -> array_size , req -> base_size , & srf ) ; if ( unlikely ( ret != 0 ) ) return ret ; user_srf = container_of ( srf , struct vmw_user_surface , srf ) ; if ( drm_is_primary_client ( file_priv ) ) user_srf -> master = drm_master_get ( file_priv -> master ) ; ret = ttm_read_lock ( & dev_priv -> reservation_sem , true ) ; if ( unlikely ( ret != 0 ) ) return ret ; res = & user_srf -> srf . res ; if ( req -> buffer_handle != SVGA3D_INVALID_ID ) { ret = vmw_user_dmabuf_lookup ( tfile , req -> buffer_handle , & res -> backup , & user_srf -> backup_base ) ; <S2SV_StartBug> if ( ret == 0 && res -> backup -> base . num_pages * PAGE_SIZE < <S2SV_EndBug> res -> backup_size ) { DRM_ERROR ( ""Surface<S2SV_blank>backup<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small.\\n"" ) ; vmw_dmabuf_unreference ( & res -> backup ) ; ret = - EINVAL ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } } else if ( req -> drm_surface_flags & drm_vmw_surface_flag_create_buffer ) ret = vmw_user_dmabuf_alloc ( dev_priv , tfile , res -> backup_size , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , & backup_handle , & res -> backup , & user_srf -> backup_base ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & res ) ; goto out_unlock ; } tmp = vmw_resource_reference ( res ) ; ret = ttm_prime_object_init ( tfile , res -> backup_size , & user_srf -> prime , req -> drm_surface_flags & drm_vmw_surface_flag_shareable , VMW_RES_SURFACE , & vmw_user_surface_base_release , NULL ) ; if ( unlikely ( ret != 0 ) ) { vmw_resource_unreference ( & tmp ) ; vmw_resource_unreference ( & res ) ; goto out_unlock ; } rep -> handle = user_srf -> prime . base . hash . key ; rep -> backup_size = res -> backup_size ; if ( res -> backup ) { rep -> buffer_map_handle = drm_vma_node_offset_addr ( & res -> backup -> base . vma_node ) ; rep -> buffer_size = res -> backup -> base . num_pages * PAGE_SIZE ; rep -> buffer_handle = backup_handle ; } else { rep -> buffer_map_handle = 0 ; rep -> buffer_size = 0 ; rep -> buffer_handle = SVGA3D_INVALID_ID ; } vmw_resource_unreference ( & res ) ; out_unlock : ttm_read_unlock ( & dev_priv -> reservation_sem ) ; return ret ; }
","<S2SV_ModStart> ; uint32_t backup_handle = 0 <S2SV_ModStart> ret == 0 ) { if ( <S2SV_ModEnd> res -> backup <S2SV_ModStart> goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
",torvalds@linux/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,CVE-2017-9605,https://github.com/torvalds/linux/commit/07678eca2cf9c9a18584e546c2b2a0d0c9a3150c,2017-06-13T19:29Z
CWE-17,"CWE-17 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; <S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ; <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; } <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
",torvalds@linux/0f2af21aae11972fa924374ddcf52e88347cf5a8,CVE-2015-0275,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,2015-10-19T10:59Z
CWE-476,"CWE-476 static void show_frame ( WriterContext * w , AVFrame * frame , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; char val_str [ 128 ] ; const char * s ; int i ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_FRAME ) ; s = av_get_media_type_string ( stream -> codecpar -> codec_type ) ; if ( s ) print_str ( ""media_type"" , s ) ; else print_str_opt ( ""media_type"" , ""unknown"" ) ; print_int ( ""stream_index"" , stream -> index ) ; print_int ( ""key_frame"" , frame -> key_frame ) ; print_ts ( ""pkt_pts"" , frame -> pts ) ; print_time ( ""pkt_pts_time"" , frame -> pts , & stream -> time_base ) ; print_ts ( ""pkt_dts"" , frame -> pkt_dts ) ; print_time ( ""pkt_dts_time"" , frame -> pkt_dts , & stream -> time_base ) ; print_ts ( ""best_effort_timestamp"" , frame -> best_effort_timestamp ) ; print_time ( ""best_effort_timestamp_time"" , frame -> best_effort_timestamp , & stream -> time_base ) ; print_duration_ts ( ""pkt_duration"" , frame -> pkt_duration ) ; print_duration_time ( ""pkt_duration_time"" , frame -> pkt_duration , & stream -> time_base ) ; if ( frame -> pkt_pos != - 1 ) print_fmt ( ""pkt_pos"" , ""%"" PRId64 , frame -> pkt_pos ) ; else print_str_opt ( ""pkt_pos"" , ""N/A"" ) ; if ( frame -> pkt_size != - 1 ) print_val ( ""pkt_size"" , frame -> pkt_size , unit_byte_str ) ; else print_str_opt ( ""pkt_size"" , ""N/A"" ) ; switch ( stream -> codecpar -> codec_type ) { AVRational sar ; case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , frame -> width ) ; print_int ( ""height"" , frame -> height ) ; s = av_get_pix_fmt_name ( frame -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , frame ) ; if ( sar . num ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; } print_fmt ( ""pict_type"" , ""%c"" , av_get_picture_type_char ( frame -> pict_type ) ) ; print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ; print_int ( ""display_picture_number"" , frame -> display_picture_number ) ; print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ; print_int ( ""top_field_first"" , frame -> top_field_first ) ; print_int ( ""repeat_pict"" , frame -> repeat_pict ) ; if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ; else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ; if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ; <S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ; if ( frame -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( frame -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( frame -> color_trc ) ) ; if ( frame -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( frame -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( frame -> chroma_location ) ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( frame -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_int ( ""nb_samples"" , frame -> nb_samples ) ; print_int ( ""channels"" , frame -> channels ) ; if ( frame -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , frame -> channels , frame -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else print_str_opt ( ""channel_layout"" , ""unknown"" ) ; break ; } if ( do_show_frame_tags ) show_tags ( w , frame -> metadata , SECTION_ID_FRAME_TAGS ) ; if ( do_show_log ) show_log ( w , SECTION_ID_FRAME_LOGS , SECTION_ID_FRAME_LOG , do_show_log ) ; if ( frame -> nb_side_data ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_LIST ) ; for ( i = 0 ; i < frame -> nb_side_data ; i ++ ) { AVFrameSideData * sd = frame -> side_data [ i ] ; const char * name ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA ) ; name = av_frame_side_data_name ( sd -> type ) ; print_str ( ""side_data_type"" , name ? name : ""unknown"" ) ; if ( sd -> type == AV_FRAME_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { writer_print_integers ( w , ""displaymatrix"" , sd -> data , 9 , ""<S2SV_blank>%11d"" , 3 , 4 , 1 ) ; print_int ( ""rotation"" , av_display_rotation_get ( ( int32_t * ) sd -> data ) ) ; } else if ( sd -> type == AV_FRAME_DATA_GOP_TIMECODE && sd -> size >= 8 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , * ( int64_t * ) ( sd -> data ) ) ; print_str ( ""timecode"" , tcbuf ) ; } else if ( sd -> type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( ""red_x"" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( ""red_y"" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( ""green_x"" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( ""green_y"" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( ""blue_x"" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( ""blue_y"" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( ""white_point_x"" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( ""white_point_y"" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( ""min_luminance"" , metadata -> min_luminance , '/' ) ; print_q ( ""max_luminance"" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( ""max_content"" , metadata -> MaxCLL ) ; print_int ( ""max_average"" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_FRAME_DATA_ICC_PROFILE ) { AVDictionaryEntry * tag = av_dict_get ( sd -> metadata , ""name"" , NULL , AV_DICT_MATCH_CASE ) ; if ( tag ) print_str ( tag -> key , tag -> value ) ; print_int ( ""size"" , sd -> size ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }
","<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> frame -> color_primaries <S2SV_ModStart> frame -> color_primaries <S2SV_ModEnd> ) ; if
",FFmpeg@FFmpeg/837cb4325b712ff1aab531bf41668933f61d75d2,CVE-2017-14225,https://github.com/FFmpeg/FFmpeg/commit/837cb4325b712ff1aab531bf41668933f61d75d2,2017-09-09T08:29Z
CWE-20,"CWE-20 static int cbor2json ( OSCTXT * pCborCtxt , OSCTXT * pJsonCtxt ) { int ret = 0 ; OSOCTET tag , ub ; ret = rtxReadBytes ( pCborCtxt , & ub , 1 ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; tag = ub >> 5 ; switch ( tag ) { case OSRTCBOR_UINT : { OSUINTTYPE value ; ret = rtCborDecUInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncUInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncUIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_NEGINT : { OSINTTYPE value ; ret = rtCborDecInt ( pCborCtxt , ub , & value ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; # ifndef _NO_INT64_SUPPORT ret = rtJsonEncInt64Value ( pJsonCtxt , value ) ; # else ret = rtJsonEncIntValue ( pJsonCtxt , value ) ; # endif if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_BYTESTR : { OSDynOctStr64 byteStr ; ret = rtCborDecDynByteStr ( pCborCtxt , ub , & byteStr ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncHexStr ( pJsonCtxt , byteStr . numocts , byteStr . data ) ; rtxMemFreePtr ( pCborCtxt , byteStr . data ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_UTF8STR : { OSUTF8CHAR * utf8str ; <S2SV_StartBug> ret = rtCborDecDynUTF8Str ( pCborCtxt , ub , ( char * * ) & utf8str ) ; <S2SV_EndBug> ret = rtJsonEncStringValue ( pJsonCtxt , utf8str ) ; rtxMemFreePtr ( pCborCtxt , utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; break ; } case OSRTCBOR_ARRAY : case OSRTCBOR_MAP : { OSOCTET len = ub & 0x1F ; char startChar = ( tag == OSRTCBOR_ARRAY ) ? '[' : '{' ; char endChar = ( tag == OSRTCBOR_ARRAY ) ? ']' : '}' ; OSRTSAFEPUTCHAR ( pJsonCtxt , startChar ) ; if ( len == OSRTCBOR_INDEF ) { OSBOOL first = TRUE ; for ( ; ; ) { if ( OSRTCBOR_MATCHEOC ( pCborCtxt ) ) { pCborCtxt -> buffer . byteIndex ++ ; break ; } if ( ! first ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; else first = FALSE ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } else { OSSIZE nitems ; ret = rtCborDecSize ( pCborCtxt , len , & nitems ) ; if ( 0 == ret ) { OSSIZE i ; for ( i = 0 ; i < nitems ; i ++ ) { if ( 0 != i ) OSRTSAFEPUTCHAR ( pJsonCtxt , ',' ) ; if ( tag == OSRTCBOR_MAP ) { ret = cborElemNameToJson ( pCborCtxt , pJsonCtxt ) ; } if ( 0 == ret ) ret = cbor2json ( pCborCtxt , pJsonCtxt ) ; if ( 0 != ret ) { OSCTXT * pctxt = ( rtxErrGetErrorCnt ( pJsonCtxt ) > 0 ) ? pJsonCtxt : pCborCtxt ; return LOG_RTERR ( pctxt , ret ) ; } } } } OSRTSAFEPUTCHAR ( pJsonCtxt , endChar ) ; break ; } case OSRTCBOR_FLOAT : if ( tag == OSRTCBOR_FALSEENC || tag == OSRTCBOR_TRUEENC ) { OSBOOL boolval = ( ub == OSRTCBOR_TRUEENC ) ? TRUE : FALSE ; ret = rtJsonEncBoolValue ( pJsonCtxt , boolval ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else if ( tag == OSRTCBOR_FLT16ENC || tag == OSRTCBOR_FLT32ENC || tag == OSRTCBOR_FLT64ENC ) { OSDOUBLE fltval ; ret = rtCborDecFloat ( pCborCtxt , ub , & fltval ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret ) ; ret = rtJsonEncDoubleValue ( pJsonCtxt , fltval , 0 ) ; if ( 0 != ret ) return LOG_RTERR ( pJsonCtxt , ret ) ; } else { ret = cborTagNotSupp ( pCborCtxt , tag ) ; } break ; default : ret = cborTagNotSupp ( pCborCtxt , tag ) ; } return ret ; }
","<S2SV_ModStart> ) & utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret
",objsys@oocborrt/539851c66778f68a244633985f6f8d0df94ea3b3,CVE-2020-24753,https://github.com/objsys/oocborrt/commit/539851c66778f68a244633985f6f8d0df94ea3b3,2020-09-17T18:15Z
CWE-284,"CWE-284 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; <S2SV_StartBug> ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , <S2SV_EndBug> & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }
","<S2SV_ModStart> = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;
",external@libavc/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,CVE-2016-3878,https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf,2016-09-11T21:59Z
CWE-416,"CWE-416 static void cmd_anal_esil ( RCore * core , const char * input ) { RAnalEsil * esil = core -> anal -> esil ; ut64 addr = core -> offset ; ut64 adr ; char * n , * n1 ; int off ; int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; int iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; int romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; int stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; int noNULL = r_config_get_i ( core -> config , ""esil.noNULL"" ) ; ut64 until_addr = UT64_MAX ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; const char * until_expr = NULL ; RAnalOp * op ; switch ( input [ 0 ] ) { case 'p' : switch ( input [ 1 ] ) { case 'c' : if ( input [ 2 ] == '<S2SV_blank>' ) { r_core_cmdf ( core , ""ar<S2SV_blank>PC=%s"" , input + 3 ) ; r_core_cmd0 ( core , "".ar*"" ) ; } else { eprintf ( ""Missing<S2SV_blank>argument\\n"" ) ; } break ; case 0 : r_anal_pin_list ( core -> anal ) ; break ; case '-' : if ( input [ 2 ] ) addr = r_num_math ( core -> num , input + 2 ) ; r_anal_pin_unset ( core -> anal , addr ) ; break ; case '<S2SV_blank>' : r_anal_pin ( core -> anal , addr , input + 2 ) ; break ; default : r_core_cmd_help ( core , help_msg_aep ) ; break ; } break ; case 'r' : cmd_anal_reg ( core , input + 1 ) ; break ; case '*' : if ( core -> anal -> esil ) { r_cons_printf ( ""trap:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap ) ; r_cons_printf ( ""trap-code:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap_code ) ; } else { eprintf ( ""esil<S2SV_blank>vm<S2SV_blank>not<S2SV_blank>initialized.<S2SV_blank>run<S2SV_blank>`aei`\\n"" ) ; } break ; case '<S2SV_blank>' : if ( ! esil ) { if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 1 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; break ; case 's' : switch ( input [ 1 ] ) { case '?' : eprintf ( ""See:<S2SV_blank>ae?~aes\\n"" ) ; break ; case 'l' : { ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ; RAnalOp * op = r_core_anal_op ( core , pc ) ; if ( ! op ) { break ; } r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ; r_anal_esil_set_pc ( esil , pc + op -> size ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'b' : if ( ! r_core_esil_step_back ( core ) ) { eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\n"" ) ; } r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'u' : if ( input [ 2 ] == 'e' ) { until_expr = input + 3 ; } else { until_addr = r_num_math ( core -> num , input + 2 ) ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'o' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { until_addr = op -> addr + op -> size ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_anal_op_free ( op ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'p' : n = strchr ( input , '<S2SV_blank>' ) ; n1 = n ? strchr ( n + 1 , '<S2SV_blank>' ) : NULL ; if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\n"" ) ; break ; } adr = r_num_math ( core -> num , n + 1 ) ; off = r_num_math ( core -> num , n1 + 1 ) ; cmd_aespc ( core , adr , off ) ; break ; case '<S2SV_blank>' : n = strchr ( input , '<S2SV_blank>' ) ; if ( ! ( n + 1 ) ) { r_core_esil_step ( core , until_addr , until_expr , NULL ) ; break ; } off = r_num_math ( core -> num , n + 1 ) ; cmd_aespc ( core , - 1 , off ) ; break ; default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; } break ; case 'c' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aec ) ; } else if ( input [ 1 ] == 's' ) { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; ut64 newaddr ; int ret ; for ( ; ; ) { op = r_core_anal_op ( core , addr ) ; if ( ! op ) { break ; } if ( op -> type == R_ANAL_OP_TYPE_SWI ) { eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_anal_op_free ( op ) ; op = NULL ; if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { break ; } if ( ! ret ) break ; r_core_cmd0 ( core , "".ar*"" ) ; newaddr = r_num_get ( core -> num , pc ) ; if ( addr == newaddr ) { addr ++ ; break ; } else { addr = newaddr ; } } if ( op ) { r_anal_op_free ( op ) ; } } else { if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) until_expr = input + 3 ; else if ( input [ 1 ] == 'u' ) until_addr = r_num_math ( core -> num , input + 2 ) ; else until_expr = ""0"" ; r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'i' : switch ( input [ 1 ] ) { case 's' : case 'm' : cmd_esil_mem ( core , input + 2 ) ; break ; case 'p' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; break ; case '?' : cmd_esil_mem ( core , ""?"" ) ; break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } r_anal_esil_free ( esil ) ; core -> anal -> esil = NULL ; break ; case 0 : r_anal_esil_free ( esil ) ; { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; } } if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ; { const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ; if ( s ) { char * my = strdup ( s ) ; if ( my ) { r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ; free ( my ) ; } } } break ; } break ; case 'k' : switch ( input [ 1 ] ) { case '\\0' : input = ""123*"" ; case '<S2SV_blank>' : if ( esil && esil -> stats ) { char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; if ( out ) { r_cons_println ( out ) ; free ( out ) ; } } else { eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\'aei\'\\n"" ) ; } break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } break ; } break ; case 'f' : { RListIter * iter ; RAnalBlock * bb ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { r_list_foreach ( fcn -> bbs , iter , bb ) { ut64 pc = bb -> addr ; ut64 end = bb -> addr + bb -> size ; RAnalOp op ; ut8 * buf ; int ret , bbs = end - pc ; if ( bbs < 1 || bbs > 0xfffff ) { eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\n"" ) ; } buf = calloc ( 1 , bbs + 1 ) ; r_io_read_at ( core -> io , pc , buf , bbs ) ; int left ; while ( pc < end ) { left = R_MIN ( end - pc , 32 ) ; r_asm_set_pc ( core -> assembler , pc ) ; ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; if ( ret ) { r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; pc += op . size ; } else { pc += 4 ; } } } } else { eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , core -> offset ) ; } } break ; case 't' : switch ( input [ 1 ] ) { case 'r' : { RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; <S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> return ; r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 2 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_free ( esil ) ; break ; } case 's' : switch ( input [ 2 ] ) { case 0 : r_anal_esil_session_list ( esil ) ; break ; case '+' : r_anal_esil_session_add ( esil ) ; break ; default : r_core_cmd_help ( core , help_msg_aets ) ; break ; } break ; default : eprintf ( ""Unknown<S2SV_blank>command.<S2SV_blank>Use<S2SV_blank>`aetr`.\\n"" ) ; break ; } break ; case 'A' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; } } else { cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; } break ; case 'a' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { switch ( input [ 2 ] ) { case 'j' : cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; default : cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; } break ; } } else { const char * arg = input [ 1 ] ? input + 2 : """" ; ut64 len = r_num_math ( core -> num , arg ) ; cmd_aea ( core , 0 , core -> offset , len ) ; } break ; case 'x' : { char * hex ; int ret , bufsz ; input = r_str_trim_ro ( input + 1 ) ; hex = strdup ( input ) ; if ( ! hex ) { break ; } RAnalOp aop = R_EMPTY ; bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; ret = r_anal_op ( core -> anal , & aop , core -> offset , ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; if ( ret > 0 ) { const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; char * str2 = r_str_newf ( ""<S2SV_blank>%s"" , str ) ; cmd_anal_esil ( core , str2 ) ; free ( str2 ) ; } r_anal_op_fini ( & aop ) ; break ; } case '?' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_detail_ae ) ; break ; } default : r_core_cmd_help ( core , help_msg_ae ) ; break ; } }
","<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
CWE-000,"CWE-000 struct dentry * nfs4_atomic_open ( struct inode * dir , struct dentry * dentry , struct nameidata * nd ) { struct path path = { . mnt = nd -> path . mnt , . dentry = dentry , } ; struct dentry * parent ; struct iattr attr ; struct rpc_cred * cred ; struct nfs4_state * state ; <S2SV_StartBug> struct dentry * res ; <S2SV_EndBug> if ( nd -> flags & LOOKUP_CREATE ) { attr . ia_mode = nd -> intent . open . create_mode ; attr . ia_valid = ATTR_MODE ; if ( ! IS_POSIXACL ( dir ) ) attr . ia_mode &= ~ current -> fs -> umask ; } else { attr . ia_valid = 0 ; BUG_ON ( nd -> intent . open . flags & O_CREAT ) ; } cred = rpc_lookup_cred ( ) ; if ( IS_ERR ( cred ) ) return ( struct dentry * ) cred ; parent = dentry -> d_parent ; nfs_block_sillyrename ( parent ) ; <S2SV_StartBug> state = nfs4_do_open ( dir , & path , nd -> intent . open . flags , & attr , cred ) ; <S2SV_EndBug> put_rpccred ( cred ) ; if ( IS_ERR ( state ) ) { if ( PTR_ERR ( state ) == - ENOENT ) { d_add ( dentry , NULL ) ; nfs_set_verifier ( dentry , nfs_save_change_attribute ( dir ) ) ; } nfs_unblock_sillyrename ( parent ) ; return ( struct dentry * ) state ; } res = d_add_unique ( dentry , igrab ( state -> inode ) ) ; if ( res != NULL ) path . dentry = res ; nfs_set_verifier ( path . dentry , nfs_save_change_attribute ( dir ) ) ; nfs_unblock_sillyrename ( parent ) ; <S2SV_StartBug> nfs4_intent_set_file ( nd , & path , state ) ; <S2SV_EndBug> return res ; }
","<S2SV_ModStart> dentry * res ; fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) <S2SV_ModStart> & path , fmode , <S2SV_ModStart> path , state , fmode
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct arpt_arp * arp ) <S2SV_EndBug> { static const struct arpt_arp uncond ; <S2SV_StartBug> return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> ( const struct arpt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> arp , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-264,"CWE-264 int copy_thread ( unsigned long clone_flags , unsigned long stack_start , unsigned long stk_sz , struct task_struct * p ) { struct thread_info * thread = task_thread_info ( p ) ; struct pt_regs * childregs = task_pt_regs ( p ) ; memset ( & thread -> cpu_context , 0 , sizeof ( struct cpu_context_save ) ) ; if ( likely ( ! ( p -> flags & PF_KTHREAD ) ) ) { * childregs = * current_pt_regs ( ) ; childregs -> ARM_r0 = 0 ; if ( stack_start ) childregs -> ARM_sp = stack_start ; } else { memset ( childregs , 0 , sizeof ( struct pt_regs ) ) ; thread -> cpu_context . r4 = stk_sz ; thread -> cpu_context . r5 = stack_start ; childregs -> ARM_cpsr = SVC_MODE ; } thread -> cpu_context . pc = ( unsigned long ) ret_from_fork ; thread -> cpu_context . sp = ( unsigned long ) childregs ; clear_ptrace_hw_breakpoint ( p ) ; if ( clone_flags & CLONE_SETTLS ) <S2SV_StartBug> thread -> tp_value = childregs -> ARM_r3 ; <S2SV_EndBug> thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0 ; }
","<S2SV_ModStart> thread -> tp_value [ 0 ] <S2SV_ModStart> childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( )
",torvalds@linux/a4780adeefd042482f624f5e0d577bf9cdcbb760,CVE-2014-9870,https://github.com/torvalds/linux/commit/a4780adeefd042482f624f5e0d577bf9cdcbb760,2016-08-06T10:59Z
CWE-295,"CWE-295 int options_parse ( CONF_TYPE type ) { SERVICE_OPTIONS * section ; options_defaults ( ) ; section = & new_service_options ; <S2SV_StartBug> if ( options_file ( configuration_file , type , & section ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( init_section ( 1 , & section ) ) <S2SV_EndBug> <S2SV_StartBug> return 1 ; <S2SV_EndBug> s_log ( LOG_NOTICE , ""Configuration<S2SV_blank>successful"" ) ; return 0 ; }
","<S2SV_ModStart> & section ) || <S2SV_ModEnd> init_section ( 1 <S2SV_ModStart> section ) ) { s_log ( LOG_ERR , ""Configuration<S2SV_blank>failed"" ) ; options_free ( 0 ) ; <S2SV_ModStart> return 1 ; }
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-190,"CWE-190 void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; <S2SV_StartBug> } else { <S2SV_EndBug> uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ; } else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> ; } } else { free ( buf ) ; }
",viabtc@viabtc_exchange_server/4a7c27bfe98f409623d4d857894d017ff0672cc9,CVE-2018-17568,https://github.com/viabtc/viabtc_exchange_server/commit/4a7c27bfe98f409623d4d857894d017ff0672cc9#diff-0c23effa84a7b85053bac7981a8580c8,2018-09-26T22:29Z
CWE-264,"CWE-264 int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) <S2SV_StartBug> { <S2SV_EndBug> if ( policy -> version != 0 ) return - EINVAL ; if ( ! inode_has_encryption_context ( inode ) ) { if ( ! inode -> i_sb -> s_cop -> empty_dir ) return - EOPNOTSUPP ; if ( ! inode -> i_sb -> s_cop -> empty_dir ( inode ) ) return - ENOTEMPTY ; return create_encryption_context_from_policy ( inode , policy ) ; } if ( is_encryption_context_consistent_with_policy ( inode , policy ) ) return 0 ; printk ( KERN_WARNING ""%s:<S2SV_blank>Policy<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>encryption<S2SV_blank>context\\n"" , __func__ ) ; return - EINVAL ; }
","<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
",torvalds@linux/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,CVE-2016-10318,https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98,2017-04-04T16:59Z
CWE-000,"CWE-000 void zipfileStep ( sqlite3_context * pCtx , int nVal , sqlite3_value * * apVal ) { ZipfileCtx * p ; ZipfileEntry e ; sqlite3_value * pName = 0 ; sqlite3_value * pMode = 0 ; sqlite3_value * pMtime = 0 ; sqlite3_value * pData = 0 ; sqlite3_value * pMethod = 0 ; int bIsDir = 0 ; u32 mode ; int rc = SQLITE_OK ; char * zErr = 0 ; int iMethod = - 1 ; const u8 * aData = 0 ; int nData = 0 ; int szUncompressed = 0 ; u8 * aFree = 0 ; u32 iCrc32 = 0 ; char * zName = 0 ; int nName = 0 ; char * zFree = 0 ; int nByte ; memset ( & e , 0 , sizeof ( e ) ) ; p = ( ZipfileCtx * ) sqlite3_aggregate_context ( pCtx , sizeof ( ZipfileCtx ) ) ; if ( p == 0 ) return ; if ( nVal != 2 && nVal != 4 && nVal != 5 ) { zErr = sqlite3_mprintf ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>function<S2SV_blank>zipfile()"" ) ; rc = SQLITE_ERROR ; goto zipfile_step_out ; } pName = apVal [ 0 ] ; if ( nVal == 2 ) { pData = apVal [ 1 ] ; } else { pMode = apVal [ 1 ] ; pMtime = apVal [ 2 ] ; pData = apVal [ 3 ] ; if ( nVal == 5 ) { pMethod = apVal [ 4 ] ; } } zName = ( char * ) sqlite3_value_text ( pName ) ; nName = sqlite3_value_bytes ( pName ) ; if ( zName == 0 ) { zErr = sqlite3_mprintf ( ""first<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>zipfile()<S2SV_blank>must<S2SV_blank>be<S2SV_blank>non-NULL"" ) ; rc = SQLITE_ERROR ; goto zipfile_step_out ; } if ( pMethod && SQLITE_NULL != sqlite3_value_type ( pMethod ) ) { iMethod = ( int ) sqlite3_value_int64 ( pMethod ) ; if ( iMethod != 0 && iMethod != 8 ) { zErr = sqlite3_mprintf ( ""illegal<S2SV_blank>method<S2SV_blank>value:<S2SV_blank>%d"" , iMethod ) ; rc = SQLITE_ERROR ; goto zipfile_step_out ; } } if ( sqlite3_value_type ( pData ) == SQLITE_NULL ) { bIsDir = 1 ; iMethod = 0 ; } else { aData = sqlite3_value_blob ( pData ) ; szUncompressed = nData = sqlite3_value_bytes ( pData ) ; iCrc32 = crc32 ( 0 , aData , nData ) ; if ( iMethod < 0 || iMethod == 8 ) { int nOut = 0 ; rc = zipfileDeflate ( aData , nData , & aFree , & nOut , & zErr ) ; if ( rc != SQLITE_OK ) { goto zipfile_step_out ; } if ( iMethod == 8 || nOut < nData ) { aData = aFree ; nData = nOut ; iMethod = 8 ; } else { iMethod = 0 ; } } } rc = zipfileGetMode ( pMode , bIsDir , & mode , & zErr ) ; if ( rc ) goto zipfile_step_out ; e . mUnixTime = zipfileGetTime ( pMtime ) ; if ( bIsDir == 0 ) { if ( zName [ nName - 1 ] == '/' ) { zErr = sqlite3_mprintf ( ""non-directory<S2SV_blank>name<S2SV_blank>must<S2SV_blank>not<S2SV_blank>end<S2SV_blank>with<S2SV_blank>/"" ) ; rc = SQLITE_ERROR ; goto zipfile_step_out ; } } else { if ( zName [ nName - 1 ] != '/' ) { zName = zFree = sqlite3_mprintf ( ""%s/"" , zName ) ; <S2SV_StartBug> nName ++ ; <S2SV_EndBug> if ( zName == 0 ) { rc = SQLITE_NOMEM ; goto zipfile_step_out ; <S2SV_StartBug> } <S2SV_EndBug> } else { while ( nName > 1 && zName [ nName - 2 ] == '/' ) nName -- ; } } e . cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; e . cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; e . cds . flags = ZIPFILE_NEWENTRY_FLAGS ; e . cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & e . cds , ( u32 ) e . mUnixTime ) ; e . cds . crc32 = iCrc32 ; e . cds . szCompressed = nData ; e . cds . szUncompressed = szUncompressed ; e . cds . iExternalAttr = ( mode << 16 ) ; e . cds . iOffset = p -> body . n ; e . cds . nFile = ( u16 ) nName ; e . cds . zFile = zName ; nByte = ZIPFILE_LFH_FIXED_SZ + e . cds . nFile + 9 ; if ( ( rc = zipfileBufferGrow ( & p -> body , nByte ) ) ) goto zipfile_step_out ; p -> body . n += zipfileSerializeLFH ( & e , & p -> body . a [ p -> body . n ] ) ; if ( nData > 0 ) { if ( ( rc = zipfileBufferGrow ( & p -> body , nData ) ) ) goto zipfile_step_out ; memcpy ( & p -> body . a [ p -> body . n ] , aData , nData ) ; p -> body . n += nData ; } nByte = ZIPFILE_CDS_FIXED_SZ + e . cds . nFile + 9 ; if ( ( rc = zipfileBufferGrow ( & p -> cds , nByte ) ) ) goto zipfile_step_out ; p -> cds . n += zipfileSerializeCDS ( & e , & p -> cds . a [ p -> cds . n ] ) ; p -> nEntry ++ ; zipfile_step_out : sqlite3_free ( aFree ) ; sqlite3_free ( zFree ) ; if ( rc ) { if ( zErr ) { sqlite3_result_error ( pCtx , zErr , - 1 ) ; } else { sqlite3_result_error_code ( pCtx , rc ) ; } } sqlite3_free ( zErr ) ; }
","<S2SV_ModStart> zName ) ; <S2SV_ModEnd> if ( zName <S2SV_ModStart> zipfile_step_out ; } nName = ( int ) strlen ( zName ) ;
",sqlite@sqlite/d8f2d46cbc9925e034a68aaaf60aad788d9373c1,CVE-2019-19959,https://github.com/sqlite/sqlite/commit/d8f2d46cbc9925e034a68aaaf60aad788d9373c1,2020-01-03T22:15Z
CWE-200,"CWE-200 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
",torvalds@linux/4a184233f21645cf0b719366210ed445d1024d72,CVE-2013-3234,https://github.com/torvalds/linux/commit/4a184233f21645cf0b719366210ed445d1024d72,2013-04-22T11:41Z
CWE-287,"CWE-287 static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ; <S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> _sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\'t<S2SV_blank>offer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_start<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( sd ) ; if ( sctx != NULL ) free ( sctx ) ; sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; sctx -> s = s ; sctx -> ctx = ctx ; gsasl_session_hook_set ( sd , ( void * ) sctx ) ; gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; gsasl_property_set ( sd , GSASL_REALM , realm ) ; hostname [ 0 ] = '\\0' ; gethostname ( hostname , 256 ) ; hostname [ 255 ] = '\\0' ; gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; ext_id = NULL ; # ifdef HAVE_SSL for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; if ( ext_id != NULL ) { for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) if ( ext_id [ i ] != NULL ) { ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; } else { ctx -> ext_id [ i ] = NULL ; break ; } } # endif _sx_debug ( ZONE , ""sasl<S2SV_blank>context<S2SV_blank>initialised<S2SV_blank>for<S2SV_blank>%d"" , s -> tag ) ; s -> plugin_data [ p -> index ] = ( void * ) sd ; if ( strcmp ( mech , ""ANONYMOUS"" ) == 0 ) { ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; buf = strdup ( out ) ; buflen = strlen ( buf ) ; } else if ( strstr ( in , ""<"" ) != NULL && strncmp ( in , ""="" , strstr ( in , ""<"" ) - in ) == 0 ) { _sx_debug ( ZONE , ""gsasl<S2SV_blank>auth<S2SV_blank>string<S2SV_blank>is<S2SV_blank>empty"" ) ; buf = strdup ( """" ) ; buflen = strlen ( buf ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } } ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; return ; } if ( ! sd ) { _sx_debug ( ZONE , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism"" ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } _sx_debug ( ZONE , ""response<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } if ( buf != NULL ) free ( buf ) ; if ( ret == GSASL_OK ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>completed"" ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; free ( buf ) ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( ret == GSASL_NEEDS_MORE ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>in<S2SV_blank>progress<S2SV_blank>(challenge:<S2SV_blank>%.*s)"" , outlen , out ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; free ( buf ) ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( out != NULL ) free ( out ) ; _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>failed;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; switch ( ret ) { case GSASL_AUTHENTICATION_ERROR : case GSASL_NO_ANONYMOUS_TOKEN : case GSASL_NO_AUTHID : case GSASL_NO_AUTHZID : case GSASL_NO_PASSWORD : case GSASL_NO_PASSCODE : case GSASL_NO_PIN : case GSASL_NO_SERVICE : case GSASL_NO_HOSTNAME : out = _sasl_err_NOT_AUTHORIZED ; break ; case GSASL_UNKNOWN_MECHANISM : case GSASL_MECHANISM_PARSE_ERROR : out = _sasl_err_INVALID_MECHANISM ; break ; case GSASL_BASE64_ERROR : out = _sasl_err_INCORRECT_ENCODING ; break ; default : out = _sasl_err_MALFORMED_REQUEST ; } _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; }
","<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
CWE-20,"CWE-20 static void _out_result ( conn_t out , nad_t nad ) { int attr ; jid_t from , to ; char * rkey ; int rkeylen ; attr = nad_find_attr ( nad , 0 , - 1 , ""from"" , NULL ) ; if ( attr < 0 || ( from = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>from<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet"" ) ; nad_free ( nad ) ; return ; } attr = nad_find_attr ( nad , 0 , - 1 , ""to"" , NULL ) ; if ( attr < 0 || ( to = jid_new ( NAD_AVAL ( nad , attr ) , NAD_AVAL_L ( nad , attr ) ) ) == NULL ) { log_debug ( ZONE , ""missing<S2SV_blank>or<S2SV_blank>invalid<S2SV_blank>to<S2SV_blank>on<S2SV_blank>db<S2SV_blank>result<S2SV_blank>packet"" ) ; jid_free ( from ) ; nad_free ( nad ) ; return ; } rkey = s2s_route_key ( NULL , to -> domain , from -> domain ) ; rkeylen = strlen ( rkey ) ; <S2SV_StartBug> if ( nad_find_attr ( nad , 0 , - 1 , ""type"" , ""valid"" ) >= 0 ) { <S2SV_EndBug> log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>valid%s%s"" , out -> fd -> fd , out -> ip , out -> port , rkey , ( out -> s -> flags & SX_SSL_WRAPPER ) ? "",<S2SV_blank>TLS<S2SV_blank>negotiated"" : """" , out -> s -> compressed ? "",<S2SV_blank>ZLIB<S2SV_blank>compression<S2SV_blank>enabled"" : """" ) ; xhash_put ( out -> states , pstrdup ( xhash_pool ( out -> states ) , rkey ) , ( void * ) conn_VALID ) ; log_debug ( ZONE , ""%s<S2SV_blank>valid,<S2SV_blank>flushing<S2SV_blank>queue"" , rkey ) ; out_flush_route_queue ( out -> s2s , rkey , rkeylen ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; return ; } log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>outgoing<S2SV_blank>route<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>now<S2SV_blank>invalid"" , out -> fd -> fd , out -> ip , out -> port , rkey ) ; log_write ( out -> s2s -> log , LOG_NOTICE , ""[%d]<S2SV_blank>[%s,<S2SV_blank>port=%d]<S2SV_blank>closing<S2SV_blank>connection"" , out -> fd -> fd , out -> ip , out -> port ) ; sx_error ( out -> s , stream_err_INVALID_ID , ""dialback<S2SV_blank>negotiation<S2SV_blank>failed"" ) ; sx_close ( out -> s ) ; out_bounce_route_queue ( out -> s2s , rkey , rkeylen , stanza_err_SERVICE_UNAVAILABLE ) ; free ( rkey ) ; jid_free ( from ) ; jid_free ( to ) ; nad_free ( nad ) ; }
","<S2SV_ModStart> ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
",Jabberd2@jabberd2/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d,CVE-2012-3525,https://github.com/Jabberd2/jabberd2/commit/aabcffae560d5fd00cd1d2ffce5d760353cf0a4d,2012-08-25T16:55Z
CWE-200,"CWE-200 static int run_post_create ( const char * dirname ) { if ( ! dir_is_in_dump_location ( dirname ) ) { error_msg ( ""Bad<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>name<S2SV_blank>\'%s\',<S2SV_blank>should<S2SV_blank>start<S2SV_blank>with:<S2SV_blank>\'%s\'"" , dirname , g_settings_dump_location ) ; return 400 ; } <S2SV_StartBug> if ( ! dump_dir_accessible_by_uid ( dirname , client_uid ) ) <S2SV_EndBug> { if ( errno == ENOTDIR ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>problem<S2SV_blank>directory"" , dirname ) ; return 404 ; } error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>accessed<S2SV_blank>by<S2SV_blank>user<S2SV_blank>with<S2SV_blank>uid<S2SV_blank>%ld"" , dirname , ( long ) client_uid ) ; return 403 ; } int child_stdout_fd ; int child_pid = spawn_event_handler_child ( dirname , ""post-create"" , & child_stdout_fd ) ; char * dup_of_dir = NULL ; struct strbuf * cmd_output = strbuf_new ( ) ; bool child_is_post_create = 1 ; read_child_output : for ( ; ; ) { char buf [ 250 ] ; errno = 0 ; int r = safe_read ( child_stdout_fd , buf , sizeof ( buf ) - 1 ) ; if ( r <= 0 ) break ; buf [ r ] = '\\0' ; char * raw = buf ; char * newline ; while ( ( newline = strchr ( raw , '\\n' ) ) != NULL ) { * newline = '\\0' ; strbuf_append_str ( cmd_output , raw ) ; char * msg = cmd_output -> buf ; log ( ""%s"" , msg ) ; if ( child_is_post_create && prefixcmp ( msg , ""DUP_OF_DIR:<S2SV_blank>"" ) == 0 ) { free ( dup_of_dir ) ; dup_of_dir = xstrdup ( msg + strlen ( ""DUP_OF_DIR:<S2SV_blank>"" ) ) ; } strbuf_clear ( cmd_output ) ; raw = newline + 1 ; } strbuf_append_str ( cmd_output , raw ) ; } int status = 0 ; if ( safe_waitpid ( child_pid , & status , 0 ) <= 0 ) perror_msg ( ""waitpid(%d)"" , child_pid ) ; if ( ! child_is_post_create ) goto ret ; if ( status != 0 ) { if ( WIFSIGNALED ( status ) ) { log ( ""\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>signal<S2SV_blank>%d"" , dirname , WTERMSIG ( status ) ) ; goto delete_bad_dir ; } if ( ! dup_of_dir ) { log ( ""\'post-create\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>%d"" , dirname , WEXITSTATUS ( status ) ) ; goto delete_bad_dir ; } } const char * work_dir = ( dup_of_dir ? dup_of_dir : dirname ) ; struct dump_dir * dd = dd_opendir ( work_dir , 0 ) ; if ( ! dd ) goto delete_bad_dir ; char * count_str = dd_load_text_ext ( dd , FILENAME_COUNT , DD_FAIL_QUIETLY_ENOENT ) ; unsigned long count = strtoul ( count_str , NULL , 10 ) ; if ( ( status != 0 && dup_of_dir ) || count == 0 ) { count ++ ; char new_count_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( new_count_str , ""%lu"" , count ) ; dd_save_text ( dd , FILENAME_COUNT , new_count_str ) ; if ( strcmp ( dd -> dd_dirname , dirname ) != 0 ) { struct dump_dir * new_dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; char * last_ocr = NULL ; if ( new_dd ) { last_ocr = dd_load_text_ext ( new_dd , FILENAME_TIME , DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT ) ; dd_close ( new_dd ) ; } else { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>from<S2SV_blank>the<S2SV_blank>new<S2SV_blank>dump<S2SV_blank>directory."" ) ; } if ( ! last_ocr ) { log ( ""Using<S2SV_blank>current<S2SV_blank>time<S2SV_blank>for<S2SV_blank>the<S2SV_blank>last<S2SV_blank>occurrence<S2SV_blank>file<S2SV_blank>which<S2SV_blank>may<S2SV_blank>be<S2SV_blank>incorrect."" ) ; time_t t = time ( NULL ) ; last_ocr = xasprintf ( ""%lu"" , ( long ) t ) ; } dd_save_text ( dd , FILENAME_LAST_OCCURRENCE , last_ocr ) ; free ( last_ocr ) ; } } dd_sanitize_mode_and_owner ( dd ) ; dd_close ( dd ) ; if ( ! dup_of_dir ) log_notice ( ""New<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s,<S2SV_blank>processing"" , work_dir ) ; else { log_warning ( ""Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>(dup<S2SV_blank>of<S2SV_blank>%s)"" , strrchr ( dirname , '/' ) + 1 , strrchr ( dup_of_dir , '/' ) + 1 ) ; delete_dump_dir ( dirname ) ; } int fd ; child_pid = spawn_event_handler_child ( work_dir , ( dup_of_dir ? ""notify-dup"" : ""notify"" ) , & fd ) ; xmove_fd ( fd , child_stdout_fd ) ; child_is_post_create = 0 ; strbuf_clear ( cmd_output ) ; free ( dup_of_dir ) ; dup_of_dir = NULL ; goto read_child_output ; delete_bad_dir : log_warning ( ""Deleting<S2SV_blank>problem<S2SV_blank>directory<S2SV_blank>\'%s\'"" , dirname ) ; delete_dump_dir ( dirname ) ; ret : strbuf_free ( cmd_output ) ; free ( dup_of_dir ) ; close ( child_stdout_fd ) ; return 0 ; }
","<S2SV_ModStart> 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( ""Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory"" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( ""abrt"" ) ; if ( ! gr ) { error_msg ( ""Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access"" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( ""Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed"" , dirname ) ; return 403 ; } } else
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
CWE-119,"CWE-119 static int header_read ( SF_PRIVATE * psf , void * ptr , int bytes ) { int count = 0 ; <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> <S2SV_StartBug> return psf_fread ( ptr , 1 , bytes , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( psf -> headindex + bytes > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { int most ; most = SIGNED_SIZEOF ( psf -> header ) - psf -> headend ; psf_fread ( psf -> header + psf -> headend , 1 , most , psf ) ; memcpy ( ptr , psf -> header + psf -> headend , most ) ; psf -> headend = psf -> headindex += most ; psf_fread ( ( char * ) ptr + most , bytes - most , 1 , psf ) ; return bytes ; } ; <S2SV_StartBug> if ( psf -> headindex + bytes > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> { count = psf_fread ( psf -> header + psf -> headend , 1 , bytes - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> if ( count != bytes - ( int ) ( psf -> headend - psf -> headindex ) ) <S2SV_EndBug> { psf_log_printf ( psf , ""Error<S2SV_blank>:<S2SV_blank>psf_fread<S2SV_blank>returned<S2SV_blank>short<S2SV_blank>count.\\n"" ) ; return count ; } ; <S2SV_StartBug> psf -> headend += count ; <S2SV_EndBug> } ; <S2SV_StartBug> memcpy ( ptr , psf -> header + psf -> headindex , bytes ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex += bytes ; <S2SV_EndBug> return bytes ; }
","<S2SV_ModStart> ( psf -> header . indx + bytes >= <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . len && psf_bump_header_allocation ( psf , bytes <S2SV_ModStart> ) ) return count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + bytes > <S2SV_ModStart> > psf -> header . end <S2SV_ModEnd> ) { count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx <S2SV_ModEnd> ) , psf <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . indx <S2SV_ModEnd> , bytes ) <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += bytes ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-20,"CWE-20 static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-id:"" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>"" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\"""" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , ""\\"""" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , "">"" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
",the-tcpdump-group@tcpdump/3ed82f4ed0095768529afc22b923c8f7171fff70,CVE-2015-3138,https://github.com/the-tcpdump-group/tcpdump/commit/3ed82f4ed0095768529afc22b923c8f7171fff70,2017-09-28T01:29Z
CWE-269,"CWE-269 STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; { <S2SV_StartBug> while ( * cp ) { <S2SV_EndBug> int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) { <S2SV_StartBug> NEARDATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; <S2SV_EndBug> const char * dp ; <S2SV_StartBug> int dcount = 0 ; <S2SV_EndBug> <S2SV_StartBug> cp ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( * cp == 'x' || * cp == 'X' ) <S2SV_EndBug> <S2SV_StartBug> for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) <S2SV_EndBug> cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ; <S2SV_StartBug> else if ( * cp == 'o' || * cp == 'O' ) <S2SV_EndBug> for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; else for ( ; * cp && ( index ( ""0123456789"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 10 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; } <S2SV_StartBug> cp ++ ; <S2SV_EndBug> } else if ( * cp == '^' && cp [ 1 ] ) { cval = ( * ++ cp & 0x1f ) ; cp ++ ; } else cval = * cp ++ ; if ( meta ) cval |= 0x80 ; <S2SV_StartBug> * tp ++ = cval ; <S2SV_EndBug> } * tp = '\\0' ; }
","<S2SV_ModStart> tp ; { static <S2SV_ModEnd> NEARDATA const char <S2SV_ModStart> NEARDATA const char oct [ ] = ""01234567"" , dec [ ] = ""0123456789"" , <S2SV_ModStart> dp ; int cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> == 'x' || <S2SV_ModStart> == 'x' || cp [ 1 ] <S2SV_ModEnd> == 'X' ) <S2SV_ModStart> == 'X' ) && cp [ 2 ] <S2SV_ModEnd> && ( dp <S2SV_ModStart> ( hex , cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> cval = ( <S2SV_ModStart> 2 ) ; } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> { switch ( <S2SV_ModStart> cp ; } ++ cp ; } <S2SV_ModEnd> if ( meta <S2SV_ModStart> tp ++ = ( char )
",NetHack@NetHack/612755bfb5c412079795c68ba392df5d93874ed8,CVE-2020-5253,https://github.com/NetHack/NetHack/commit/612755bfb5c412079795c68ba392df5d93874ed8,2020-03-10T17:15Z
CWE-000,"CWE-000 static int ras_getdatastd ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap , jas_image_t * image ) { int pad ; int nz ; int z ; int c ; int y ; int x ; int v ; int i ; jas_matrix_t * data [ 3 ] ; cmap = 0 ; <S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } pad = RAS_ROWSIZE ( hdr ) - ( hdr -> width * hdr -> depth + 7 ) / 8 ; for ( y = 0 ; y < hdr -> height ; y ++ ) { nz = 0 ; z = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { while ( nz < hdr -> depth ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { return - 1 ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }
","<S2SV_ModStart> = 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( image <S2SV_ModStart> ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = <S2SV_ModStart> EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",mdadams@jasper/411a4068f8c464e883358bf403a3e25158863823,CVE-2016-9388,https://github.com/mdadams/jasper/commit/411a4068f8c464e883358bf403a3e25158863823,2017-03-23T18:59Z
CWE-000,"CWE-000 static int cacheDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks lifespan , clientLifespan , serverLifespan ; char * option , * ovalue , * tok ; char * methods , * extensions , * types , * uris ; int flags ; flags = 0 ; lifespan = clientLifespan = serverLifespan = 0 ; methods = uris = extensions = types = 0 ; for ( option = stok ( sclone ( value ) , ""<S2SV_blank>\\t"" , & tok ) ; option ; option = stok ( 0 , ""<S2SV_blank>\\t"" , & tok ) ) { if ( * option == '/' ) { uris = option ; if ( tok ) { tok [ - 1 ] = ',' ; } break ; } <S2SV_StartBug> option = stok ( option , ""<S2SV_blank>=\\t,"" , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( ( int ) isdigit ( ( uchar ) * option ) ) { lifespan = httpGetTicks ( option ) ; } else if ( smatch ( option , ""client"" ) ) { flags |= HTTP_CACHE_CLIENT ; if ( ovalue ) { clientLifespan = httpGetTicks ( ovalue ) ; } } else if ( smatch ( option , ""server"" ) ) { flags |= HTTP_CACHE_SERVER ; if ( ovalue ) { serverLifespan = httpGetTicks ( ovalue ) ; } } else if ( smatch ( option , ""extensions"" ) ) { extensions = ovalue ; } else if ( smatch ( option , ""types"" ) ) { types = ovalue ; } else if ( smatch ( option , ""unique"" ) ) { flags |= HTTP_CACHE_UNIQUE ; } else if ( smatch ( option , ""manual"" ) ) { flags |= HTTP_CACHE_MANUAL ; } else if ( smatch ( option , ""methods"" ) ) { methods = ovalue ; } else { mprLog ( ""error<S2SV_blank>appweb<S2SV_blank>config"" , 0 , ""Unknown<S2SV_blank>Cache<S2SV_blank>option<S2SV_blank>\'%s\'"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } if ( lifespan > 0 && ! uris && ! extensions && ! types && ! methods ) { state -> route -> lifespan = lifespan ; } else { httpAddCache ( state -> route , methods , uris , extensions , types , clientLifespan , serverLifespan , flags ) ; } return 0 ; }
","<S2SV_ModStart> } option = ssplit <S2SV_ModEnd> ( option ,
",embedthis@appweb/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,CVE-2014-9708,https://github.com/embedthis/appweb/commit/7e6a925f5e86a19a7934a94bbd6959101d0b84eb,2015-03-31T14:59Z
CWE-399,"CWE-399 static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; } <S2SV_StartBug> rc = fuse_dev_release ( inode , file ) ; <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;
",torvalds@linux/2c5816b4beccc8ba709144539f6fdd764f8fa49c,CVE-2015-1339,https://github.com/torvalds/linux/commit/2c5816b4beccc8ba709144539f6fdd764f8fa49c,2016-04-27T17:59Z
CWE-20,"CWE-20 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
","<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) { return 1 ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 int rds_ib_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { struct rds_ib_connection * ic = conn -> c_transport_data ; struct ib_device * dev = ic -> i_cm_id -> device ; struct rds_ib_send_work * send = NULL ; struct rds_ib_send_work * first ; struct rds_ib_send_work * prev ; struct ib_send_wr * failed_wr ; struct scatterlist * scat ; u32 pos ; u32 i ; u32 work_alloc ; u32 credit_alloc = 0 ; u32 posted ; u32 adv_credits = 0 ; int send_flags = 0 ; int bytes_sent = 0 ; int ret ; int flow_controlled = 0 ; int nr_sig = 0 ; BUG_ON ( off % RDS_FRAG_SIZE ) ; BUG_ON ( hdr_off != 0 && hdr_off != sizeof ( struct rds_header ) ) ; if ( conn -> c_loopback && rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; <S2SV_StartBug> return sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; <S2SV_EndBug> } if ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) == 0 ) i = 1 ; else i = ceil ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) , RDS_FRAG_SIZE ) ; work_alloc = rds_ib_ring_alloc ( & ic -> i_send_ring , i , & pos ) ; if ( work_alloc == 0 ) { set_bit ( RDS_LL_SEND_FULL , & conn -> c_flags ) ; rds_ib_stats_inc ( s_ib_tx_ring_full ) ; ret = - ENOMEM ; goto out ; } if ( ic -> i_flowctl ) { credit_alloc = rds_ib_send_grab_credits ( ic , work_alloc , & posted , 0 , RDS_MAX_ADV_CREDIT ) ; adv_credits += posted ; if ( credit_alloc < work_alloc ) { rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc - credit_alloc ) ; work_alloc = credit_alloc ; flow_controlled = 1 ; } if ( work_alloc == 0 ) { set_bit ( RDS_LL_SEND_FULL , & conn -> c_flags ) ; rds_ib_stats_inc ( s_ib_tx_throttle ) ; ret = - ENOMEM ; goto out ; } } if ( ! ic -> i_data_op ) { if ( rm -> data . op_nents ) { rm -> data . op_count = ib_dma_map_sg ( dev , rm -> data . op_sg , rm -> data . op_nents , DMA_TO_DEVICE ) ; rdsdebug ( ""ic<S2SV_blank>%p<S2SV_blank>mapping<S2SV_blank>rm<S2SV_blank>%p:<S2SV_blank>%d\\n"" , ic , rm , rm -> data . op_count ) ; if ( rm -> data . op_count == 0 ) { rds_ib_stats_inc ( s_ib_tx_sg_mapping_failure ) ; rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc ) ; ret = - ENOMEM ; goto out ; } } else { rm -> data . op_count = 0 ; } rds_message_addref ( rm ) ; ic -> i_data_op = & rm -> data ; if ( test_bit ( RDS_MSG_ACK_REQUIRED , & rm -> m_flags ) ) rm -> m_inc . i_hdr . h_flags |= RDS_FLAG_ACK_REQUIRED ; if ( test_bit ( RDS_MSG_RETRANSMITTED , & rm -> m_flags ) ) rm -> m_inc . i_hdr . h_flags |= RDS_FLAG_RETRANSMITTED ; if ( rm -> rdma . op_active ) { struct rds_ext_header_rdma ext_hdr ; ext_hdr . h_rdma_rkey = cpu_to_be32 ( rm -> rdma . op_rkey ) ; rds_message_add_extension ( & rm -> m_inc . i_hdr , RDS_EXTHDR_RDMA , & ext_hdr , sizeof ( ext_hdr ) ) ; } if ( rm -> m_rdma_cookie ) { rds_message_add_rdma_dest_extension ( & rm -> m_inc . i_hdr , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , rds_rdma_cookie_offset ( rm -> m_rdma_cookie ) ) ; } rm -> m_inc . i_hdr . h_ack = cpu_to_be64 ( rds_ib_piggyb_ack ( ic ) ) ; rds_message_make_checksum ( & rm -> m_inc . i_hdr ) ; if ( ic -> i_flowctl ) { rds_ib_send_grab_credits ( ic , 0 , & posted , 1 , RDS_MAX_ADV_CREDIT - adv_credits ) ; adv_credits += posted ; BUG_ON ( adv_credits > 255 ) ; } } if ( rm -> rdma . op_active && rm -> rdma . op_fence ) send_flags = IB_SEND_FENCE ; send = & ic -> i_sends [ pos ] ; first = send ; prev = NULL ; scat = & ic -> i_data_op -> op_sg [ sg ] ; i = 0 ; do { unsigned int len = 0 ; send -> s_wr . send_flags = send_flags ; send -> s_wr . opcode = IB_WR_SEND ; send -> s_wr . num_sge = 1 ; send -> s_wr . next = NULL ; send -> s_queued = jiffies ; send -> s_op = NULL ; send -> s_sge [ 0 ] . addr = ic -> i_send_hdrs_dma + ( pos * sizeof ( struct rds_header ) ) ; send -> s_sge [ 0 ] . length = sizeof ( struct rds_header ) ; memcpy ( & ic -> i_send_hdrs [ pos ] , & rm -> m_inc . i_hdr , sizeof ( struct rds_header ) ) ; if ( i < work_alloc && scat != & rm -> data . op_sg [ rm -> data . op_count ] ) { len = min ( RDS_FRAG_SIZE , ib_sg_dma_len ( dev , scat ) - off ) ; send -> s_wr . num_sge = 2 ; send -> s_sge [ 1 ] . addr = ib_sg_dma_address ( dev , scat ) + off ; send -> s_sge [ 1 ] . length = len ; bytes_sent += len ; off += len ; if ( off == ib_sg_dma_len ( dev , scat ) ) { scat ++ ; off = 0 ; } } rds_ib_set_wr_signal_state ( ic , send , 0 ) ; if ( ic -> i_flowctl && flow_controlled && i == ( work_alloc - 1 ) ) send -> s_wr . send_flags |= IB_SEND_SIGNALED | IB_SEND_SOLICITED ; if ( send -> s_wr . send_flags & IB_SEND_SIGNALED ) nr_sig ++ ; rdsdebug ( ""send<S2SV_blank>%p<S2SV_blank>wr<S2SV_blank>%p<S2SV_blank>num_sge<S2SV_blank>%u<S2SV_blank>next<S2SV_blank>%p\\n"" , send , & send -> s_wr , send -> s_wr . num_sge , send -> s_wr . next ) ; if ( ic -> i_flowctl && adv_credits ) { struct rds_header * hdr = & ic -> i_send_hdrs [ pos ] ; hdr -> h_credit = adv_credits ; rds_message_make_checksum ( hdr ) ; adv_credits = 0 ; rds_ib_stats_inc ( s_ib_tx_credit_updates ) ; } if ( prev ) prev -> s_wr . next = & send -> s_wr ; prev = send ; pos = ( pos + 1 ) % ic -> i_send_ring . w_nr ; send = & ic -> i_sends [ pos ] ; i ++ ; } while ( i < work_alloc && scat != & rm -> data . op_sg [ rm -> data . op_count ] ) ; if ( hdr_off == 0 ) bytes_sent += sizeof ( struct rds_header ) ; if ( scat == & rm -> data . op_sg [ rm -> data . op_count ] ) { prev -> s_op = ic -> i_data_op ; prev -> s_wr . send_flags |= IB_SEND_SOLICITED ; ic -> i_data_op = NULL ; } if ( i < work_alloc ) { rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc - i ) ; work_alloc = i ; } if ( ic -> i_flowctl && i < credit_alloc ) rds_ib_send_add_credits ( conn , credit_alloc - i ) ; if ( nr_sig ) atomic_add ( nr_sig , & ic -> i_signaled_sends ) ; failed_wr = & first -> s_wr ; ret = ib_post_send ( ic -> i_cm_id -> qp , & first -> s_wr , & failed_wr ) ; rdsdebug ( ""ic<S2SV_blank>%p<S2SV_blank>first<S2SV_blank>%p<S2SV_blank>(wr<S2SV_blank>%p)<S2SV_blank>ret<S2SV_blank>%d<S2SV_blank>wr<S2SV_blank>%p\\n"" , ic , first , & first -> s_wr , ret , failed_wr ) ; BUG_ON ( failed_wr != & first -> s_wr ) ; if ( ret ) { printk ( KERN_WARNING ""RDS/IB:<S2SV_blank>ib_post_send<S2SV_blank>to<S2SV_blank>%pI4<S2SV_blank>"" ""returned<S2SV_blank>%d\\n"" , & conn -> c_faddr , ret ) ; rds_ib_ring_unalloc ( & ic -> i_send_ring , work_alloc ) ; rds_ib_sub_signaled ( ic , nr_sig ) ; if ( prev -> s_op ) { ic -> i_data_op = prev -> s_op ; prev -> s_op = NULL ; } rds_ib_conn_error ( ic -> conn , ""ib_post_send<S2SV_blank>failed\\n"" ) ; goto out ; } ret = bytes_sent ; out : BUG_ON ( adv_credits ) ; return ret ; }
","<S2SV_ModStart> 0 ) ; scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ) + RDS_CONG_MAP_BYTES ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret
",torvalds@linux/6094628bfd94323fc1cea05ec2c6affd98c18f7f,CVE-2011-1023,https://github.com/torvalds/linux/commit/6094628bfd94323fc1cea05ec2c6affd98c18f7f,2012-06-21T23:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static int svc_log ( SvcContext * svc_ctx , int level , const char * fmt , ... ) { <S2SV_EndBug> char buf [ 512 ] ; int retval = 0 ; va_list ap ; <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( level > svc_ctx -> log_level ) { return retval ; } va_start ( ap , fmt ) ; retval = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ; va_end ( ap ) ; if ( svc_ctx -> log_print ) { printf ( ""%s"" , buf ) ; } else { strncat ( si -> message_buffer , buf , sizeof ( si -> message_buffer ) - strlen ( si -> message_buffer ) - 1 ) ; } if ( level == SVC_LOG_ERROR ) { si -> codec_ctx -> err_detail = si -> message_buffer ; } return retval ; }
","<S2SV_ModStart> * svc_ctx , SVC_LOG_LEVEL <S2SV_ModEnd> level , const <S2SV_ModStart> va_list ap ; SvcInternal_t <S2SV_ModEnd> * const si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }
","<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
",torvalds@linux/78c9c4dfbf8c04883941445a195276bb4bb92c76,CVE-2018-12896,https://github.com/torvalds/linux/commit/78c9c4dfbf8c04883941445a195276bb4bb92c76,2018-07-02T17:29Z
CWE-20,"CWE-20 static MagickBooleanType ConcatenateImages ( int argc , char * * argv , ExceptionInfo * exception ) { FILE * input , * output ; <S2SV_StartBug> int <S2SV_EndBug> c ; register ssize_t i ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) ThrowFileException ( exception , ResourceLimitError , ""MemoryAllocationFailed"" , GetExceptionMessage ( errno ) ) ; output = fopen_utf8 ( argv [ argc - 1 ] , ""wb"" ) ; if ( output == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ argc - 1 ] ) ; return ( MagickFalse ) ; } <S2SV_StartBug> for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { <S2SV_EndBug> # if 0 fprintf ( stderr , ""DEBUG:<S2SV_blank>Concatenate<S2SV_blank>Image:<S2SV_blank>\\""%s\\""\\n"" , argv [ i ] ) ; # endif input = fopen_utf8 ( argv [ i ] , ""rb"" ) ; if ( input == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ i ] ) ; continue ; } for ( c = fgetc ( input ) ; c != EOF ; c = fgetc ( input ) ) <S2SV_StartBug> ( void ) fputc ( ( char ) c , output ) ; <S2SV_EndBug> <S2SV_StartBug> ( void ) fclose ( input ) ; <S2SV_EndBug> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; <S2SV_StartBug> return ( MagickTrue ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * output ; MagickBooleanType status ; <S2SV_ModStart> ) ; } status = MagickTrue ; <S2SV_ModStart> i ++ ) { <S2SV_ModEnd> input = fopen_utf8 <S2SV_ModStart> input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> ( void ) fclose ( input <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> output ) ; <S2SV_ModStart> ; return ( status <S2SV_ModEnd> ) ; }
",ImageMagick@ImageMagick/933e96f01a8c889c7bf5ffd30020e86a02a046e7,CVE-2016-10060,https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7,2017-03-02T21:59Z
CWE-617,"CWE-617 static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> return NULL ;
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13223,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
CWE-476,"CWE-476 static int unimac_mdio_probe ( struct platform_device * pdev ) { struct unimac_mdio_pdata * pdata = pdev -> dev . platform_data ; struct unimac_mdio_priv * priv ; struct device_node * np ; struct mii_bus * bus ; struct resource * r ; int ret ; np = pdev -> dev . of_node ; priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; <S2SV_EndBug> if ( ! priv -> base ) { dev_err ( & pdev -> dev , ""failed<S2SV_blank>to<S2SV_blank>remap<S2SV_blank>register\\n"" ) ; return - ENOMEM ; } priv -> mii_bus = mdiobus_alloc ( ) ; if ( ! priv -> mii_bus ) return - ENOMEM ; bus = priv -> mii_bus ; bus -> priv = priv ; if ( pdata ) { bus -> name = pdata -> bus_name ; priv -> wait_func = pdata -> wait_func ; priv -> wait_func_data = pdata -> wait_func_data ; bus -> phy_mask = ~ pdata -> phy_mask ; } else { bus -> name = ""unimac<S2SV_blank>MII<S2SV_blank>bus"" ; priv -> wait_func_data = priv ; priv -> wait_func = unimac_mdio_poll ; } bus -> parent = & pdev -> dev ; bus -> read = unimac_mdio_read ; bus -> write = unimac_mdio_write ; bus -> reset = unimac_mdio_reset ; snprintf ( bus -> id , MII_BUS_ID_SIZE , ""%s-%d"" , pdev -> name , pdev -> id ) ; ret = of_mdiobus_register ( bus , np ) ; if ( ret ) { dev_err ( & pdev -> dev , ""MDIO<S2SV_blank>bus<S2SV_blank>registration<S2SV_blank>failed\\n"" ) ; goto out_mdio_free ; } platform_set_drvdata ( pdev , priv ) ; dev_info ( & pdev -> dev , ""Broadcom<S2SV_blank>UniMAC<S2SV_blank>MDIO<S2SV_blank>bus<S2SV_blank>at<S2SV_blank>0x%p\\n"" , priv -> base ) ; return 0 ; out_mdio_free : mdiobus_free ( bus ) ; return ret ; }
","<S2SV_ModStart> 0 ) ; if ( ! r ) return - EINVAL ;
",torvalds@linux/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,CVE-2018-8043,https://github.com/torvalds/linux/commit/297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5,2018-03-10T22:29Z
CWE-284,"CWE-284 static void uipc_flush_ch_locked ( tUIPC_CH_ID ch_id ) { char buf [ UIPC_FLUSH_BUFFER_SIZE ] ; struct pollfd pfd ; int ret ; pfd . events = POLLIN ; pfd . fd = uipc_main . ch [ ch_id ] . fd ; if ( uipc_main . ch [ ch_id ] . fd == UIPC_DISCONNECTED ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>fd<S2SV_blank>disconnected.<S2SV_blank>Exiting"" , __FUNCTION__ ) ; return ; } while ( 1 ) { <S2SV_StartBug> ret = poll ( & pfd , 1 , 1 ) ; <S2SV_EndBug> BTIF_TRACE_VERBOSE ( ""%s()<S2SV_blank>-<S2SV_blank>polling<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>revents:<S2SV_blank>0x%x,<S2SV_blank>ret<S2SV_blank>%d"" , __FUNCTION__ , pfd . fd , pfd . revents , ret ) ; if ( pfd . revents & ( POLLERR | POLLHUP ) ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>POLLERR<S2SV_blank>or<S2SV_blank>POLLHUP.<S2SV_blank>Exiting"" , __FUNCTION__ ) ; return ; } if ( ret <= 0 ) { BTIF_TRACE_EVENT ( ""%s()<S2SV_blank>-<S2SV_blank>error<S2SV_blank>(%d).<S2SV_blank>Exiting"" , __FUNCTION__ , ret ) ; return ; } <S2SV_StartBug> read ( pfd . fd , & buf , UIPC_FLUSH_BUFFER_SIZE ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 1 ) <S2SV_ModStart> return ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , UIPC_FLUSH_BUFFER_SIZE ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-190,"CWE-190 jas_seq2d_t * jas_seq2d_copy ( jas_seq2d_t * x ) { jas_matrix_t * y ; <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; y = jas_seq2d_create ( jas_seq2d_xstart ( x ) , jas_seq2d_ystart ( x ) , jas_seq2d_xend ( x ) , jas_seq2d_yend ( x ) ) ; assert ( y ) ; for ( i = 0 ; i < x -> numrows_ ; ++ i ) { for ( j = 0 ; j < x -> numcols_ ; ++ j ) { * jas_matrix_getref ( y , i , j ) = jas_matrix_get ( x , i , j ) ; } } return y ; }
","<S2SV_ModStart> * y ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; y
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_write_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Write ( s , fields -> Buffer , fields -> Len ) ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
CWE-119,"CWE-119 static int picolcd_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * raw_data , int size ) { struct picolcd_data * data = hid_get_drvdata ( hdev ) ; unsigned long flags ; int ret = 0 ; if ( ! data ) return 1 ; <S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; } else if ( report -> id == REPORT_IR_DATA ) { ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; } else { spin_lock_irqsave ( & data -> lock , flags ) ; if ( data -> pending ) { memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; data -> pending -> raw_size = size - 1 ; data -> pending -> in_report = report ; complete ( & data -> pending -> ready ) ; } spin_unlock_irqrestore ( & data -> lock , flags ) ; } picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; return 1 ; }
","<S2SV_ModStart> ; if ( size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if (
",torvalds@linux/844817e47eef14141cf59b8d5ac08dd11c0a9189,CVE-2014-3186,https://github.com/torvalds/linux/commit/844817e47eef14141cf59b8d5ac08dd11c0a9189,2014-09-28T10:55Z
CWE-125,"CWE-125 PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; <S2SV_StartBug> PIX * pixc , * pixm , * pixg , * pixd ; <S2SV_EndBug> PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixs<S2SV_blank>undefined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>32<S2SV_blank>bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalid<S2SV_blank>level"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; <S2SV_StartBug> if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) <S2SV_EndBug> <S2SV_StartBug> return ( PIX * ) ERROR_PTR ( ""too<S2SV_blank>many<S2SV_blank>colors"" , procName , NULL ) ; <S2SV_EndBug> cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] = - 1 ; for ( i = 0 , index = 0 ; i < ncolors ; i ++ ) { pixcmapGetColor ( cmap , i , & rval , & gval , & bval ) ; minval = L_MIN ( rval , gval ) ; minval = L_MIN ( minval , bval ) ; if ( minval > lightthresh ) continue ; maxval = L_MAX ( rval , gval ) ; maxval = L_MAX ( maxval , bval ) ; if ( maxval < darkthresh ) continue ; if ( maxval - minval >= diffthresh ) { pixcmapAddColor ( cmapd , rval , gval , bval ) ; lut [ i ] = index ; index ++ ; } } pixGetDimensions ( pixs , & w , & h , NULL ) ; pixd = pixCreate ( w , h , 8 ) ; pixSetColormap ( pixd , cmapd ) ; pixm = pixCreate ( w , h , 1 ) ; datac = pixGetData ( pixc ) ; datam = pixGetData ( pixm ) ; datad = pixGetData ( pixd ) ; wplc = pixGetWpl ( pixc ) ; wplm = pixGetWpl ( pixm ) ; wpld = pixGetWpl ( pixd ) ; for ( i = 0 ; i < h ; i ++ ) { linec = datac + i * wplc ; linem = datam + i * wplm ; lined = datad + i * wpld ; for ( j = 0 ; j < w ; j ++ ) { val = GET_DATA_BYTE ( linec , j ) ; if ( lut [ val ] == - 1 ) SET_DATA_BIT ( linem , j ) ; else SET_DATA_BYTE ( lined , j , lut [ val ] ) ; } } pixg = pixConvertTo8 ( pixs , 0 ) ; pixGrayQuantFromHisto ( pixd , pixg , pixm , minfract , maxspan ) ; LEPT_FREE ( lut ) ; pixDestroy ( & pixc ) ; pixDestroy ( & pixm ) ; pixDestroy ( & pixg ) ; return pixd ; }
","<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1
",DanBloomberg@leptonica/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,CVE-2020-36281,https://github.com/DanBloomberg/leptonica/commit/5ee24b398bb67666f6d173763eaaedd9c36fb1e5,2021-03-12T01:15Z
CWE-119,"CWE-119 void vp8_second_pass ( VP8_COMP * cpi ) { int tmp_q ; int frames_left = ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ; FIRSTPASS_STATS this_frame = { 0 } ; FIRSTPASS_STATS this_frame_copy ; double this_frame_intra_error ; double this_frame_coded_error ; int overhead_bits ; if ( ! cpi -> twopass . stats_in ) { return ; } vp8_clear_system_state ( ) ; if ( EOF == input_stats ( cpi , & this_frame ) ) return ; this_frame_intra_error = this_frame . intra_error ; this_frame_coded_error = this_frame . coded_error ; if ( cpi -> twopass . frames_to_key == 0 ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> find_next_key_frame ( cpi , & this_frame_copy ) ; if ( cpi -> oxcf . error_resilient_mode ) { cpi -> twopass . gf_group_bits = cpi -> twopass . kf_group_bits ; cpi -> twopass . gf_group_error_left = ( int ) cpi -> twopass . kf_group_error_left ; cpi -> baseline_gf_interval = cpi -> twopass . frames_to_key ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; cpi -> source_alt_ref_pending = 0 ; } } if ( cpi -> frames_till_gf_update_due == 0 ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> define_gf_group ( cpi , & this_frame_copy ) ; if ( cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) { int bak = cpi -> per_frame_bandwidth ; <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; cpi -> per_frame_bandwidth = bak ; } } else { if ( cpi -> oxcf . error_resilient_mode ) { cpi -> frames_till_gf_update_due = cpi -> twopass . frames_to_key ; if ( cpi -> common . frame_type != KEY_FRAME ) { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; } } else { <S2SV_StartBug> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; <S2SV_EndBug> assign_std_frame_bits ( cpi , & this_frame_copy ) ; } } cpi -> twopass . this_iiratio = ( unsigned int ) ( this_frame_intra_error / DOUBLE_DIVIDE_CHECK ( this_frame_coded_error ) ) ; { FIRSTPASS_STATS next_frame ; if ( lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) { cpi -> twopass . next_iiratio = ( unsigned int ) ( next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; } } cpi -> target_bandwidth = ( int ) ( cpi -> per_frame_bandwidth * cpi -> output_framerate ) ; if ( cpi -> target_bandwidth < 0 ) cpi -> target_bandwidth = 0 ; overhead_bits = ( int ) estimate_modemvcost ( cpi , & cpi -> twopass . total_left_stats ) ; if ( cpi -> common . current_video_frame == 0 ) { cpi -> twopass . est_max_qcorrection_factor = 1.0 ; if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { int est_cq ; est_cq = estimate_cq ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; cpi -> cq_target_quality = cpi -> oxcf . cq_level ; if ( est_cq > cpi -> cq_target_quality ) cpi -> cq_target_quality = est_cq ; } cpi -> twopass . maxq_max_limit = cpi -> worst_quality ; cpi -> twopass . maxq_min_limit = cpi -> best_quality ; tmp_q = estimate_max_q ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; cpi -> twopass . maxq_max_limit = ( ( tmp_q + 32 ) < cpi -> worst_quality ) ? ( tmp_q + 32 ) : cpi -> worst_quality ; cpi -> twopass . maxq_min_limit = ( ( tmp_q - 32 ) > cpi -> best_quality ) ? ( tmp_q - 32 ) : cpi -> best_quality ; cpi -> active_worst_quality = tmp_q ; cpi -> ni_av_qi = tmp_q ; } else if ( ( cpi -> common . current_video_frame < ( ( ( unsigned int ) cpi -> twopass . total_stats . count * 255 ) >> 8 ) ) && ( ( cpi -> common . current_video_frame + cpi -> baseline_gf_interval ) < ( unsigned int ) cpi -> twopass . total_stats . count ) ) { if ( frames_left < 1 ) frames_left = 1 ; tmp_q = estimate_max_q ( cpi , & cpi -> twopass . total_left_stats , ( int ) ( cpi -> twopass . bits_left / frames_left ) , overhead_bits ) ; if ( tmp_q > cpi -> active_worst_quality ) cpi -> active_worst_quality ++ ; else if ( tmp_q < cpi -> active_worst_quality ) cpi -> active_worst_quality -- ; cpi -> active_worst_quality = ( ( cpi -> active_worst_quality * 3 ) + tmp_q + 2 ) / 4 ; } cpi -> twopass . frames_to_key -- ; subtract_stats ( & cpi -> twopass . total_left_stats , & this_frame ) ; }
","<S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & this_frame_copy <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & this_frame_copy <S2SV_ModStart> -> per_frame_bandwidth ; memcpy <S2SV_ModEnd> ( & this_frame_copy <S2SV_ModStart> KEY_FRAME ) { memcpy <S2SV_ModEnd> ( & this_frame_copy <S2SV_ModStart> } else { memcpy <S2SV_ModEnd> ( & this_frame_copy
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static BOOL update_read_icon_info ( wStream * s , ICON_INFO * iconInfo ) { BYTE * newBitMask ; if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ; Stream_Read_UINT16 ( s , iconInfo -> cacheEntry ) ; Stream_Read_UINT8 ( s , iconInfo -> cacheId ) ; Stream_Read_UINT8 ( s , iconInfo -> bpp ) ; if ( ( iconInfo -> bpp < 1 ) || ( iconInfo -> bpp > 32 ) ) { WLog_ERR ( TAG , ""invalid<S2SV_blank>bpp<S2SV_blank>value<S2SV_blank>%"" PRIu32 """" , iconInfo -> bpp ) ; return FALSE ; } Stream_Read_UINT16 ( s , iconInfo -> width ) ; Stream_Read_UINT16 ( s , iconInfo -> height ) ; switch ( iconInfo -> bpp ) { case 1 : case 4 : case 8 : if ( Stream_GetRemainingLength ( s ) < 2 ) return FALSE ; Stream_Read_UINT16 ( s , iconInfo -> cbColorTable ) ; break ; default : iconInfo -> cbColorTable = 0 ; break ; } if ( Stream_GetRemainingLength ( s ) < 4 ) return FALSE ; Stream_Read_UINT16 ( s , iconInfo -> cbBitsMask ) ; Stream_Read_UINT16 ( s , iconInfo -> cbBitsColor ) ; <S2SV_StartBug> if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsMask + iconInfo -> cbBitsColor ) <S2SV_EndBug> return FALSE ; newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( ! newBitMask ) { free ( iconInfo -> bitsMask ) ; iconInfo -> bitsMask = NULL ; return FALSE ; } iconInfo -> bitsMask = newBitMask ; Stream_Read ( s , iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( iconInfo -> colorTable == NULL ) { if ( iconInfo -> cbColorTable ) { iconInfo -> colorTable = ( BYTE * ) malloc ( iconInfo -> cbColorTable ) ; if ( ! iconInfo -> colorTable ) return FALSE ; } } else if ( iconInfo -> cbColorTable ) { BYTE * new_tab ; new_tab = ( BYTE * ) realloc ( iconInfo -> colorTable , iconInfo -> cbColorTable ) ; if ( ! new_tab ) { free ( iconInfo -> colorTable ) ; iconInfo -> colorTable = NULL ; return FALSE ; } iconInfo -> colorTable = new_tab ; } else { free ( iconInfo -> colorTable ) ; iconInfo -> colorTable = NULL ; } if ( iconInfo -> colorTable ) <S2SV_StartBug> Stream_Read ( s , iconInfo -> colorTable , iconInfo -> cbColorTable ) ; <S2SV_EndBug> <S2SV_StartBug> newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> if ( ! newBitMask ) { free ( iconInfo -> bitsColor ) ; iconInfo -> bitsColor = NULL ; return FALSE ; } iconInfo -> bitsColor = newBitMask ; <S2SV_StartBug> Stream_Read ( s , iconInfo -> bitsColor , iconInfo -> cbBitsColor ) ; <S2SV_EndBug> return TRUE ; }
","<S2SV_ModStart> cbBitsColor ) ; newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( ! newBitMask ) { free ( iconInfo -> bitsMask ) ; iconInfo -> bitsMask = NULL ; return FALSE ; } iconInfo -> bitsMask = newBitMask ; <S2SV_ModStart> iconInfo -> cbBitsMask ) return FALSE <S2SV_ModEnd> ; Stream_Read ( <S2SV_ModStart> -> colorTable ) { if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ; <S2SV_ModStart> cbColorTable ) ; } <S2SV_ModStart> = newBitMask ; if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ;
",FreeRDP@FreeRDP/6b2bc41935e53b0034fe5948aeeab4f32e80f30f,CVE-2020-11042,https://github.com/FreeRDP/FreeRDP/commit/6b2bc41935e53b0034fe5948aeeab4f32e80f30f,2020-05-07T19:15Z
CWE-125,"CWE-125 static u_int ieee802_11_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int orig_caplen , int pad , u_int fcslen ) { uint16_t fc ; u_int caplen , hdrlen , meshdrlen ; struct lladdr_info src , dst ; int llc_hdrlen ; caplen = orig_caplen ; if ( length < fcslen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return caplen ; } length -= fcslen ; if ( caplen > length ) { fcslen = caplen - length ; caplen -= fcslen ; ndo -> ndo_snapend -= fcslen ; } if ( caplen < IEEE802_11_FC_LEN ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return orig_caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( ndo , fc ) ; if ( hdrlen == 0 ) { return ( 0 ) ; } if ( pad ) hdrlen = roundup2 ( hdrlen , 4 ) ; if ( ndo -> ndo_Hflag && FC_TYPE ( fc ) == T_DATA && DATA_FRAME_IS_QOS ( FC_SUBTYPE ( fc ) ) ) { <S2SV_StartBug> meshdrlen = extract_mesh_header_length ( p + hdrlen ) ; <S2SV_EndBug> hdrlen += meshdrlen ; } else meshdrlen = 0 ; if ( caplen < hdrlen ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } if ( ndo -> ndo_eflag ) ieee_802_11_hdr_print ( ndo , fc , p , hdrlen , meshdrlen ) ; length -= hdrlen ; caplen -= hdrlen ; p += hdrlen ; src . addr_string = etheraddr_string ; dst . addr_string = etheraddr_string ; switch ( FC_TYPE ( fc ) ) { case T_MGMT : get_mgmt_src_dst_mac ( p - hdrlen , & src . addr , & dst . addr ) ; if ( ! mgmt_body_print ( ndo , fc , src . addr , p , length ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_CTRL : if ( ! ctrl_body_print ( ndo , fc , p - hdrlen ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } break ; case T_DATA : if ( DATA_FRAME_IS_NULL ( FC_SUBTYPE ( fc ) ) ) return hdrlen ; if ( FC_PROTECTED ( fc ) ) { ND_PRINT ( ( ndo , ""Data"" ) ) ; if ( ! wep_print ( ndo , p ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; } } else { get_data_src_dst_mac ( fc , p - hdrlen , & src . addr , & dst . addr ) ; llc_hdrlen = llc_print ( ndo , p , length , caplen , & src , & dst ) ; if ( llc_hdrlen < 0 ) { if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; llc_hdrlen = - llc_hdrlen ; } hdrlen += llc_hdrlen ; } break ; default : break ; } return hdrlen ; }
","<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return hdrlen ; }
",the-tcpdump-group@tcpdump/4846b3c5d0a850e860baf4f07340495d29837d09,CVE-2018-16227,https://github.com/the-tcpdump-group/tcpdump/commit/4846b3c5d0a850e860baf4f07340495d29837d09,2019-10-03T16:15Z
CWE-399,"CWE-399 int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else { <S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> top = p -> top ; BN_ULONG * udp , * bdp , * vdp , * cdp ; bn_wexpand ( u , top ) ; udp = u -> d ; for ( i = u -> top ; i < top ; i ++ ) udp [ i ] = 0 ; u -> top = top ; bn_wexpand ( b , top ) ; bdp = b -> d ; bdp [ 0 ] = 1 ; for ( i = 1 ; i < top ; i ++ ) bdp [ i ] = 0 ; b -> top = top ; bn_wexpand ( c , top ) ; cdp = c -> d ; for ( i = 0 ; i < top ; i ++ ) cdp [ i ] = 0 ; c -> top = top ; vdp = v -> d ; while ( 1 ) { while ( ubits && ! ( udp [ 0 ] & 1 ) ) { BN_ULONG u0 , u1 , b0 , b1 , mask ; u0 = udp [ 0 ] ; b0 = bdp [ 0 ] ; mask = ( BN_ULONG ) 0 - ( b0 & 1 ) ; b0 ^= p -> d [ 0 ] & mask ; for ( i = 0 ; i < top - 1 ; i ++ ) { u1 = udp [ i + 1 ] ; udp [ i ] = ( ( u0 >> 1 ) | ( u1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; u0 = u1 ; b1 = bdp [ i + 1 ] ^ ( p -> d [ i + 1 ] & mask ) ; bdp [ i ] = ( ( b0 >> 1 ) | ( b1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; b0 = b1 ; } udp [ i ] = u0 >> 1 ; bdp [ i ] = b0 >> 1 ; ubits -- ; } <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> if ( ubits < vbits ) { i = ubits ; ubits = vbits ; vbits = i ; tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; udp = vdp ; vdp = v -> d ; bdp = cdp ; cdp = c -> d ; } for ( i = 0 ; i < top ; i ++ ) { udp [ i ] ^= vdp [ i ] ; bdp [ i ] ^= cdp [ i ] ; } if ( ubits == vbits ) { BN_ULONG ul ; int utop = ( ubits - 1 ) / BN_BITS2 ; while ( ( ul = udp [ utop ] ) == 0 && utop ) utop -- ; ubits = utop * BN_BITS2 + BN_num_bits_word ( ul ) ; } } bn_correct_top ( b ) ; } # endif if ( ! BN_copy ( r , b ) ) goto err ; bn_check_top ( r ) ; ret = 1 ; err : # ifdef BN_DEBUG bn_correct_top ( c ) ; bn_correct_top ( u ) ; bn_correct_top ( v ) ; # endif BN_CTX_end ( ctx ) ; return ret ; }
","<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
",openssl@openssl/4924b37ee01f71ae19c94a8934b80eeb2f677932,CVE-2015-1788,https://github.com/openssl/openssl/commit/4924b37ee01f71ae19c94a8934b80eeb2f677932,2015-06-12T19:59Z
CWE-476,"CWE-476 static int crypto_skcipher_init_tfm ( struct crypto_tfm * tfm ) { struct crypto_skcipher * skcipher = __crypto_skcipher_cast ( tfm ) ; struct skcipher_alg * alg = crypto_skcipher_alg ( skcipher ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_blkcipher_type ) return crypto_init_skcipher_ops_blkcipher ( tfm ) ; if ( tfm -> __crt_alg -> cra_type == & crypto_ablkcipher_type || tfm -> __crt_alg -> cra_type == & crypto_givcipher_type ) return crypto_init_skcipher_ops_ablkcipher ( tfm ) ; <S2SV_StartBug> skcipher -> setkey = alg -> setkey ; <S2SV_EndBug> skcipher -> encrypt = alg -> encrypt ; skcipher -> decrypt = alg -> decrypt ; skcipher -> ivsize = alg -> ivsize ; skcipher -> keysize = alg -> max_keysize ; if ( alg -> exit ) skcipher -> base . exit = crypto_skcipher_exit_tfm ; if ( alg -> init ) return alg -> init ( skcipher ) ; return 0 ; }
","<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
",torvalds@linux/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,CVE-2017-9211,https://github.com/torvalds/linux/commit/9933e113c2e87a9f46a40fde8dafbf801dca1ab9,2017-05-23T05:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_fwht4x4_c ( const int16_t * input , int16_t * output , int stride ) { <S2SV_EndBug> int i ; <S2SV_StartBug> int a1 , b1 , c1 , d1 , e1 ; <S2SV_EndBug> <S2SV_StartBug> const int16_t * ip = input ; <S2SV_EndBug> <S2SV_StartBug> int16_t * op = output ; <S2SV_EndBug> for ( i = 0 ; i < 4 ; i ++ ) { <S2SV_StartBug> a1 = ip [ 0 * stride ] ; <S2SV_EndBug> b1 = ip [ 1 * stride ] ; c1 = ip [ 2 * stride ] ; <S2SV_StartBug> d1 = ip [ 3 * stride ] ; <S2SV_EndBug> a1 += b1 ; d1 = d1 - c1 ; e1 = ( a1 - d1 ) >> 1 ; b1 = e1 - b1 ; c1 = e1 - c1 ; a1 -= c1 ; d1 += b1 ; <S2SV_StartBug> op [ 0 ] = a1 ; <S2SV_EndBug> op [ 4 ] = c1 ; <S2SV_StartBug> op [ 8 ] = d1 ; <S2SV_EndBug> <S2SV_StartBug> op [ 12 ] = b1 ; <S2SV_EndBug> ip ++ ; op ++ ; } ip = output ; op = output ; for ( i = 0 ; i < 4 ; i ++ ) { a1 = ip [ 0 ] ; b1 = ip [ 1 ] ; c1 = ip [ 2 ] ; d1 = ip [ 3 ] ; a1 += b1 ; d1 -= c1 ; e1 = ( a1 - d1 ) >> 1 ; b1 = e1 - b1 ; c1 = e1 - c1 ; a1 -= c1 ; d1 += b1 ; <S2SV_StartBug> op [ 0 ] = a1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 1 ] = c1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 2 ] = d1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> <S2SV_StartBug> op [ 3 ] = b1 * UNIT_QUANT_FACTOR ; <S2SV_EndBug> ip += 4 ; op += 4 ; } }
","<S2SV_ModStart> * input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> int i ; tran_high_t <S2SV_ModEnd> a1 , b1 <S2SV_ModStart> const int16_t * ip_pass0 <S2SV_ModEnd> = input ; <S2SV_ModStart> = input ; const tran_low_t * ip = NULL ; tran_low_t <S2SV_ModEnd> * op = <S2SV_ModStart> { a1 = ip_pass0 [ 0 * stride ] ; b1 = ip_pass0 [ 1 * stride ] ; c1 = ip_pass0 <S2SV_ModEnd> [ 2 * <S2SV_ModStart> ; d1 = ip_pass0 <S2SV_ModEnd> [ 3 * <S2SV_ModStart> 0 ] = ( tran_low_t ) a1 ; op [ 4 ] = ( tran_low_t ) <S2SV_ModEnd> c1 ; op <S2SV_ModStart> 8 ] = ( tran_low_t ) <S2SV_ModStart> 12 ] = ( tran_low_t ) b1 ; ip_pass0 <S2SV_ModEnd> ++ ; op <S2SV_ModStart> 0 ] = ( tran_low_t ) ( <S2SV_ModStart> a1 * UNIT_QUANT_FACTOR ) ; op [ 1 ] = ( tran_low_t ) ( <S2SV_ModEnd> c1 * UNIT_QUANT_FACTOR <S2SV_ModStart> c1 * UNIT_QUANT_FACTOR ) <S2SV_ModStart> 2 ] = ( tran_low_t ) ( <S2SV_ModStart> d1 * UNIT_QUANT_FACTOR ) <S2SV_ModStart> 3 ] = ( tran_low_t ) ( <S2SV_ModStart> b1 * UNIT_QUANT_FACTOR )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static int dn_create ( struct net * net , struct socket * sock , int protocol , int kern ) { <S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_SEQPACKET : if ( protocol != DNPROTO_NSP ) return - EPROTONOSUPPORT ; break ; case SOCK_STREAM : break ; default : return - ESOCKTNOSUPPORT ; } if ( ( sk = dn_alloc_sock ( net , sock , GFP_KERNEL , kern ) ) == NULL ) return - ENOBUFS ; sk -> sk_protocol = protocol ; return 0 ; }
","<S2SV_ModStart> sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
",torvalds@linux/79462ad02e861803b3840cc782248c7359451cd9,CVE-2015-8543,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,2015-12-28T11:59Z
CWE-119,"CWE-119 static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) { if ( f -> segments [ 0 ] == 64 && getn ( f , header , 6 ) && header [ 0 ] == 'f' && header [ 1 ] == 'i' && header [ 2 ] == 's' && header [ 3 ] == 'h' && header [ 4 ] == 'e' && header [ 5 ] == 'a' && get8 ( f ) == 'd' && get8 ( f ) == '\\0' ) return error ( f , VORBIS_ogg_skeleton_not_supported ) ; else return error ( f , VORBIS_invalid_first_page ) ; } if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; <S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> channel_buffers [ i ] , 0 , sizeof ( float ) * f -> blocksize_1 ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; int n_read = limit_r_end - limit_r_begin ; int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }
","<S2SV_ModStart> ; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> 1 ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> -> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } else <S2SV_ModStart> g -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ) + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )
",nothings@stb/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,CVE-2019-13217,https://github.com/nothings/stb/commit/98fdfc6df88b1e34a736d5e126e6c8139c8de1a6,2019-08-15T17:15Z
CWE-834,"CWE-834 static int cine_read_header ( AVFormatContext * avctx ) { AVIOContext * pb = avctx -> pb ; AVStream * st ; unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; int vflip ; char * description ; uint64_t i ; st = avformat_new_stream ( avctx , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; st -> codecpar -> codec_tag = 0 ; avio_skip ( pb , 4 ) ; compression = avio_rl16 ( pb ) ; version = avio_rl16 ( pb ) ; if ( version != 1 ) { avpriv_request_sample ( avctx , ""unknown<S2SV_blank>version<S2SV_blank>%i"" , version ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 12 ) ; st -> duration = avio_rl32 ( pb ) ; offImageHeader = avio_rl32 ( pb ) ; offSetup = avio_rl32 ( pb ) ; offImageOffsets = avio_rl32 ( pb ) ; avio_skip ( pb , 8 ) ; avio_seek ( pb , offImageHeader , SEEK_SET ) ; avio_skip ( pb , 4 ) ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; if ( avio_rl16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; biBitCount = avio_rl16 ( pb ) ; if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } switch ( avio_rl32 ( pb ) ) { case BMP_RGB : vflip = 0 ; break ; case 0x100 : st -> codecpar -> codec_tag = MKTAG ( 'B' , 'I' , 'T' , 0 ) ; vflip = 1 ; break ; default : avpriv_request_sample ( avctx , ""unknown<S2SV_blank>bitmap<S2SV_blank>compression"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 4 ) ; avio_seek ( pb , offSetup , SEEK_SET ) ; avio_skip ( pb , 140 ) ; if ( avio_rl16 ( pb ) != 0x5453 ) return AVERROR_INVALIDDATA ; length = avio_rl16 ( pb ) ; if ( length < 0x163C ) { avpriv_request_sample ( avctx , ""short<S2SV_blank>SETUP<S2SV_blank>header"" ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 616 ) ; if ( ! avio_rl32 ( pb ) ^ vflip ) { st -> codecpar -> extradata = av_strdup ( ""BottomUp"" ) ; st -> codecpar -> extradata_size = 9 ; } avio_skip ( pb , 4 ) ; avpriv_set_pts_info ( st , 64 , 1 , avio_rl32 ( pb ) ) ; avio_skip ( pb , 20 ) ; set_metadata_int ( & st -> metadata , ""camera_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""firmware_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""software_version"" , avio_rl32 ( pb ) , 0 ) ; set_metadata_int ( & st -> metadata , ""recording_timezone"" , avio_rl32 ( pb ) , 0 ) ; CFA = avio_rl32 ( pb ) ; set_metadata_int ( & st -> metadata , ""brightness"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""contrast"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""gamma"" , avio_rl32 ( pb ) , 1 ) ; avio_skip ( pb , 12 + 16 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].r"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; set_metadata_float ( & st -> metadata , ""wbgain[0].b"" , av_int2float ( avio_rl32 ( pb ) ) , 1 ) ; avio_skip ( pb , 36 ) ; st -> codecpar -> bits_per_coded_sample = avio_rl32 ( pb ) ; if ( compression == CC_RGB ) { if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_GRAY16LE ; } else if ( biBitCount == 24 ) { st -> codecpar -> format = AV_PIX_FMT_BGR24 ; } else if ( biBitCount == 48 ) { st -> codecpar -> format = AV_PIX_FMT_BGR48LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } } else if ( compression == CC_UNINT ) { switch ( CFA & 0xFFFFFF ) { case CFA_BAYER : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_GBRG16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; case CFA_BAYERFLIP : if ( biBitCount == 8 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB8 ; } else if ( biBitCount == 16 ) { st -> codecpar -> format = AV_PIX_FMT_BAYER_RGGB16LE ; } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>biBitCount<S2SV_blank>%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } break ; default : avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>Color<S2SV_blank>Field<S2SV_blank>Array<S2SV_blank>(CFA)<S2SV_blank>%i"" , CFA & 0xFFFFFF ) ; return AVERROR_INVALIDDATA ; } } else { avpriv_request_sample ( avctx , ""unsupported<S2SV_blank>compression<S2SV_blank>%i"" , compression ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 668 ) ; set_metadata_int ( & st -> metadata , ""shutter_ns"" , avio_rl32 ( pb ) , 0 ) ; avio_skip ( pb , 24 ) ; # define DESCRIPTION_SIZE 4096 description = av_malloc ( DESCRIPTION_SIZE + 1 ) ; if ( ! description ) return AVERROR ( ENOMEM ) ; i = avio_get_str ( pb , DESCRIPTION_SIZE , description , DESCRIPTION_SIZE + 1 ) ; if ( i < DESCRIPTION_SIZE ) avio_skip ( pb , DESCRIPTION_SIZE - i ) ; if ( description [ 0 ] ) av_dict_set ( & st -> metadata , ""description"" , description , AV_DICT_DONT_STRDUP_VAL ) ; else av_free ( description ) ; avio_skip ( pb , 1176 ) ; set_metadata_int ( & st -> metadata , ""enable_crop"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_left"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_top"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_right"" , avio_rl32 ( pb ) , 1 ) ; set_metadata_int ( & st -> metadata , ""crop_bottom"" , avio_rl32 ( pb ) , 1 ) ; avio_seek ( pb , offImageOffsets , SEEK_SET ) ; <S2SV_StartBug> for ( i = 0 ; i < st -> duration ; i ++ ) <S2SV_EndBug> av_add_index_entry ( st , avio_rl64 ( pb ) , i , 0 , 0 , AVINDEX_KEYFRAME ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> AVINDEX_KEYFRAME ) ; }
",FFmpeg@FFmpeg/7e80b63ecd259d69d383623e75b318bf2bd491f6,CVE-2017-14059,https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6,2017-08-31T15:29Z
CWE-255,"CWE-255 int vt_reset_keyboard ( int fd ) { <S2SV_StartBug> int kb ; <S2SV_EndBug> <S2SV_StartBug> kb = vt_default_utf8 ( ) != 0 ? K_UNICODE : K_XLATE ; <S2SV_EndBug> if ( ioctl ( fd , KDSKBMODE , kb ) < 0 ) return - errno ; return 0 ; }
","<S2SV_ModStart> { int kb , r <S2SV_ModStart> K_UNICODE : K_XLATE ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , ""Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m"" ) ; return 0 ; } else if ( r < 0 ) return r
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z
CWE-200,"CWE-200 static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { <S2SV_StartBug> ret = copy_to_user ( param , ptr , sizeof ( * ptr ) ) ; <S2SV_EndBug> if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }
","<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
",torvalds@linux/2145e15e0557a01b9195d1c7199a1b92cb9be81f,CVE-2014-1738,https://github.com/torvalds/linux/commit/2145e15e0557a01b9195d1c7199a1b92cb9be81f,2014-05-11T21:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> const FIRSTPASS_STATS * next_frame ) { <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> next_frame -> coded_error ) / cm -> MBs ; <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ; }
","<S2SV_ModStart> get_prediction_decay_rate ( const VP9_COMP * cpi <S2SV_ModEnd> , const FIRSTPASS_STATS <S2SV_ModStart> { const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> ; const double <S2SV_ModStart> ; const double zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> ( 1.0 - <S2SV_ModStart> ( 1.0 - sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }
","<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
CWE-20,"CWE-20 error_t ftpClientParseDirEntry ( char_t * line , FtpDirEntry * dirEntry ) { uint_t i ; size_t n ; char_t * p ; char_t * token ; static const char_t months [ 13 ] [ 4 ] = { ""<S2SV_blank><S2SV_blank><S2SV_blank>"" , ""Jan"" , ""Feb"" , ""Mar"" , ""Apr"" , ""May"" , ""Jun"" , ""Jul"" , ""Aug"" , ""Sep"" , ""Oct"" , ""Nov"" , ""Dec"" } ; token = osStrtok_r ( line , ""<S2SV_blank>\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osIsdigit ( token [ 0 ] ) ) { if ( osStrlen ( token ) == 8 && token [ 2 ] == '-' && token [ 5 ] == '-' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) + 2000 ; } else if ( osStrlen ( token ) == 10 && token [ 2 ] == '/' && token [ 5 ] == '/' ) { dirEntry -> modified . month = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token + 6 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) >= 5 && token [ 2 ] == ':' ) { dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; <S2SV_StartBug> if ( strstr ( token , ""PM"" ) != NULL ) <S2SV_EndBug> dirEntry -> modified . hours += 12 ; } <S2SV_StartBug> else <S2SV_EndBug> { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcmp ( token , ""<DIR>"" ) ) { dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; } else { dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\0' ; } else { <S2SV_StartBug> if ( strchr ( token , 'd' ) != NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_DIRECTORY ; <S2SV_StartBug> if ( strchr ( token , 'w' ) == NULL ) <S2SV_EndBug> dirEntry -> attributes |= FTP_FILE_ATTR_READ_ONLY ; <S2SV_StartBug> token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; <S2SV_EndBug> if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> size = osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; for ( i = 1 ; i <= 12 ; i ++ ) { if ( ! osStrcmp ( token , months [ i ] ) ) { dirEntry -> modified . month = i ; break ; } } token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; dirEntry -> modified . day = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; token = osStrtok_r ( NULL , ""<S2SV_blank>"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( osStrlen ( token ) == 4 ) { dirEntry -> modified . year = ( uint16_t ) osStrtoul ( token , NULL , 10 ) ; } else if ( osStrlen ( token ) == 5 ) { token [ 2 ] = '\\0' ; dirEntry -> modified . hours = ( uint8_t ) osStrtoul ( token , NULL , 10 ) ; dirEntry -> modified . minutes = ( uint8_t ) osStrtoul ( token + 3 , NULL , 10 ) ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , ""<S2SV_blank>\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; n = osStrlen ( token ) ; n = MIN ( n , FTP_CLIENT_MAX_FILENAME_LEN ) ; osStrncpy ( dirEntry -> name , token , n ) ; dirEntry -> name [ n ] = '\\0' ; } return NO_ERROR ; }
","<S2SV_ModStart> ; if ( osStrstr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> 12 ; } } <S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_DIRECTORY ; } if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> == NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_READ_ONLY ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 static int isis_print ( netdissect_options * ndo , const uint8_t * p , u_int length ) { const struct isis_common_header * isis_header ; const struct isis_iih_lan_header * header_iih_lan ; const struct isis_iih_ptp_header * header_iih_ptp ; const struct isis_lsp_header * header_lsp ; const struct isis_csnp_header * header_csnp ; const struct isis_psnp_header * header_psnp ; const struct isis_tlv_lsp * tlv_lsp ; const struct isis_tlv_ptp_adj * tlv_ptp_adj ; const struct isis_tlv_is_reach * tlv_is_reach ; const struct isis_tlv_es_reach * tlv_es_reach ; uint8_t pdu_type , max_area , id_length , tlv_type , tlv_len , tmp , alen , lan_alen , prefix_len ; uint8_t ext_is_len , ext_ip_len , mt_len ; const uint8_t * optr , * pptr , * tptr ; u_short packet_len , pdu_len , key_id ; u_int i , vendor_id ; int sigcheck ; packet_len = length ; optr = p ; isis_header = ( const struct isis_common_header * ) p ; ND_TCHECK ( * isis_header ) ; if ( length < ISIS_COMMON_HEADER_SIZE ) goto trunc ; pptr = p + ( ISIS_COMMON_HEADER_SIZE ) ; header_iih_lan = ( const struct isis_iih_lan_header * ) pptr ; header_iih_ptp = ( const struct isis_iih_ptp_header * ) pptr ; header_lsp = ( const struct isis_lsp_header * ) pptr ; header_csnp = ( const struct isis_csnp_header * ) pptr ; header_psnp = ( const struct isis_psnp_header * ) pptr ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IS-IS"" ) ) ; if ( isis_header -> version != ISIS_VERSION ) { ND_PRINT ( ( ndo , ""version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , isis_header -> version ) ) ; return ( 0 ) ; } if ( ( isis_header -> id_length != SYSTEM_ID_LEN ) && ( isis_header -> id_length != 0 ) ) { ND_PRINT ( ( ndo , ""system<S2SV_blank>ID<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported"" , isis_header -> id_length ) ) ; return ( 0 ) ; } if ( isis_header -> pdu_version != ISIS_VERSION ) { ND_PRINT ( ( ndo , ""version<S2SV_blank>%d<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , isis_header -> pdu_version ) ) ; return ( 0 ) ; } if ( length < isis_header -> fixed_len ) { ND_PRINT ( ( ndo , ""fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>><S2SV_blank>packet<S2SV_blank>length<S2SV_blank>%u"" , isis_header -> fixed_len , length ) ) ; return ( 0 ) ; } if ( isis_header -> fixed_len < ISIS_COMMON_HEADER_SIZE ) { ND_PRINT ( ( ndo , ""fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>minimum<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u"" , isis_header -> fixed_len , ( u_int ) ISIS_COMMON_HEADER_SIZE ) ) ; return ( 0 ) ; } max_area = isis_header -> max_area ; switch ( max_area ) { case 0 : max_area = 3 ; break ; case 255 : ND_PRINT ( ( ndo , ""bad<S2SV_blank>packet<S2SV_blank>--<S2SV_blank>255<S2SV_blank>areas"" ) ) ; return ( 0 ) ; default : break ; } id_length = isis_header -> id_length ; switch ( id_length ) { case 0 : id_length = 6 ; break ; case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : case 8 : break ; case 255 : id_length = 0 ; break ; default : break ; } if ( id_length != 6 ) { ND_PRINT ( ( ndo , ""bad<S2SV_blank>packet<S2SV_blank>--<S2SV_blank>illegal<S2SV_blank>sys-ID<S2SV_blank>length<S2SV_blank>(%u)"" , id_length ) ) ; return ( 0 ) ; } pdu_type = isis_header -> pdu_type ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , ""%s%s"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , tok2str ( isis_pdu_values , ""unknown<S2SV_blank>PDU-Type<S2SV_blank>%u"" , pdu_type ) ) ) ; } else { ND_PRINT ( ( ndo , ""%slength<S2SV_blank>%u"" , ndo -> ndo_eflag ? """" : "",<S2SV_blank>"" , length ) ) ; ND_PRINT ( ( ndo , ""\\n\\t%s,<S2SV_blank>hlen:<S2SV_blank>%u,<S2SV_blank>v:<S2SV_blank>%u,<S2SV_blank>pdu-v:<S2SV_blank>%u,<S2SV_blank>sys-id-len:<S2SV_blank>%u<S2SV_blank>(%u),<S2SV_blank>max-area:<S2SV_blank>%u<S2SV_blank>(%u)"" , tok2str ( isis_pdu_values , ""unknown,<S2SV_blank>type<S2SV_blank>%u"" , pdu_type ) , isis_header -> fixed_len , isis_header -> version , isis_header -> pdu_version , id_length , isis_header -> id_length , max_area , isis_header -> max_area ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , optr , ""\\n\\t"" , 8 ) ) return ( 0 ) ; } } switch ( pdu_type ) { case ISIS_PDU_L1_LAN_IIH : case ISIS_PDU_L2_LAN_IIH : if ( isis_header -> fixed_len != ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_LAN_HEADER_SIZE ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bogus<S2SV_blank>fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%lu"" , isis_header -> fixed_len , ( unsigned long ) ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_LAN_HEADER_SIZE ) ) ) ; return ( 0 ) ; } ND_TCHECK ( * header_iih_lan ) ; if ( length < ISIS_COMMON_HEADER_SIZE + ISIS_IIH_LAN_HEADER_SIZE ) goto trunc ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>src-id<S2SV_blank>%s"" , isis_print_id ( header_iih_lan -> source_id , SYSTEM_ID_LEN ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lan-id<S2SV_blank>%s,<S2SV_blank>prio<S2SV_blank>%u"" , isis_print_id ( header_iih_lan -> lan_id , NODE_ID_LEN ) , header_iih_lan -> priority ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } pdu_len = EXTRACT_16BITS ( header_iih_lan -> pdu_len ) ; if ( packet_len > pdu_len ) { packet_len = pdu_len ; length = pdu_len ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>source-id:<S2SV_blank>%s,<S2SV_blank><S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , isis_print_id ( header_iih_lan -> source_id , SYSTEM_ID_LEN ) , EXTRACT_16BITS ( header_iih_lan -> holding_time ) , tok2str ( isis_iih_circuit_type_values , ""unknown<S2SV_blank>circuit<S2SV_blank>type<S2SV_blank>0x%02x"" , header_iih_lan -> circuit_type ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>lan-id:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s,<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , isis_print_id ( header_iih_lan -> lan_id , NODE_ID_LEN ) , ( header_iih_lan -> priority ) & ISIS_LAN_PRIORITY_MASK , pdu_len ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ISIS_IIH_LAN_HEADER_SIZE ) ) return ( 0 ) ; } packet_len -= ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_LAN_HEADER_SIZE ) ; pptr = p + ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_LAN_HEADER_SIZE ) ; break ; case ISIS_PDU_PTP_IIH : if ( isis_header -> fixed_len != ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_PTP_HEADER_SIZE ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bogus<S2SV_blank>fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%lu"" , isis_header -> fixed_len , ( unsigned long ) ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_PTP_HEADER_SIZE ) ) ) ; return ( 0 ) ; } ND_TCHECK ( * header_iih_ptp ) ; if ( length < ISIS_COMMON_HEADER_SIZE + ISIS_IIH_PTP_HEADER_SIZE ) goto trunc ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>src-id<S2SV_blank>%s"" , isis_print_id ( header_iih_ptp -> source_id , SYSTEM_ID_LEN ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } pdu_len = EXTRACT_16BITS ( header_iih_ptp -> pdu_len ) ; if ( packet_len > pdu_len ) { packet_len = pdu_len ; length = pdu_len ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>source-id:<S2SV_blank>%s,<S2SV_blank>holding<S2SV_blank>time:<S2SV_blank>%us,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , isis_print_id ( header_iih_ptp -> source_id , SYSTEM_ID_LEN ) , EXTRACT_16BITS ( header_iih_ptp -> holding_time ) , tok2str ( isis_iih_circuit_type_values , ""unknown<S2SV_blank>circuit<S2SV_blank>type<S2SV_blank>0x%02x"" , header_iih_ptp -> circuit_type ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>circuit-id:<S2SV_blank>0x%02x,<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , header_iih_ptp -> circuit_id , pdu_len ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ISIS_IIH_PTP_HEADER_SIZE ) ) return ( 0 ) ; } packet_len -= ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_PTP_HEADER_SIZE ) ; pptr = p + ( ISIS_COMMON_HEADER_SIZE + ISIS_IIH_PTP_HEADER_SIZE ) ; break ; case ISIS_PDU_L1_LSP : case ISIS_PDU_L2_LSP : if ( isis_header -> fixed_len != ( ISIS_COMMON_HEADER_SIZE + ISIS_LSP_HEADER_SIZE ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bogus<S2SV_blank>fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%lu"" , isis_header -> fixed_len , ( unsigned long ) ISIS_LSP_HEADER_SIZE ) ) ; return ( 0 ) ; } ND_TCHECK ( * header_lsp ) ; if ( length < ISIS_COMMON_HEADER_SIZE + ISIS_LSP_HEADER_SIZE ) goto trunc ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>lsp-id<S2SV_blank>%s,<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>lifetime<S2SV_blank>%5us"" , isis_print_id ( header_lsp -> lsp_id , LSP_ID_LEN ) , EXTRACT_32BITS ( header_lsp -> sequence_number ) , EXTRACT_16BITS ( header_lsp -> remaining_lifetime ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } pdu_len = EXTRACT_16BITS ( header_lsp -> pdu_len ) ; if ( packet_len > pdu_len ) { packet_len = pdu_len ; length = pdu_len ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>lsp-id:<S2SV_blank>%s,<S2SV_blank>seq:<S2SV_blank>0x%08x,<S2SV_blank>lifetime:<S2SV_blank>%5us\\n\\t<S2SV_blank><S2SV_blank>chksum:<S2SV_blank>0x%04x"" , isis_print_id ( header_lsp -> lsp_id , LSP_ID_LEN ) , EXTRACT_32BITS ( header_lsp -> sequence_number ) , EXTRACT_16BITS ( header_lsp -> remaining_lifetime ) , EXTRACT_16BITS ( header_lsp -> checksum ) ) ) ; osi_print_cksum ( ndo , ( const uint8_t * ) header_lsp -> lsp_id , EXTRACT_16BITS ( header_lsp -> checksum ) , 12 , length - 12 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[<S2SV_blank>%s"" , pdu_len , ISIS_MASK_LSP_OL_BIT ( header_lsp -> typeblock ) ? ""Overload<S2SV_blank>bit<S2SV_blank>set,<S2SV_blank>"" : """" ) ) ; if ( ISIS_MASK_LSP_ATT_BITS ( header_lsp -> typeblock ) ) { ND_PRINT ( ( ndo , ""%s"" , ISIS_MASK_LSP_ATT_DEFAULT_BIT ( header_lsp -> typeblock ) ? ""default<S2SV_blank>"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s"" , ISIS_MASK_LSP_ATT_DELAY_BIT ( header_lsp -> typeblock ) ? ""delay<S2SV_blank>"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s"" , ISIS_MASK_LSP_ATT_EXPENSE_BIT ( header_lsp -> typeblock ) ? ""expense<S2SV_blank>"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s"" , ISIS_MASK_LSP_ATT_ERROR_BIT ( header_lsp -> typeblock ) ? ""error<S2SV_blank>"" : """" ) ) ; ND_PRINT ( ( ndo , ""ATT<S2SV_blank>bit<S2SV_blank>set,<S2SV_blank>"" ) ) ; } ND_PRINT ( ( ndo , ""%s"" , ISIS_MASK_LSP_PARTITION_BIT ( header_lsp -> typeblock ) ? ""P<S2SV_blank>bit<S2SV_blank>set,<S2SV_blank>"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>]"" , tok2str ( isis_lsp_istype_values , ""Unknown(0x%x)"" , ISIS_MASK_LSP_ISTYPE_BITS ( header_lsp -> typeblock ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ISIS_LSP_HEADER_SIZE ) ) return ( 0 ) ; } packet_len -= ( ISIS_COMMON_HEADER_SIZE + ISIS_LSP_HEADER_SIZE ) ; pptr = p + ( ISIS_COMMON_HEADER_SIZE + ISIS_LSP_HEADER_SIZE ) ; break ; case ISIS_PDU_L1_CSNP : case ISIS_PDU_L2_CSNP : if ( isis_header -> fixed_len != ( ISIS_COMMON_HEADER_SIZE + ISIS_CSNP_HEADER_SIZE ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>bogus<S2SV_blank>fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%lu"" , isis_header -> fixed_len , ( unsigned long ) ( ISIS_COMMON_HEADER_SIZE + ISIS_CSNP_HEADER_SIZE ) ) ) ; return ( 0 ) ; } ND_TCHECK ( * header_csnp ) ; if ( length < ISIS_COMMON_HEADER_SIZE + ISIS_CSNP_HEADER_SIZE ) goto trunc ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>src-id<S2SV_blank>%s"" , isis_print_id ( header_csnp -> source_id , NODE_ID_LEN ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } pdu_len = EXTRACT_16BITS ( header_csnp -> pdu_len ) ; if ( packet_len > pdu_len ) { packet_len = pdu_len ; length = pdu_len ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>source-id:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s,<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , isis_print_id ( header_csnp -> source_id , NODE_ID_LEN ) , pdu_len ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>start<S2SV_blank>lsp-id:<S2SV_blank>%s"" , isis_print_id ( header_csnp -> start_lsp_id , LSP_ID_LEN ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>end<S2SV_blank>lsp-id:<S2SV_blank><S2SV_blank><S2SV_blank>%s"" , isis_print_id ( header_csnp -> end_lsp_id , LSP_ID_LEN ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ISIS_CSNP_HEADER_SIZE ) ) return ( 0 ) ; } packet_len -= ( ISIS_COMMON_HEADER_SIZE + ISIS_CSNP_HEADER_SIZE ) ; pptr = p + ( ISIS_COMMON_HEADER_SIZE + ISIS_CSNP_HEADER_SIZE ) ; break ; case ISIS_PDU_L1_PSNP : case ISIS_PDU_L2_PSNP : if ( isis_header -> fixed_len != ( ISIS_COMMON_HEADER_SIZE + ISIS_PSNP_HEADER_SIZE ) ) { ND_PRINT ( ( ndo , ""-<S2SV_blank>bogus<S2SV_blank>fixed<S2SV_blank>header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%lu"" , isis_header -> fixed_len , ( unsigned long ) ( ISIS_COMMON_HEADER_SIZE + ISIS_PSNP_HEADER_SIZE ) ) ) ; return ( 0 ) ; } ND_TCHECK ( * header_psnp ) ; if ( length < ISIS_COMMON_HEADER_SIZE + ISIS_PSNP_HEADER_SIZE ) goto trunc ; if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>src-id<S2SV_blank>%s"" , isis_print_id ( header_psnp -> source_id , NODE_ID_LEN ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } pdu_len = EXTRACT_16BITS ( header_psnp -> pdu_len ) ; if ( packet_len > pdu_len ) { packet_len = pdu_len ; length = pdu_len ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>source-id:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s,<S2SV_blank>PDU<S2SV_blank>length:<S2SV_blank>%u"" , isis_print_id ( header_psnp -> source_id , NODE_ID_LEN ) , pdu_len ) ) ; if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , ISIS_PSNP_HEADER_SIZE ) ) return ( 0 ) ; } packet_len -= ( ISIS_COMMON_HEADER_SIZE + ISIS_PSNP_HEADER_SIZE ) ; pptr = p + ( ISIS_COMMON_HEADER_SIZE + ISIS_PSNP_HEADER_SIZE ) ; break ; default : if ( ndo -> ndo_vflag == 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ( 1 ) ; } ( void ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank>"" , length ) ; return ( 0 ) ; } while ( packet_len > 0 ) { ND_TCHECK2 ( * pptr , 2 ) ; if ( packet_len < 2 ) goto trunc ; tlv_type = * pptr ++ ; tlv_len = * pptr ++ ; tmp = tlv_len ; tptr = pptr ; packet_len -= 2 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_tlv_values , ""unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; if ( tlv_len == 0 ) continue ; if ( packet_len < tlv_len ) goto trunc ; switch ( tlv_type ) { case ISIS_TLV_AREA_ADDR : ND_TCHECK2 ( * tptr , 1 ) ; alen = * tptr ++ ; <S2SV_StartBug> while ( tmp && alen < tmp ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Area<S2SV_blank>address<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s"" , alen , isonsap_string ( ndo , tptr , alen ) ) ) ; tptr += alen ; tmp -= alen + 1 ; if ( tmp == 0 ) break ; ND_TCHECK2 ( * tptr , 1 ) ; alen = * tptr ++ ; } break ; case ISIS_TLV_ISNEIGH : while ( tmp >= ETHER_ADDR_LEN ) { ND_TCHECK2 ( * tptr , ETHER_ADDR_LEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SNPA:<S2SV_blank>%s"" , isis_print_id ( tptr , ETHER_ADDR_LEN ) ) ) ; tmp -= ETHER_ADDR_LEN ; tptr += ETHER_ADDR_LEN ; } break ; case ISIS_TLV_ISNEIGH_VARLEN : if ( ! ND_TTEST2 ( * tptr , 1 ) || tmp < 3 ) goto trunctlv ; lan_alen = * tptr ++ ; if ( lan_alen == 0 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>LAN<S2SV_blank>address<S2SV_blank>length<S2SV_blank>0<S2SV_blank>bytes<S2SV_blank>(invalid)"" ) ) ; break ; } tmp -- ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>LAN<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>"" , lan_alen ) ) ; while ( tmp >= lan_alen ) { ND_TCHECK2 ( * tptr , lan_alen ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tIS<S2SV_blank>Neighbor:<S2SV_blank>%s"" , isis_print_id ( tptr , lan_alen ) ) ) ; tmp -= lan_alen ; tptr += lan_alen ; } break ; case ISIS_TLV_PADDING : break ; case ISIS_TLV_MT_IS_REACH : mt_len = isis_print_mtid ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; if ( mt_len == 0 ) goto trunctlv ; tptr += mt_len ; tmp -= mt_len ; while ( tmp >= 2 + NODE_ID_LEN + 3 + 1 ) { ext_is_len = isis_print_ext_is_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_type ) ; if ( ext_is_len == 0 ) goto trunctlv ; tmp -= ext_is_len ; tptr += ext_is_len ; } break ; case ISIS_TLV_IS_ALIAS_ID : while ( tmp >= NODE_ID_LEN + 1 ) { ext_is_len = isis_print_ext_is_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_type ) ; if ( ext_is_len == 0 ) goto trunctlv ; tmp -= ext_is_len ; tptr += ext_is_len ; } break ; case ISIS_TLV_EXT_IS_REACH : while ( tmp >= NODE_ID_LEN + 3 + 1 ) { ext_is_len = isis_print_ext_is_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_type ) ; if ( ext_is_len == 0 ) goto trunctlv ; tmp -= ext_is_len ; tptr += ext_is_len ; } break ; case ISIS_TLV_IS_REACH : ND_TCHECK2 ( * tptr , 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , tok2str ( isis_is_reach_virtual_values , ""bogus<S2SV_blank>virtual<S2SV_blank>flag<S2SV_blank>0x%02x"" , * tptr ++ ) ) ) ; tlv_is_reach = ( const struct isis_tlv_is_reach * ) tptr ; while ( tmp >= sizeof ( struct isis_tlv_is_reach ) ) { ND_TCHECK ( * tlv_is_reach ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IS<S2SV_blank>Neighbor:<S2SV_blank>%s"" , isis_print_id ( tlv_is_reach -> neighbor_nodeid , NODE_ID_LEN ) ) ) ; isis_print_metric_block ( ndo , & tlv_is_reach -> isis_metric_block ) ; tmp -= sizeof ( struct isis_tlv_is_reach ) ; tlv_is_reach ++ ; } break ; case ISIS_TLV_ESNEIGH : tlv_es_reach = ( const struct isis_tlv_es_reach * ) tptr ; while ( tmp >= sizeof ( struct isis_tlv_es_reach ) ) { ND_TCHECK ( * tlv_es_reach ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ES<S2SV_blank>Neighbor:<S2SV_blank>%s"" , isis_print_id ( tlv_es_reach -> neighbor_sysid , SYSTEM_ID_LEN ) ) ) ; isis_print_metric_block ( ndo , & tlv_es_reach -> isis_metric_block ) ; tmp -= sizeof ( struct isis_tlv_es_reach ) ; tlv_es_reach ++ ; } break ; case ISIS_TLV_INT_IP_REACH : case ISIS_TLV_EXT_IP_REACH : if ( ! isis_print_tlv_ip_reach ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_len ) ) return ( 1 ) ; break ; case ISIS_TLV_EXTD_IP_REACH : while ( tmp > 0 ) { ext_ip_len = isis_print_extd_ip_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , AF_INET ) ; if ( ext_ip_len == 0 ) goto trunctlv ; tptr += ext_ip_len ; tmp -= ext_ip_len ; } break ; case ISIS_TLV_MT_IP_REACH : mt_len = isis_print_mtid ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; if ( mt_len == 0 ) { goto trunctlv ; } tptr += mt_len ; tmp -= mt_len ; while ( tmp > 0 ) { ext_ip_len = isis_print_extd_ip_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , AF_INET ) ; if ( ext_ip_len == 0 ) goto trunctlv ; tptr += ext_ip_len ; tmp -= ext_ip_len ; } break ; case ISIS_TLV_IP6_REACH : while ( tmp > 0 ) { ext_ip_len = isis_print_extd_ip_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , AF_INET6 ) ; if ( ext_ip_len == 0 ) goto trunctlv ; tptr += ext_ip_len ; tmp -= ext_ip_len ; } break ; case ISIS_TLV_MT_IP6_REACH : mt_len = isis_print_mtid ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; if ( mt_len == 0 ) { goto trunctlv ; } tptr += mt_len ; tmp -= mt_len ; while ( tmp > 0 ) { ext_ip_len = isis_print_extd_ip_reach ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , AF_INET6 ) ; if ( ext_ip_len == 0 ) goto trunctlv ; tptr += ext_ip_len ; tmp -= ext_ip_len ; } break ; case ISIS_TLV_IP6ADDR : while ( tmp >= sizeof ( struct in6_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>interface<S2SV_blank>address:<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tptr += sizeof ( struct in6_addr ) ; tmp -= sizeof ( struct in6_addr ) ; } break ; case ISIS_TLV_AUTH : ND_TCHECK2 ( * tptr , 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s:<S2SV_blank>"" , tok2str ( isis_subtlv_auth_values , ""unknown<S2SV_blank>Authentication<S2SV_blank>type<S2SV_blank>0x%02x"" , * tptr ) ) ) ; switch ( * tptr ) { case ISIS_SUBTLV_AUTH_SIMPLE : if ( fn_printzp ( ndo , tptr + 1 , tlv_len - 1 , ndo -> ndo_snapend ) ) goto trunctlv ; break ; case ISIS_SUBTLV_AUTH_MD5 : for ( i = 1 ; i < tlv_len ; i ++ ) { ND_TCHECK2 ( * ( tptr + i ) , 1 ) ; ND_PRINT ( ( ndo , ""%02x"" , * ( tptr + i ) ) ) ; } if ( tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN + 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>(invalid<S2SV_blank>subTLV)<S2SV_blank>"" ) ) ; sigcheck = signature_verify ( ndo , optr , length , tptr + 1 , isis_clear_checksum_lifetime , header_lsp ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; break ; case ISIS_SUBTLV_AUTH_GENERIC : ND_TCHECK2 ( * ( tptr + 1 ) , 2 ) ; key_id = EXTRACT_16BITS ( ( tptr + 1 ) ) ; ND_PRINT ( ( ndo , ""%u,<S2SV_blank>password:<S2SV_blank>"" , key_id ) ) ; for ( i = 1 + sizeof ( uint16_t ) ; i < tlv_len ; i ++ ) { ND_TCHECK2 ( * ( tptr + i ) , 1 ) ; ND_PRINT ( ( ndo , ""%02x"" , * ( tptr + i ) ) ) ; } break ; case ISIS_SUBTLV_AUTH_PRIVATE : default : if ( ! print_unknown_data ( ndo , tptr + 1 , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , tlv_len - 1 ) ) return ( 0 ) ; break ; } break ; case ISIS_TLV_PTP_ADJ : tlv_ptp_adj = ( const struct isis_tlv_ptp_adj * ) tptr ; if ( tmp >= 1 ) { ND_TCHECK2 ( * tptr , 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Adjacency<S2SV_blank>State:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( isis_ptp_adjancey_values , ""unknown"" , * tptr ) , * tptr ) ) ; tmp -- ; } if ( tmp > sizeof ( tlv_ptp_adj -> extd_local_circuit_id ) ) { ND_TCHECK ( tlv_ptp_adj -> extd_local_circuit_id ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended<S2SV_blank>Local<S2SV_blank>circuit-ID:<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tlv_ptp_adj -> extd_local_circuit_id ) ) ) ; tmp -= sizeof ( tlv_ptp_adj -> extd_local_circuit_id ) ; } if ( tmp >= SYSTEM_ID_LEN ) { ND_TCHECK2 ( tlv_ptp_adj -> neighbor_sysid , SYSTEM_ID_LEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>System-ID:<S2SV_blank>%s"" , isis_print_id ( tlv_ptp_adj -> neighbor_sysid , SYSTEM_ID_LEN ) ) ) ; tmp -= SYSTEM_ID_LEN ; } if ( tmp >= sizeof ( tlv_ptp_adj -> neighbor_extd_local_circuit_id ) ) { ND_TCHECK ( tlv_ptp_adj -> neighbor_extd_local_circuit_id ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Neighbor<S2SV_blank>Extended<S2SV_blank>Local<S2SV_blank>circuit-ID:<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tlv_ptp_adj -> neighbor_extd_local_circuit_id ) ) ) ; } break ; case ISIS_TLV_PROTOCOLS : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>NLPID(s):<S2SV_blank>"" ) ) ; while ( tmp > 0 ) { ND_TCHECK2 ( * ( tptr ) , 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)"" , tok2str ( nlpid_values , ""unknown"" , * tptr ) , * tptr ) ) ; if ( tmp > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; tptr ++ ; tmp -- ; } break ; case ISIS_TLV_MT_PORT_CAP : { ND_TCHECK2 ( * ( tptr ) , 2 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>MTID(s):<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 12 ) , ( EXTRACT_16BITS ( tptr ) & 0x0fff ) ) ) ; tmp = tmp - 2 ; tptr = tptr + 2 ; if ( tmp ) isis_print_mt_port_cap_subtlv ( ndo , tptr , tmp ) ; break ; } case ISIS_TLV_MT_CAPABILITY : ND_TCHECK2 ( * ( tptr ) , 2 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>O:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>MTID(s):<S2SV_blank>%d"" , ( EXTRACT_16BITS ( tptr ) >> 15 ) & 0x01 , ( EXTRACT_16BITS ( tptr ) >> 12 ) & 0x07 , EXTRACT_16BITS ( tptr ) & 0x0fff ) ) ; tmp = tmp - 2 ; tptr = tptr + 2 ; if ( tmp ) isis_print_mt_capability_subtlv ( ndo , tptr , tmp ) ; break ; case ISIS_TLV_TE_ROUTER_ID : ND_TCHECK2 ( * pptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Traffic<S2SV_blank>Engineering<S2SV_blank>Router<S2SV_blank>ID:<S2SV_blank>%s"" , ipaddr_string ( ndo , pptr ) ) ) ; break ; case ISIS_TLV_IPADDR : while ( tmp >= sizeof ( struct in_addr ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>interface<S2SV_blank>address:<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tptr += sizeof ( struct in_addr ) ; tmp -= sizeof ( struct in_addr ) ; } break ; case ISIS_TLV_HOSTNAME : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hostname:<S2SV_blank>"" ) ) ; if ( fn_printzp ( ndo , tptr , tmp , ndo -> ndo_snapend ) ) goto trunctlv ; break ; case ISIS_TLV_SHARED_RISK_GROUP : if ( tmp < NODE_ID_LEN ) break ; ND_TCHECK2 ( * tptr , NODE_ID_LEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IS<S2SV_blank>Neighbor:<S2SV_blank>%s"" , isis_print_id ( tptr , NODE_ID_LEN ) ) ) ; tptr += ( NODE_ID_LEN ) ; tmp -= ( NODE_ID_LEN ) ; if ( tmp < 1 ) break ; ND_TCHECK2 ( * tptr , 1 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]"" , ISIS_MASK_TLV_SHARED_RISK_GROUP ( * tptr ++ ) ? ""numbered"" : ""unnumbered"" ) ) ; tmp -- ; if ( tmp < sizeof ( struct in_addr ) ) break ; ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>interface<S2SV_blank>address:<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tptr += sizeof ( struct in_addr ) ; tmp -= sizeof ( struct in_addr ) ; if ( tmp < sizeof ( struct in_addr ) ) break ; ND_TCHECK2 ( * tptr , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>neighbor<S2SV_blank>address:<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tptr += sizeof ( struct in_addr ) ; tmp -= sizeof ( struct in_addr ) ; while ( tmp >= 4 ) { ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link-ID:<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr += 4 ; tmp -= 4 ; } break ; case ISIS_TLV_LSP : tlv_lsp = ( const struct isis_tlv_lsp * ) tptr ; while ( tmp >= sizeof ( struct isis_tlv_lsp ) ) { ND_TCHECK ( ( tlv_lsp -> lsp_id ) [ LSP_ID_LEN - 1 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>lsp-id:<S2SV_blank>%s"" , isis_print_id ( tlv_lsp -> lsp_id , LSP_ID_LEN ) ) ) ; ND_TCHECK2 ( tlv_lsp -> sequence_number , 4 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq:<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tlv_lsp -> sequence_number ) ) ) ; ND_TCHECK2 ( tlv_lsp -> remaining_lifetime , 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>lifetime:<S2SV_blank>%5ds"" , EXTRACT_16BITS ( tlv_lsp -> remaining_lifetime ) ) ) ; ND_TCHECK2 ( tlv_lsp -> checksum , 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>chksum:<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( tlv_lsp -> checksum ) ) ) ; tmp -= sizeof ( struct isis_tlv_lsp ) ; tlv_lsp ++ ; } break ; case ISIS_TLV_CHECKSUM : if ( tmp < ISIS_TLV_CHECKSUM_MINLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_CHECKSUM_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checksum:<S2SV_blank>0x%04x<S2SV_blank>"" , EXTRACT_16BITS ( tptr ) ) ) ; osi_print_cksum ( ndo , optr , EXTRACT_16BITS ( tptr ) , tptr - optr , length ) ; break ; case ISIS_TLV_POI : if ( tlv_len >= SYSTEM_ID_LEN + 1 ) { ND_TCHECK2 ( * tptr , SYSTEM_ID_LEN + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Purge<S2SV_blank>Originator<S2SV_blank>System-ID:<S2SV_blank>%s"" , isis_print_id ( tptr + 1 , SYSTEM_ID_LEN ) ) ) ; } if ( tlv_len == 2 * SYSTEM_ID_LEN + 1 ) { ND_TCHECK2 ( * tptr , 2 * SYSTEM_ID_LEN + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received<S2SV_blank>from<S2SV_blank>System-ID:<S2SV_blank>%s"" , isis_print_id ( tptr + SYSTEM_ID_LEN + 1 , SYSTEM_ID_LEN ) ) ) ; } break ; case ISIS_TLV_MT_SUPPORTED : if ( tmp < ISIS_TLV_MT_SUPPORTED_MINLEN ) break ; while ( tmp > 1 ) { if ( tmp != 1 ) { mt_len = isis_print_mtid ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; if ( mt_len == 0 ) goto trunctlv ; tptr += mt_len ; tmp -= mt_len ; } else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>invalid<S2SV_blank>MT-ID"" ) ) ; break ; } } break ; case ISIS_TLV_RESTART_SIGNALING : if ( tmp < ISIS_TLV_RESTART_SIGNALING_FLAGLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_RESTART_SIGNALING_FLAGLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( isis_restart_flag_values , ""none"" , * tptr ) ) ) ; tptr += ISIS_TLV_RESTART_SIGNALING_FLAGLEN ; tmp -= ISIS_TLV_RESTART_SIGNALING_FLAGLEN ; if ( tmp == 0 ) break ; if ( tmp < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Remaining<S2SV_blank>holding<S2SV_blank>time<S2SV_blank>%us"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr += ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN ; tmp -= ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN ; if ( tmp == SYSTEM_ID_LEN ) { ND_TCHECK2 ( * tptr , SYSTEM_ID_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>for<S2SV_blank>%s"" , isis_print_id ( tptr , SYSTEM_ID_LEN ) ) ) ; } break ; case ISIS_TLV_IDRP_INFO : if ( tmp < ISIS_TLV_IDRP_INFO_MINLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_IDRP_INFO_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Inter-Domain<S2SV_blank>Information<S2SV_blank>Type:<S2SV_blank>%s"" , tok2str ( isis_subtlv_idrp_values , ""Unknown<S2SV_blank>(0x%02x)"" , * tptr ) ) ) ; switch ( * tptr ++ ) { case ISIS_SUBTLV_IDRP_ASN : ND_TCHECK2 ( * tptr , 2 ) ; ND_PRINT ( ( ndo , ""AS<S2SV_blank>Number:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_IDRP_LOCAL : case ISIS_SUBTLV_IDRP_RES : default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_len - 1 ) ) return ( 0 ) ; break ; } break ; case ISIS_TLV_LSP_BUFFERSIZE : if ( tmp < ISIS_TLV_LSP_BUFFERSIZE_MINLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_LSP_BUFFERSIZE_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>LSP<S2SV_blank>Buffersize:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; break ; case ISIS_TLV_PART_DIS : while ( tmp >= SYSTEM_ID_LEN ) { ND_TCHECK2 ( * tptr , SYSTEM_ID_LEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , isis_print_id ( tptr , SYSTEM_ID_LEN ) ) ) ; tptr += SYSTEM_ID_LEN ; tmp -= SYSTEM_ID_LEN ; } break ; case ISIS_TLV_PREFIX_NEIGH : if ( tmp < sizeof ( struct isis_metric_block ) ) break ; ND_TCHECK2 ( * tptr , sizeof ( struct isis_metric_block ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Metric<S2SV_blank>Block"" ) ) ; isis_print_metric_block ( ndo , ( const struct isis_metric_block * ) tptr ) ; tptr += sizeof ( struct isis_metric_block ) ; tmp -= sizeof ( struct isis_metric_block ) ; while ( tmp > 0 ) { ND_TCHECK2 ( * tptr , 1 ) ; prefix_len = * tptr ++ ; if ( prefix_len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t\\tAddress:<S2SV_blank>prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>2"" , prefix_len ) ) ; break ; } tmp -- ; if ( tmp < prefix_len / 2 ) break ; ND_TCHECK2 ( * tptr , prefix_len / 2 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\tAddress:<S2SV_blank>%s/%u"" , isonsap_string ( ndo , tptr , prefix_len / 2 ) , prefix_len * 4 ) ) ; tptr += prefix_len / 2 ; tmp -= prefix_len / 2 ; } break ; case ISIS_TLV_IIH_SEQNR : if ( tmp < ISIS_TLV_IIH_SEQNR_MINLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_IIH_SEQNR_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sequence<S2SV_blank>number:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case ISIS_TLV_VENDOR_PRIVATE : if ( tmp < ISIS_TLV_VENDOR_PRIVATE_MINLEN ) break ; ND_TCHECK2 ( * tptr , ISIS_TLV_VENDOR_PRIVATE_MINLEN ) ; vendor_id = EXTRACT_24BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , vendor_id ) , vendor_id ) ) ; tptr += 3 ; tmp -= 3 ; if ( tmp > 0 ) if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t"" , tmp ) ) return ( 0 ) ; break ; case ISIS_TLV_DECNET_PHASE4 : case ISIS_TLV_LUCENT_PRIVATE : case ISIS_TLV_IPAUTH : case ISIS_TLV_NORTEL_PRIVATE1 : case ISIS_TLV_NORTEL_PRIVATE2 : default : if ( ndo -> ndo_vflag <= 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t\\t"" , tlv_len ) ) return ( 0 ) ; } break ; } if ( ndo -> ndo_vflag > 1 ) { if ( ! print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlv_len ) ) return ( 0 ) ; } pptr += tlv_len ; packet_len -= tlv_len ; } if ( packet_len != 0 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>straggler<S2SV_blank>bytes"" , packet_len ) ) ; } return ( 1 ) ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; trunctlv : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }
","<S2SV_ModStart> tmp ) { ND_TCHECK2 ( * tptr , alen ) ;
",the-tcpdump-group@tcpdump/3b32029db354cbc875127869d9b12a9addc75b50,CVE-2017-12999,https://github.com/the-tcpdump-group/tcpdump/commit/3b32029db354cbc875127869d9b12a9addc75b50,2017-09-14T06:29Z
CWE-119,"CWE-119 char * logger_get_mask_expanded ( struct t_gui_buffer * buffer , const char * mask ) { <S2SV_StartBug> char * mask2 , * mask_decoded , * mask_decoded2 , * mask_decoded3 , * mask_decoded4 ; <S2SV_EndBug> char * mask_decoded5 ; const char * dir_separator ; int length ; time_t seconds ; struct tm * date_tmp ; mask2 = NULL ; <S2SV_StartBug> mask_decoded = NULL ; <S2SV_EndBug> mask_decoded2 = NULL ; mask_decoded3 = NULL ; mask_decoded4 = NULL ; mask_decoded5 = NULL ; dir_separator = weechat_info_get ( ""dir_separator"" , """" ) ; if ( ! dir_separator ) return NULL ; <S2SV_StartBug> mask2 = weechat_string_replace ( mask , dir_separator , ""\\01"" ) ; <S2SV_EndBug> if ( ! mask2 ) goto end ; mask_decoded = weechat_buffer_string_replace_local_var ( buffer , mask2 ) ; if ( ! mask_decoded ) goto end ; mask_decoded2 = weechat_string_replace ( mask_decoded , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask_decoded2 ) goto end ; # ifdef __CYGWIN__ mask_decoded3 = weechat_string_replace ( mask_decoded2 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask_decoded3 = strdup ( mask_decoded2 ) ; # endif if ( ! mask_decoded3 ) goto end ; mask_decoded4 = weechat_string_replace ( mask_decoded3 , ""\\01"" , dir_separator ) ; if ( ! mask_decoded4 ) goto end ; length = strlen ( mask_decoded4 ) + 256 + 1 ; <S2SV_StartBug> mask_decoded5 = malloc ( length ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! mask_decoded5 ) <S2SV_EndBug> goto end ; seconds = time ( NULL ) ; date_tmp = localtime ( & seconds ) ; <S2SV_StartBug> mask_decoded5 [ 0 ] = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> strftime ( mask_decoded5 , length - 1 , mask_decoded4 , date_tmp ) ; <S2SV_EndBug> if ( weechat_config_boolean ( logger_config_file_name_lower_case ) ) <S2SV_StartBug> weechat_string_tolower ( mask_decoded5 ) ; <S2SV_EndBug> if ( weechat_logger_plugin -> debug ) { weechat_printf_date_tags ( NULL , 0 , ""no_log"" , ""%s:<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"",<S2SV_blank>"" ""decoded<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>\\""%s\\"""" , LOGGER_PLUGIN_NAME , weechat_buffer_get_string ( buffer , ""name"" ) , <S2SV_StartBug> mask , mask_decoded5 ) ; <S2SV_EndBug> } end : if ( mask2 ) free ( mask2 ) ; <S2SV_StartBug> if ( mask_decoded ) <S2SV_EndBug> <S2SV_StartBug> free ( mask_decoded ) ; <S2SV_EndBug> if ( mask_decoded2 ) <S2SV_StartBug> free ( mask_decoded2 ) ; <S2SV_EndBug> if ( mask_decoded3 ) <S2SV_StartBug> free ( mask_decoded3 ) ; <S2SV_EndBug> if ( mask_decoded4 ) <S2SV_StartBug> free ( mask_decoded4 ) ; <S2SV_EndBug> <S2SV_StartBug> return mask_decoded5 ; <S2SV_EndBug> }
","<S2SV_ModStart> mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char <S2SV_ModStart> = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> return NULL ; length = strlen ( mask <S2SV_ModEnd> ) + 256 <S2SV_ModStart> + 1 ; mask2 <S2SV_ModEnd> = malloc ( <S2SV_ModStart> if ( ! mask2 <S2SV_ModEnd> ) goto end <S2SV_ModStart> seconds ) ; mask2 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = '\\0' ; if ( strftime ( mask2 <S2SV_ModEnd> , length - <S2SV_ModStart> - 1 , mask <S2SV_ModEnd> , date_tmp ) <S2SV_ModStart> , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , ""\\01"" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , ""\\\\"" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , ""\\01"" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , mask , mask7 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( mask3 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask6 <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return mask7 <S2SV_ModEnd> ; } <S2SV_null>
",weechat@weechat/f105c6f0b56fb5687b2d2aedf37cb1d1b434d556,CVE-2017-14727,https://github.com/weechat/weechat/commit/f105c6f0b56fb5687b2d2aedf37cb1d1b434d556,2017-09-23T20:29Z
CWE-119,"CWE-119 static int search_impl ( i_ctx_t * i_ctx_p , bool forward ) { os_ptr op = osp ; os_ptr op1 = op - 1 ; uint size = r_size ( op ) ; uint count ; byte * pat ; byte * ptr ; byte ch ; int incr = forward ? 1 : - 1 ; check_read_type ( * op1 , t_string ) ; check_read_type ( * op , t_string ) ; if ( size > r_size ( op1 ) ) { make_false ( op ) ; return 0 ; } count = r_size ( op1 ) - size ; ptr = op1 -> value . bytes ; if ( size == 0 ) goto found ; if ( ! forward ) ptr += count ; pat = op -> value . bytes ; ch = pat [ 0 ] ; do { if ( * ptr == ch && ( size == 1 || ! memcmp ( ptr , pat , size ) ) ) goto found ; ptr += incr ; } while ( count -- ) ; make_false ( op ) ; return 0 ; found : op -> tas . type_attrs = op1 -> tas . type_attrs ; op -> value . bytes = ptr ; <S2SV_StartBug> r_set_size ( op , size ) ; <S2SV_EndBug> push ( 2 ) ; op [ - 1 ] = * op1 ; <S2SV_StartBug> r_set_size ( op - 1 , ptr - op [ - 1 ] . value . bytes ) ; <S2SV_EndBug> op1 -> value . bytes = ptr + size ; <S2SV_StartBug> r_set_size ( op1 , count + ( ! forward ? ( size - 1 ) : 0 ) ) ; <S2SV_EndBug> make_true ( op ) ; return 0 ; }
","<S2SV_ModStart> = ptr ; op -> tas . rsize = size <S2SV_ModEnd> ; push ( <S2SV_ModStart> * op1 ; op [ - 3 ] . <S2SV_ModEnd> value . bytes <S2SV_ModStart> + size ; if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> make_true ( op
",ArtifexSoftware@ghostpdl/5d499272b95a6b890a1397e11d20937de000d31b,CVE-2020-15900,https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b,2020-07-28T16:15Z
CWE-264,"CWE-264 <S2SV_StartBug> int open_debug_log ( void ) { <S2SV_EndBug> if ( verify_config || test_scheduling == TRUE ) return OK ; if ( debug_level == DEBUGL_NONE ) return OK ; <S2SV_StartBug> if ( ( debug_file_fp = fopen ( debug_file , ""a+"" ) ) == NULL ) <S2SV_EndBug> return ERROR ; <S2SV_StartBug> ( void ) fcntl ( fileno ( debug_file_fp ) , F_SETFD , FD_CLOEXEC ) ; <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> void ) { int fh ; struct stat st ; <S2SV_ModStart> if ( ( fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ; if ( ( debug_file_fp = fdopen ( fh <S2SV_ModEnd> , ""a+"" ) <S2SV_ModStart> return ERROR ; if ( ( fstat ( fh , & st ) ) == - 1 ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } <S2SV_ModStart> ) fcntl ( fh <S2SV_ModEnd> , F_SETFD ,
",NagiosEnterprises@nagioscore/c29557dec91eba2306f5fb11b8da4474ba63f8c4,CVE-2016-9566,https://github.com/NagiosEnterprises/nagioscore/commit/c29557dec91eba2306f5fb11b8da4474ba63f8c4,2016-12-15T22:59Z
CWE-119,"CWE-119 void grubfs_free ( GrubFS * gf ) { if ( gf ) { <S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> free ( gf -> file ) ; free ( gf ) ; } }
","<S2SV_ModStart> -> device ) { <S2SV_ModStart> disk ) ; }
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
CWE-119,"CWE-119 int mndp_add_attribute ( struct mt_packet * packet , enum mt_mndp_attrtype attrtype , void * attrdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned short type = attrtype ; unsigned short len = data_len ; <S2SV_StartBug> if ( packet -> size + 4 + data_len > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""mndp_add_attribute:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } type = htons ( type ) ; memcpy ( data , & type , sizeof ( type ) ) ; len = htons ( len ) ; memcpy ( data + 2 , & len , sizeof ( len ) ) ; memcpy ( data + 4 , attrdata , data_len ) ; packet -> size += 4 + data_len ; return 4 + data_len ; }
","<S2SV_ModStart> ; if ( data_len > MT_PACKET_LEN - 4 - <S2SV_ModStart> packet -> size <S2SV_ModEnd> ) { fprintf
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z
CWE-119,"CWE-119 static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; <S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }
","<S2SV_ModStart> . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; <S2SV_StartBug> strlcpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-74,"CWE-74 static void child_setup_func ( gpointer user_data ) { ChildSetupData * data = ( ChildSetupData * ) user_data ; FdMapEntry * fd_map = data -> fd_map ; sigset_t set ; int i ; flatpak_close_fds_workaround ( 3 ) ; if ( data -> instance_id_fd != - 1 ) <S2SV_StartBug> drop_cloexec ( data -> instance_id_fd ) ; <S2SV_EndBug> sigemptyset ( & set ) ; if ( pthread_sigmask ( SIG_SETMASK , & set , NULL ) == - 1 ) { g_warning ( ""Failed<S2SV_blank>to<S2SV_blank>unblock<S2SV_blank>signals<S2SV_blank>when<S2SV_blank>starting<S2SV_blank>child"" ) ; return ; } for ( i = 1 ; i < NSIG ; i ++ ) { if ( i != SIGSTOP && i != SIGKILL ) signal ( i , SIG_DFL ) ; } for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . from != fd_map [ i ] . to ) { dup2 ( fd_map [ i ] . from , fd_map [ i ] . to ) ; close ( fd_map [ i ] . from ) ; } } for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . to != fd_map [ i ] . final ) { dup2 ( fd_map [ i ] . to , fd_map [ i ] . final ) ; close ( fd_map [ i ] . to ) ; } drop_cloexec ( fd_map [ i ] . final ) ; } setsid ( ) ; setpgid ( 0 , 0 ) ; if ( data -> set_tty ) { for ( i = 0 ; i < data -> fd_map_len ; i ++ ) { if ( fd_map [ i ] . from == data -> tty ) { if ( ioctl ( fd_map [ i ] . final , TIOCSCTTY , 0 ) == - 1 ) g_debug ( ""ioctl(%d,<S2SV_blank>TIOCSCTTY,<S2SV_blank>0)<S2SV_blank>failed:<S2SV_blank>%s"" , fd_map [ i ] . final , strerror ( errno ) ) ; break ; } } } }
","<S2SV_ModStart> data -> instance_id_fd ) ; if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd
",flatpak@flatpak/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4,CVE-2021-21261,https://github.com/flatpak/flatpak/commit/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4,2021-01-14T20:15Z
CWE-119,"CWE-119 static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , ""Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\n"" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec"" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }
","<S2SV_ModStart> : 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 int SMB2_write ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , struct kvec * iov , int n_vec ) { struct smb_rqst rqst ; int rc = 0 ; struct smb2_write_req * req = NULL ; struct smb2_write_rsp * rsp = NULL ; int resp_buftype ; struct kvec rsp_iov ; int flags = 0 ; unsigned int total_len ; * nbytes = 0 ; if ( n_vec < 1 ) return rc ; rc = smb2_plain_req_init ( SMB2_WRITE , io_parms -> tcon , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; if ( io_parms -> tcon -> ses -> server == NULL ) return - ECONNABORTED ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; req -> sync_hdr . ProcessId = cpu_to_le32 ( io_parms -> pid ) ; req -> PersistentFileId = io_parms -> persistent_fid ; req -> VolatileFileId = io_parms -> volatile_fid ; req -> WriteChannelInfoOffset = 0 ; req -> WriteChannelInfoLength = 0 ; req -> Channel = 0 ; req -> Length = cpu_to_le32 ( io_parms -> length ) ; req -> Offset = cpu_to_le64 ( io_parms -> offset ) ; req -> DataOffset = cpu_to_le16 ( offsetof ( struct smb2_write_req , Buffer ) ) ; req -> RemainingBytes = 0 ; trace_smb3_write_enter ( xid , io_parms -> persistent_fid , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length ) ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len - 1 ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = n_vec + 1 ; rc = cifs_send_recv ( xid , io_parms -> tcon -> ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_write_rsp * ) rsp_iov . iov_base ; if ( rc ) { trace_smb3_write_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; cifs_stats_fail_inc ( io_parms -> tcon , SMB2_WRITE_HE ) ; cifs_dbg ( VFS , ""Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>write<S2SV_blank>=<S2SV_blank>%d\\n"" , rc ) ; } else { * nbytes = le32_to_cpu ( rsp -> DataLength ) ; trace_smb3_write_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , io_parms -> tcon -> ses -> Suid , io_parms -> offset , * nbytes ) ; } <S2SV_StartBug> free_rsp_buf ( resp_buftype , rsp ) ; <S2SV_EndBug> return rc ; }
","<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;
",torvalds@linux/6a3eb3360667170988f8a6477f6686242061488a,CVE-2019-15919,https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a,2019-09-04T19:15Z
CWE-399,"CWE-399 protected struct magic_set * file_ms_alloc ( int flags ) { struct magic_set * ms ; size_t i , len ; if ( ( ms = CAST ( struct magic_set * , calloc ( ( size_t ) 1 , sizeof ( struct magic_set ) ) ) ) == NULL ) return NULL ; if ( magic_setflags ( ms , flags ) == - 1 ) { errno = EINVAL ; goto free ; } ms -> o . buf = ms -> o . pbuf = NULL ; len = ( ms -> c . len = 10 ) * sizeof ( * ms -> c . li ) ; if ( ( ms -> c . li = CAST ( struct level_info * , malloc ( len ) ) ) == NULL ) goto free ; ms -> event_flags = 0 ; ms -> error = - 1 ; for ( i = 0 ; i < MAGIC_SETS ; i ++ ) ms -> mlist [ i ] = NULL ; ms -> file = ""unknown"" ; ms -> line = 0 ; ms -> indir_max = FILE_INDIR_MAX ; ms -> name_max = FILE_NAME_MAX ; ms -> elf_shnum_max = FILE_ELF_SHNUM_MAX ; ms -> elf_phnum_max = FILE_ELF_PHNUM_MAX ; <S2SV_StartBug> return ms ; <S2SV_EndBug> free : free ( ms ) ; return NULL ; }
","<S2SV_ModStart> = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;
",file@file/ce90e05774dd77d86cfc8dfa6da57b32816841c4,CVE-2014-9620,https://github.com/file/file/commit/ce90e05774dd77d86cfc8dfa6da57b32816841c4,2015-01-21T18:59Z
CWE-125,"CWE-125 void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z
CWE-416,"CWE-416 int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; <S2SV_StartBug> int err = - EINVAL ; <S2SV_EndBug> if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
","<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
",torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z
CWE-000,"CWE-000 gchar * _rsvg_io_get_file_path ( const gchar * filename , const gchar * base_uri ) { gchar * absolute_filename ; <S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> absolute_filename = g_strdup ( filename ) ; } else { gchar * tmpcdir ; gchar * base_filename ; if ( base_uri ) { base_filename = g_filename_from_uri ( base_uri , NULL , NULL ) ; if ( base_filename != NULL ) { tmpcdir = g_path_get_dirname ( base_filename ) ; g_free ( base_filename ) ; } else return NULL ; } else tmpcdir = g_get_current_dir ( ) ; absolute_filename = g_build_filename ( tmpcdir , filename , NULL ) ; g_free ( tmpcdir ) ; } return absolute_filename ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> g_path_is_absolute ( filename
",ImageMagick@librsvg/f9d69eadd2b16b00d1a1f9f286122123f8e547dd,CVE-2018-1000041,https://github.com/ImageMagick/librsvg/commit/f9d69eadd2b16b00d1a1f9f286122123f8e547dd,2018-02-09T23:29Z
CWE-000,"CWE-000 int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }
","<S2SV_ModStart> ; return error < 0 ? error : 0
",torvalds@linux/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,CVE-2015-8812,https://github.com/torvalds/linux/commit/67f1aee6f45059fd6b0f5b0ecb2c97ad0451f6b3,2016-04-27T17:59Z
CWE-416,"CWE-416 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
CWE-125,"CWE-125 int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , ""Negotiate<S2SV_blank>protocol\\n"" ) ; if ( ! server ) { WARN ( 1 , ""%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n"" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , ""Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>"" ""specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing"" ""<S2SV_blank>older<S2SV_blank>servers\\n"" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , ""Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , ""mode<S2SV_blank>0x%x\\n"" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n"" ) ; else { cifs_dbg ( VFS , ""Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , ""Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n"" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , ""missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n"" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , ""Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n"" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }
","<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
",torvalds@linux/b57a55e2200ede754e4dc9cce4ba9402544b9365,CVE-2019-15918,https://github.com/torvalds/linux/commit/b57a55e2200ede754e4dc9cce4ba9402544b9365,2019-09-04T19:15Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> const int update = va_arg ( args , int ) ; vp9_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , mask , mode , ofd , omode ; off_t size , statbytes ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) do { why = str ; goto screwup ; } while ( 0 ) setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) ( void ) atomicio ( vwrite , STDERR_FILENO , buf + 1 , strlen ( buf + 1 ) ) ; if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; return ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; mtime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; atime . tv_sec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; for ( size = 0 ; isdigit ( * cp ) ; ) size = size * 10 + ( * cp ++ - '0' ) ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; <S2SV_StartBug> if ( ( strchr ( cp , '/' ) != NULL ) || ( strcmp ( cp , "".."" ) == 0 ) ) { <S2SV_EndBug> run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( targisdir ) { static char * namebuf = NULL ; static size_t cursize = 0 ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { if ( namebuf ) xfree ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) < 0 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect ) ; if ( setimes ) { setimes = 0 ; if ( utimes ( vect [ 0 ] , tv ) < 0 ) run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; if ( vect [ 0 ] ) xfree ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) < 0 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , 4096 ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = NO ; statbytes = 0 ; # ifdef PROGRESS_METER if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; # endif for ( count = i = 0 ; i < size ; i += 4096 ) { amt = 4096 ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio ( read , remin , cp , amt ) ; if ( j == 0 ) { run_err ( ""%s"" , j ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; statbytes += j ; } while ( amt > 0 ) ; if ( limit_rate ) bwlimit ( 4096 ) ; if ( count == bp -> cnt ) { if ( wrerr == NO ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } } count = 0 ; cp = bp -> buf ; } } # ifdef PROGRESS_METER if ( showprogress ) stop_progress_meter ( ) ; # endif if ( count != 0 && wrerr == NO && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { wrerr = YES ; wrerrno = errno ; } if ( wrerr == NO && ftruncate ( ofd , size ) != 0 ) { run_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif run_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } if ( close ( ofd ) == - 1 ) { wrerr = YES ; wrerrno = errno ; } ( void ) response ( ) ; if ( setimes && wrerr == NO ) { setimes = 0 ; if ( utimes ( np , tv ) < 0 ) { run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = DISPLAYED ; } } switch ( wrerr ) { case YES : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( wrerrno ) ) ; break ; case NO : ( void ) atomicio ( vwrite , remout , """" , 1 ) ; break ; case DISPLAYED : break ; } } screwup : run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , ""."" ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
",mkj@dropbear/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,CVE-2020-36254,https://github.com/mkj/dropbear/commit/8f8a3dff705fad774a10864a2e3dbcfa9779ceff,2021-02-25T09:15Z
CWE-119,"CWE-119 static void scsi_write_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; <S2SV_StartBug> uint32_t len ; <S2SV_EndBug> uint32_t n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_WRITE ) ) { return ; } } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; if ( r -> sector_count == 0 ) { scsi_req_complete ( & r -> req , GOOD ) ; } else { <S2SV_StartBug> len = r -> sector_count * 512 ; <S2SV_EndBug> if ( len > SCSI_DMA_BUF_SIZE ) { len = SCSI_DMA_BUF_SIZE ; } r -> iov . iov_len = len ; <S2SV_StartBug> DPRINTF ( ""Write<S2SV_blank>complete<S2SV_blank>tag=0x%x<S2SV_blank>more=%d\\n"" , r -> req . tag , len ) ; <S2SV_EndBug> <S2SV_StartBug> scsi_req_data ( & r -> req , len ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ) ; uint32_t <S2SV_ModEnd> n ; if <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data <S2SV_ModStart> -> req , r -> qiov . size <S2SV_ModEnd> ) ; }
",bonzini@qemu/103b40f51e4012b3b0ad20f615562a1806d7f49a,CVE-2011-3346,https://github.com/bonzini/qemu/commit/103b40f51e4012b3b0ad20f615562a1806d7f49a,2014-04-01T06:35Z
CWE-119,"CWE-119 <S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }
","<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset
",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z
CWE-119,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
",torvalds@linux/1df2ae31c724e57be9d7ac00d78db8a5dabdd050,CVE-2012-3400,https://github.com/torvalds/linux/commit/1df2ae31c724e57be9d7ac00d78db8a5dabdd050,2012-10-03T11:02Z
CWE-787,"CWE-787 static char * get_object ( FILE * fp , int obj_id , const xref_t * xref , size_t * size , int * is_stream ) { static const int blk_sz = 256 ; int i , total_sz , read_sz , n_blks , search , stream ; size_t obj_sz ; char * c , * data ; long start ; const xref_entry_t * entry ; if ( size ) * size = 0 ; if ( is_stream ) * is_stream = 0 ; start = ftell ( fp ) ; entry = NULL ; for ( i = 0 ; i < xref -> n_entries ; i ++ ) if ( xref -> entries [ i ] . obj_id == obj_id ) { entry = & xref -> entries [ i ] ; break ; } if ( ! entry ) return NULL ; fseek ( fp , entry -> offset , SEEK_SET ) ; obj_sz = 0 ; total_sz = 0 ; n_blks = 1 ; <S2SV_StartBug> data = malloc ( blk_sz * n_blks ) ; <S2SV_EndBug> memset ( data , 0 , blk_sz * n_blks ) ; stream = 0 ; while ( ( read_sz = fread ( data + total_sz , 1 , blk_sz - 1 , fp ) ) && ! ferror ( fp ) ) { total_sz += read_sz ; * ( data + total_sz ) = '\\0' ; if ( total_sz + blk_sz >= ( blk_sz * n_blks ) ) data = realloc ( data , blk_sz * ( ++ n_blks ) ) ; search = total_sz - read_sz ; if ( search < 0 ) search = 0 ; if ( ( c = strstr ( data + search , ""endobj"" ) ) ) { * ( c + strlen ( ""endobj"" ) + 1 ) = '\\0' ; obj_sz = ( void * ) strstr ( data + search , ""endobj"" ) - ( void * ) data ; obj_sz += strlen ( ""endobj"" ) + 1 ; break ; } else if ( strstr ( data , ""stream"" ) ) stream = 1 ; } clearerr ( fp ) ; fseek ( fp , start , SEEK_SET ) ; if ( size ) * size = obj_sz ; if ( is_stream ) * is_stream = stream ; return data ; }
","<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
",enferex@pdfresurrect/0c4120fffa3dffe97b95c486a120eded82afe8a6,CVE-2019-14934,https://github.com/enferex/pdfresurrect/commit/0c4120fffa3dffe97b95c486a120eded82afe8a6,2019-08-11T22:15Z
CWE-362,"CWE-362 void flush_tlb_page ( struct vm_area_struct * vma , unsigned long start ) { struct mm_struct * mm = vma -> vm_mm ; preempt_disable ( ) ; if ( current -> active_mm == mm ) { <S2SV_StartBug> if ( current -> mm ) <S2SV_EndBug> __flush_tlb_one ( start ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> leave_mm ( smp_processor_id ( ) ) ; <S2SV_EndBug> } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , 0UL ) ; preempt_enable ( ) ; }
","<S2SV_ModStart> -> mm ) { <S2SV_ModStart> start ) ; } else { <S2SV_ModEnd> leave_mm ( smp_processor_id <S2SV_ModStart> ) ) ; smp_mb ( ) ; }
",torvalds@linux/71b3c126e61177eb693423f2e18a1914205b165e,CVE-2016-2069,https://github.com/torvalds/linux/commit/71b3c126e61177eb693423f2e18a1914205b165e,2016-04-27T17:59Z
CWE-119,"CWE-119 static void y4m_convert_null ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> _aux ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static UINT drive_process_irp_write ( DRIVE_DEVICE * drive , IRP * irp ) { DRIVE_FILE * file ; UINT32 Length ; UINT64 Offset ; <S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> return ERROR_INVALID_PARAMETER ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , Length ) ; Stream_Read_UINT64 ( irp -> input , Offset ) ; Stream_Seek ( irp -> input , 20 ) ; <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> if ( ! file ) { irp -> IoStatus = STATUS_UNSUCCESSFUL ; Length = 0 ; } else if ( ! drive_file_seek ( file , Offset ) ) { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } Stream_Write_UINT32 ( irp -> output , Length ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return irp -> Complete ( irp ) ; }
","<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-119,"CWE-119 void gdImageFillToBorder ( gdImagePtr im , int x , int y , int border , int color ) { int lastBorder ; int leftLimit = - 1 , rightLimit ; int i , restoreAlphaBlending = 0 ; <S2SV_StartBug> if ( border < 0 ) { <S2SV_EndBug> return ; } if ( ! im -> trueColor ) { if ( ( color > ( im -> colorsTotal - 1 ) ) || ( border > ( im -> colorsTotal - 1 ) ) || ( color < 0 ) ) { return ; } } restoreAlphaBlending = im -> alphaBlendingFlag ; im -> alphaBlendingFlag = 0 ; if ( x >= im -> sx ) { x = im -> sx - 1 ; } else if ( x < 0 ) { x = 0 ; } if ( y >= im -> sy ) { y = im -> sy - 1 ; } else if ( y < 0 ) { y = 0 ; } for ( i = x ; i >= 0 ; i -- ) { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; leftLimit = i ; } if ( leftLimit == - 1 ) { im -> alphaBlendingFlag = restoreAlphaBlending ; return ; } rightLimit = x ; for ( i = ( x + 1 ) ; i < im -> sx ; i ++ ) { if ( gdImageGetPixel ( im , i , y ) == border ) { break ; } gdImageSetPixel ( im , i , y , color ) ; rightLimit = i ; } if ( y > 0 ) { lastBorder = 1 ; for ( i = leftLimit ; i <= rightLimit ; i ++ ) { int c = gdImageGetPixel ( im , i , y - 1 ) ; if ( lastBorder ) { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y - 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } if ( y < ( ( im -> sy ) - 1 ) ) { lastBorder = 1 ; for ( i = leftLimit ; i <= rightLimit ; i ++ ) { int c = gdImageGetPixel ( im , i , y + 1 ) ; if ( lastBorder ) { if ( ( c != border ) && ( c != color ) ) { gdImageFillToBorder ( im , i , y + 1 , border , color ) ; lastBorder = 0 ; } } else if ( ( c == border ) || ( c == color ) ) { lastBorder = 1 ; } } } im -> alphaBlendingFlag = restoreAlphaBlending ; }
","<S2SV_ModStart> border < 0 || color < 0
",php@php-src/863d37ea66d5c960db08d6f4a2cbd2518f0f80d1,CVE-2016-9933,https://github.com/php/php-src/commit/863d37ea66d5c960db08d6f4a2cbd2518f0f80d1,2017-01-04T20:59Z
CWE-190,"CWE-190 static uint8_t * extend_raw_data ( LHAFileHeader * * header , LHAInputStream * stream , size_t nbytes ) { LHAFileHeader * new_header ; size_t new_raw_len ; <S2SV_StartBug> uint8_t * result ; <S2SV_EndBug> new_raw_len = RAW_DATA_LEN ( header ) + nbytes ; new_header = realloc ( * header , sizeof ( LHAFileHeader ) + new_raw_len ) ; if ( new_header == NULL ) { return NULL ; } * header = new_header ; new_header -> raw_data = ( uint8_t * ) ( new_header + 1 ) ; result = new_header -> raw_data + new_header -> raw_data_len ; if ( ! lha_input_stream_read ( stream , result , nbytes ) ) { return NULL ; } new_header -> raw_data_len = new_raw_len ; return result ; }
","<S2SV_ModStart> * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
",fragglet@lhasa/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564,CVE-2016-2347,https://github.com/fragglet/lhasa/commit/6fcdb8f1f538b9d63e63a5fa199c5514a15d4564,2017-04-21T20:59Z
CWE-190,"CWE-190 MONGO_EXPORT int mongo_insert_batch ( mongo * conn , const char * ns , const bson * * bsons , int count , mongo_write_concern * custom_write_concern , int flags ) { mongo_message * mm ; mongo_write_concern * write_concern = NULL ; int i ; char * data ; <S2SV_StartBug> int overhead = 16 + 4 + strlen ( ns ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> int size = overhead ; <S2SV_EndBug> if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ; for ( i = 0 ; i < count ; i ++ ) { size += bson_size ( bsons [ i ] ) ; if ( mongo_bson_valid ( conn , bsons [ i ] , 1 ) != MONGO_OK ) return MONGO_ERROR ; } if ( ( size - overhead ) > conn -> max_bson_size ) { conn -> err = MONGO_BSON_TOO_LARGE ; return MONGO_ERROR ; } if ( mongo_choose_write_concern ( conn , custom_write_concern , & write_concern ) == MONGO_ERROR ) { return MONGO_ERROR ; } mm = mongo_message_create ( size , 0 , 0 , MONGO_OP_INSERT ) ; data = & mm -> data ; if ( flags & MONGO_CONTINUE_ON_ERROR ) data = mongo_data_append32 ( data , & ONE ) ; else data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , ns , strlen ( ns ) + 1 ) ; for ( i = 0 ; i < count ; i ++ ) { data = mongo_data_append ( data , bsons [ i ] -> data , bson_size ( bsons [ i ] ) ) ; } if ( write_concern ) { if ( mongo_message_send ( conn , mm ) == MONGO_ERROR ) { return MONGO_ERROR ; } return mongo_check_last_error ( conn , ns , write_concern ) ; } else { return mongo_message_send ( conn , mm ) ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> overhead = 16 <S2SV_ModStart> + 1 ; size_t <S2SV_ModEnd> size = overhead
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-264,"CWE-264 static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( lc -> <S2SV_ModStart> ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z
CWE-19,"CWE-19 void ext2_xattr_delete_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } ea_bdebug ( bh , ""b_count=%d"" , atomic_read ( & ( bh -> b_count ) ) ) ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { ext2_error ( inode -> i_sb , ""ext2_xattr_delete_inode"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> lock_buffer ( bh ) ; if ( HDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ext2_free_blocks ( inode , EXT2_I ( inode ) -> i_file_acl , 1 ) ; get_bh ( bh ) ; bforget ( bh ) ; unlock_buffer ( bh ) ; } else { <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; ea_bdebug ( bh , ""refcount<S2SV_blank>now=%d"" , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; unlock_buffer ( bh ) ; mark_buffer_dirty ( bh ) ; if ( IS_SYNC ( inode ) ) sync_dirty_buffer ( bh ) ; dquot_free_block_nodirty ( inode , 1 ) ; } EXT2_I ( inode ) -> i_file_acl = 0 ; cleanup : brelse ( bh ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; }
","<S2SV_ModStart> = NULL ; <S2SV_ModEnd> down_write ( & <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; ext2_free_blocks <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; ea_bdebug
",torvalds@linux/be0726d33cb8f411945884664924bed3cb8c70ee,CVE-2015-8952,https://github.com/torvalds/linux/commit/be0726d33cb8f411945884664924bed3cb8c70ee,2016-10-16T21:59Z
CWE-119,"CWE-119 static INLINE int get_tx_eob ( const struct segmentation * seg , int segment_id , TX_SIZE tx_size ) { const int eob_max = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> return vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ? 0 : eob_max ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return segfeature_active <S2SV_ModEnd> ( seg ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 __visible __notrace_funcgraph struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) { struct thread_struct * prev = & prev_p -> thread ; struct thread_struct * next = & next_p -> thread ; int cpu = smp_processor_id ( ) ; struct tss_struct * tss = & per_cpu ( init_tss , cpu ) ; unsigned fsindex , gsindex ; fpu_switch_t fpu ; fpu = switch_fpu_prepare ( prev_p , next_p , cpu ) ; load_sp0 ( tss , next ) ; <S2SV_StartBug> savesegment ( es , prev -> es ) ; <S2SV_EndBug> if ( unlikely ( next -> es | prev -> es ) ) loadsegment ( es , next -> es ) ; savesegment ( ds , prev -> ds ) ; if ( unlikely ( next -> ds | prev -> ds ) ) <S2SV_StartBug> loadsegment ( ds , next -> ds ) ; <S2SV_EndBug> savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; if ( unlikely ( fsindex | next -> fsindex | prev -> fs ) ) { loadsegment ( fs , next -> fsindex ) ; if ( fsindex ) prev -> fs = 0 ; } if ( next -> fs ) wrmsrl ( MSR_FS_BASE , next -> fs ) ; prev -> fsindex = fsindex ; if ( unlikely ( gsindex | next -> gsindex | prev -> gs ) ) { load_gs_index ( next -> gsindex ) ; if ( gsindex ) prev -> gs = 0 ; } if ( next -> gs ) wrmsrl ( MSR_KERNEL_GS_BASE , next -> gs ) ; prev -> gsindex = gsindex ; switch_fpu_finish ( next_p , fpu ) ; prev -> usersp = this_cpu_read ( old_rsp ) ; this_cpu_write ( old_rsp , next -> usersp ) ; this_cpu_write ( current_task , next_p ) ; task_thread_info ( prev_p ) -> saved_preempt_count = this_cpu_read ( __preempt_count ) ; this_cpu_write ( __preempt_count , task_thread_info ( next_p ) -> saved_preempt_count ) ; this_cpu_write ( kernel_stack , ( unsigned long ) task_stack_page ( next_p ) + THREAD_SIZE - KERNEL_STACK_OFFSET ) ; if ( unlikely ( task_thread_info ( next_p ) -> flags & _TIF_WORK_CTXSW_NEXT || task_thread_info ( prev_p ) -> flags & _TIF_WORK_CTXSW_PREV ) ) __switch_to_xtra ( prev_p , next_p , tss ) ; return prev_p ; }
","<S2SV_ModStart> ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> next -> ds <S2SV_ModEnd> ) ; if
",torvalds@linux/f647d7c155f069c1a068030255c300663516420e,CVE-2014-9419,https://github.com/torvalds/linux/commit/f647d7c155f069c1a068030255c300663516420e,2014-12-26T00:59Z
CWE-416,"CWE-416 static ssize_t sg_write ( struct file * filp , const char __user * buf , size_t count , loff_t * ppos ) { int mxsize , cmd_size , k ; int input_size , blocking ; unsigned char opcode ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; struct sg_header old_hdr ; sg_io_hdr_t * hp ; unsigned char cmnd [ SG_MAX_CDB_SIZE ] ; <S2SV_StartBug> if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) <S2SV_EndBug> return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank>count=%d\\n"" , ( int ) count ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_READ , buf , count ) ) return - EFAULT ; if ( count < SZ_SG_HEADER ) return - EIO ; if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) ) return - EFAULT ; blocking = ! ( filp -> f_flags & O_NONBLOCK ) ; if ( old_hdr . reply_len < 0 ) return sg_new_write ( sfp , filp , buf , count , blocking , 0 , 0 , NULL ) ; if ( count < ( SZ_SG_HEADER + 6 ) ) return - EIO ; if ( ! ( srp = sg_add_request ( sfp ) ) ) { SCSI_LOG_TIMEOUT ( 1 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank>queue<S2SV_blank>full\\n"" ) ) ; return - EDOM ; } buf += SZ_SG_HEADER ; __get_user ( opcode , buf ) ; if ( sfp -> next_cmd_len > 0 ) { cmd_size = sfp -> next_cmd_len ; sfp -> next_cmd_len = 0 ; } else { cmd_size = COMMAND_SIZE ( opcode ) ; if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte ) cmd_size = 12 ; } SCSI_LOG_TIMEOUT ( 4 , sg_printk ( KERN_INFO , sdp , ""sg_write:<S2SV_blank><S2SV_blank><S2SV_blank>scsi<S2SV_blank>opcode=0x%02x,<S2SV_blank>cmd_size=%d\\n"" , ( int ) opcode , cmd_size ) ) ; input_size = count - cmd_size ; mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len ; mxsize -= SZ_SG_HEADER ; input_size -= SZ_SG_HEADER ; if ( input_size < 0 ) { sg_remove_request ( sfp , srp ) ; return - EIO ; } hp = & srp -> header ; hp -> interface_id = '\\0' ; hp -> cmd_len = ( unsigned char ) cmd_size ; hp -> iovec_count = 0 ; hp -> mx_sb_len = 0 ; if ( input_size > 0 ) hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV ; else hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE ; hp -> dxfer_len = mxsize ; if ( ( hp -> dxfer_direction == SG_DXFER_TO_DEV ) || ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) ) hp -> dxferp = ( char __user * ) buf + cmd_size ; else hp -> dxferp = NULL ; hp -> sbp = NULL ; hp -> timeout = old_hdr . reply_len ; hp -> flags = input_size ; hp -> pack_id = old_hdr . pack_id ; hp -> usr_ptr = NULL ; if ( __copy_from_user ( cmnd , buf , cmd_size ) ) return - EFAULT ; if ( hp -> dxfer_direction == SG_DXFER_TO_FROM_DEV ) { static char cmd [ TASK_COMM_LEN ] ; if ( strcmp ( current -> comm , cmd ) ) { printk_ratelimited ( KERN_WARNING ""sg_write:<S2SV_blank>data<S2SV_blank>in/out<S2SV_blank>%d/%d<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>SCSI<S2SV_blank>command<S2SV_blank>0x%x--<S2SV_blank>guessing<S2SV_blank>"" ""data<S2SV_blank>in;\\n<S2SV_blank><S2SV_blank><S2SV_blank>program<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>setting<S2SV_blank>"" ""count<S2SV_blank>and/or<S2SV_blank>reply_len<S2SV_blank>properly\\n"" , old_hdr . reply_len - ( int ) SZ_SG_HEADER , input_size , ( unsigned int ) cmnd [ 0 ] , current -> comm ) ; strcpy ( cmd , current -> comm ) ; } } k = sg_common_write ( sfp , srp , cmnd , sfp -> timeout , blocking ) ; return ( k < 0 ) ? k : count ; }
","<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
",torvalds@linux/128394eff343fc6d2f32172f03e24829539c5835,CVE-2016-10088,https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835,2016-12-30T18:59Z
CWE-416,"CWE-416 static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; } while ( len ) ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; if ( input_wakeup ) wakeup_pipe_writers ( ipipe ) ; return ret ; }
","<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
CWE-369,"CWE-369 static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
","<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
",uclouvain@openjpeg/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,CVE-2016-10506,https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,2017-08-30T09:29Z
CWE-000,"CWE-000 static void sas_eh_finish_cmd ( struct scsi_cmnd * cmd ) { struct sas_ha_struct * sas_ha = SHOST_TO_SAS_HA ( cmd -> device -> host ) ; <S2SV_StartBug> struct sas_task * task = TO_SAS_TASK ( cmd ) ; <S2SV_EndBug> sas_end_task ( cmd , task ) ; <S2SV_StartBug> scsi_eh_finish_cmd ( cmd , & sas_ha -> eh_done_q ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
",torvalds@linux/318aaf34f1179b39fa9c30fa0f3288b645beee39,CVE-2018-10021,https://github.com/torvalds/linux/commit/318aaf34f1179b39fa9c30fa0f3288b645beee39,2018-04-11T17:29Z
CWE-404,"CWE-404 int nfssvc_decode_readdirargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readdirargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; args -> cookie = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ; args -> count = min_t ( u32 , args -> count , PAGE_SIZE ) ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> PAGE_SIZE ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-125,"CWE-125 int obj2ast_arg ( PyObject * obj , arg_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty annotation ; <S2SV_StartBug> int lineno ; <S2SV_EndBug> int col_offset ; int end_lineno ; int end_col_offset ; if ( _PyObject_LookupAttrId ( obj , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_lineno = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_col_offset = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> expr_ty annotation ; string type_comment ; <S2SV_ModStart> , & annotation , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModStart> , annotation , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-200,"CWE-200 static int sco_sock_getsockopt_old ( struct socket * sock , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct sco_options opts ; struct sco_conninfo cinfo ; int len , err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case SCO_OPTIONS : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } opts . mtu = sco_pi ( sk ) -> conn -> mtu ; BT_DBG ( ""mtu<S2SV_blank>%d"" , opts . mtu ) ; len = min_t ( unsigned int , len , sizeof ( opts ) ) ; if ( copy_to_user ( optval , ( char * ) & opts , len ) ) err = - EFAULT ; break ; case SCO_CONNINFO : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } <S2SV_StartBug> cinfo . hci_handle = sco_pi ( sk ) -> conn -> hcon -> handle ; <S2SV_EndBug> memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ; len = min_t ( unsigned int , len , sizeof ( cinfo ) ) ; if ( copy_to_user ( optval , ( char * ) & cinfo , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }
","<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
",torvalds@linux/c4c896e1471aec3b004a693c689f60be3b17ac86,CVE-2011-1078,https://github.com/torvalds/linux/commit/c4c896e1471aec3b004a693c689f60be3b17ac86,2012-06-21T23:55Z
CWE-119,"CWE-119 static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { const uint8_t * data_start = data ; <S2SV_StartBug> const uint8_t * data_end = data + data_sz ; <S2SV_EndBug> <S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> uint32_t sizes [ 8 ] ; <S2SV_StartBug> int frames_this_pts , frame_count = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( data == NULL || data_sz == 0 ) <S2SV_EndBug> <S2SV_StartBug> return VPX_CODEC_INVALID_PARAM ; <S2SV_EndBug> <S2SV_StartBug> parse_superframe_index ( data , data_sz , sizes , & frames_this_pts ) ; <S2SV_EndBug> do { if ( data_sz && ( * data_start & 0xe0 ) == 0xc0 ) { <S2SV_StartBug> const uint8_t marker = * data_start ; <S2SV_EndBug> const uint32_t frames = ( marker & 0x7 ) + 1 ; const uint32_t mag = ( ( marker >> 3 ) & 0x3 ) + 1 ; const uint32_t index_sz = 2 + mag * frames ; if ( data_sz >= index_sz && data_start [ index_sz - 1 ] == marker ) { data_start += index_sz ; data_sz -= index_sz ; if ( data_start < data_end ) continue ; else break ; } } if ( frames_this_pts ) { uint32_t this_sz = sizes [ frame_count ] ; if ( data_sz < this_sz ) { ctx -> base . err_detail = ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ; return VPX_CODEC_CORRUPT_FRAME ; } data_sz = this_sz ; frame_count ++ ; } res = decode_one ( ctx , & data_start , data_sz , user_priv , deadline ) ; assert ( data_start >= data ) ; assert ( data_start <= data_end ) ; if ( res ) break ; while ( data_start < data_end && * data_start == 0 ) data_start ++ ; data_sz = ( unsigned int ) ( data_end - data_start ) ; } while ( data_start < data_end ) ; return res ; }
","<S2SV_ModStart> const uint8_t * const <S2SV_ModStart> ; vpx_codec_err_t res ; uint32_t frame_sizes <S2SV_ModEnd> [ 8 ] <S2SV_ModStart> ] ; int frame_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> data == NULL && <S2SV_ModEnd> data_sz == 0 <S2SV_ModStart> == 0 ) { ctx -> flushed = 1 ; return VPX_CODEC_OK ; } ctx -> flushed = 0 ; if ( ctx -> frame_workers == NULL ) { const vpx_codec_err_t res = init_decoder ( ctx ) ; if ( res != VPX_CODEC_OK ) return res ; } res = vp9_parse_superframe_index <S2SV_ModEnd> ( data , <S2SV_ModStart> , data_sz , frame_sizes , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( res != VPX_CODEC_OK ) return res ; if ( ctx -> frame_parallel_decode ) { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , ""Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full."" ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; } } else { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; vpx_codec_err_t res ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , ""Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index"" ) ; return VPX_CODEC_CORRUPT_FRAME ; } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { while ( data_start < data_end ) { const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; while ( data_start < data_end <S2SV_ModEnd> ) { const <S2SV_ModStart> uint8_t marker = read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ; if ( marker ) break ; ++ data_start ; } } } } <S2SV_ModEnd> return res ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 static inline void set_socket_blocking ( int s , int blocking ) { int opts ; <S2SV_StartBug> opts = fcntl ( s , F_GETFL ) ; <S2SV_EndBug> if ( opts < 0 ) APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ; if ( blocking ) opts &= ~ O_NONBLOCK ; else opts |= O_NONBLOCK ; <S2SV_StartBug> if ( fcntl ( s , F_SETFL , opts ) < 0 ) <S2SV_EndBug> APPL_TRACE_ERROR ( ""set<S2SV_blank>blocking<S2SV_blank>(%s)"" , strerror ( errno ) ) ; }
","<S2SV_ModStart> ; opts = TEMP_FAILURE_RETRY ( <S2SV_ModStart> s , F_GETFL ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> F_SETFL , opts )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; one = 1 ; image = AcquireImage ( image_info ) ; image -> depth = 8 ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } Header . FileId = ReadBlobLSBLong ( image ) ; Header . DataOffset = ( MagickOffsetType ) ReadBlobLSBLong ( image ) ; Header . ProductType = ReadBlobLSBShort ( image ) ; Header . FileType = ReadBlobLSBShort ( image ) ; Header . MajorVersion = ReadBlobByte ( image ) ; Header . MinorVersion = ReadBlobByte ( image ) ; Header . EncryptKey = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . FileId != 0x435057FF || ( Header . ProductType >> 8 ) != 0x16 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( Header . EncryptKey != 0 ) ThrowReaderException ( CoderError , ""EncryptedWPGImageFileNotSupported"" ) ; image -> columns = 1 ; image -> rows = 1 ; image -> colors = 0 ; bpp = 0 ; BitmapHeader2 . RotAngle = 0 ; Rec2 . RecordLength = 0 ; switch ( Header . FileType ) { case 1 : while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec . RecordLength ; switch ( Rec . RecType ) { case 0x0B : BitmapHeader1 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader1 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader1 . Width == 0 ) || ( BitmapHeader1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader1 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader1 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader1 . VertRes = ReadBlobLSBShort ( image ) ; if ( BitmapHeader1 . HorzRes && BitmapHeader1 . VertRes ) { image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = BitmapHeader1 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader1 . VertRes / 470.0 ; } image -> columns = BitmapHeader1 . Width ; image -> rows = BitmapHeader1 . Height ; bpp = BitmapHeader1 . Depth ; goto UnpackRaster ; case 0x0E : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > <S2SV_StartBug> ( Rec2 . RecordLength - 2 - 2 ) / 3 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } break ; case 0x11 : if ( Rec . RecordLength > 8 ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 8 , ( ssize_t ) Rec . RecordLength - 8 , exception ) ; break ; case 0x14 : BitmapHeader2 . RotAngle = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . LowLeftY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightX = ReadBlobLSBShort ( image ) ; BitmapHeader2 . UpRightY = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Width = ReadBlobLSBShort ( image ) ; BitmapHeader2 . Height = ReadBlobLSBShort ( image ) ; if ( ( BitmapHeader2 . Width == 0 ) || ( BitmapHeader2 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; BitmapHeader2 . Depth = ReadBlobLSBShort ( image ) ; BitmapHeader2 . HorzRes = ReadBlobLSBShort ( image ) ; BitmapHeader2 . VertRes = ReadBlobLSBShort ( image ) ; image -> units = PixelsPerCentimeterResolution ; image -> page . width = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightX ) / 470.0 ) ; image -> page . height = ( unsigned int ) ( ( BitmapHeader2 . LowLeftX - BitmapHeader2 . UpRightY ) / 470.0 ) ; image -> page . x = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; image -> page . y = ( int ) ( BitmapHeader2 . LowLeftX / 470.0 ) ; if ( BitmapHeader2 . HorzRes && BitmapHeader2 . VertRes ) { image -> x_resolution = BitmapHeader2 . HorzRes / 470.0 ; image -> y_resolution = BitmapHeader2 . VertRes / 470.0 ; } image -> columns = BitmapHeader2 . Width ; image -> rows = BitmapHeader2 . Height ; bpp = BitmapHeader2 . Depth ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp <= 16 ) ) { image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) { NoMemory : ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; ( i < ( int ) image -> colors ) && ( i < 256 ) ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( WPG1_Palette [ i ] . Red ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( WPG1_Palette [ i ] . Green ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( WPG1_Palette [ i ] . Blue ) ; } } else { if ( bpp < 24 ) if ( ( image -> colors < ( one << bpp ) ) && ( bpp != 24 ) ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } if ( bpp == 1 ) { if ( image -> colormap [ 0 ] . red == 0 && image -> colormap [ 0 ] . green == 0 && image -> colormap [ 0 ] . blue == 0 && image -> colormap [ 1 ] . red == 0 && image -> colormap [ 1 ] . green == 0 && image -> colormap [ 1 ] . blue == 0 ) { image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; } } if ( UnpackWPGRaster ( image , bpp ) < 0 ) { DecompressionFailed : ThrowReaderException ( CoderError , ""UnableToDecompressImage"" ) ; } if ( Rec . RecType == 0x14 && BitmapHeader2 . RotAngle != 0 && ! image_info -> ping ) { if ( BitmapHeader2 . RotAngle & 0x8000 ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x2000 ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } if ( BitmapHeader2 . RotAngle & 0x0FFF ) { Image * rotate_image ; rotate_image = RotateImage ( image , ( BitmapHeader2 . RotAngle & 0x0FFF ) , exception ) ; if ( rotate_image != ( Image * ) NULL ) { DuplicateBlob ( rotate_image , image ) ; ReplaceImageInList ( & image , rotate_image ) ; } } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x1B : if ( Rec . RecordLength > 0x3C ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + 0x3C , ( ssize_t ) Rec . RecordLength - 0x3C , exception ) ; break ; } } break ; case 2 : ( void ) memset ( CTM , 0 , sizeof ( CTM ) ) ; StartWPG . PosSizePrecision = 0 ; while ( ! EOFBlob ( image ) ) { ( void ) SeekBlob ( image , Header . DataOffset , SEEK_SET ) ; if ( EOFBlob ( image ) ) break ; Rec2 . Class = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rec2 . RecType = ( i = ReadBlobByte ( image ) ) ; if ( i == EOF ) break ; Rd_WP_DWORD ( image , & Rec2 . Extension ) ; Rd_WP_DWORD ( image , & Rec2 . RecordLength ) ; if ( EOFBlob ( image ) ) break ; Header . DataOffset = TellBlob ( image ) + Rec2 . RecordLength ; switch ( Rec2 . RecType ) { case 1 : StartWPG . HorizontalUnits = ReadBlobLSBShort ( image ) ; StartWPG . VerticalUnits = ReadBlobLSBShort ( image ) ; StartWPG . PosSizePrecision = ReadBlobByte ( image ) ; break ; case 0x0C : WPG_Palette . StartIndex = ReadBlobLSBShort ( image ) ; WPG_Palette . NumOfEntries = ReadBlobLSBShort ( image ) ; if ( ( WPG_Palette . NumOfEntries - WPG_Palette . StartIndex ) > ( Rec2 . RecordLength - 2 - 2 ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; image -> colors = WPG_Palette . NumOfEntries ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = WPG_Palette . StartIndex ; i < ( int ) WPG_Palette . NumOfEntries ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( char ) ReadBlobByte ( image ) ) ; ( void ) ReadBlobByte ( image ) ; } break ; case 0x0E : Bitmap2Header1 . Width = ReadBlobLSBShort ( image ) ; Bitmap2Header1 . Height = ReadBlobLSBShort ( image ) ; if ( ( Bitmap2Header1 . Width == 0 ) || ( Bitmap2Header1 . Height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; Bitmap2Header1 . Depth = ReadBlobByte ( image ) ; Bitmap2Header1 . Compression = ReadBlobByte ( image ) ; if ( Bitmap2Header1 . Compression > 1 ) continue ; switch ( Bitmap2Header1 . Depth ) { case 1 : bpp = 1 ; break ; case 2 : bpp = 2 ; break ; case 3 : bpp = 4 ; break ; case 4 : bpp = 8 ; break ; case 8 : bpp = 24 ; break ; default : continue ; } image -> columns = Bitmap2Header1 . Width ; image -> rows = Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) break ; if ( ( image -> colors == 0 ) && ( bpp != 24 ) ) { size_t one ; one = 1 ; image -> colors = one << bpp ; if ( ! AcquireImageColormap ( image , image -> colors ) ) goto NoMemory ; } else { if ( bpp < 24 ) if ( image -> colors < ( one << bpp ) && bpp != 24 ) image -> colormap = ( PixelPacket * ) ResizeQuantumMemory ( image -> colormap , ( size_t ) ( one << bpp ) , sizeof ( * image -> colormap ) ) ; } switch ( Bitmap2Header1 . Compression ) { case 0 : { ldblk = ( ssize_t ) ( ( bpp * image -> columns + 7 ) / 8 ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk + 1 , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == ( unsigned char * ) NULL ) goto NoMemory ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { ( void ) ReadBlob ( image , ldblk , BImgBuff ) ; InsertRow ( BImgBuff , i , image , bpp ) ; } if ( BImgBuff ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; break ; } case 1 : { if ( UnpackWPG2Raster ( image , bpp ) < 0 ) goto DecompressionFailed ; break ; } } if ( CTM [ 0 ] [ 0 ] < 0 && ! image_info -> ping ) { Image * flop_image ; flop_image = FlopImage ( image , exception ) ; if ( flop_image != ( Image * ) NULL ) { DuplicateBlob ( flop_image , image ) ; ReplaceImageInList ( & image , flop_image ) ; } } if ( CTM [ 1 ] [ 1 ] < 0 && ! image_info -> ping ) { Image * flip_image ; flip_image = FlipImage ( image , exception ) ; if ( flip_image != ( Image * ) NULL ) { DuplicateBlob ( flip_image , image ) ; ReplaceImageInList ( & image , flip_image ) ; } } AcquireNextImage ( image_info , image ) ; image -> depth = 8 ; if ( image -> next == ( Image * ) NULL ) goto Finish ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 1 ; image -> colors = 0 ; break ; case 0x12 : i = ReadBlobLSBShort ( image ) ; if ( Rec2 . RecordLength > ( unsigned int ) i ) image = ExtractPostscript ( image , image_info , TellBlob ( image ) + i , ( ssize_t ) ( Rec2 . RecordLength - i - 2 ) , exception ) ; break ; case 0x1B : WPG2Flags = LoadWPG2Flags ( image , StartWPG . PosSizePrecision , NULL , & CTM ) ; ( void ) WPG2Flags ; break ; } } break ; default : { ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; } } Finish : ( void ) CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = ( size_t ) scene ++ ; } if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImageFileDoesNotContainAnyImageData"" ) ; return ( image ) ; }
","<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , ""InvalidColormapIndex"" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
",ImageMagick@ImageMagick/e04cf3e9524f50ca336253513d977224e083b816,CVE-2017-16546,https://github.com/ImageMagick/ImageMagick/commit/e04cf3e9524f50ca336253513d977224e083b816,2017-11-05T22:29Z
CWE-476,"CWE-476 static int jp2_bpcc_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_bpcc_t * bpcc = & box -> data . bpcc ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> bpcc -> numcmpts = box -> datalen ; if ( ! ( bpcc -> bpcs = jas_alloc2 ( bpcc -> numcmpts , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < bpcc -> numcmpts ; ++ i ) { if ( jp2_getuint8 ( in , & bpcc -> bpcs [ i ] ) ) { return - 1 ; } } return 0 ; }
","<S2SV_ModStart> unsigned int i ; bpcc -> bpcs = 0
",mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z
CWE-22,"CWE-22 DEFINE_TEST ( test_write_disk_secure ) { # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) skipping ( ""archive_write_disk<S2SV_blank>security<S2SV_blank>checks<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>Windows"" ) ; # else struct archive * a ; struct archive_entry * ae ; struct stat st ; assertUmask ( UMASK ) ; assert ( ( a = archive_write_disk_new ( ) ) != NULL ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""dir"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/filea"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir/fileb"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS ) ; failure ( ""Extracting<S2SV_blank>a<S2SV_blank>file<S2SV_blank>through<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir2/filec"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_SYMLINKS | ARCHIVE_EXTRACT_UNLINK ) ; assertEqualIntA ( a , ARCHIVE_OK , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir3"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir3"" , & st ) ) ; assert ( S_ISLNK ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""nonexistent_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir4"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir4"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""non_dir"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFLNK | 0777 ) ; archive_entry_set_symlink ( ae , ""non_dir"" ) ; archive_write_disk_set_options ( a , 0 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""link_to_dir5"" ) ; archive_entry_set_mode ( ae , S_IFDIR | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertEqualInt ( 0 , lstat ( ""link_to_dir5"" , & st ) ) ; assert ( S_ISDIR ( st . st_mode ) ) ; archive_entry_free ( ae ) ; <S2SV_StartBug> assertEqualInt ( ARCHIVE_OK , archive_write_free ( a ) ) ; <S2SV_EndBug> assert ( 0 == lstat ( ""dir"" , & st ) ) ; failure ( ""dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir"" , & st ) ) ; failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( S_ISLNK ( st . st_mode ) ) ; # if HAVE_LCHMOD failure ( ""link_to_dir:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif assert ( 0 == lstat ( ""dir/filea"" , & st ) ) ; failure ( ""dir/filea:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; failure ( ""dir/fileb:<S2SV_blank>This<S2SV_blank>file<S2SV_blank>should<S2SV_blank>not<S2SV_blank>have<S2SV_blank>been<S2SV_blank>created"" ) ; assert ( 0 != lstat ( ""dir/fileb"" , & st ) ) ; assert ( 0 == lstat ( ""link_to_dir2"" , & st ) ) ; failure ( ""link_to_dir2<S2SV_blank>should<S2SV_blank>have<S2SV_blank>been<S2SV_blank>re-created<S2SV_blank>as<S2SV_blank>a<S2SV_blank>true<S2SV_blank>dir"" ) ; assert ( S_ISDIR ( st . st_mode ) ) ; failure ( ""link_to_dir2:<S2SV_blank>Implicit<S2SV_blank>dir<S2SV_blank>creation<S2SV_blank>should<S2SV_blank>obey<S2SV_blank>umask,<S2SV_blank>but<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 0777 ) == 0755 ) ; assert ( 0 == lstat ( ""link_to_dir2/filec"" , & st ) ) ; assert ( S_ISREG ( st . st_mode ) ) ; failure ( ""link_to_dir2/filec:<S2SV_blank>st.st_mode=%o"" , st . st_mode ) ; assert ( ( st . st_mode & 07777 ) == 0755 ) ; # endif }
","<S2SV_ModStart> ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; assert ( 0 == unlink ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( ""Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here."" ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( ""/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp"" ) ;
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-399,"CWE-399 static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; <S2SV_StartBug> struct resv_map * reservations = vma_resv_map ( vma ) ; <S2SV_EndBug> unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; kref_put ( & reservations -> refs , resv_map_release ) ; if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; <S2SV_StartBug> hugetlb_put_quota ( vma -> vm_file -> f_mapping , reserve ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve )
",torvalds@linux/90481622d75715bfcb68501280a917dbfe516029,CVE-2012-2133,https://github.com/torvalds/linux/commit/90481622d75715bfcb68501280a917dbfe516029,2012-07-03T16:40Z
CWE-787,"CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; j ++ ; szLine [ i ] &= 0xbf ; } else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } szLineConv [ j ] = szLine [ i ] ; j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; <S2SV_StartBug> szLineConv [ i ] = 0 ; <S2SV_EndBug> strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
","<S2SV_ModStart> sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
",gpac@gpac/4c1360818fc8948e9307059fba4dc47ba8ad255d,CVE-2018-20760,https://github.com/gpac/gpac/commit/4c1360818fc8948e9307059fba4dc47ba8ad255d,2019-02-06T23:29Z
CWE-17,"CWE-17 int ip_forward ( struct sk_buff * skb ) { u32 mtu ; struct iphdr * iph ; struct rtable * rt ; struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; if ( skb -> pkt_type != PACKET_HOST ) goto drop ; if ( skb_warn_if_lro ( skb ) ) goto drop ; if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_FWD , skb ) ) goto drop ; if ( IPCB ( skb ) -> opt . router_alert && ip_call_ra_chain ( skb ) ) return NET_RX_SUCCESS ; skb_forward_csum ( skb ) ; if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ; if ( ! xfrm4_route_forward ( skb ) ) goto drop ; rt = skb_rtable ( skb ) ; if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ; IPCB ( skb ) -> flags |= IPSKB_FORWARDED ; mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ; if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) { IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ; icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ; goto drop ; } if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ; iph = ip_hdr ( skb ) ; ip_decrease_ttl ( iph ) ; <S2SV_StartBug> if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) <S2SV_EndBug> ip_rt_send_redirect ( skb ) ; skb -> priority = rt_tos2priority ( iph -> tos ) ; return NF_HOOK ( NFPROTO_IPV4 , NF_INET_FORWARD , skb , skb -> dev , rt -> dst . dev , ip_forward_finish ) ; sr_failed : icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_SR_FAILED , 0 ) ; goto drop ; too_many_hops : IP_INC_STATS_BH ( dev_net ( skb_dst ( skb ) -> dev ) , IPSTATS_MIB_INHDRERRORS ) ; icmp_send ( skb , ICMP_TIME_EXCEEDED , ICMP_EXC_TTL , 0 ) ; drop : kfree_skb ( skb ) ; return NET_RX_DROP ; }
","<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> && ! opt
",torvalds@linux/df4d92549f23e1c037e83323aff58a21b3de7fe0,CVE-2015-1465,https://github.com/torvalds/linux/commit/df4d92549f23e1c037e83323aff58a21b3de7fe0,2015-04-05T21:59Z
CWE-125,"CWE-125 int cli_scanxar ( cli_ctx * ctx ) { int rc = CL_SUCCESS ; unsigned int cksum_fails = 0 ; unsigned int extract_errors = 0 ; # if HAVE_LIBXML2 int fd = - 1 ; struct xar_header hdr ; fmap_t * map = * ctx -> fmap ; <S2SV_StartBug> long length , offset , size , at ; <S2SV_EndBug> int encoding ; z_stream strm ; char * toc , * tmpname ; xmlTextReaderPtr reader = NULL ; int a_hash , e_hash ; unsigned char * a_cksum = NULL , * e_cksum = NULL ; void * a_hash_ctx = NULL , * e_hash_ctx = NULL ; char result [ SHA1_HASH_SIZE ] ; memset ( & strm , 0x00 , sizeof ( z_stream ) ) ; if ( fmap_readn ( * ctx -> fmap , & hdr , 0 , sizeof ( hdr ) ) != sizeof ( hdr ) ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Invalid<S2SV_blank>header,<S2SV_blank>too<S2SV_blank>short.\\n"" ) ; return CL_EFORMAT ; } hdr . magic = be32_to_host ( hdr . magic ) ; if ( hdr . magic == XAR_HEADER_MAGIC ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Matched<S2SV_blank>magic\\n"" ) ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Invalid<S2SV_blank>magic\\n"" ) ; return CL_EFORMAT ; } hdr . size = be16_to_host ( hdr . size ) ; hdr . version = be16_to_host ( hdr . version ) ; hdr . toc_length_compressed = be64_to_host ( hdr . toc_length_compressed ) ; hdr . toc_length_decompressed = be64_to_host ( hdr . toc_length_decompressed ) ; hdr . chksum_alg = be32_to_host ( hdr . chksum_alg ) ; strm . next_in = ( unsigned char * ) fmap_need_off_once ( * ctx -> fmap , hdr . size , hdr . toc_length_compressed ) ; if ( strm . next_in == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>fmap_need_off_once<S2SV_blank>fails<S2SV_blank>on<S2SV_blank>TOC.\\n"" ) ; return CL_EREAD ; } strm . avail_in = hdr . toc_length_compressed ; toc = cli_malloc ( hdr . toc_length_decompressed + 1 ) ; if ( toc == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_malloc<S2SV_blank>fails<S2SV_blank>on<S2SV_blank>TOC<S2SV_blank>decompress<S2SV_blank>buffer.\\n"" ) ; return CL_EMEM ; } toc [ hdr . toc_length_decompressed ] = '\\0' ; strm . avail_out = hdr . toc_length_decompressed ; strm . next_out = ( unsigned char * ) toc ; rc = inflateInit ( & strm ) ; if ( rc != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:inflateInit<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; goto exit_toc ; } rc = inflate ( & strm , Z_SYNC_FLUSH ) ; if ( rc != Z_OK && rc != Z_STREAM_END ) { cli_dbgmsg ( ""cli_scanxar:inflate<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; goto exit_toc ; } rc = inflateEnd ( & strm ) ; if ( rc != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:inflateEnd<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>\\n"" , rc ) ; rc = CL_EFORMAT ; <S2SV_StartBug> goto exit_toc ; <S2SV_EndBug> } cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>scanning<S2SV_blank>xar<S2SV_blank>TOC<S2SV_blank>xml<S2SV_blank>in<S2SV_blank>memory.\\n"" ) ; rc = cli_mem_scandesc ( toc , hdr . toc_length_decompressed , ctx ) ; if ( rc != CL_SUCCESS ) { if ( rc != CL_VIRUS || ! SCAN_ALL ) goto exit_toc ; } if ( ctx -> engine -> keeptmp ) { if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>file<S2SV_blank>for<S2SV_blank>TOC.\\n"" ) ; goto exit_toc ; } if ( cli_writen ( fd , toc , hdr . toc_length_decompressed ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>TOC.\\n"" ) ; rc = CL_EWRITE ; xar_cleanup_temp_file ( ctx , fd , tmpname ) ; goto exit_toc ; } rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( rc != CL_SUCCESS ) goto exit_toc ; } reader = xmlReaderForMemory ( toc , hdr . toc_length_decompressed , ""noname.xml"" , NULL , CLAMAV_MIN_XMLREADER_FLAGS ) ; if ( reader == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>xmlReaderForMemory<S2SV_blank>error<S2SV_blank>for<S2SV_blank>TOC\\n"" ) ; goto exit_toc ; } rc = xar_scan_subdocuments ( reader , ctx ) ; if ( rc != CL_SUCCESS ) { cli_dbgmsg ( ""xar_scan_subdocuments<S2SV_blank>returns<S2SV_blank>%i.\\n"" , rc ) ; goto exit_reader ; } fd = - 1 ; tmpname = NULL ; while ( CL_SUCCESS == ( rc = xar_get_toc_data_values ( reader , & length , & offset , & size , & encoding , & a_cksum , & a_hash , & e_cksum , & e_hash ) ) ) { int do_extract_cksum = 1 ; unsigned char * blockp ; void * a_sc , * e_sc ; void * a_mc , * e_mc ; char * expected ; if ( fd > - 1 && tmpname ) { rc = xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( rc != CL_SUCCESS ) goto exit_reader ; } at = offset + hdr . toc_length_compressed + hdr . size ; if ( ( rc = cli_gentempfd ( ctx -> engine -> tmpdir , & tmpname , & fd ) ) != CL_SUCCESS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>generate<S2SV_blank>temporary<S2SV_blank>file.\\n"" ) ; goto exit_reader ; } <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%li,\\n"" <S2SV_EndBug> ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%li<S2SV_blank>length<S2SV_blank>%li\\n"" , tmpname , size , offset , length ) ; a_hash_ctx = xar_hash_init ( a_hash , & a_sc , & a_mc ) ; e_hash_ctx = xar_hash_init ( e_hash , & e_sc , & e_mc ) ; switch ( encoding ) { case CL_TYPE_GZ : memset ( & strm , 0 , sizeof ( strm ) ) ; if ( ( rc = inflateInit ( & strm ) ) != Z_OK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>InflateInit<S2SV_blank>failed:<S2SV_blank>%d\\n"" , rc ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } while ( ( size_t ) at < map -> len && ( unsigned long ) at < offset + hdr . toc_length_compressed + hdr . size + length ) { unsigned long avail_in ; void * next_in ; unsigned int bytes = MIN ( map -> len - at , map -> pgsz ) ; bytes = MIN ( length , bytes ) ; if ( ! ( strm . next_in = next_in = ( void * ) fmap_need_off_once ( map , at , bytes ) ) ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%lu.\\n"" , bytes , ( long unsigned ) at ) ; inflateEnd ( & strm ) ; rc = CL_EREAD ; goto exit_tmpfile ; } at += bytes ; strm . avail_in = avail_in = bytes ; do { int inf , outsize = 0 ; unsigned char buff [ FILEBUFF ] ; strm . avail_out = sizeof ( buff ) ; strm . next_out = buff ; inf = inflate ( & strm , Z_SYNC_FLUSH ) ; if ( inf != Z_OK && inf != Z_STREAM_END && inf != Z_BUF_ERROR ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>inflate<S2SV_blank>error<S2SV_blank>%i<S2SV_blank>%s.\\n"" , inf , strm . msg ? strm . msg : """" ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } bytes = sizeof ( buff ) - strm . avail_out ; if ( e_hash_ctx != NULL ) xar_hash_update ( e_hash_ctx , buff , bytes , e_hash ) ; if ( cli_writen ( fd , buff , bytes ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>file<S2SV_blank>%s.\\n"" , tmpname ) ; inflateEnd ( & strm ) ; rc = CL_EWRITE ; goto exit_tmpfile ; } outsize += sizeof ( buff ) - strm . avail_out ; if ( cli_checklimits ( ""cli_scanxar"" , ctx , outsize , 0 , 0 ) != CL_CLEAN ) { break ; } if ( inf == Z_STREAM_END ) { break ; } } while ( strm . avail_out == 0 ) ; if ( rc != CL_SUCCESS ) break ; avail_in -= strm . avail_in ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , next_in , avail_in , a_hash ) ; } inflateEnd ( & strm ) ; break ; case CL_TYPE_7Z : # define CLI_LZMA_OBUF_SIZE 1024 * 1024 # define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE + 8 # define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE >> 2 { struct CLI_LZMA lz ; <S2SV_StartBug> unsigned long in_remaining = length ; <S2SV_EndBug> unsigned long out_size = 0 ; unsigned char * buff = __lzma_wrap_alloc ( NULL , CLI_LZMA_OBUF_SIZE ) ; <S2SV_StartBug> int lret ; <S2SV_EndBug> memset ( & lz , 0 , sizeof ( lz ) ) ; if ( buff == NULL ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>memory<S2SV_blank>request<S2SV_blank>for<S2SV_blank>lzma<S2SV_blank>decompression<S2SV_blank>buffer<S2SV_blank>fails.\\n"" ) ; rc = CL_EMEM ; goto exit_tmpfile ; } blockp = ( void * ) fmap_need_off_once ( map , at , CLI_LZMA_HDR_SIZE ) ; if ( blockp == NULL ) { char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> length , at , errbuff ) ; rc = CL_EREAD ; __lzma_wrap_free ( NULL , buff ) ; goto exit_tmpfile ; } lz . next_in = blockp ; lz . avail_in = CLI_LZMA_HDR_SIZE ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , blockp , CLI_LZMA_HDR_SIZE , a_hash ) ; lret = cli_LzmaInit ( & lz , 0 ) ; if ( lret != LZMA_RESULT_OK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaInit()<S2SV_blank>fails:<S2SV_blank>%i.\\n"" , lret ) ; rc = CL_EFORMAT ; __lzma_wrap_free ( NULL , buff ) ; extract_errors ++ ; break ; } at += CLI_LZMA_HDR_SIZE ; in_remaining -= CLI_LZMA_HDR_SIZE ; while ( ( size_t ) at < map -> len && ( unsigned long ) at < offset + hdr . toc_length_compressed + hdr . size + length ) { SizeT avail_in ; SizeT avail_out ; void * next_in ; unsigned long in_consumed ; lz . next_out = buff ; lz . avail_out = CLI_LZMA_OBUF_SIZE ; lz . avail_in = avail_in = MIN ( CLI_LZMA_IBUF_SIZE , in_remaining ) ; lz . next_in = next_in = ( void * ) fmap_need_off_once ( map , at , lz . avail_in ) ; if ( lz . next_in == NULL ) { char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\n"" , <S2SV_StartBug> length , at , errbuff ) ; <S2SV_EndBug> rc = CL_EREAD ; __lzma_wrap_free ( NULL , buff ) ; cli_LzmaShutdown ( & lz ) ; goto exit_tmpfile ; } lret = cli_LzmaDecode ( & lz ) ; if ( lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaDecode()<S2SV_blank>fails:<S2SV_blank>%i.\\n"" , lret ) ; rc = CL_EFORMAT ; extract_errors ++ ; break ; } in_consumed = avail_in - lz . avail_in ; in_remaining -= in_consumed ; at += in_consumed ; avail_out = CLI_LZMA_OBUF_SIZE - lz . avail_out ; if ( avail_out == 0 ) cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_LzmaDecode()<S2SV_blank>produces<S2SV_blank>no<S2SV_blank>output<S2SV_blank>for<S2SV_blank>"" ""avail_in<S2SV_blank>%llu,<S2SV_blank>avail_out<S2SV_blank>%llu.\\n"" , ( long long unsigned ) avail_in , ( long long unsigned ) avail_out ) ; if ( a_hash_ctx != NULL ) xar_hash_update ( a_hash_ctx , next_in , in_consumed , a_hash ) ; if ( e_hash_ctx != NULL ) xar_hash_update ( e_hash_ctx , buff , avail_out , e_hash ) ; if ( cli_writen ( fd , buff , avail_out ) < 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>writing<S2SV_blank>lzma<S2SV_blank>temp<S2SV_blank>file<S2SV_blank>for<S2SV_blank>%llu<S2SV_blank>bytes.\\n"" , ( long long unsigned ) avail_out ) ; __lzma_wrap_free ( NULL , buff ) ; cli_LzmaShutdown ( & lz ) ; rc = CL_EWRITE ; goto exit_tmpfile ; } out_size += avail_out ; if ( cli_checklimits ( ""cli_scanxar"" , ctx , out_size , 0 , 0 ) != CL_CLEAN ) { break ; } if ( lret == LZMA_STREAM_END ) break ; } cli_LzmaShutdown ( & lz ) ; __lzma_wrap_free ( NULL , buff ) ; } break ; case CL_TYPE_ANY : default : case CL_TYPE_BZ : case CL_TYPE_XZ : do_extract_cksum = 0 ; { <S2SV_StartBug> unsigned long write_len ; <S2SV_EndBug> if ( ctx -> engine -> maxfilesize ) <S2SV_StartBug> write_len = MIN ( ( size_t ) ( ctx -> engine -> maxfilesize ) , ( size_t ) length ) ; <S2SV_EndBug> else write_len = length ; <S2SV_StartBug> if ( ! ( blockp = ( void * ) fmap_need_off_once ( map , at , length ) ) ) { <S2SV_EndBug> char errbuff [ 128 ] ; cli_strerror ( errno , errbuff , sizeof ( errbuff ) ) ; <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , <S2SV_EndBug> length , at , errbuff ) ; rc = CL_EREAD ; goto exit_tmpfile ; } if ( a_hash_ctx != NULL ) <S2SV_StartBug> xar_hash_update ( a_hash_ctx , blockp , length , a_hash ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cli_writen ( fd , blockp , write_len ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , length , at ) ; <S2SV_EndBug> rc = CL_EWRITE ; goto exit_tmpfile ; } } } if ( rc == CL_SUCCESS ) { if ( a_hash_ctx != NULL ) { xar_hash_final ( a_hash_ctx , result , a_hash ) ; a_hash_ctx = NULL ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>missing.\\n"" ) ; cksum_fails ++ ; } if ( a_cksum != NULL ) { expected = cli_hex2str ( ( char * ) a_cksum ) ; if ( xar_hash_check ( a_hash , result , expected ) != 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>mismatch.\\n"" ) ; cksum_fails ++ ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>archived-checksum<S2SV_blank>matched.\\n"" ) ; } free ( expected ) ; } if ( e_hash_ctx != NULL ) { xar_hash_final ( e_hash_ctx , result , e_hash ) ; e_hash_ctx = NULL ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum(unarchived-checksum)<S2SV_blank>missing.\\n"" ) ; cksum_fails ++ ; } if ( e_cksum != NULL ) { if ( do_extract_cksum ) { expected = cli_hex2str ( ( char * ) e_cksum ) ; if ( xar_hash_check ( e_hash , result , expected ) != 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>mismatch.\\n"" ) ; cksum_fails ++ ; } else { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>extracted-checksum<S2SV_blank>matched.\\n"" ) ; } free ( expected ) ; } } rc = cli_magic_scandesc ( fd , ctx ) ; if ( rc != CL_SUCCESS ) { if ( rc == CL_VIRUS ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Infected<S2SV_blank>with<S2SV_blank>%s\\n"" , cli_get_last_virus ( ctx ) ) ; if ( ! SCAN_ALL ) goto exit_tmpfile ; } else if ( rc != CL_BREAK ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_magic_scandesc<S2SV_blank>error<S2SV_blank>%i\\n"" , rc ) ; goto exit_tmpfile ; } } } if ( a_cksum != NULL ) { xmlFree ( a_cksum ) ; a_cksum = NULL ; } if ( e_cksum != NULL ) { xmlFree ( e_cksum ) ; e_cksum = NULL ; } } exit_tmpfile : xar_cleanup_temp_file ( ctx , fd , tmpname ) ; if ( a_hash_ctx != NULL ) xar_hash_final ( a_hash_ctx , result , a_hash ) ; if ( e_hash_ctx != NULL ) xar_hash_final ( e_hash_ctx , result , e_hash ) ; exit_reader : if ( a_cksum != NULL ) xmlFree ( a_cksum ) ; if ( e_cksum != NULL ) xmlFree ( e_cksum ) ; xmlTextReaderClose ( reader ) ; xmlFreeTextReader ( reader ) ; exit_toc : free ( toc ) ; if ( rc == CL_BREAK ) rc = CL_SUCCESS ; # else cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>can\'t<S2SV_blank>scan<S2SV_blank>xar<S2SV_blank>files,<S2SV_blank>need<S2SV_blank>libxml2.\\n"" ) ; # endif if ( cksum_fails + extract_errors != 0 ) { <S2SV_StartBug> cli_warnmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors,<S2SV_blank>use<S2SV_blank>--debug<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info.\\n"" , <S2SV_EndBug> cksum_fails , extract_errors ) ; } return rc ; }
","<S2SV_ModStart> -> fmap ; size_t <S2SV_ModEnd> length , offset <S2SV_ModStart> ; goto exit_toc ; } if ( hdr . toc_length_decompressed != strm . total_out ) { cli_dbgmsg ( ""TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%"" PRIu64 ""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\n"" , hdr . toc_length_decompressed , strm . total_out ) ; toc [ strm . total_out ] = '\\0' ; hdr . toc_length_decompressed = strm . total_out <S2SV_ModStart> } cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%zu,\\n"" ""from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%zu<S2SV_blank>length<S2SV_blank>%zu\\n"" <S2SV_ModEnd> , tmpname , <S2SV_ModStart> long in_remaining = MIN ( length , map -> len - at ) <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> ; int lret ; if ( length > in_remaining ) length = in_remaining <S2SV_ModStart> ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n"" , CLI_LZMA_HDR_SIZE <S2SV_ModEnd> , at , <S2SV_ModStart> ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\n"" , lz . avail_in <S2SV_ModEnd> , at , <S2SV_ModStart> 0 ; { size_t writelen = MIN ( map -> len - at , length ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> maxfilesize ) writelen <S2SV_ModEnd> = MIN ( <S2SV_ModStart> maxfilesize ) , writelen ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , at , writelen <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ; cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\n"" , writelen <S2SV_ModEnd> , at , <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> , a_hash ) <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> ) < 0 <S2SV_ModStart> { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n"" , writelen <S2SV_ModEnd> , at ) <S2SV_ModStart> 0 ) { cli_dbgmsg ( ""cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\n"" <S2SV_ModEnd> , cksum_fails ,
",Cisco-Talos@clamav-devel/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,CVE-2018-1000085,https://github.com/Cisco-Talos/clamav-devel/commit/d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6,2018-03-13T15:29Z
CWE-20,"CWE-20 static int _snd_timer_stop ( struct snd_timer_instance * timeri , int keep_flag , int event ) { struct snd_timer * timer ; unsigned long flags ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { if ( ! keep_flag ) { spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> } goto __end ; } timer = timeri -> timer ; if ( ! timer ) return - EINVAL ; spin_lock_irqsave ( & timer -> lock , flags ) ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; if ( ( timeri -> flags & SNDRV_TIMER_IFLG_RUNNING ) && ! ( -- timer -> running ) ) { timer -> hw . stop ( timer ) ; if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) { timer -> flags &= ~ SNDRV_TIMER_FLG_RESCHED ; snd_timer_reschedule ( timer , 0 ) ; if ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } } if ( ! keep_flag ) timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; __end : if ( event != SNDRV_TIMER_EVENT_RESOLUTION ) snd_timer_notify1 ( timeri , event ) ; return 0 ; }
","<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
CWE-190,"CWE-190 int pgx_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ PGX_MAGICLEN ] ; <S2SV_EndBug> uint_fast32_t magic ; int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , PGX_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < PGX_MAGICLEN ) { return - 1 ; } magic = ( buf [ 0 ] << 8 ) | buf [ 1 ] ; if ( magic != PGX_MAGIC ) { return - 1 ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ PGX_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-190,"CWE-190 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; <S2SV_StartBug> for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) <S2SV_EndBug> <S2SV_StartBug> if ( depth >= 64 ) <S2SV_EndBug> break ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_ModStart> depth ++ ) <S2SV_ModEnd> ; image ->
",ImageMagick@ImageMagick/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d,CVE-2017-14173,https://github.com/ImageMagick/ImageMagick/commit/48bcf7c39302cdf9b0d9202ad03bf1b95152c44d,2017-09-07T06:29Z
CWE-119,"CWE-119 static int set_vt_partitioning ( VP9_COMP * cpi , <S2SV_StartBug> void * data , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , <S2SV_StartBug> int mi_size ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; variance_node vt ; const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int64_t threshold_multiplier = 25 ; <S2SV_EndBug> int64_t threshold = threshold_multiplier * cpi -> common . base_qindex ; assert ( block_height == block_width ) ; tree_to_node ( data , bsize , & vt ) ; <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> mi_row + block_height / 2 < cm -> mi_rows && vt . part_variances -> none . variance < threshold ) { <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows && <S2SV_StartBug> vt . part_variances -> vert [ 0 ] . variance < threshold && <S2SV_EndBug> vt . part_variances -> vert [ 1 ] . variance < threshold ) { BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_VERT ) ; <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ; <S2SV_EndBug> return 1 ; } <S2SV_StartBug> if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_EndBug> vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold ) { BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_HORZ ) ; <S2SV_StartBug> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; <S2SV_EndBug> <S2SV_StartBug> set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ; <S2SV_EndBug> return 1 ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> * cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , <S2SV_ModStart> * data , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> int mi_col , int64_t threshold , BLOCK_SIZE bsize_min , int force_split <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> ] ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; if ( force_split == 1 ) return 0 ; if ( bsize == bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( <S2SV_ModStart> ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } return 0 ; } else if ( bsize > bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( cm -> frame_type == KEY_FRAME && ( bsize > BLOCK_32X32 || vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { return 0 ; } if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_ModEnd> mi_row + block_height <S2SV_ModStart> . part_variances -> none <S2SV_ModEnd> . variance < <S2SV_ModStart> variance < threshold ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModEnd> ) { BLOCK_SIZE <S2SV_ModStart> PARTITION_VERT ) ; get_variance ( & vt . part_variances -> vert [ 0 ] ) ; get_variance ( & vt . part_variances -> vert [ 1 ] ) ; if ( vt . part_variances -> vert [ 0 ] . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> ( cpi , x , xd <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , x , xd <S2SV_ModEnd> , mi_row , <S2SV_ModStart> 1 ; } } <S2SV_ModStart> cm -> mi_cols <S2SV_ModEnd> ) { BLOCK_SIZE <S2SV_ModStart> PARTITION_HORZ ) ; get_variance ( & vt . part_variances -> horz [ 0 ] ) ; get_variance ( & vt . part_variances -> horz [ 1 ] ) ; if ( vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> ( cpi , x , xd <S2SV_ModEnd> , mi_row , <S2SV_ModStart> ( cpi , x , xd <S2SV_ModEnd> , mi_row + <S2SV_ModStart> 1 ; } } return 0 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-400,"CWE-400 <S2SV_StartBug> static void perf_event_output ( struct perf_event * event , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_output_handle handle ; struct perf_event_header header ; rcu_read_lock ( ) ; perf_prepare_sample ( & header , data , event , regs ) ; <S2SV_StartBug> if ( perf_output_begin ( & handle , event , header . size , nmi , 1 ) ) <S2SV_EndBug> goto exit ; perf_output_sample ( & handle , & header , data , event ) ; perf_output_end ( & handle ) ; exit : rcu_read_unlock ( ) ; }
","<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> . size , <S2SV_ModEnd> 1 ) )
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-000,"CWE-000 static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""Magic<S2SV_blank>Mismatch,<S2SV_blank>valid(0x%x)<S2SV_blank>-<S2SV_blank>read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( F2FS_BLKSIZE != PAGE_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>page_cache_size<S2SV_blank>(%lu),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , PAGE_SIZE ) ; return 1 ; } blocksize = 1 << le32_to_cpu ( raw_super -> log_blocksize ) ; if ( blocksize != F2FS_BLKSIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>blocksize<S2SV_blank>(%u),<S2SV_blank>supports<S2SV_blank>only<S2SV_blank>4KB\\n"" , blocksize ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocks_per_seg ) != 9 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>blocks<S2SV_blank>per<S2SV_blank>segment<S2SV_blank>(%u)\\n"" , le32_to_cpu ( raw_super -> log_blocks_per_seg ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectorsize<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectors_per_block ) + le32_to_cpu ( raw_super -> log_sectorsize ) != F2FS_MAX_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>log<S2SV_blank>sectors<S2SV_blank>per<S2SV_blank>block(%u)<S2SV_blank>log<S2SV_blank>sectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectors_per_block ) , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> node_ino ) != 1 || le32_to_cpu ( raw_super -> meta_ino ) != 2 || le32_to_cpu ( raw_super -> root_ino ) != 3 ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>Fs<S2SV_blank>Meta<S2SV_blank>Ino:<S2SV_blank>node(%u)<S2SV_blank>meta(%u)<S2SV_blank>root(%u)"" , le32_to_cpu ( raw_super -> node_ino ) , le32_to_cpu ( raw_super -> meta_ino ) , le32_to_cpu ( raw_super -> root_ino ) ) ; return 1 ; } <S2SV_StartBug> if ( sanity_check_area_boundary ( sbi , bh ) ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , ""Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)"" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
",torvalds@linux/b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,https://github.com/torvalds/linux/commit/b9dd46188edc2f0d1f37328637860bb65a771124,2017-08-19T18:29Z
CWE-476,"CWE-476 int fscrypt_setup_filename ( struct inode * dir , const struct qstr * iname , int lookup , struct fscrypt_name * fname ) { int ret = 0 , bigname = 0 ; memset ( fname , 0 , sizeof ( struct fscrypt_name ) ) ; fname -> usr_fname = iname ; if ( ! dir -> i_sb -> s_cop -> is_encrypted ( dir ) || fscrypt_is_dot_dotdot ( iname ) ) { fname -> disk_name . name = ( unsigned char * ) iname -> name ; fname -> disk_name . len = iname -> len ; return 0 ; } <S2SV_StartBug> ret = fscrypt_get_crypt_info ( dir ) ; <S2SV_EndBug> if ( ret && ret != - EOPNOTSUPP ) return ret ; if ( dir -> i_crypt_info ) { ret = fscrypt_fname_alloc_buffer ( dir , iname -> len , & fname -> crypto_buf ) ; if ( ret ) return ret ; ret = fname_encrypt ( dir , iname , & fname -> crypto_buf ) ; if ( ret ) goto errout ; fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; return 0 ; } if ( ! lookup ) return - ENOKEY ; if ( iname -> name [ 0 ] == '_' ) bigname = 1 ; if ( ( bigname && ( iname -> len != 33 ) ) || ( ! bigname && ( iname -> len > 43 ) ) ) return - ENOENT ; fname -> crypto_buf . name = kmalloc ( 32 , GFP_KERNEL ) ; if ( fname -> crypto_buf . name == NULL ) return - ENOMEM ; ret = digest_decode ( iname -> name + bigname , iname -> len - bigname , fname -> crypto_buf . name ) ; if ( ret < 0 ) { ret = - ENOENT ; goto errout ; } fname -> crypto_buf . len = ret ; if ( bigname ) { memcpy ( & fname -> hash , fname -> crypto_buf . name , 4 ) ; memcpy ( & fname -> minor_hash , fname -> crypto_buf . name + 4 , 4 ) ; } else { fname -> disk_name . name = fname -> crypto_buf . name ; fname -> disk_name . len = fname -> crypto_buf . len ; } return 0 ; errout : fscrypt_fname_free_buffer ( & fname -> crypto_buf ) ; return ret ; }
","<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
",torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,CVE-2017-7374,https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,2017-03-31T20:59Z
CWE-190,"CWE-190 static int jpg_dec_parseopts ( char * optstr , jpg_dec_importopts_t * opts ) { jas_tvparser_t * tvp ; <S2SV_StartBug> opts -> max_size = 0 ; <S2SV_EndBug> if ( ! ( tvp = jas_tvparser_create ( optstr ? optstr : """" ) ) ) { return - 1 ; } while ( ! jas_tvparser_next ( tvp ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( decopts , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case OPT_MAXSIZE : <S2SV_StartBug> opts -> max_size = atoi ( jas_tvparser_getval ( tvp ) ) ; <S2SV_EndBug> break ; default : jas_eprintf ( ""warning:<S2SV_blank>ignoring<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>%s\\n"" , jas_tvparser_gettag ( tvp ) ) ; break ; } } jas_tvparser_destroy ( tvp ) ; return 0 ; }
","<S2SV_ModStart> ; opts -> max_samples = 64 * JAS_MEBI <S2SV_ModEnd> ; if ( <S2SV_ModStart> : opts -> max_samples <S2SV_ModEnd> = atoi (
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-190,"CWE-190 int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; }
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
CWE-200,"CWE-200 static void usage ( const char * prog ) { fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank>[OPTION...]\\n"" , prog ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-f,<S2SV_blank>--use-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>configuration<S2SV_blank>file\\n"" ) ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-P,<S2SV_blank>--vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>VRRP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-C,<S2SV_blank>--check<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Only<S2SV_blank>run<S2SV_blank>with<S2SV_blank>Health-checker<S2SV_blank>subsystem\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-B,<S2SV_blank>--no_bfd<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>run<S2SV_blank>BFD<S2SV_blank>subsystem\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--all<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Force<S2SV_blank>all<S2SV_blank>child<S2SV_blank>processes<S2SV_blank>to<S2SV_blank>run,<S2SV_blank>even<S2SV_blank>if<S2SV_blank>have<S2SV_blank>no<S2SV_blank>configuration\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-l,<S2SV_blank>--log-console<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>messages<S2SV_blank>to<S2SV_blank>local<S2SV_blank>console\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-D,<S2SV_blank>--log-detail<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Detailed<S2SV_blank>log<S2SV_blank>messages\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-S,<S2SV_blank>--log-facility=[0-7]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Set<S2SV_blank>syslog<S2SV_blank>facility<S2SV_blank>to<S2SV_blank>LOG_LOCAL[0-7]\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-g,<S2SV_blank>--log-file=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Also<S2SV_blank>log<S2SV_blank>to<S2SV_blank>FILE<S2SV_blank>(default<S2SV_blank>/tmp/keepalived.log)\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--flush-log-file<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flush<S2SV_blank>log<S2SV_blank>file<S2SV_blank>on<S2SV_blank>write\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; <S2SV_StartBug> # ifdef _WITH_VRRP_ <S2SV_EndBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-X,<S2SV_blank>--release-vips<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Drop<S2SV_blank>VIP<S2SV_blank>on<S2SV_blank>transition<S2SV_blank>from<S2SV_blank>signal.\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-V,<S2SV_blank>--dont-release-vrrp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>VRRP<S2SV_blank>VIPs<S2SV_blank>and<S2SV_blank>VROUTEs<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-I,<S2SV_blank>--dont-release-ipvs<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>remove<S2SV_blank>IPVS<S2SV_blank>topology<S2SV_blank>on<S2SV_blank>daemon<S2SV_blank>stop\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-R,<S2SV_blank>--dont-respawn<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>respawn<S2SV_blank>child<S2SV_blank>processes\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-n,<S2SV_blank>--dont-fork<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>fork<S2SV_blank>the<S2SV_blank>daemon<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--dump-conf<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Dump<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>data\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>process\\n"" ) ; # ifdef _WITH_VRRP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-r,<S2SV_blank>--vrrp_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>VRRP<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_LVS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-c,<S2SV_blank>--checkers_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>checkers<S2SV_blank>child<S2SV_blank>process\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-a,<S2SV_blank>--address-monitoring<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Report<S2SV_blank>all<S2SV_blank>address<S2SV_blank>additions/deletions<S2SV_blank>notified<S2SV_blank>via<S2SV_blank>netlink\\n"" ) ; # endif # ifdef _WITH_BFD_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-b,<S2SV_blank>--bfd_pid=FILE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Use<S2SV_blank>specified<S2SV_blank>pidfile<S2SV_blank>for<S2SV_blank>BFD<S2SV_blank>child<S2SV_blank>process\\n"" ) ; # endif # ifdef _WITH_SNMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--snmp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>SNMP<S2SV_blank>subsystem\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-A,<S2SV_blank>--snmp-agent-socket=FILE<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>master<S2SV_blank>agent\\n"" ) ; # endif # if HAVE_DECL_CLONE_NEWNET fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--namespace=NAME<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Run<S2SV_blank>in<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>NAME<S2SV_blank>(overrides<S2SV_blank>config)\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-m,<S2SV_blank>--core-dump<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Produce<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>if<S2SV_blank>terminate<S2SV_blank>abnormally\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-M,<S2SV_blank>--core-dump-pattern=PATN<S2SV_blank>Also<S2SV_blank>set<S2SV_blank>/proc/sys/kernel/core_pattern<S2SV_blank>to<S2SV_blank>PATN<S2SV_blank>(default<S2SV_blank>\'core\')\\n"" ) ; # ifdef _MEM_CHECK_LOG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-L,<S2SV_blank>--mem-check-log<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Log<S2SV_blank>malloc/frees<S2SV_blank>to<S2SV_blank>syslog\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-i,<S2SV_blank>--config-id<S2SV_blank>id<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Skip<S2SV_blank>any<S2SV_blank>configuration<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>\'@\'<S2SV_blank>that<S2SV_blank>don\'t<S2SV_blank>match<S2SV_blank>id\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>or<S2SV_blank>any<S2SV_blank>lines<S2SV_blank>beginning<S2SV_blank>@^<S2SV_blank>that<S2SV_blank>do<S2SV_blank>match.\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>The<S2SV_blank>config-id<S2SV_blank>defaults<S2SV_blank>to<S2SV_blank>the<S2SV_blank>node<S2SV_blank>name<S2SV_blank>if<S2SV_blank>option<S2SV_blank>not<S2SV_blank>used\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--signum=SIGFUNC<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>signal<S2SV_blank>number<S2SV_blank>for<S2SV_blank>STOP,<S2SV_blank>RELOAD,<S2SV_blank>DATA,<S2SV_blank>STATS"" # ifdef _WITH_JSON_ "",<S2SV_blank>JSON"" # endif ""\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-t,<S2SV_blank>--config-test[=LOG_FILE]<S2SV_blank>Check<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>for<S2SV_blank>obvious<S2SV_blank>errors,<S2SV_blank>output<S2SV_blank>to\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>stderr<S2SV_blank>by<S2SV_blank>default\\n"" ) ; # ifdef _WITH_PERF_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--perf[=PERF_TYPE]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Collect<S2SV_blank>perf<S2SV_blank>data,<S2SV_blank>PERF_TYPE=all,<S2SV_blank>run(default)<S2SV_blank>or<S2SV_blank>end\\n"" ) ; # endif # ifdef WITH_DEBUG_OPTIONS fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--debug[=...]<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>debug<S2SV_blank>options.<S2SV_blank>p,<S2SV_blank>b,<S2SV_blank>c,<S2SV_blank>v<S2SV_blank>specify<S2SV_blank>parent,<S2SV_blank>bfd,<S2SV_blank>checker<S2SV_blank>and<S2SV_blank>vrrp<S2SV_blank>processes\\n"" ) ; # ifdef _TIMER_CHECK_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>T<S2SV_blank>-<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif # ifdef _SMTP_ALERT_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>M<S2SV_blank>-<S2SV_blank>email<S2SV_blank>alert<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>E<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>debug\\n"" ) ; # endif # ifdef _EPOLL_THREAD_DUMP_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>D<S2SV_blank>-<S2SV_blank>epoll<S2SV_blank>thread<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _VRRP_FD_DEBUG fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>F<S2SV_blank>-<S2SV_blank>vrrp<S2SV_blank>fd<S2SV_blank>dump<S2SV_blank>debug\\n"" ) ; # endif # ifdef _REGEX_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>debug\\n"" ) ; # endif # ifdef _WITH_REGEX_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>X<S2SV_blank>-<S2SV_blank>regex<S2SV_blank>timers\\n"" ) ; # endif # ifdef _TSM_DEBUG_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>S<S2SV_blank>-<S2SV_blank>TSM<S2SV_blank>debug\\n"" ) ; # endif # ifdef _NETLINK_TIMERS_ fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>N<S2SV_blank>-<S2SV_blank>netlink<S2SV_blank>timer<S2SV_blank>debug\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Example<S2SV_blank>--debug=TpMEvcp\\n"" ) ; # endif fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>the<S2SV_blank>version<S2SV_blank>number\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-h,<S2SV_blank>--help<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Display<S2SV_blank>this<S2SV_blank>help<S2SV_blank>message\\n"" ) ; }
","<S2SV_ModStart> ""<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n"" ) ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n"" ) ;
",acassen@keepalived/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,CVE-2018-19045,https://github.com/acassen/keepalived/commit/c6247a9ef2c7b33244ab1d3aa5d629ec49f0a067,2018-11-08T20:29Z
CWE-264,"CWE-264 int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString : <S2SV_StartBug> case NPPVformValue : <S2SV_EndBug> type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : <S2SV_StartBug> type = RPC_TYPE_BOOLEAN ; <S2SV_EndBug> break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
","<S2SV_ModStart> : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :
",davidben@nspluginwrapper/7e4ab8e1189846041f955e6c83f72bc1624e7a98,CVE-2011-2486,https://github.com/davidben/nspluginwrapper/commit/7e4ab8e1189846041f955e6c83f72bc1624e7a98,2012-11-19T12:10Z
CWE-264,"CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
",torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
CWE-119,"CWE-119 static int calc_pframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { <S2SV_StartBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; <S2SV_EndBug> const RATE_CONTROL * rc = & cpi -> rc ; const SVC * const svc = & cpi -> svc ; <S2SV_StartBug> const int64_t diff = oxcf -> optimal_buffer_level - rc -> buffer_level ; <S2SV_EndBug> <S2SV_StartBug> const int64_t one_pct_bits = 1 + oxcf -> optimal_buffer_level / 100 ; <S2SV_EndBug> <S2SV_StartBug> int min_frame_target = MAX ( rc -> av_per_frame_bandwidth >> 4 , <S2SV_EndBug> FRAME_OVERHEAD_BITS ) ; <S2SV_StartBug> int target = rc -> av_per_frame_bandwidth ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 && <S2SV_EndBug> oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) { int current_temporal_layer = svc -> temporal_layer_id ; <S2SV_StartBug> const LAYER_CONTEXT * lc = & svc -> layer_context [ current_temporal_layer ] ; <S2SV_EndBug> target = lc -> avg_frame_size ; min_frame_target = MAX ( lc -> avg_frame_size >> 4 , FRAME_OVERHEAD_BITS ) ; } if ( diff > 0 ) { const int pct_low = ( int ) MIN ( diff / one_pct_bits , oxcf -> under_shoot_pct ) ; target -= ( target * pct_low ) / 200 ; } else if ( diff < 0 ) { const int pct_high = ( int ) MIN ( - diff / one_pct_bits , oxcf -> over_shoot_pct ) ; target += ( target * pct_high ) / 200 ; } <S2SV_StartBug> return MAX ( min_frame_target , target ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) { const VP9EncoderConfig <S2SV_ModEnd> * oxcf = <S2SV_ModStart> int64_t diff = rc <S2SV_ModEnd> -> optimal_buffer_level - <S2SV_ModStart> = 1 + rc <S2SV_ModEnd> -> optimal_buffer_level / <S2SV_ModStart> ( rc -> avg_frame_bandwidth <S2SV_ModEnd> >> 4 , <S2SV_ModStart> ; int target ; if ( oxcf -> gf_cbr_boost_pct ) { const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ; target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ; } else { target = rc -> avg_frame_bandwidth ; } if ( is_one_pass_cbr_svc ( cpi ) ) { int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , <S2SV_ModEnd> svc -> number_temporal_layers <S2SV_ModStart> svc -> number_temporal_layers ) <S2SV_ModEnd> ; const LAYER_CONTEXT <S2SV_ModStart> -> layer_context [ layer <S2SV_ModEnd> ] ; target <S2SV_ModStart> 200 ; } if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 static int xfrm_user_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( skb -> sk ) ; struct nlattr * attrs [ XFRMA_MAX + 1 ] ; const struct xfrm_link * link ; int type , err ; # ifdef CONFIG_COMPAT if ( in_compat_syscall ( ) ) return - EOPNOTSUPP ; # endif type = nlh -> nlmsg_type ; if ( type > XFRM_MSG_MAX ) return - EINVAL ; type -= XFRM_MSG_BASE ; link = & xfrm_dispatch [ type ] ; if ( ! netlink_net_capable ( skb , CAP_NET_ADMIN ) ) return - EPERM ; if ( ( type == ( XFRM_MSG_GETSA - XFRM_MSG_BASE ) || type == ( XFRM_MSG_GETPOLICY - XFRM_MSG_BASE ) ) && ( nlh -> nlmsg_flags & NLM_F_DUMP ) ) { if ( link -> dump == NULL ) return - EINVAL ; { struct netlink_dump_control c = { <S2SV_StartBug> . dump = link -> dump , <S2SV_EndBug> . done = link -> done , } ; return netlink_dump_start ( net -> xfrm . nlsk , skb , nlh , & c ) ; } } err = nlmsg_parse ( nlh , xfrm_msg_min [ type ] , attrs , link -> nla_max ? : XFRMA_MAX , link -> nla_pol ? : xfrma_policy , extack ) ; if ( err < 0 ) return err ; if ( link -> doit == NULL ) return - EINVAL ; return link -> doit ( skb , nlh , attrs ) ; }
","<S2SV_ModStart> = { . start = link -> start , .
",torvalds@linux/1137b5e2529a8f5ca8ee709288ecba3e68044df2,CVE-2017-16939,https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2,2017-11-24T10:29Z
CWE-000,"CWE-000 static void check_1_6_dummy ( kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * * passptr ) { int i ; char * password = * passptr ; <S2SV_StartBug> if ( ! ( mask & KADM5_ATTRIBUTES ) || <S2SV_EndBug> ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ; for ( i = 0 ; ( unsigned char ) password [ i ] == i + 1 ; i ++ ) ; if ( password [ i ] != '\\0' || i != 255 ) return ; * passptr = NULL ; }
","<S2SV_ModStart> ; if ( password == NULL ||
",krb5@krb5/c5be6209311d4a8f10fda37d0d3f876c1b33b77b,CVE-2012-1013,https://github.com/krb5/krb5/commit/c5be6209311d4a8f10fda37d0d3f876c1b33b77b,2012-06-07T19:55Z
CWE-476,"CWE-476 static enum count_type __read_io_type ( struct page * page ) { <S2SV_StartBug> struct address_space * mapping = page -> mapping ; <S2SV_EndBug> if ( mapping ) { struct inode * inode = mapping -> host ; struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; if ( inode -> i_ino == F2FS_META_INO ( sbi ) ) return F2FS_RD_META ; if ( inode -> i_ino == F2FS_NODE_INO ( sbi ) ) return F2FS_RD_NODE ; } return F2FS_RD_DATA ; }
","<S2SV_ModStart> * mapping = page_file_mapping ( page ) <S2SV_ModEnd> ; if (
",torvalds@linux/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,CVE-2019-19815,https://github.com/torvalds/linux/commit/4969c06a0d83c9c3dc50b8efcdc8eeedfce896f6,2019-12-17T07:15Z
CWE-119,"CWE-119 static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } return ( 1 ) ; }
","<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
CWE-59,"CWE-59 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { rc = fsmVerify ( fpath , fi ) ; } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; <S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
","<S2SV_ModStart> , psm , 0 ,
",rpm-software-management@rpm/404ef011c300207cdb1e531670384564aae04bdc,CVE-2017-7501,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,2017-11-22T22:29Z
CWE-119,"CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , ""BPF_NEG<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , ""BPF_END<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_MOV<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { regs [ insn -> dst_reg ] = regs [ insn -> src_reg ] ; regs [ insn -> dst_reg ] . live |= REG_LIVE_WRITTEN ; } else { if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>partial<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>pointer\\n"" , insn -> src_reg ) ; return - EACCES ; } mark_reg_unknown ( env , regs , insn -> dst_reg ) ; regs [ insn -> dst_reg ] . var_off = tnum_cast ( regs [ insn -> dst_reg ] . var_off , 4 ) ; __update_reg_bounds ( & regs [ insn -> dst_reg ] ) ; } } else { regs [ insn -> dst_reg ] . type = SCALAR_VALUE ; <S2SV_StartBug> __mark_reg_known ( regs + insn -> dst_reg , insn -> imm ) ; <S2SV_EndBug> } } else if ( opcode > BPF_END ) { verbose ( env , ""invalid<S2SV_blank>BPF_ALU<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } else { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 ) { verbose ( env , ""BPF_ALU<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( ( opcode == BPF_MOD || opcode == BPF_DIV ) && BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 ) { verbose ( env , ""div<S2SV_blank>by<S2SV_blank>zero\\n"" ) ; return - EINVAL ; } if ( ( opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH ) && BPF_SRC ( insn -> code ) == BPF_K ) { int size = BPF_CLASS ( insn -> code ) == BPF_ALU64 ? 64 : 32 ; if ( insn -> imm < 0 || insn -> imm >= size ) { verbose ( env , ""invalid<S2SV_blank>shift<S2SV_blank>%d\\n"" , insn -> imm ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; return adjust_reg_min_max_vals ( env , insn ) ; } return 0 ; }
","<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
",torvalds@linux/95a762e2c8c942780948091f8f2a4f32fce1ac6f,CVE-2017-16995,https://github.com/torvalds/linux/commit/95a762e2c8c942780948091f8f2a4f32fce1ac6f,2017-12-27T17:08Z
CWE-000,"CWE-000 int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> return AVERROR ( ENOMEM ) ; return 0 ; }
","<S2SV_ModStart> * ptrptr && <S2SV_ModEnd> nmemb && size <S2SV_ModStart> nmemb && size <S2SV_ModEnd> ) return AVERROR
",FFmpeg@FFmpeg/c94f9e854228e0ea00e1de8769d8d3f7cab84a55,CVE-2013-4265,https://github.com/FFmpeg/FFmpeg/commit/c94f9e854228e0ea00e1de8769d8d3f7cab84a55,2013-11-23T17:55Z
CWE-200,"CWE-200 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;
",torvalds@linux/06b6a1cf6e776426766298d055bb3991957d90a7,CVE-2012-3430,https://github.com/torvalds/linux/commit/06b6a1cf6e776426766298d055bb3991957d90a7,2012-10-03T11:02Z
CWE-264,"CWE-264 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock (
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-89,"CWE-89 char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen ) { <S2SV_StartBug> int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; <S2SV_EndBug> char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; <S2SV_StartBug> CURLcode res ; <S2SV_EndBug> if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; <S2SV_StartBug> res = Curl_convert_from_network ( handle , & in , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( res ) { <S2SV_EndBug> free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) <S2SV_StartBug> * olen = strindex ; <S2SV_EndBug> return ns ; }
","<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
CWE-119,"CWE-119 static int su3000_power_ctrl ( struct dvb_usb_device * d , int i ) { struct dw2102_state * state = ( struct dw2102_state * ) d -> priv ; <S2SV_StartBug> u8 obuf [ ] = { 0xde , 0 } ; <S2SV_EndBug> info ( ""%s:<S2SV_blank>%d,<S2SV_blank>initialized<S2SV_blank>%d"" , __func__ , i , state -> initialized ) ; if ( i && ! state -> initialized ) { <S2SV_StartBug> state -> initialized = 1 ; <S2SV_EndBug> <S2SV_StartBug> return dvb_usb_generic_rw ( d , obuf , 2 , NULL , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( <S2SV_ModStart> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> = 1 ; ret = <S2SV_ModEnd> dvb_usb_generic_rw ( d <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z
CWE-416,"CWE-416 R_API int r_core_bin_set_env ( RCore * r , RBinFile * binfile ) { RBinObject * binobj = binfile ? binfile -> o : NULL ; RBinInfo * info = binobj ? binobj -> info : NULL ; if ( info ) { int va = info -> has_va ; <S2SV_StartBug> const char * arch = info -> arch ; <S2SV_EndBug> ut16 bits = info -> bits ; ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ; r_config_set_i ( r -> config , ""io.va"" , ( binobj -> info ) ? binobj -> info -> has_va : 0 ) ; r_config_set_i ( r -> config , ""bin.baddr"" , baseaddr ) ; r_config_set ( r -> config , ""asm.arch"" , arch ) ; r_config_set_i ( r -> config , ""asm.bits"" , bits ) ; r_config_set ( r -> config , ""anal.arch"" , arch ) ; <S2SV_StartBug> if ( info -> cpu && * info -> cpu ) { <S2SV_EndBug> <S2SV_StartBug> r_config_set ( r -> config , ""anal.cpu"" , info -> cpu ) ; <S2SV_EndBug> } else { r_config_set ( r -> config , ""anal.cpu"" , arch ) ; } r_asm_use ( r -> assembler , arch ) ; r_core_bin_info ( r , R_CORE_BIN_ACC_ALL , R_CORE_BIN_SET , va , NULL , NULL ) ; <S2SV_StartBug> r_core_bin_set_cur ( r , binfile ) ; <S2SV_EndBug> return true ; } return false ; }
","<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart> , ""anal.cpu"" , <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r , binfile ) ; free ( cpu ) ; free ( arch
",radare@radare2/f85bc674b2a2256a364fe796351bc1971e106005,CVE-2017-9520,https://github.com/radare/radare2/commit/f85bc674b2a2256a364fe796351bc1971e106005,2017-06-08T14:29Z
CWE-362,"CWE-362 <S2SV_StartBug> int ip_options_get ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> unsigned char * data , int optlen ) { <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> if ( ! opt ) return - ENOMEM ; if ( optlen ) <S2SV_StartBug> memcpy ( opt -> __data , data , optlen ) ; <S2SV_EndBug> return ip_options_get_finish ( net , optp , opt , optlen ) ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-200,"CWE-200 int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ; # ifdef ES_AGGRESSIVE_TEST struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ; # endif map -> m_flags = 0 ; ext_debug ( ""ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u,"" ""logical<S2SV_blank>block<S2SV_blank>%lu\\n"" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > INT_MAX ) ) map -> m_len = INT_MAX ; if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) return - EFSCORRUPTED ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { BUG_ON ( 1 ) ; } # ifdef ES_AGGRESSIVE_TEST ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ; # endif goto found ; } down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ; map -> m_flags &= ~ EXT4_MAP_FLAGS ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; } if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , ""ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>"" ""%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d"" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; <S2SV_StartBug> } <S2SV_EndBug> return retval ; }
","<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
",torvalds@linux/06bd3c36a733ac27962fea7d6f47168841376824,CVE-2017-7495,https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824,2017-05-15T18:29Z
CWE-416,"CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , ""Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n"" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , ""bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n"" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
","<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;
",torvalds@linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e,CVE-2019-15920,https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e,2019-09-04T19:15Z
CWE-119,"CWE-119 static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , ""M-SEARCH<S2SV_blank>*"" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , ""No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , ""Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s"" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , ""\\r\\nST:"" ) ; if ( ! type ) { logit ( LOG_DEBUG , ""No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>"" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , ""\\r\\n"" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d"" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , ""M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s"" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }
","<S2SV_ModStart> buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( buf ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( sa
",troglobit@ssdp-responder/ce04b1f29a137198182f60bbb628d5ceb8171765,CVE-2019-14323,https://github.com/troglobit/ssdp-responder/commit/ce04b1f29a137198182f60bbb628d5ceb8171765,2019-07-28T13:15Z
CWE-399,"CWE-399 static int masq_inet_event ( struct notifier_block * this , unsigned long event , void * ptr ) { <S2SV_StartBug> struct net_device * dev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev -> dev ; <S2SV_EndBug> struct netdev_notifier_info info ; <S2SV_StartBug> netdev_notifier_info_init ( & info , dev ) ; <S2SV_EndBug> return masq_device_event ( this , event , & info ) ; }
","<S2SV_ModStart> ) { struct in_device * idev <S2SV_ModEnd> = ( ( <S2SV_ModStart> ) -> ifa_dev <S2SV_ModEnd> ; struct netdev_notifier_info <S2SV_ModStart> netdev_notifier_info info ; if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> & info , idev ->
",torvalds@linux/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,CVE-2016-3156,https://github.com/torvalds/linux/commit/fbd40ea0180a2d328c5adc61414dc8bab9335ce2,2016-04-27T17:59Z
CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""Invalid<S2SV_blank>RDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> return ; <S2SV_EndBug> } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-476,"CWE-476 static int bmp_getint32 ( jas_stream_t * in , int_fast32_t * val ) { int n ; uint_fast32_t v ; int c ; for ( n = 4 , v = 0 ; ; ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } <S2SV_StartBug> v |= ( c << 24 ) ; <S2SV_EndBug> if ( -- n <= 0 ) { break ; } v >>= 8 ; } if ( val ) { * val = v ; } return 0 ; }
","<S2SV_ModStart> v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 )
",mdadams@jasper/8f62b4761711d036fd8964df256b938c809b7fca,CVE-2016-8690,https://github.com/mdadams/jasper/commit/8f62b4761711d036fd8964df256b938c809b7fca,2017-02-15T19:59Z
CWE-000,"CWE-000 sctp_disposition_t sctp_sf_do_5_2_4_dupcook ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { sctp_disposition_t retval ; struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; int error = 0 ; char action ; struct sctp_chunk * err_chk_p ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } action = sctp_tietags_compare ( new_asoc , asoc ) ; switch ( action ) { case 'A' : retval = sctp_sf_do_dupcook_a ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'B' : retval = sctp_sf_do_dupcook_b ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'C' : retval = sctp_sf_do_dupcook_c ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; case 'D' : retval = sctp_sf_do_dupcook_d ( net , ep , asoc , chunk , commands , new_asoc ) ; break ; default : retval = sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; break ; } <S2SV_StartBug> sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; <S2SV_EndBug> sctp_add_cmd_sf ( commands , SCTP_CMD_DELETE_TCB , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_ASOC , SCTP_ASOC ( ( struct sctp_association * ) asoc ) ) ; return retval ; nomem : return SCTP_DISPOSITION_NOMEM ; }
","<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (
",torvalds@linux/f2815633504b442ca0b0605c16bf3d88a3a0fcea,CVE-2013-2206,https://github.com/torvalds/linux/commit/f2815633504b442ca0b0605c16bf3d88a3a0fcea,2013-07-04T21:55Z
CWE-59,"CWE-59 void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , ""VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n"" , vrrp -> iname ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Advertisements:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n"" , vrrp -> stats -> advert_sent ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> become_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> release_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n"" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n"" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n"" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , ""<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }
","<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , ""w"" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
CWE-78,"CWE-78 static void <S2SV_StartBug> build_config ( char * prefix , struct server * server ) <S2SV_EndBug> { char * path = NULL ; int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ; path = ss_malloc ( path_size ) ; snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ; FILE * f = fopen ( path , ""w+"" ) ; if ( f == NULL ) { if ( verbose ) { LOGE ( ""unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file"" ) ; } ss_free ( path ) ; return ; } fprintf ( f , ""{\\n"" ) ; fprintf ( f , ""\\""server_port\\"":%d,\\n"" , atoi ( server -> port ) ) ; <S2SV_StartBug> fprintf ( f , ""\\""password\\"":\\""%s\\"""" , server -> password ) ; <S2SV_EndBug> if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\\n\\""fast_open\\"":<S2SV_blank>%s"" , server -> fast_open ) ; if ( server -> mode ) fprintf ( f , "",\\n\\""mode\\"":\\""%s\\"""" , server -> mode ) ; <S2SV_StartBug> if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; <S2SV_EndBug> if ( server -> plugin ) fprintf ( f , "",\\n\\""plugin\\"":\\""%s\\"""" , server -> plugin ) ; if ( server -> plugin_opts ) fprintf ( f , "",\\n\\""plugin_opts\\"":\\""%s\\"""" , server -> plugin_opts ) ; fprintf ( f , ""\\n}\\n"" ) ; fclose ( f ) ; ss_free ( path ) ; }
","<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , server -> method ) ; else if ( manager -> method ) fprintf ( f , "",\\n\\""method\\"":\\""%s\\"""" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf
",shadowsocks@shadowsocks-libev/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,CVE-2017-15924,https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3,2017-10-27T16:29Z
CWE-119,"CWE-119 int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ; <S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do { <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ; <S2SV_StartBug> return q ; <S2SV_EndBug> }
","<S2SV_ModStart> i , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> ; do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = ( <S2SV_ModStart> i , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( bits_per_mb_at_this_q <S2SV_ModStart> active_worst_quality ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static stmt_ty ast_for_import_stmt ( struct compiling * c , const node * n ) { int lineno ; int col_offset ; int i ; asdl_seq * aliases ; REQ ( n , import_stmt ) ; lineno = LINENO ( n ) ; col_offset = n -> n_col_offset ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == import_name ) { n = CHILD ( n , 1 ) ; REQ ( n , dotted_as_names ) ; aliases = _Py_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } return Import ( aliases , lineno , col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( n ) == import_from ) { int n_children ; int idx , ndots = 0 ; const node * n_copy = n ; alias_ty mod = NULL ; identifier modname = NULL ; for ( idx = 1 ; idx < NCH ( n ) ; idx ++ ) { if ( TYPE ( CHILD ( n , idx ) ) == dotted_name ) { mod = alias_for_import_name ( c , CHILD ( n , idx ) , 0 ) ; if ( ! mod ) return NULL ; idx ++ ; break ; } else if ( TYPE ( CHILD ( n , idx ) ) == ELLIPSIS ) { ndots += 3 ; continue ; } else if ( TYPE ( CHILD ( n , idx ) ) != DOT ) { break ; } ndots ++ ; } idx ++ ; switch ( TYPE ( CHILD ( n , idx ) ) ) { case STAR : n = CHILD ( n , idx ) ; n_children = 1 ; break ; case LPAR : n = CHILD ( n , idx + 1 ) ; n_children = NCH ( n ) ; break ; case import_as_names : n = CHILD ( n , idx ) ; n_children = NCH ( n ) ; if ( n_children % 2 == 0 ) { ast_error ( c , n , ""trailing<S2SV_blank>comma<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>without"" ""<S2SV_blank>surrounding<S2SV_blank>parentheses"" ) ; return NULL ; } break ; default : ast_error ( c , n , ""Unexpected<S2SV_blank>node-type<S2SV_blank>in<S2SV_blank>from-import"" ) ; return NULL ; } aliases = _Py_asdl_seq_new ( ( n_children + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; if ( TYPE ( n ) == STAR ) { alias_ty import_alias = alias_for_import_name ( c , n , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , 0 , import_alias ) ; } else { for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } } if ( mod != NULL ) modname = mod -> name ; return ImportFrom ( modname , aliases , ndots , lineno , col_offset , n_copy -> n_end_lineno , n_copy -> n_end_col_offset , c -> c_arena ) ; } PyErr_Format ( PyExc_SystemError , ""unknown<S2SV_blank>import<S2SV_blank>statement:<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>command<S2SV_blank>\'%s\'"" , STR ( CHILD ( n , 0 ) ) ) ; return NULL ; }
","
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-20,"CWE-20 static int proc_sys_readdir ( struct file * file , struct dir_context * ctx ) { struct ctl_table_header * head = grab_header ( file_inode ( file ) ) ; struct ctl_table_header * h = NULL ; struct ctl_table * entry ; struct ctl_dir * ctl_dir ; unsigned long pos ; if ( IS_ERR ( head ) ) return PTR_ERR ( head ) ; ctl_dir = container_of ( head , struct ctl_dir , header ) ; if ( ! dir_emit_dots ( file , ctx ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> pos = 2 ; for ( first_entry ( ctl_dir , & h , & entry ) ; h ; next_entry ( & h , & entry ) ) { if ( ! scan ( h , entry , & pos , file , ctx ) ) { sysctl_head_finish ( h ) ; break ; } } <S2SV_StartBug> sysctl_head_finish ( head ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ctx ) ) goto out <S2SV_ModEnd> ; pos = <S2SV_ModStart> ; } } out :
",torvalds@linux/93362fa47fe98b62e4a34ab408c4a418432e7939,CVE-2016-9191,https://github.com/torvalds/linux/commit/93362fa47fe98b62e4a34ab408c4a418432e7939,2016-11-28T03:59Z
CWE-20,"CWE-20 static int cleanup_pathname ( struct archive_write_disk * a ) { <S2SV_StartBug> char * dest , * src ; <S2SV_EndBug> char separator = '\\0' ; <S2SV_StartBug> dest = src = a -> name ; <S2SV_EndBug> <S2SV_StartBug> if ( * src == '\\0' ) { <S2SV_EndBug> <S2SV_StartBug> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , <S2SV_EndBug> ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } <S2SV_StartBug> # if defined ( __CYGWIN__ ) <S2SV_EndBug> cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; <S2SV_StartBug> return ( ARCHIVE_FAILED ) ; <S2SV_EndBug> } separator = * src ++ ; } for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
","<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = cleanup_pathname_fsobj ( <S2SV_ModEnd> a -> name <S2SV_ModStart> a -> name , & error_number , & error_string , a -> flags ) <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , ""%s"" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
",libarchive@libarchive/dfd6b54ce33960e420fb206d8872fb759b577ad9,CVE-2016-5418,https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9,2016-09-21T14:25Z
CWE-119,"CWE-119 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if ( ps_dec -> i4_degrade_type && ps_dec -> i4_degrade_pics ) { WORD32 degrade_pic ; ps_dec -> i4_degrade_pic_cnt ++ ; degrade_pic = 0 ; switch ( ps_dec -> i4_degrade_pics ) { case 4 : { degrade_pic = 1 ; break ; } case 3 : { if ( ps_cur_slice -> u1_slice_type != I_SLICE ) degrade_pic = 1 ; break ; } case 2 : { if ( ( ps_cur_slice -> u1_slice_type != I_SLICE ) && ( ps_dec -> i4_degrade_pic_cnt != ps_dec -> i4_nondegrade_interval ) ) degrade_pic = 1 ; break ; } case 1 : { if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { degrade_pic = 1 ; } break ; } } if ( degrade_pic ) { if ( ps_dec -> i4_degrade_type & 0x2 ) ps_dec -> u4_app_disable_deblk_frm = 1 ; if ( 0 == ps_cur_slice -> u1_nal_ref_idc ) { if ( ps_dec -> i4_degrade_type & 0x4 ) ps_dec -> i4_mv_frac_mask = 0 ; if ( ps_dec -> i4_degrade_type & 0x8 ) ps_dec -> i4_mv_frac_mask = 0 ; } } else ps_dec -> i4_degrade_pic_cnt = 0 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_dec -> u1_sl_typ_5_9 && ( ( ps_cur_slice -> u1_slice_type == I_SLICE ) || ( ps_cur_slice -> u1_slice_type == SI_SLICE ) ) ) ps_err -> u1_cur_pic_type = PIC_TYPE_I ; else ps_err -> u1_cur_pic_type = PIC_TYPE_UNKNOWN ; if ( ps_err -> u1_pic_aud_i == PIC_TYPE_I ) { ps_err -> u1_cur_pic_type = PIC_TYPE_I ; ps_err -> u1_pic_aud_i = PIC_TYPE_UNKNOWN ; } if ( ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { if ( ps_err -> u1_err_flag ) ih264d_reset_ref_bufs ( ps_dec -> ps_dpb_mgr ) ; ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } if ( ps_dec -> u1_init_dec_flag && ps_dec -> s_prev_seq_params . u1_eoseq_pending ) { WORD32 j ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> u1_second_field = 0 ; ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> s_prev_seq_params . u1_eoseq_pending = 0 ; } ret = ih264d_init_pic ( ps_dec , u2_frame_num , i4_poc , ps_pps ) ; if ( ret != OK ) return ret ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_pic_tu_coeff_data ; ps_dec -> ps_nmb_info = ps_dec -> ps_frm_mb_info ; if ( ps_dec -> u1_separate_parse ) { UWORD16 pic_wd ; UWORD16 pic_ht ; UWORD32 num_mbs ; pic_wd = ps_dec -> u2_pic_wd ; pic_ht = ps_dec -> u2_pic_ht ; num_mbs = ( pic_wd * pic_ht ) >> 8 ; if ( ps_dec -> pu1_dec_mb_map ) { memset ( ( void * ) ps_dec -> pu1_dec_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu1_recon_mb_map ) { memset ( ( void * ) ps_dec -> pu1_recon_mb_map , 0 , num_mbs ) ; } if ( ps_dec -> pu2_slice_num_map ) { memset ( ( void * ) ps_dec -> pu2_slice_num_map , 0 , ( num_mbs * sizeof ( UWORD16 ) ) ) ; } } ps_dec -> ps_parse_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_decode_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; ps_dec -> ps_computebs_cur_slice = & ( ps_dec -> ps_dec_slice_buf [ 0 ] ) ; <S2SV_StartBug> ps_dec -> s_high_profile . u1_scaling_present = 0 ; <S2SV_EndBug> ps_dec -> s_high_profile . u1_transform8x8_present = 0 ; if ( 1 == ps_dec -> u4_share_disp_buf ) { UWORD32 i ; for ( i = 0 ; i < MAX_DISP_BUFS_NEW ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) continue ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , i , BUF_MGR_IO ) ; ps_dec -> u4_disp_buf_to_be_freed [ i ] = 0 ; ps_dec -> u4_disp_buf_mapping [ i ] = 0 ; } } if ( ! ( u1_field_pic_flag && 0 != ps_dec -> u1_top_bottom_decoded ) ) { pic_buffer_t * ps_cur_pic ; WORD32 cur_pic_buf_id , cur_mv_buf_id ; col_mv_buf_t * ps_col_mv ; while ( 1 ) { ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } if ( 0 == ps_dec -> u4_disp_buf_mapping [ cur_pic_buf_id ] ) { break ; } } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; if ( ps_dec -> u1_first_slice_in_stream ) { ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; * ( ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] [ 0 ] ) = * ps_cur_pic ; } if ( ! ps_dec -> ps_cur_pic ) { WORD32 j ; H264_DEC_DEBUG_PRINT ( ""-------<S2SV_blank>Display<S2SV_blank>Buffers<S2SV_blank>Reset<S2SV_blank>--------\\n"" ) ; for ( j = 0 ; j < MAX_DISP_BUFS_NEW ; j ++ ) { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , ps_dec -> au1_pic_buf_id_mv_buf_id_map [ j ] , BUF_MGR_REF ) ; ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , j , BUF_MGR_IO ) ; } ps_dec -> i4_cur_display_seq = 0 ; ps_dec -> i4_prev_max_display_seq = 0 ; ps_dec -> i4_max_poc = 0 ; ps_cur_pic = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & cur_pic_buf_id ) ; if ( ps_cur_pic == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_PICBUF_T ; return ERROR_UNAVAIL_PICBUF_T ; } ps_col_mv = ( col_mv_buf_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_mv_buf_mgr , & cur_mv_buf_id ) ; if ( ps_col_mv == NULL ) { ps_dec -> i4_error_code = ERROR_UNAVAIL_MVBUF_T ; return ERROR_UNAVAIL_MVBUF_T ; } ps_dec -> ps_cur_pic = ps_cur_pic ; ps_dec -> u1_pic_buf_id = cur_pic_buf_id ; ps_cur_pic -> u4_ts = ps_dec -> u4_ts ; ps_dec -> apv_buf_id_pic_buf_map [ cur_pic_buf_id ] = ( void * ) ps_cur_pic ; ps_cur_pic -> u1_mv_buf_id = cur_mv_buf_id ; ps_dec -> au1_pic_buf_id_mv_buf_id_map [ cur_pic_buf_id ] = cur_mv_buf_id ; ps_cur_pic -> pu1_col_zero_flag = ( UWORD8 * ) ps_col_mv -> pv_col_zero_flag ; ps_cur_pic -> ps_mv = ( mv_pred_t * ) ps_col_mv -> pv_mv ; ps_dec -> au1_pic_buf_ref_flag [ cur_pic_buf_id ] = 0 ; } ps_dec -> ps_cur_pic -> u1_picturetype = u1_field_pic_flag ; ps_dec -> ps_cur_pic -> u4_pack_slc_typ = SKIP_NONE ; H264_DEC_DEBUG_PRINT ( ""got<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } else { H264_DEC_DEBUG_PRINT ( ""did<S2SV_blank>not<S2SV_blank>get<S2SV_blank>a<S2SV_blank>buffer\\n"" ) ; } ps_dec -> u4_pic_buf_got = 1 ; ps_dec -> ps_cur_pic -> i4_poc = i4_poc ; ps_dec -> ps_cur_pic -> i4_frame_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_pic_num = u2_frame_num ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = ps_pps -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = ps_pps -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_avg_poc = ps_pps -> i4_avg_poc ; ps_dec -> ps_cur_pic -> u4_time_stamp = ps_dec -> u4_pts ; ps_dec -> s_cur_pic = * ( ps_dec -> ps_cur_pic ) ; if ( u1_field_pic_flag && u1_bottom_field_flag ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; ps_dec -> s_cur_pic . pu1_buf1 += ps_dec -> s_cur_pic . u2_frm_wd_y ; ps_dec -> s_cur_pic . pu1_buf2 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . pu1_buf3 += ps_dec -> s_cur_pic . u2_frm_wd_uv ; ps_dec -> s_cur_pic . ps_mv += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> s_cur_pic . pu1_col_zero_flag += ( ( ps_dec -> u2_pic_ht * ps_dec -> u2_pic_wd ) >> 5 ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= BOT_FLD ; i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; ps_dec -> ps_cur_pic -> u1_picturetype |= ( ps_cur_slice -> u1_mbaff_frame_flag << 2 ) ; ps_dec -> ps_cur_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_cur_mb_row += 2 ; ps_dec -> ps_top_mb_row = ps_dec -> ps_nbr_mb_row ; ps_dec -> ps_top_mb_row += ( ( ps_dec -> u2_frm_wd_in_mbs + 2 ) << ( 1 - ps_dec -> ps_cur_sps -> u1_frame_mbs_only_flag ) ) ; ps_dec -> ps_top_mb_row += 2 ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_top = ps_dec -> ps_mv_top_p [ 0 ] ; ps_dec -> u1_mv_top_p = 0 ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> ps_mv_left = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> i4_submb_ofst = - ( SUB_BLK_SIZE ) ; ps_dec -> u4_pred_info_idx = 0 ; ps_dec -> u4_pred_info_pkd_idx = 0 ; ps_dec -> u4_dma_buf_idx = 0 ; ps_dec -> ps_mv = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> ps_mv_bank_cur = ps_dec -> s_cur_pic . ps_mv ; ps_dec -> pu1_col_zero_flag = ps_dec -> s_cur_pic . pu1_col_zero_flag ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> i2_prev_slice_mbx = - 1 ; ps_dec -> i2_prev_slice_mby = 0 ; ps_dec -> u2_mv_2mb [ 0 ] = 0 ; ps_dec -> u2_mv_2mb [ 1 ] = 0 ; ps_dec -> u1_last_pic_not_decoded = 0 ; <S2SV_StartBug> ps_dec -> u2_cur_slice_num = 0 ; <S2SV_EndBug> ps_dec -> u2_cur_slice_num_dec_thread = 0 ; ps_dec -> u2_cur_slice_num_bs = 0 ; ps_dec -> u4_intra_pred_line_ofst = 0 ; ps_dec -> pu1_cur_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_cur_y_intra_pred_line_base = ps_dec -> pu1_y_intra_pred_line ; ps_dec -> pu1_cur_u_intra_pred_line_base = ps_dec -> pu1_u_intra_pred_line ; ps_dec -> pu1_cur_v_intra_pred_line_base = ps_dec -> pu1_v_intra_pred_line ; ps_dec -> pu1_prev_y_intra_pred_line = ps_dec -> pu1_y_intra_pred_line + ( ps_dec -> u2_frm_wd_in_mbs * MB_SIZE ) ; ps_dec -> pu1_prev_u_intra_pred_line = ps_dec -> pu1_u_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR ; ps_dec -> pu1_prev_v_intra_pred_line = ps_dec -> pu1_v_intra_pred_line + ps_dec -> u2_frm_wd_in_mbs * BLK8x8SIZE ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; { if ( ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_compute_bs = ih264d_compute_bs_mbaff ; ps_dec -> pf_mvpred = ih264d_mvpred_mbaff ; } else { ps_dec -> pf_compute_bs = ih264d_compute_bs_non_mbaff ; ps_dec -> u1_cur_mb_fld_dec_flag = ps_cur_slice -> u1_field_pic_flag ; } } { UWORD8 u1_field_pic_flag = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; UWORD8 u1_mbaff = ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 uc_lastmbs = ( ( ( ps_dec -> u2_pic_wd ) >> 4 ) % ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) ) ; UWORD16 ui16_lastmbs_widthY = ( uc_lastmbs ? ( uc_lastmbs << 4 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 4 ) ) ; UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? ( uc_lastmbs << 3 ) : ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) << 3 ) ; ps_dec -> s_tran_addrecon . pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_dec -> s_tran_addrecon . pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_dec -> s_tran_addrecon . pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_dec -> s_tran_addrecon . u2_frm_wd_y = ps_dec -> u2_frm_wd_y << u1_field_pic_flag ; ps_dec -> s_tran_addrecon . u2_frm_wd_uv = ps_dec -> u2_frm_wd_uv << u1_field_pic_flag ; if ( u1_field_pic_flag ) { ui16_lastmbs_widthY += ps_dec -> u2_frm_wd_y ; ui16_lastmbs_widthUV += ps_dec -> u2_frm_wd_uv ; } ps_dec -> s_tran_addrecon . u4_inc_y [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 0 ] = ( ( ps_dec -> u1_recon_mb_grp << 4 ) >> u1_mbaff ) ; ps_dec -> s_tran_addrecon . u4_inc_y [ 1 ] = ( ui16_lastmbs_widthY + ( PAD_LEN_Y_H << 1 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_y * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ps_dec -> s_tran_addrecon . u4_inc_uv [ 1 ] = ( ui16_lastmbs_widthUV + ( PAD_LEN_UV_H << 2 ) + ps_dec -> s_tran_addrecon . u2_frm_wd_uv * ( ( 15 << u1_mbaff ) + u1_mbaff ) ) ; ih264d_assign_pic_num ( ps_dec ) ; ps_dec -> s_tran_addrecon . u2_mv_top_left_inc = ( ps_dec -> u1_recon_mb_grp << 2 ) - 1 - ( u1_mbaff << 2 ) ; ps_dec -> s_tran_addrecon . u2_mv_left_inc = ( ( ps_dec -> u1_recon_mb_grp >> u1_mbaff ) - 1 ) << ( 4 + u1_mbaff ) ; } if ( ps_seq -> u1_profile_idc == HIGH_PROFILE_IDC ) { if ( ( ps_seq -> i4_seq_scaling_matrix_present_flag ) || ( ps_pps -> i4_pic_scaling_matrix_present_flag ) ) { ih264d_form_scaling_matrix_picture ( ps_seq , ps_pps , ps_dec ) ; ps_dec -> s_high_profile . u1_scaling_present = 1 ; } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } if ( ps_pps -> i4_transform_8x8_mode_flag ) { ps_dec -> s_high_profile . u1_transform8x8_present = 1 ; } } else { ih264d_form_default_scaling_matrix ( ps_dec ) ; } ps_dec -> s_high_profile . u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; ps_dec -> s_high_profile . s_cavlc_ctxt = ps_dec -> s_cavlc_ctxt ; ps_dec -> i1_recon_in_thread3_flag = 1 ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_addrecon ; if ( ps_dec -> u1_separate_parse ) { memcpy ( & ps_dec -> s_tran_addrecon_parse , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; if ( ps_dec -> u4_num_cores >= 3 && ps_dec -> i1_recon_in_thread3_flag ) { memcpy ( & ps_dec -> s_tran_iprecon , & ps_dec -> s_tran_addrecon , sizeof ( tfr_ctxt_t ) ) ; ps_dec -> ps_frame_buf_ip_recon = & ps_dec -> s_tran_iprecon ; } } ih264d_init_deblk_tfr_ctxt ( ps_dec , & ( ps_dec -> s_pad_mgr ) , & ( ps_dec -> s_tran_addrecon ) , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; ps_dec -> ps_cur_deblk_mb = ps_dec -> ps_deblk_pic ; ps_dec -> u4_cur_deblk_mb_num = 0 ; ps_dec -> u4_deblk_mb_x = 0 ; ps_dec -> u4_deblk_mb_y = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; H264_MUTEX_UNLOCK ( & ps_dec -> process_disp_mutex ) ; return OK ; }
","<S2SV_ModStart> ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart> ; ps_dec -> <S2SV_ModEnd> u2_cur_slice_num_dec_thread = 0
",external@libavc/a78887bcffbc2995cf9ed72e0697acf560875e9e,CVE-2016-3820,https://android.googlesource.com/platform/external/libavc/+/a78887bcffbc2995cf9ed72e0697acf560875e9e,2016-08-05T20:59Z
CWE-772,"CWE-772 static inline rsRetVal processBatchMultiRuleset ( batch_t * pBatch ) { ruleset_t * currRuleset ; batch_t snglRuleBatch ; int i ; int iStart ; int iNew ; <S2SV_StartBug> DEFiRet ; <S2SV_EndBug> CHKiRet ( batchInit ( & snglRuleBatch , pBatch -> nElem ) ) ; snglRuleBatch . pbShutdownImmediate = pBatch -> pbShutdownImmediate ; <S2SV_StartBug> while ( 1 ) { <S2SV_EndBug> for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) FINALIZE ; currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { batchCopyElem ( & ( snglRuleBatch . pElem [ iNew ++ ] ) , & ( pBatch -> pElem [ i ] ) ) ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; } batchFree ( & snglRuleBatch ) ; finalize_it : RETiRet ; }
","<S2SV_ModStart> int iNew ; int bHaveUnprocessed ; DEFiRet ; do { bHaveUnprocessed = 0 ; for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) break ; <S2SV_ModEnd> CHKiRet ( batchInit <S2SV_ModStart> -> pbShutdownImmediate ; currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ; snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ; ++ iNew ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } else { bHaveUnprocessed = 1 ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; batchFree ( & snglRuleBatch ) ; } while ( bHaveUnprocessed == 1 <S2SV_ModEnd> ) ; finalize_it
",rsyslog@rsyslog/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a,CVE-2011-1490,https://github.com/rsyslog/rsyslog/commit/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a,2019-11-14T02:15Z
CWE-125,"CWE-125 static int read_Header ( struct archive_read * a , struct _7z_header_info * h , int check_header_id ) { struct _7zip * zip = ( struct _7zip * ) a -> format -> data ; const unsigned char * p ; struct _7z_folder * folders ; struct _7z_stream_info * si = & ( zip -> si ) ; struct _7zip_entry * entries ; uint32_t folderIndex , indexInFolder ; unsigned i ; int eindex , empty_streams , sindex ; if ( check_header_id ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; if ( * p != kHeader ) return ( - 1 ) ; } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; if ( * p == kArchiveProperties ) { for ( ; ; ) { uint64_t size ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; if ( * p == 0 ) break ; if ( parse_7zip_uint64 ( a , & size ) < 0 ) return ( - 1 ) ; } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; } if ( * p == kMainStreamsInfo ) { if ( read_StreamsInfo ( a , & ( zip -> si ) ) < 0 ) return ( - 1 ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; } if ( * p == kEnd ) return ( 0 ) ; if ( * p != kFilesInfo ) return ( - 1 ) ; if ( parse_7zip_uint64 ( a , & ( zip -> numFiles ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < zip -> numFiles ) return ( - 1 ) ; zip -> entries = calloc ( ( size_t ) zip -> numFiles , sizeof ( * zip -> entries ) ) ; if ( zip -> entries == NULL ) return ( - 1 ) ; entries = zip -> entries ; empty_streams = 0 ; for ( ; ; ) { int type ; uint64_t size ; size_t ll ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kEnd ) break ; if ( parse_7zip_uint64 ( a , & size ) < 0 ) return ( - 1 ) ; if ( zip -> header_bytes_remaining < size ) return ( - 1 ) ; ll = ( size_t ) size ; switch ( type ) { case kEmptyStream : <S2SV_StartBug> h -> emptyStreamBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> sizeof ( * h -> emptyStreamBools ) ) ; if ( h -> emptyStreamBools == NULL ) return ( - 1 ) ; if ( read_Bools ( a , h -> emptyStreamBools , ( size_t ) zip -> numFiles ) < 0 ) return ( - 1 ) ; empty_streams = 0 ; for ( i = 0 ; i < zip -> numFiles ; i ++ ) { if ( h -> emptyStreamBools [ i ] ) empty_streams ++ ; } break ; case kEmptyFile : if ( empty_streams <= 0 ) { if ( header_bytes ( a , ll ) == NULL ) return ( - 1 ) ; break ; } <S2SV_StartBug> h -> emptyFileBools = calloc ( empty_streams , <S2SV_EndBug> sizeof ( * h -> emptyFileBools ) ) ; if ( h -> emptyFileBools == NULL ) return ( - 1 ) ; if ( read_Bools ( a , h -> emptyFileBools , empty_streams ) < 0 ) return ( - 1 ) ; break ; case kAnti : if ( empty_streams <= 0 ) { if ( header_bytes ( a , ll ) == NULL ) return ( - 1 ) ; break ; } <S2SV_StartBug> h -> antiBools = calloc ( empty_streams , <S2SV_EndBug> sizeof ( * h -> antiBools ) ) ; if ( h -> antiBools == NULL ) return ( - 1 ) ; if ( read_Bools ( a , h -> antiBools , empty_streams ) < 0 ) return ( - 1 ) ; break ; case kCTime : case kATime : case kMTime : if ( read_Times ( a , h , type ) < 0 ) return ( - 1 ) ; break ; case kName : { unsigned char * np ; size_t nl , nb ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; ll -- ; <S2SV_StartBug> if ( ( ll & 1 ) || ll < zip -> numFiles * 4 ) <S2SV_EndBug> return ( - 1 ) ; zip -> entry_names = malloc ( ll ) ; if ( zip -> entry_names == NULL ) return ( - 1 ) ; np = zip -> entry_names ; nb = ll ; while ( nb ) { size_t b ; if ( nb > UBUFF_SIZE ) b = UBUFF_SIZE ; else b = nb ; if ( ( p = header_bytes ( a , b ) ) == NULL ) return ( - 1 ) ; memcpy ( np , p , b ) ; np += b ; nb -= b ; } np = zip -> entry_names ; nl = ll ; for ( i = 0 ; i < zip -> numFiles ; i ++ ) { entries [ i ] . utf16name = np ; # if defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) && defined ( _DEBUG ) entries [ i ] . wname = ( wchar_t * ) np ; # endif while ( nl >= 2 && ( np [ 0 ] || np [ 1 ] ) ) { np += 2 ; nl -= 2 ; } if ( nl < 2 ) return ( - 1 ) ; entries [ i ] . name_len = np - entries [ i ] . utf16name ; np += 2 ; nl -= 2 ; } break ; } case kAttributes : { int allAreDefined ; if ( ( p = header_bytes ( a , 2 ) ) == NULL ) return ( - 1 ) ; allAreDefined = * p ; <S2SV_StartBug> h -> attrBools = calloc ( ( size_t ) zip -> numFiles , <S2SV_EndBug> sizeof ( * h -> attrBools ) ) ; if ( h -> attrBools == NULL ) return ( - 1 ) ; if ( allAreDefined ) memset ( h -> attrBools , 1 , ( size_t ) zip -> numFiles ) ; else { if ( read_Bools ( a , h -> attrBools , ( size_t ) zip -> numFiles ) < 0 ) return ( - 1 ) ; } for ( i = 0 ; i < zip -> numFiles ; i ++ ) { if ( h -> attrBools [ i ] ) { if ( ( p = header_bytes ( a , 4 ) ) == NULL ) return ( - 1 ) ; entries [ i ] . attr = archive_le32dec ( p ) ; } } break ; } case kDummy : if ( ll == 0 ) break ; default : if ( header_bytes ( a , ll ) == NULL ) return ( - 1 ) ; break ; } } folders = si -> ci . folders ; eindex = sindex = 0 ; folderIndex = indexInFolder = 0 ; for ( i = 0 ; i < zip -> numFiles ; i ++ ) { if ( h -> emptyStreamBools == NULL || h -> emptyStreamBools [ i ] == 0 ) entries [ i ] . flg |= HAS_STREAM ; entries [ i ] . mode = entries [ i ] . attr >> 16 ; if ( entries [ i ] . flg & HAS_STREAM ) { if ( ( size_t ) sindex >= si -> ss . unpack_streams ) return ( - 1 ) ; if ( entries [ i ] . mode == 0 ) entries [ i ] . mode = AE_IFREG | 0666 ; if ( si -> ss . digestsDefined [ sindex ] ) entries [ i ] . flg |= CRC32_IS_SET ; entries [ i ] . ssIndex = sindex ; sindex ++ ; } else { int dir ; if ( h -> emptyFileBools == NULL ) dir = 1 ; else { if ( h -> emptyFileBools [ eindex ] ) dir = 0 ; else dir = 1 ; eindex ++ ; } if ( entries [ i ] . mode == 0 ) { if ( dir ) entries [ i ] . mode = AE_IFDIR | 0777 ; else entries [ i ] . mode = AE_IFREG | 0666 ; } else if ( dir && ( entries [ i ] . mode & AE_IFMT ) != AE_IFDIR ) { entries [ i ] . mode &= ~ AE_IFMT ; entries [ i ] . mode |= AE_IFDIR ; } if ( ( entries [ i ] . mode & AE_IFMT ) == AE_IFDIR && entries [ i ] . name_len >= 2 && ( entries [ i ] . utf16name [ entries [ i ] . name_len - 2 ] != '/' || entries [ i ] . utf16name [ entries [ i ] . name_len - 1 ] != 0 ) ) { entries [ i ] . utf16name [ entries [ i ] . name_len ] = '/' ; entries [ i ] . utf16name [ entries [ i ] . name_len + 1 ] = 0 ; entries [ i ] . name_len += 2 ; } entries [ i ] . ssIndex = - 1 ; } if ( entries [ i ] . attr & 0x01 ) entries [ i ] . mode &= ~ 0222 ; if ( ( entries [ i ] . flg & HAS_STREAM ) == 0 && indexInFolder == 0 ) { entries [ i ] . folderIndex = - 1 ; continue ; } if ( indexInFolder == 0 ) { for ( ; ; ) { if ( folderIndex >= si -> ci . numFolders ) return ( - 1 ) ; if ( folders [ folderIndex ] . numUnpackStreams ) break ; folderIndex ++ ; } } entries [ i ] . folderIndex = folderIndex ; if ( ( entries [ i ] . flg & HAS_STREAM ) == 0 ) continue ; indexInFolder ++ ; if ( indexInFolder >= folders [ folderIndex ] . numUnpackStreams ) { folderIndex ++ ; indexInFolder = 0 ; } } return ( 0 ) ; }
","<S2SV_ModStart> case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> numFiles * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> * p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
",libarchive@libarchive/7f17c791dcfd8c0416e2cd2485b19410e47ef126,CVE-2016-8689,https://github.com/libarchive/libarchive/commit/7f17c791dcfd8c0416e2cd2485b19410e47ef126,2017-02-15T19:59Z
CWE-20,"CWE-20 error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""Initializing<S2SV_blank>TJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ; <S2SV_StartBug> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; <S2SV_EndBug> tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
","<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ; tja1101WritePhyReg (
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-200,"CWE-200 static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-787,"CWE-787 GPLOT * gplotRead ( const char * filename ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( ""gplotRead"" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( ""filename<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>opened"" , procName , NULL ) ; ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ; } <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> rootname = stringNew ( buf ) ; ignore = fscanf ( fp , ""Output<S2SV_blank>format:<S2SV_blank>%d\\n"" , & outformat ) ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , ""\\nCommandfile<S2SV_blank>data:"" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nDatafile<S2SV_blank>names:"" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>data:"" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>titles:"" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>styles:"" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\n"" , & gplot -> nplots ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , ""Axis<S2SV_blank>scaling:<S2SV_blank>%d\\n"" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }
","<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( fp , ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf )
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
CWE-000,"CWE-000 void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; <S2SV_StartBug> ngx_uint_t n , sec , min , hour , mday , mon , year , wday , days , leap ; <S2SV_EndBug> <S2SV_StartBug> n = ( ngx_uint_t ) t ; <S2SV_EndBug> days = n / 86400 ; <S2SV_StartBug> wday = ( 4 + days ) % 7 ; <S2SV_EndBug> <S2SV_StartBug> n %= 86400 ; <S2SV_EndBug> hour = n / 3600 ; <S2SV_StartBug> n %= 3600 ; <S2SV_EndBug> <S2SV_StartBug> min = n / 60 ; <S2SV_EndBug> <S2SV_StartBug> sec = n % 60 ; <S2SV_EndBug> days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }
","<S2SV_ModStart> yday ; ngx_uint_t <S2SV_ModEnd> sec , min <S2SV_ModStart> , leap ; if ( t < 0 ) { t = 0 ; } days = t <S2SV_ModEnd> / 86400 ; <S2SV_ModStart> / 86400 ; sec = t % 86400 ; <S2SV_ModStart> % 7 ; hour = sec <S2SV_ModEnd> / 3600 ; <S2SV_ModStart> / 3600 ; sec <S2SV_ModEnd> %= 3600 ; <S2SV_ModStart> ; min = sec <S2SV_ModEnd> / 60 ; <S2SV_ModStart> 60 ; sec %= <S2SV_ModEnd> 60 ; days
",nginx@nginx/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf,CVE-2017-20005,https://github.com/nginx/nginx/commit/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf,2021-06-06T22:15Z
CWE-119,"CWE-119 struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , ""tpgt_"" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\""tpgt_#\\""<S2SV_blank>directory"" ""<S2SV_blank>group\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\n"" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO ""TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s"" ""<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n"" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }
","<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
",torvalds@linux/12f09ccb4612734a53e47ed5302e0479c10a50f8,CVE-2011-5327,https://github.com/torvalds/linux/commit/12f09ccb4612734a53e47ed5302e0479c10a50f8,2019-07-27T22:15Z
CWE-119,"CWE-119 static void cliRefreshPrompt ( void ) { <S2SV_StartBug> int len ; <S2SV_EndBug> if ( config . eval_ldb ) return ; <S2SV_StartBug> if ( config . hostsocket != NULL ) <S2SV_EndBug> <S2SV_StartBug> len = snprintf ( config . prompt , sizeof ( config . prompt ) , ""redis<S2SV_blank>%s"" , <S2SV_EndBug> config . hostsocket ) ; else len = anetFormatAddr ( config . prompt , sizeof ( config . prompt ) , config . hostip , config . hostport ) ; if ( config . dbnum != 0 ) len += snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""[%d]"" , config . dbnum ) ; snprintf ( config . prompt + len , sizeof ( config . prompt ) - len , ""><S2SV_blank>"" ) ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> if ( config <S2SV_ModStart> ) return ; sds prompt = sdsempty ( ) ; <S2SV_ModStart> != NULL ) { prompt = sdscatfmt ( prompt , ""redis<S2SV_blank>%s"" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , ""[%i]"" , config . dbnum ) ; prompt = sdscatlen ( prompt , ""><S2SV_blank>"" , 2 ) ; <S2SV_ModEnd> snprintf ( config <S2SV_ModStart> prompt ) , ""%s"" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> ) ; }
",antirez@redis/9fdcc15962f9ff4baebe6fdd947816f43f730d50,CVE-2018-12326,https://github.com/antirez/redis/commit/9fdcc15962f9ff4baebe6fdd947816f43f730d50,2018-06-17T14:29Z
CWE-129,"CWE-129 int sanity_check_ckpt ( struct f2fs_sb_info * sbi ) { unsigned int total , fsmeta ; struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; unsigned int ovp_segments , reserved_segments ; <S2SV_StartBug> total = le32_to_cpu ( raw_super -> segment_count ) ; <S2SV_EndBug> fsmeta = le32_to_cpu ( raw_super -> segment_count_ckpt ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_sit ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_nat ) ; fsmeta += le32_to_cpu ( ckpt -> rsvd_segment_count ) ; fsmeta += le32_to_cpu ( raw_super -> segment_count_ssa ) ; if ( unlikely ( fsmeta >= total ) ) return 1 ; ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; if ( unlikely ( fsmeta < F2FS_MIN_SEGMENTS || ovp_segments == 0 || reserved_segments == 0 ) ) { f2fs_msg ( sbi -> sb , KERN_ERR , ""Wrong<S2SV_blank>layout:<S2SV_blank>check<S2SV_blank>mkfs.f2fs<S2SV_blank>version"" ) ; return 1 ; } <S2SV_StartBug> if ( unlikely ( f2fs_cp_error ( sbi ) ) ) { <S2SV_EndBug> f2fs_msg ( sbi -> sb , KERN_ERR , ""A<S2SV_blank>bug<S2SV_blank>case:<S2SV_blank>need<S2SV_blank>to<S2SV_blank>run<S2SV_blank>fsck"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
",torvalds@linux/15d3042a937c13f5d9244241c7a9c8416ff6e82a,CVE-2017-10663,https://github.com/torvalds/linux/commit/15d3042a937c13f5d9244241c7a9c8416ff6e82a,2017-08-19T18:29Z
CWE-400,"CWE-400 static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; <S2SV_StartBug> __be16 type ; <S2SV_EndBug> off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }
","<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
",torvalds@linux/fac8e0f579695a3ecbc4d3cac369139d7f819971,CVE-2016-8666,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,2016-10-16T21:59Z
CWE-125,"CWE-125 static void sycc420_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b , * nr , * ng , * nb ; const int * y , * cb , * cr , * ny ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> { <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> nr = r + maxw ; ng = g + maxw ; nb = b + maxw ; <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } y += maxw ; r += maxw ; g += maxw ; b += maxw ; } <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> max ) ; d2 = b <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> i < ( loopmaxh <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> 2U ) { size_t j ; <S2SV_ModStart> + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> ( i < loopmaxh ) { size_t j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
",uclouvain@openjpeg/15f081c89650dccee4aa4ae66f614c3fdb268767,CVE-2016-3183,https://github.com/uclouvain/openjpeg/commit/15f081c89650dccee4aa4ae66f614c3fdb268767,2017-02-03T16:59Z
CWE-125,"CWE-125 static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""<S2SV_blank>wb-prep:"" ) ) ; <S2SV_StartBug> if ( len < sizeof ( * prep ) ) { <S2SV_EndBug> return ( - 1 ) ; <S2SV_StartBug> } <S2SV_EndBug> n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
","<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z
CWE-264,"CWE-264 void dev_load ( struct net * net , const char * name ) { struct net_device * dev ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> dev = dev_get_by_name_rcu ( net , name ) ; rcu_read_unlock ( ) ; <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * dev ; int no_module ; <S2SV_ModStart> ( ) ; no_module = ! dev ; if ( no_module <S2SV_ModEnd> && capable ( <S2SV_ModStart> CAP_NET_ADMIN ) ) no_module = request_module ( ""netdev-%s"" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> , name ) ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\n"" , name ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/8909c9ad8ff03611c9c96c9a92656213e4bb495b,CVE-2011-1019,https://github.com/torvalds/linux/commit/8909c9ad8ff03611c9c96c9a92656213e4bb495b,2013-03-01T12:37Z
CWE-22,"CWE-22 int main ( int argc , char * argv [ ] ) { static char buff [ 16384 ] ; struct cpio _cpio ; struct cpio * cpio ; const char * errmsg ; int uid , gid ; int opt ; cpio = & _cpio ; memset ( cpio , 0 , sizeof ( * cpio ) ) ; cpio -> buff = buff ; cpio -> buff_size = sizeof ( buff ) ; # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) { struct sigaction sa ; sigemptyset ( & sa . sa_mask ) ; sa . sa_flags = 0 ; sa . sa_handler = SIG_IGN ; sigaction ( SIGPIPE , & sa , NULL ) ; } # endif lafe_setprogname ( * argv , ""bsdcpio"" ) ; # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , """" ) == NULL ) lafe_warnc ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>default<S2SV_blank>locale"" ) ; # endif cpio -> uid_override = - 1 ; cpio -> gid_override = - 1 ; cpio -> argv = argv ; cpio -> argc = argc ; cpio -> mode = '\\0' ; cpio -> verbose = 0 ; cpio -> compress = '\\0' ; cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ; cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ; # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; # endif cpio -> bytes_per_block = 512 ; cpio -> filename = NULL ; cpio -> matching = archive_match_new ( ) ; if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) { switch ( opt ) { case '0' : cpio -> option_null = 1 ; break ; case 'A' : cpio -> option_append = 1 ; break ; case 'a' : cpio -> option_atime_restore = 1 ; break ; case 'B' : cpio -> bytes_per_block = 5120 ; break ; case OPTION_B64ENCODE : cpio -> add_filter = opt ; break ; case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ; if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , ""Invalid<S2SV_blank>blocksize<S2SV_blank>%s"" , cpio -> argument ) ; break ; case 'c' : cpio -> format = ""odc"" ; break ; case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ; break ; case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case 'F' : cpio -> filename = cpio -> argument ; break ; case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case OPTION_GRZIP : cpio -> compress = opt ; break ; case 'H' : cpio -> format = cpio -> argument ; break ; case 'h' : long_help ( ) ; break ; case 'I' : cpio -> filename = cpio -> argument ; break ; case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-i<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'J' : cpio -> compress = opt ; break ; case 'j' : cpio -> compress = opt ; break ; case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ; <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> break ; case 'L' : cpio -> option_follow_links = 1 ; break ; case 'l' : cpio -> option_link = 1 ; break ; case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ; break ; case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ; break ; case 'n' : cpio -> option_numeric_uid_gid = 1 ; break ; case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ; break ; case 'O' : cpio -> filename = cpio -> argument ; break ; case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-o<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-p<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; break ; case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ; break ; case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; break ; case OPTION_QUIET : cpio -> quiet = 1 ; break ; case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ; if ( errmsg ) { lafe_warnc ( - 1 , ""%s"" , errmsg ) ; usage ( ) ; } if ( uid != - 1 ) { cpio -> uid_override = uid ; cpio -> uname_override = NULL ; } if ( gid != - 1 ) { cpio -> gid_override = gid ; cpio -> gname_override = NULL ; } break ; case 'r' : cpio -> option_rename = 1 ; break ; case 't' : cpio -> option_list = 1 ; break ; case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; break ; case OPTION_UUENCODE : cpio -> add_filter = opt ; break ; case 'v' : cpio -> verbose ++ ; break ; case 'V' : cpio -> dot ++ ; break ; case OPTION_VERSION : version ( ) ; break ; # if 0 case 'W' : break ; # endif case 'y' : cpio -> compress = opt ; break ; case 'Z' : cpio -> compress = opt ; break ; case 'z' : cpio -> compress = opt ; break ; default : usage ( ) ; } } if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ; if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-t<S2SV_blank>requires<S2SV_blank>-i"" ) ; if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-n<S2SV_blank>requires<S2SV_blank>-it"" ) ; if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>--format<S2SV_blank>requires<S2SV_blank>-o"" ) ; if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-l<S2SV_blank>requires<S2SV_blank>-p"" ) ; if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ; switch ( cpio -> mode ) { case 'o' : if ( cpio -> format == NULL ) cpio -> format = ""odc"" ; mode_out ( cpio ) ; break ; case 'i' : while ( * cpio -> argv != NULL ) { if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; -- cpio -> argc ; ++ cpio -> argv ; } if ( cpio -> option_list ) mode_list ( cpio ) ; else mode_in ( cpio ) ; break ; case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , ""-p<S2SV_blank>mode<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>target<S2SV_blank>directory"" ) ; mode_pass ( cpio , * cpio -> argv ) ; break ; default : lafe_errc ( 1 , 0 , ""Must<S2SV_blank>specify<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>of<S2SV_blank>-i,<S2SV_blank>-o,<S2SV_blank>or<S2SV_blank>-p"" ) ; } archive_match_free ( cpio -> matching ) ; free_cache ( cpio -> gname_cache ) ; free_cache ( cpio -> uname_cache ) ; free ( cpio -> destdir ) ; passphrase_free ( cpio -> ppbuff ) ; return ( cpio -> return_value ) ; }
","<S2SV_ModStart> -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-200,"CWE-200 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ; else { g_user_core_flags = O_EXCL ; g_need_nonrelative = 1 ; } } <S2SV_StartBug> if ( setting_MakeCompatCore && ulimit_c != 0 ) <S2SV_EndBug> user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { if ( snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path"" , path ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } <S2SV_StartBug> dd = dd_create_skeleton ( path , fsuid , DEFAULT_DUMP_DIR_MODE , 0 ) ; <S2SV_EndBug> if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; } # if 0 { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } } # endif dd_reset_ownership ( dd ) ; dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>\'%s\'"" , core_basename , user_pwd ) ; unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , core_basename , user_pwd , ( long long ) core_size ) ; } if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return 0 ; }
","<S2SV_ModStart> ; } } const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> ( path , dduid <S2SV_ModEnd> , DEFAULT_DUMP_DIR_MODE ,
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
CWE-772,"CWE-772 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; <S2SV_StartBug> logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; <S2SV_EndBug> image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
",ImageMagick@ImageMagick/437a35e57db5ec078f4a3ccbf71f941276e88430,CVE-2017-13146,https://github.com/ImageMagick/ImageMagick/commit/437a35e57db5ec078f4a3ccbf71f941276e88430,2017-08-23T06:29Z
CWE-000,"CWE-000 <S2SV_StartBug> static void update_open_stateflags ( struct nfs4_state * state , mode_t open_flags ) <S2SV_EndBug> { <S2SV_StartBug> switch ( open_flags ) { <S2SV_EndBug> case FMODE_WRITE : state -> n_wronly ++ ; break ; case FMODE_READ : state -> n_rdonly ++ ; break ; case FMODE_READ | FMODE_WRITE : state -> n_rdwr ++ ; } <S2SV_StartBug> nfs4_state_set_mode_locked ( state , state -> state | open_flags ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( fmode <S2SV_ModEnd> ) { case <S2SV_ModStart> -> state | fmode <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-674,"CWE-674 static krb5_error_code get_tag ( const uint8_t * asn1 , size_t len , taginfo * tag_out , const uint8_t * * contents_out , size_t * clen_out , <S2SV_StartBug> const uint8_t * * remainder_out , size_t * rlen_out ) <S2SV_EndBug> { krb5_error_code ret ; uint8_t o ; const uint8_t * c , * p , * tag_start = asn1 ; size_t clen , llen , i ; taginfo t ; * contents_out = * remainder_out = NULL ; * clen_out = * rlen_out = 0 ; if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; tag_out -> asn1class = o & 0xC0 ; tag_out -> construction = o & 0x20 ; if ( ( o & 0x1F ) != 0x1F ) { tag_out -> tagnum = o & 0x1F ; } else { tag_out -> tagnum = 0 ; do { if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; tag_out -> tagnum = ( tag_out -> tagnum << 7 ) | ( o & 0x7F ) ; } while ( o & 0x80 ) ; } if ( len == 0 ) return ASN1_OVERRUN ; o = * asn1 ++ ; len -- ; if ( o == 0x80 ) { if ( tag_out -> construction != CONSTRUCTED ) return ASN1_MISMATCH_INDEF ; <S2SV_StartBug> p = asn1 ; <S2SV_EndBug> while ( ! ( len >= 2 && p [ 0 ] == 0 && p [ 1 ] == 0 ) ) { <S2SV_StartBug> ret = get_tag ( p , len , & t , & c , & clen , & p , & len ) ; <S2SV_EndBug> if ( ret ) return ret ; } tag_out -> tag_end_len = 2 ; * contents_out = asn1 ; * clen_out = p - asn1 ; * remainder_out = p + 2 ; * rlen_out = len - 2 ; } else if ( ( o & 0x80 ) == 0 ) { if ( o > len ) return ASN1_OVERRUN ; tag_out -> tag_end_len = 0 ; * contents_out = asn1 ; * clen_out = o ; * remainder_out = asn1 + * clen_out ; * rlen_out = len - ( * remainder_out - asn1 ) ; } else { llen = o & 0x7F ; if ( llen > len ) return ASN1_OVERRUN ; if ( llen > sizeof ( * clen_out ) ) return ASN1_OVERFLOW ; for ( i = 0 , clen = 0 ; i < llen ; i ++ ) clen = ( clen << 8 ) | asn1 [ i ] ; if ( clen > len - llen ) return ASN1_OVERRUN ; tag_out -> tag_end_len = 0 ; * contents_out = asn1 + llen ; * clen_out = clen ; * remainder_out = * contents_out + clen ; * rlen_out = len - ( * remainder_out - asn1 ) ; } tag_out -> tag_len = * contents_out - tag_start ; return 0 ; }
","<S2SV_ModStart> size_t * rlen_out , int recursion <S2SV_ModStart> return ASN1_MISMATCH_INDEF ; if ( recursion >= 32 ) return ASN1_OVERFLOW ; <S2SV_ModStart> , & len , recursion + 1
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z
CWE-20,"CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MaxTextExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( depth , BImgBuff , i , image ) ; } ( void ) SyncImage ( image ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , & image -> exception ) != MagickFalse ) ) { if ( GetCutColors ( image ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( q , QuantumRange ) ; SetPixelGreen ( q , QuantumRange ) ; SetPixelBlue ( q , QuantumRange ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
",ImageMagick@ImageMagick6/1e59b29e520d2beab73e8c78aacd5f1c0d76196d,CVE-2019-13135,https://github.com/ImageMagick/ImageMagick6/commit/1e59b29e520d2beab73e8c78aacd5f1c0d76196d,2019-07-01T20:15Z
CWE-787,"CWE-787 __inline # if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__ __attribute__ ( ( __gnu_inline__ ) ) # endif # endif const struct ByUnfoldKey * unicode_unfold_key ( OnigCodePoint code ) { static const struct ByUnfoldKey wordlist [ ] = { { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x1040a , 3267 , 1 } , { 0x1e0a , 1727 , 1 } , { 0x040a , 1016 , 1 } , { 0x010a , 186 , 1 } , { 0x1f0a , 2088 , 1 } , { 0x2c0a , 2451 , 1 } , { 0x0189 , 619 , 1 } , { 0x1f89 , 134 , 2 } , { 0x1f85 , 154 , 2 } , { 0x0389 , 733 , 1 } , { 0x03ff , 724 , 1 } , { 0xab89 , 1523 , 1 } , { 0xab85 , 1511 , 1 } , { 0x10c89 , 3384 , 1 } , { 0x10c85 , 3372 , 1 } , { 0x1e84 , 1911 , 1 } , { 0x03f5 , 752 , 1 } , { 0x0184 , 360 , 1 } , { 0x1f84 , 149 , 2 } , { 0x2c84 , 2592 , 1 } , { 0x017d , 351 , 1 } , { 0x1ff3 , 96 , 2 } , { 0xab84 , 1508 , 1 } , { 0xa784 , 3105 , 1 } , { 0x10c84 , 3369 , 1 } , { 0xab7d , 1487 , 1 } , { 0xa77d , 1706 , 1 } , { 0x1e98 , 38 , 2 } , { 0x0498 , 1106 , 1 } , { 0x0198 , 375 , 1 } , { 0x1f98 , 169 , 2 } , { 0x2c98 , 2622 , 1 } , { 0x0398 , 762 , 1 } , { 0xa684 , 2940 , 1 } , { 0xab98 , 1568 , 1 } , { 0xa798 , 3123 , 1 } , { 0x10c98 , 3429 , 1 } , { 0x050a , 1277 , 1 } , { 0x1ffb , 2265 , 1 } , { 0x1e96 , 16 , 2 } , { 0x0496 , 1103 , 1 } , { 0x0196 , 652 , 1 } , { 0x1f96 , 199 , 2 } , { 0x2c96 , 2619 , 1 } , { 0x0396 , 756 , 1 } , { 0xa698 , 2970 , 1 } , { 0xab96 , 1562 , 1 } , { 0xa796 , 3120 , 1 } , { 0x10c96 , 3423 , 1 } , { 0x1feb , 2259 , 1 } , { 0x2ceb , 2736 , 1 } , { 0x1e90 , 1929 , 1 } , { 0x0490 , 1094 , 1 } , { 0x0190 , 628 , 1 } , { 0x1f90 , 169 , 2 } , { 0x2c90 , 2610 , 1 } , { 0x0390 , 25 , 3 } , { 0xa696 , 2967 , 1 } , { 0xab90 , 1544 , 1 } , { 0xa790 , 3114 , 1 } , { 0x10c90 , 3405 , 1 } , { 0x01d7 , 444 , 1 } , { 0x1fd7 , 31 , 3 } , { 0x1ea6 , 1947 , 1 } , { 0x04a6 , 1127 , 1 } , { 0x01a6 , 676 , 1 } , { 0x1fa6 , 239 , 2 } , { 0x2ca6 , 2643 , 1 } , { 0x03a6 , 810 , 1 } , { 0xa690 , 2958 , 1 } , { 0xaba6 , 1610 , 1 } , { 0xa7a6 , 3144 , 1 } , { 0x10ca6 , 3471 , 1 } , { 0x1ea4 , 1944 , 1 } , { 0x04a4 , 1124 , 1 } , { 0x01a4 , 390 , 1 } , { 0x1fa4 , 229 , 2 } , { 0x2ca4 , 2640 , 1 } , { 0x03a4 , 804 , 1 } , { 0x10a6 , 2763 , 1 } , { 0xaba4 , 1604 , 1 } , { 0xa7a4 , 3141 , 1 } , { 0x10ca4 , 3465 , 1 } , { 0x1ea0 , 1938 , 1 } , { 0x04a0 , 1118 , 1 } , { 0x01a0 , 384 , 1 } , { 0x1fa0 , 209 , 2 } , { 0x2ca0 , 2634 , 1 } , { 0x03a0 , 792 , 1 } , { 0x10a4 , 2757 , 1 } , { 0xaba0 , 1592 , 1 } , { 0xa7a0 , 3135 , 1 } , { 0x10ca0 , 3453 , 1 } , { 0x1eb2 , 1965 , 1 } , { 0x04b2 , 1145 , 1 } , { 0x01b2 , 694 , 1 } , { 0x1fb2 , 249 , 2 } , { 0x2cb2 , 2661 , 1 } , { 0x03fd , 718 , 1 } , { 0x10a0 , 2745 , 1 } , { 0xabb2 , 1646 , 1 } , { 0xa7b2 , 703 , 1 } , { 0x10cb2 , 3507 , 1 } , { 0x1eac , 1956 , 1 } , { 0x04ac , 1136 , 1 } , { 0x01ac , 396 , 1 } , { 0x1fac , 229 , 2 } , { 0x2cac , 2652 , 1 } , { 0x0537 , 1352 , 1 } , { 0x10b2 , 2799 , 1 } , { 0xabac , 1628 , 1 } , { 0xa7ac , 637 , 1 } , { 0x10cac , 3489 , 1 } , { 0x1eaa , 1953 , 1 } , { 0x04aa , 1133 , 1 } , { 0x00dd , 162 , 1 } , { 0x1faa , 219 , 2 } , { 0x2caa , 2649 , 1 } , { 0x03aa , 824 , 1 } , { 0x10ac , 2781 , 1 } , { 0xabaa , 1622 , 1 } , { 0xa7aa , 646 , 1 } , { 0x10caa , 3483 , 1 } , { 0x1ea8 , 1950 , 1 } , { 0x04a8 , 1130 , 1 } , { 0x020a , 517 , 1 } , { 0x1fa8 , 209 , 2 } , { 0x2ca8 , 2646 , 1 } , { 0x03a8 , 817 , 1 } , { 0x10aa , 2775 , 1 } , { 0xaba8 , 1616 , 1 } , { 0xa7a8 , 3147 , 1 } , { 0x10ca8 , 3477 , 1 } , { 0x1ea2 , 1941 , 1 } , { 0x04a2 , 1121 , 1 } , { 0x01a2 , 387 , 1 } , { 0x1fa2 , 219 , 2 } , { 0x2ca2 , 2637 , 1 } , { 0x118a6 , 3528 , 1 } , { 0x10a8 , 2769 , 1 } , { 0xaba2 , 1598 , 1 } , { 0xa7a2 , 3138 , 1 } , { 0x10ca2 , 3459 , 1 } , { 0x2ced , 2739 , 1 } , { 0x1fe9 , 2283 , 1 } , { 0x1fe7 , 47 , 3 } , { 0x1eb0 , 1962 , 1 } , { 0x04b0 , 1142 , 1 } , { 0x118a4 , 3522 , 1 } , { 0x10a2 , 2751 , 1 } , { 0x2cb0 , 2658 , 1 } , { 0x03b0 , 41 , 3 } , { 0x1fe3 , 41 , 3 } , { 0xabb0 , 1640 , 1 } , { 0xa7b0 , 706 , 1 } , { 0x10cb0 , 3501 , 1 } , { 0x01d9 , 447 , 1 } , { 0x1fd9 , 2277 , 1 } , { 0x118a0 , 3510 , 1 } , { 0x00df , 24 , 2 } , { 0x00d9 , 150 , 1 } , { 0xab77 , 1469 , 1 } , { 0x10b0 , 2793 , 1 } , { 0x1eae , 1959 , 1 } , { 0x04ae , 1139 , 1 } , { 0x01ae , 685 , 1 } , { 0x1fae , 239 , 2 } , { 0x2cae , 2655 , 1 } , { 0x118b2 , 3564 , 1 } , { 0xab73 , 1457 , 1 } , { 0xabae , 1634 , 1 } , { 0xab71 , 1451 , 1 } , { 0x10cae , 3495 , 1 } , { 0x1e2a , 1775 , 1 } , { 0x042a , 968 , 1 } , { 0x012a , 234 , 1 } , { 0x1f2a , 2130 , 1 } , { 0x2c2a , 2547 , 1 } , { 0x118ac , 3546 , 1 } , { 0x10ae , 2787 , 1 } , { 0x0535 , 1346 , 1 } , { 0xa72a , 2988 , 1 } , { 0x1e9a , 0 , 2 } , { 0x049a , 1109 , 1 } , { 0xff37 , 3225 , 1 } , { 0x1f9a , 179 , 2 } , { 0x2c9a , 2625 , 1 } , { 0x039a , 772 , 1 } , { 0x118aa , 3540 , 1 } , { 0xab9a , 1574 , 1 } , { 0xa79a , 3126 , 1 } , { 0x10c9a , 3435 , 1 } , { 0x1e94 , 1935 , 1 } , { 0x0494 , 1100 , 1 } , { 0x0194 , 640 , 1 } , { 0x1f94 , 189 , 2 } , { 0x2c94 , 2616 , 1 } , { 0x0394 , 749 , 1 } , { 0x118a8 , 3534 , 1 } , { 0xab94 , 1556 , 1 } , { 0xa69a , 2973 , 1 } , { 0x10c94 , 3417 , 1 } , { 0x10402 , 3243 , 1 } , { 0x1e02 , 1715 , 1 } , { 0x0402 , 992 , 1 } , { 0x0102 , 174 , 1 } , { 0x0533 , 1340 , 1 } , { 0x2c02 , 2427 , 1 } , { 0x118a2 , 3516 , 1 } , { 0x052a , 1325 , 1 } , { 0xa694 , 2964 , 1 } , { 0x1e92 , 1932 , 1 } , { 0x0492 , 1097 , 1 } , { 0x2165 , 2307 , 1 } , { 0x1f92 , 179 , 2 } , { 0x2c92 , 2613 , 1 } , { 0x0392 , 742 , 1 } , { 0x2161 , 2295 , 1 } , { 0xab92 , 1550 , 1 } , { 0xa792 , 3117 , 1 } , { 0x10c92 , 3411 , 1 } , { 0x118b0 , 3558 , 1 } , { 0x1f5f , 2199 , 1 } , { 0x1e8e , 1926 , 1 } , { 0x048e , 1091 , 1 } , { 0x018e , 453 , 1 } , { 0x1f8e , 159 , 2 } , { 0x2c8e , 2607 , 1 } , { 0x038e , 833 , 1 } , { 0xa692 , 2961 , 1 } , { 0xab8e , 1538 , 1 } , { 0x0055 , 59 , 1 } , { 0x10c8e , 3399 , 1 } , { 0x1f5d , 2196 , 1 } , { 0x212a , 27 , 1 } , { 0x04cb , 1181 , 1 } , { 0x01cb , 425 , 1 } , { 0x1fcb , 2241 , 1 } , { 0x118ae , 3552 , 1 } , { 0x0502 , 1265 , 1 } , { 0x00cb , 111 , 1 } , { 0xa68e , 2955 , 1 } , { 0x1e8a , 1920 , 1 } , { 0x048a , 1085 , 1 } , { 0x018a , 622 , 1 } , { 0x1f8a , 139 , 2 } , { 0x2c8a , 2601 , 1 } , { 0x038a , 736 , 1 } , { 0x2c67 , 2571 , 1 } , { 0xab8a , 1526 , 1 } , { 0x1e86 , 1914 , 1 } , { 0x10c8a , 3387 , 1 } , { 0x0186 , 616 , 1 } , { 0x1f86 , 159 , 2 } , { 0x2c86 , 2595 , 1 } , { 0x0386 , 727 , 1 } , { 0xff35 , 3219 , 1 } , { 0xab86 , 1514 , 1 } , { 0xa786 , 3108 , 1 } , { 0x10c86 , 3375 , 1 } , { 0xa68a , 2949 , 1 } , { 0x0555 , 1442 , 1 } , { 0x1ebc , 1980 , 1 } , { 0x04bc , 1160 , 1 } , { 0x01bc , 411 , 1 } , { 0x1fbc , 62 , 2 } , { 0x2cbc , 2676 , 1 } , { 0x1f5b , 2193 , 1 } , { 0xa686 , 2943 , 1 } , { 0xabbc , 1676 , 1 } , { 0x1eb8 , 1974 , 1 } , { 0x04b8 , 1154 , 1 } , { 0x01b8 , 408 , 1 } , { 0x1fb8 , 2268 , 1 } , { 0x2cb8 , 2670 , 1 } , { 0x01db , 450 , 1 } , { 0x1fdb , 2247 , 1 } , { 0xabb8 , 1664 , 1 } , { 0x10bc , 2829 , 1 } , { 0x00db , 156 , 1 } , { 0x1eb6 , 1971 , 1 } , { 0x04b6 , 1151 , 1 } , { 0xff33 , 3213 , 1 } , { 0x1fb6 , 58 , 2 } , { 0x2cb6 , 2667 , 1 } , { 0xff2a , 3186 , 1 } , { 0x10b8 , 2817 , 1 } , { 0xabb6 , 1658 , 1 } , { 0xa7b6 , 3153 , 1 } , { 0x10426 , 3351 , 1 } , { 0x1e26 , 1769 , 1 } , { 0x0426 , 956 , 1 } , { 0x0126 , 228 , 1 } , { 0x0053 , 52 , 1 } , { 0x2c26 , 2535 , 1 } , { 0x0057 , 65 , 1 } , { 0x10b6 , 2811 , 1 } , { 0x022a , 562 , 1 } , { 0xa726 , 2982 , 1 } , { 0x1e2e , 1781 , 1 } , { 0x042e , 980 , 1 } , { 0x012e , 240 , 1 } , { 0x1f2e , 2142 , 1 } , { 0x2c2e , 2559 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2167 , 2313 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa72e , 2994 , 1 } , { 0x1e2c , 1778 , 1 } , { 0x042c , 974 , 1 } , { 0x012c , 237 , 1 } , { 0x1f2c , 2136 , 1 } , { 0x2c2c , 2553 , 1 } , { 0x1f6f , 2223 , 1 } , { 0x2c6f , 604 , 1 } , { 0xabbf , 1685 , 1 } , { 0xa72c , 2991 , 1 } , { 0x1e28 , 1772 , 1 } , { 0x0428 , 962 , 1 } , { 0x0128 , 231 , 1 } , { 0x1f28 , 2124 , 1 } , { 0x2c28 , 2541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0553 , 1436 , 1 } , { 0x10bf , 2838 , 1 } , { 0xa728 , 2985 , 1 } , { 0x0526 , 1319 , 1 } , { 0x0202 , 505 , 1 } , { 0x1e40 , 1808 , 1 } , { 0x10424 , 3345 , 1 } , { 0x1e24 , 1766 , 1 } , { 0x0424 , 950 , 1 } , { 0x0124 , 225 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c24 , 2529 , 1 } , { 0x052e , 1331 , 1 } , { 0xa740 , 3018 , 1 } , { 0x118bc , 3594 , 1 } , { 0xa724 , 2979 , 1 } , { 0x1ef2 , 2061 , 1 } , { 0x04f2 , 1241 , 1 } , { 0x01f2 , 483 , 1 } , { 0x1ff2 , 257 , 2 } , { 0x2cf2 , 2742 , 1 } , { 0x052c , 1328 , 1 } , { 0x118b8 , 3582 , 1 } , { 0xa640 , 2865 , 1 } , { 0x10422 , 3339 , 1 } , { 0x1e22 , 1763 , 1 } , { 0x0422 , 944 , 1 } , { 0x0122 , 222 , 1 } , { 0x2126 , 820 , 1 } , { 0x2c22 , 2523 , 1 } , { 0x0528 , 1322 , 1 } , { 0x01f1 , 483 , 1 } , { 0x118b6 , 3576 , 1 } , { 0xa722 , 2976 , 1 } , { 0x03f1 , 796 , 1 } , { 0x1ebe , 1983 , 1 } , { 0x04be , 1163 , 1 } , { 0xfb02 , 12 , 2 } , { 0x1fbe , 767 , 1 } , { 0x2cbe , 2679 , 1 } , { 0x01b5 , 405 , 1 } , { 0x0540 , 1379 , 1 } , { 0xabbe , 1682 , 1 } , { 0x0524 , 1316 , 1 } , { 0x00b5 , 779 , 1 } , { 0xabb5 , 1655 , 1 } , { 0x1eba , 1977 , 1 } , { 0x04ba , 1157 , 1 } , { 0x216f , 2337 , 1 } , { 0x1fba , 2226 , 1 } , { 0x2cba , 2673 , 1 } , { 0x10be , 2835 , 1 } , { 0x0051 , 46 , 1 } , { 0xabba , 1670 , 1 } , { 0x10b5 , 2808 , 1 } , { 0x1e6e , 1878 , 1 } , { 0x046e , 1055 , 1 } , { 0x016e , 330 , 1 } , { 0x1f6e , 2220 , 1 } , { 0x2c6e , 664 , 1 } , { 0x118bf , 3603 , 1 } , { 0x0522 , 1313 , 1 } , { 0x10ba , 2823 , 1 } , { 0xa76e , 3087 , 1 } , { 0x1eb4 , 1968 , 1 } , { 0x04b4 , 1148 , 1 } , { 0x2c75 , 2583 , 1 } , { 0x1fb4 , 50 , 2 } , { 0x2cb4 , 2664 , 1 } , { 0xab75 , 1463 , 1 } , { 0x1ec2 , 1989 , 1 } , { 0xabb4 , 1652 , 1 } , { 0xa7b4 , 3150 , 1 } , { 0x1fc2 , 253 , 2 } , { 0x2cc2 , 2685 , 1 } , { 0x03c2 , 800 , 1 } , { 0x00c2 , 83 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff26 , 3174 , 1 } , { 0x10b4 , 2805 , 1 } , { 0x1eca , 2001 , 1 } , { 0x0551 , 1430 , 1 } , { 0x01ca , 425 , 1 } , { 0x1fca , 2238 , 1 } , { 0x2cca , 2697 , 1 } , { 0x10c2 , 2847 , 1 } , { 0x00ca , 108 , 1 } , { 0xff2e , 3198 , 1 } , { 0x1e8c , 1923 , 1 } , { 0x048c , 1088 , 1 } , { 0x0226 , 556 , 1 } , { 0x1f8c , 149 , 2 } , { 0x2c8c , 2604 , 1 } , { 0x038c , 830 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8c , 1532 , 1 } , { 0xff2c , 3192 , 1 } , { 0x10c8c , 3393 , 1 } , { 0x1ec4 , 1992 , 1 } , { 0x022e , 568 , 1 } , { 0x01c4 , 417 , 1 } , { 0x1fc4 , 54 , 2 } , { 0x2cc4 , 2688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c4 , 89 , 1 } , { 0xff28 , 3180 , 1 } , { 0xa68c , 2952 , 1 } , { 0x01cf , 432 , 1 } , { 0x022c , 565 , 1 } , { 0x118be , 3600 , 1 } , { 0x03cf , 839 , 1 } , { 0x00cf , 123 , 1 } , { 0x118b5 , 3573 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c4 , 2853 , 1 } , { 0x216e , 2334 , 1 } , { 0x24cb , 2406 , 1 } , { 0x0228 , 559 , 1 } , { 0xff24 , 3168 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ba , 3588 , 1 } , { 0x1efe , 2079 , 1 } , { 0x04fe , 1259 , 1 } , { 0x01fe , 499 , 1 } , { 0x1e9e , 24 , 2 } , { 0x049e , 1115 , 1 } , { 0x03fe , 721 , 1 } , { 0x1f9e , 199 , 2 } , { 0x2c9e , 2631 , 1 } , { 0x039e , 786 , 1 } , { 0x0224 , 553 , 1 } , { 0xab9e , 1586 , 1 } , { 0xa79e , 3132 , 1 } , { 0x10c9e , 3447 , 1 } , { 0x01f7 , 414 , 1 } , { 0x1ff7 , 67 , 3 } , { 0xff22 , 3162 , 1 } , { 0x03f7 , 884 , 1 } , { 0x118b4 , 3570 , 1 } , { 0x049c , 1112 , 1 } , { 0x019c , 661 , 1 } , { 0x1f9c , 189 , 2 } , { 0x2c9c , 2628 , 1 } , { 0x039c , 779 , 1 } , { 0x24bc , 2361 , 1 } , { 0xab9c , 1580 , 1 } , { 0xa79c , 3129 , 1 } , { 0x10c9c , 3441 , 1 } , { 0x0222 , 550 , 1 } , { 0x1e7c , 1899 , 1 } , { 0x047c , 1076 , 1 } , { 0x1e82 , 1908 , 1 } , { 0x24b8 , 2349 , 1 } , { 0x0182 , 357 , 1 } , { 0x1f82 , 139 , 2 } , { 0x2c82 , 2589 , 1 } , { 0xab7c , 1484 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab82 , 1502 , 1 } , { 0xa782 , 3102 , 1 } , { 0x10c82 , 3363 , 1 } , { 0x2c63 , 1709 , 1 } , { 0x24b6 , 2343 , 1 } , { 0x1e80 , 1905 , 1 } , { 0x0480 , 1082 , 1 } , { 0x1f59 , 2190 , 1 } , { 0x1f80 , 129 , 2 } , { 0x2c80 , 2586 , 1 } , { 0x0059 , 71 , 1 } , { 0xa682 , 2937 , 1 } , { 0xab80 , 1496 , 1 } , { 0xa780 , 3099 , 1 } , { 0x10c80 , 3357 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1e4c , 1826 , 1 } , { 0x0145 , 270 , 1 } , { 0x014c , 279 , 1 } , { 0x1f4c , 2184 , 1 } , { 0x0345 , 767 , 1 } , { 0x0045 , 12 , 1 } , { 0x004c , 31 , 1 } , { 0xa680 , 2934 , 1 } , { 0xa74c , 3036 , 1 } , { 0x1e4a , 1823 , 1 } , { 0x01d5 , 441 , 1 } , { 0x014a , 276 , 1 } , { 0x1f4a , 2178 , 1 } , { 0x03d5 , 810 , 1 } , { 0x00d5 , 141 , 1 } , { 0x004a , 24 , 1 } , { 0x24bf , 2370 , 1 } , { 0xa74a , 3033 , 1 } , { 0xa64c , 2883 , 1 } , { 0x1041c , 3321 , 1 } , { 0x1e1c , 1754 , 1 } , { 0x041c , 926 , 1 } , { 0x011c , 213 , 1 } , { 0x1f1c , 2118 , 1 } , { 0x2c1c , 2505 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xa64a , 2880 , 1 } , { 0x1041a , 3315 , 1 } , { 0x1e1a , 1751 , 1 } , { 0x041a , 920 , 1 } , { 0x011a , 210 , 1 } , { 0x1f1a , 2112 , 1 } , { 0x2c1a , 2499 , 1 } , { 0xabbd , 1679 , 1 } , { 0x0545 , 1394 , 1 } , { 0x054c , 1415 , 1 } , { 0x10418 , 3309 , 1 } , { 0x1e18 , 1748 , 1 } , { 0x0418 , 914 , 1 } , { 0x0118 , 207 , 1 } , { 0x1f18 , 2106 , 1 } , { 0x2c18 , 2493 , 1 } , { 0x10bd , 2832 , 1 } , { 0x2163 , 2301 , 1 } , { 0x054a , 1409 , 1 } , { 0x1040e , 3279 , 1 } , { 0x1e0e , 1733 , 1 } , { 0x040e , 1028 , 1 } , { 0x010e , 192 , 1 } , { 0x1f0e , 2100 , 1 } , { 0x2c0e , 2463 , 1 } , { 0x1efc , 2076 , 1 } , { 0x04fc , 1256 , 1 } , { 0x01fc , 496 , 1 } , { 0x1ffc , 96 , 2 } , { 0x051c , 1304 , 1 } , { 0x1040c , 3273 , 1 } , { 0x1e0c , 1730 , 1 } , { 0x040c , 1022 , 1 } , { 0x010c , 189 , 1 } , { 0x1f0c , 2094 , 1 } , { 0x2c0c , 2457 , 1 } , { 0x1f6d , 2217 , 1 } , { 0x2c6d , 607 , 1 } , { 0x051a , 1301 , 1 } , { 0x24be , 2367 , 1 } , { 0x10408 , 3261 , 1 } , { 0x1e08 , 1724 , 1 } , { 0x0408 , 1010 , 1 } , { 0x0108 , 183 , 1 } , { 0x1f08 , 2082 , 1 } , { 0x2c08 , 2445 , 1 } , { 0x04c9 , 1178 , 1 } , { 0x0518 , 1298 , 1 } , { 0x1fc9 , 2235 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ba , 2355 , 1 } , { 0x00c9 , 105 , 1 } , { 0x10416 , 3303 , 1 } , { 0x1e16 , 1745 , 1 } , { 0x0416 , 908 , 1 } , { 0x0116 , 204 , 1 } , { 0x050e , 1283 , 1 } , { 0x2c16 , 2487 , 1 } , { 0x10414 , 3297 , 1 } , { 0x1e14 , 1742 , 1 } , { 0x0414 , 902 , 1 } , { 0x0114 , 201 , 1 } , { 0x042b , 971 , 1 } , { 0x2c14 , 2481 , 1 } , { 0x1f2b , 2133 , 1 } , { 0x2c2b , 2550 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x050c , 1280 , 1 } , { 0x10406 , 3255 , 1 } , { 0x1e06 , 1721 , 1 } , { 0x0406 , 1004 , 1 } , { 0x0106 , 180 , 1 } , { 0x13fb , 1697 , 1 } , { 0x2c06 , 2439 , 1 } , { 0x24c2 , 2379 , 1 } , { 0x118bd , 3597 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0508 , 1274 , 1 } , { 0x10404 , 3249 , 1 } , { 0x1e04 , 1718 , 1 } , { 0x0404 , 998 , 1 } , { 0x0104 , 177 , 1 } , { 0x1f95 , 194 , 2 } , { 0x2c04 , 2433 , 1 } , { 0x0395 , 752 , 1 } , { 0x24ca , 2403 , 1 } , { 0xab95 , 1559 , 1 } , { 0x0531 , 1334 , 1 } , { 0x10c95 , 3420 , 1 } , { 0x0516 , 1295 , 1 } , { 0x1e6c , 1875 , 1 } , { 0x046c , 1052 , 1 } , { 0x016c , 327 , 1 } , { 0x1f6c , 2214 , 1 } , { 0x216d , 2331 , 1 } , { 0x0514 , 1292 , 1 } , { 0x0245 , 697 , 1 } , { 0x024c , 598 , 1 } , { 0xa76c , 3084 , 1 } , { 0x10400 , 3237 , 1 } , { 0x1e00 , 1712 , 1 } , { 0x0400 , 986 , 1 } , { 0x0100 , 171 , 1 } , { 0x24c4 , 2385 , 1 } , { 0x2c00 , 2421 , 1 } , { 0x0506 , 1271 , 1 } , { 0x024a , 595 , 1 } , { 0x1fab , 224 , 2 } , { 0xa66c , 2931 , 1 } , { 0x03ab , 827 , 1 } , { 0x24cf , 2418 , 1 } , { 0xabab , 1625 , 1 } , { 0xa7ab , 631 , 1 } , { 0x10cab , 3486 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0504 , 1268 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x021c , 544 , 1 } , { 0x01a9 , 679 , 1 } , { 0x1fa9 , 214 , 2 } , { 0x10ab , 2778 , 1 } , { 0x03a9 , 820 , 1 } , { 0x212b , 92 , 1 } , { 0xaba9 , 1619 , 1 } , { 0x1e88 , 1917 , 1 } , { 0x10ca9 , 3480 , 1 } , { 0x021a , 541 , 1 } , { 0x1f88 , 129 , 2 } , { 0x2c88 , 2598 , 1 } , { 0x0388 , 730 , 1 } , { 0x13fd , 1703 , 1 } , { 0xab88 , 1520 , 1 } , { 0x10a9 , 2772 , 1 } , { 0x10c88 , 3381 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0218 , 538 , 1 } , { 0x0500 , 1262 , 1 } , { 0x1f4d , 2187 , 1 } , { 0x01a7 , 393 , 1 } , { 0x1fa7 , 244 , 2 } , { 0x004d , 34 , 1 } , { 0x03a7 , 814 , 1 } , { 0xa688 , 2946 , 1 } , { 0xaba7 , 1613 , 1 } , { 0x020e , 523 , 1 } , { 0x10ca7 , 3474 , 1 } , { 0x1e6a , 1872 , 1 } , { 0x046a , 1049 , 1 } , { 0x016a , 324 , 1 } , { 0x1f6a , 2208 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216c , 2328 , 1 } , { 0x10a7 , 2766 , 1 } , { 0x01d1 , 435 , 1 } , { 0xa76a , 3081 , 1 } , { 0x020c , 520 , 1 } , { 0x03d1 , 762 , 1 } , { 0x00d1 , 129 , 1 } , { 0x1e68 , 1869 , 1 } , { 0x0468 , 1046 , 1 } , { 0x0168 , 321 , 1 } , { 0x1f68 , 2202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff31 , 3207 , 1 } , { 0xa66a , 2928 , 1 } , { 0x0208 , 514 , 1 } , { 0xa768 , 3078 , 1 } , { 0x1e64 , 1863 , 1 } , { 0x0464 , 1040 , 1 } , { 0x0164 , 315 , 1 } , { 0x054d , 1418 , 1 } , { 0x2c64 , 673 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff2b , 3189 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa764 , 3072 , 1 } , { 0xa668 , 2925 , 1 } , { 0x0216 , 535 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x118ab , 3543 , 1 } , { 0x1e62 , 1860 , 1 } , { 0x0462 , 1037 , 1 } , { 0x0162 , 312 , 1 } , { 0x0214 , 532 , 1 } , { 0x2c62 , 655 , 1 } , { 0xa664 , 2919 , 1 } , { 0x1ed2 , 2013 , 1 } , { 0x04d2 , 1193 , 1 } , { 0xa762 , 3069 , 1 } , { 0x1fd2 , 20 , 3 } , { 0x2cd2 , 2709 , 1 } , { 0x118a9 , 3537 , 1 } , { 0x00d2 , 132 , 1 } , { 0x0206 , 511 , 1 } , { 0x10420 , 3333 , 1 } , { 0x1e20 , 1760 , 1 } , { 0x0420 , 938 , 1 } , { 0x0120 , 219 , 1 } , { 0xa662 , 2916 , 1 } , { 0x2c20 , 2517 , 1 } , { 0x1e60 , 1856 , 1 } , { 0x0460 , 1034 , 1 } , { 0x0160 , 309 , 1 } , { 0x0204 , 508 , 1 } , { 0x2c60 , 2562 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24bd , 2364 , 1 } , { 0x216a , 2322 , 1 } , { 0xa760 , 3066 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb16 , 125 , 2 } , { 0x118a7 , 3531 , 1 } , { 0x1efa , 2073 , 1 } , { 0x04fa , 1253 , 1 } , { 0x01fa , 493 , 1 } , { 0x1ffa , 2262 , 1 } , { 0xfb14 , 109 , 2 } , { 0x03fa , 887 , 1 } , { 0xa660 , 2913 , 1 } , { 0x2168 , 2316 , 1 } , { 0x01b7 , 700 , 1 } , { 0x1fb7 , 10 , 3 } , { 0x1f6b , 2211 , 1 } , { 0x2c6b , 2577 , 1 } , { 0x0200 , 502 , 1 } , { 0xabb7 , 1661 , 1 } , { 0xfb06 , 29 , 2 } , { 0x1e56 , 1841 , 1 } , { 0x2164 , 2304 , 1 } , { 0x0156 , 294 , 1 } , { 0x1f56 , 62 , 3 } , { 0x0520 , 1310 , 1 } , { 0x004f , 40 , 1 } , { 0x0056 , 62 , 1 } , { 0x10b7 , 2814 , 1 } , { 0xa756 , 3051 , 1 } , { 0xfb04 , 5 , 3 } , { 0x1e78 , 1893 , 1 } , { 0x0478 , 1070 , 1 } , { 0x0178 , 168 , 1 } , { 0x1e54 , 1838 , 1 } , { 0x2162 , 2298 , 1 } , { 0x0154 , 291 , 1 } , { 0x1f54 , 57 , 3 } , { 0xab78 , 1472 , 1 } , { 0xa656 , 2898 , 1 } , { 0x0054 , 56 , 1 } , { 0x1e52 , 1835 , 1 } , { 0xa754 , 3048 , 1 } , { 0x0152 , 288 , 1 } , { 0x1f52 , 52 , 3 } , { 0x24c9 , 2400 , 1 } , { 0x1e32 , 1787 , 1 } , { 0x0052 , 49 , 1 } , { 0x0132 , 243 , 1 } , { 0xa752 , 3045 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xfb00 , 4 , 2 } , { 0xa654 , 2895 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa732 , 2997 , 1 } , { 0x2160 , 2292 , 1 } , { 0x054f , 1424 , 1 } , { 0x0556 , 1445 , 1 } , { 0x1e50 , 1832 , 1 } , { 0xa652 , 2892 , 1 } , { 0x0150 , 285 , 1 } , { 0x1f50 , 84 , 2 } , { 0x017b , 348 , 1 } , { 0x1e4e , 1829 , 1 } , { 0x0050 , 43 , 1 } , { 0x014e , 282 , 1 } , { 0xa750 , 3042 , 1 } , { 0xab7b , 1481 , 1 } , { 0xa77b , 3093 , 1 } , { 0x004e , 37 , 1 } , { 0x0554 , 1439 , 1 } , { 0xa74e , 3039 , 1 } , { 0x1e48 , 1820 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x216b , 2325 , 1 } , { 0x1f48 , 2172 , 1 } , { 0xa650 , 2889 , 1 } , { 0x0552 , 1433 , 1 } , { 0x0048 , 21 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa748 , 3030 , 1 } , { 0xa64e , 2886 , 1 } , { 0x0532 , 1337 , 1 } , { 0x1041e , 3327 , 1 } , { 0x1e1e , 1757 , 1 } , { 0x041e , 932 , 1 } , { 0x011e , 216 , 1 } , { 0x118b7 , 3579 , 1 } , { 0x2c1e , 2511 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa648 , 2877 , 1 } , { 0x1ff9 , 2253 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03f9 , 878 , 1 } , { 0x0550 , 1427 , 1 } , { 0x10412 , 3291 , 1 } , { 0x1e12 , 1739 , 1 } , { 0x0412 , 896 , 1 } , { 0x0112 , 198 , 1 } , { 0x054e , 1421 , 1 } , { 0x2c12 , 2475 , 1 } , { 0x10410 , 3285 , 1 } , { 0x1e10 , 1736 , 1 } , { 0x0410 , 890 , 1 } , { 0x0110 , 195 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c10 , 2469 , 1 } , { 0x2132 , 2289 , 1 } , { 0x0548 , 1403 , 1 } , { 0x1ef8 , 2070 , 1 } , { 0x04f8 , 1250 , 1 } , { 0x01f8 , 490 , 1 } , { 0x1ff8 , 2250 , 1 } , { 0x0220 , 381 , 1 } , { 0x1ee2 , 2037 , 1 } , { 0x04e2 , 1217 , 1 } , { 0x01e2 , 462 , 1 } , { 0x1fe2 , 36 , 3 } , { 0x2ce2 , 2733 , 1 } , { 0x03e2 , 857 , 1 } , { 0x051e , 1307 , 1 } , { 0x1ede , 2031 , 1 } , { 0x04de , 1211 , 1 } , { 0x01de , 456 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cde , 2727 , 1 } , { 0x03de , 851 , 1 } , { 0x00de , 165 , 1 } , { 0x1f69 , 2205 , 1 } , { 0x2c69 , 2574 , 1 } , { 0x1eda , 2025 , 1 } , { 0x04da , 1205 , 1 } , { 0x0512 , 1289 , 1 } , { 0x1fda , 2244 , 1 } , { 0x2cda , 2721 , 1 } , { 0x03da , 845 , 1 } , { 0x00da , 153 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0510 , 1286 , 1 } , { 0x1ed8 , 2022 , 1 } , { 0x04d8 , 1202 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd8 , 2274 , 1 } , { 0x2cd8 , 2718 , 1 } , { 0x03d8 , 842 , 1 } , { 0x00d8 , 147 , 1 } , { 0x1ed6 , 2019 , 1 } , { 0x04d6 , 1199 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fd6 , 76 , 2 } , { 0x2cd6 , 2715 , 1 } , { 0x03d6 , 792 , 1 } , { 0x00d6 , 144 , 1 } , { 0x1ec8 , 1998 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01c8 , 421 , 1 } , { 0x1fc8 , 2232 , 1 } , { 0x2cc8 , 2694 , 1 } , { 0xff32 , 3210 , 1 } , { 0x00c8 , 102 , 1 } , { 0x04c7 , 1175 , 1 } , { 0x01c7 , 421 , 1 } , { 0x1fc7 , 15 , 3 } , { 0x1ec0 , 1986 , 1 } , { 0x04c0 , 1187 , 1 } , { 0x00c7 , 99 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cc0 , 2682 , 1 } , { 0x0179 , 345 , 1 } , { 0x00c0 , 77 , 1 } , { 0x0232 , 574 , 1 } , { 0x01b3 , 402 , 1 } , { 0x1fb3 , 62 , 2 } , { 0xab79 , 1475 , 1 } , { 0xa779 , 3090 , 1 } , { 0x10c7 , 2859 , 1 } , { 0xabb3 , 1649 , 1 } , { 0xa7b3 , 3156 , 1 } , { 0x1fa5 , 234 , 2 } , { 0x10c0 , 2841 , 1 } , { 0x03a5 , 807 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xaba5 , 1607 , 1 } , { 0x01b1 , 691 , 1 } , { 0x10ca5 , 3468 , 1 } , { 0x10b3 , 2802 , 1 } , { 0x2169 , 2319 , 1 } , { 0x024e , 601 , 1 } , { 0xabb1 , 1643 , 1 } , { 0xa7b1 , 682 , 1 } , { 0x10cb1 , 3504 , 1 } , { 0x10a5 , 2760 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x01af , 399 , 1 } , { 0x1faf , 244 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0248 , 592 , 1 } , { 0x10b1 , 2796 , 1 } , { 0xabaf , 1637 , 1 } , { 0x1fad , 234 , 2 } , { 0x10caf , 3498 , 1 } , { 0x04cd , 1184 , 1 } , { 0x01cd , 429 , 1 } , { 0xabad , 1631 , 1 } , { 0xa7ad , 658 , 1 } , { 0x10cad , 3492 , 1 } , { 0x00cd , 117 , 1 } , { 0x10af , 2790 , 1 } , { 0x021e , 547 , 1 } , { 0x1fa3 , 224 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03a3 , 800 , 1 } , { 0x10ad , 2784 , 1 } , { 0xaba3 , 1601 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10ca3 , 3462 , 1 } , { 0x10cd , 2862 , 1 } , { 0x1fa1 , 214 , 2 } , { 0x24b7 , 2346 , 1 } , { 0x03a1 , 796 , 1 } , { 0x0212 , 529 , 1 } , { 0xaba1 , 1595 , 1 } , { 0x10a3 , 2754 , 1 } , { 0x10ca1 , 3456 , 1 } , { 0x01d3 , 438 , 1 } , { 0x1fd3 , 25 , 3 } , { 0x0210 , 526 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00d3 , 135 , 1 } , { 0x1e97 , 34 , 2 } , { 0x10a1 , 2748 , 1 } , { 0x0197 , 649 , 1 } , { 0x1f97 , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0397 , 759 , 1 } , { 0x1041d , 3324 , 1 } , { 0xab97 , 1565 , 1 } , { 0x041d , 929 , 1 } , { 0x10c97 , 3426 , 1 } , { 0x1f1d , 2121 , 1 } , { 0x2c1d , 2508 , 1 } , { 0x1e72 , 1884 , 1 } , { 0x0472 , 1061 , 1 } , { 0x0172 , 336 , 1 } , { 0x118b3 , 3567 , 1 } , { 0x2c72 , 2580 , 1 } , { 0x0372 , 712 , 1 } , { 0x1041b , 3318 , 1 } , { 0xab72 , 1454 , 1 } , { 0x041b , 923 , 1 } , { 0x118a5 , 3525 , 1 } , { 0x1f1b , 2115 , 1 } , { 0x2c1b , 2502 , 1 } , { 0x1e70 , 1881 , 1 } , { 0x0470 , 1058 , 1 } , { 0x0170 , 333 , 1 } , { 0x118b1 , 3561 , 1 } , { 0x2c70 , 610 , 1 } , { 0x0370 , 709 , 1 } , { 0x1e46 , 1817 , 1 } , { 0xab70 , 1448 , 1 } , { 0x1e66 , 1866 , 1 } , { 0x0466 , 1043 , 1 } , { 0x0166 , 318 , 1 } , { 0x1e44 , 1814 , 1 } , { 0x0046 , 15 , 1 } , { 0x118af , 3555 , 1 } , { 0xa746 , 3027 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa766 , 3075 , 1 } , { 0x0044 , 9 , 1 } , { 0x118ad , 3549 , 1 } , { 0xa744 , 3024 , 1 } , { 0x1e7a , 1896 , 1 } , { 0x047a , 1073 , 1 } , { 0x1e3a , 1799 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa646 , 2874 , 1 } , { 0x1f3a , 2154 , 1 } , { 0xa666 , 2922 , 1 } , { 0xab7a , 1478 , 1 } , { 0x118a3 , 3519 , 1 } , { 0xa644 , 2871 , 1 } , { 0xa73a , 3009 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1ef4 , 2064 , 1 } , { 0x04f4 , 1244 , 1 } , { 0x01f4 , 487 , 1 } , { 0x1ff4 , 101 , 2 } , { 0x118a1 , 3513 , 1 } , { 0x03f4 , 762 , 1 } , { 0x1eec , 2052 , 1 } , { 0x04ec , 1232 , 1 } , { 0x01ec , 477 , 1 } , { 0x1fec , 2286 , 1 } , { 0x0546 , 1397 , 1 } , { 0x03ec , 872 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x013f , 261 , 1 } , { 0x1f3f , 2169 , 1 } , { 0x0544 , 1391 , 1 } , { 0x1eea , 2049 , 1 } , { 0x04ea , 1229 , 1 } , { 0x01ea , 474 , 1 } , { 0x1fea , 2256 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x03ea , 869 , 1 } , { 0x1ee8 , 2046 , 1 } , { 0x04e8 , 1226 , 1 } , { 0x01e8 , 471 , 1 } , { 0x1fe8 , 2280 , 1 } , { 0x053a , 1361 , 1 } , { 0x03e8 , 866 , 1 } , { 0x1ee6 , 2043 , 1 } , { 0x04e6 , 1223 , 1 } , { 0x01e6 , 468 , 1 } , { 0x1fe6 , 88 , 2 } , { 0x1f4b , 2181 , 1 } , { 0x03e6 , 863 , 1 } , { 0x1e5e , 1853 , 1 } , { 0x004b , 27 , 1 } , { 0x015e , 306 , 1 } , { 0x2166 , 2310 , 1 } , { 0x1ee4 , 2040 , 1 } , { 0x04e4 , 1220 , 1 } , { 0x01e4 , 465 , 1 } , { 0x1fe4 , 80 , 2 } , { 0xa75e , 3063 , 1 } , { 0x03e4 , 860 , 1 } , { 0x1ee0 , 2034 , 1 } , { 0x04e0 , 1214 , 1 } , { 0x01e0 , 459 , 1 } , { 0x053f , 1376 , 1 } , { 0x2ce0 , 2730 , 1 } , { 0x03e0 , 854 , 1 } , { 0x1edc , 2028 , 1 } , { 0x04dc , 1208 , 1 } , { 0xa65e , 2910 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2cdc , 2724 , 1 } , { 0x03dc , 848 , 1 } , { 0x00dc , 159 , 1 } , { 0x1ed0 , 2010 , 1 } , { 0x04d0 , 1190 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x2cd0 , 2706 , 1 } , { 0x03d0 , 742 , 1 } , { 0x00d0 , 126 , 1 } , { 0x1ecc , 2004 , 1 } , { 0x054b , 1412 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fcc , 71 , 2 } , { 0x2ccc , 2700 , 1 } , { 0x1ec6 , 1995 , 1 } , { 0x00cc , 114 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fc6 , 67 , 2 } , { 0x2cc6 , 2691 , 1 } , { 0x24c8 , 2397 , 1 } , { 0x00c6 , 96 , 1 } , { 0x04c5 , 1172 , 1 } , { 0x01c5 , 417 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1fbb , 2229 , 1 } , { 0x24c7 , 2394 , 1 } , { 0x00c5 , 92 , 1 } , { 0x1fb9 , 2271 , 1 } , { 0xabbb , 1673 , 1 } , { 0x24c0 , 2373 , 1 } , { 0x04c3 , 1169 , 1 } , { 0xabb9 , 1667 , 1 } , { 0x1fc3 , 71 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x00c3 , 86 , 1 } , { 0x10c5 , 2856 , 1 } , { 0x10bb , 2826 , 1 } , { 0x1ed4 , 2016 , 1 } , { 0x04d4 , 1196 , 1 } , { 0x10b9 , 2820 , 1 } , { 0x13fc , 1700 , 1 } , { 0x2cd4 , 2712 , 1 } , { 0x0246 , 589 , 1 } , { 0x00d4 , 138 , 1 } , { 0x10c3 , 2850 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xff3a , 3234 , 1 } , { 0x0244 , 688 , 1 } , { 0x019f , 670 , 1 } , { 0x1f9f , 204 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x039f , 789 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab9f , 1589 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c9f , 3450 , 1 } , { 0x019d , 667 , 1 } , { 0x1f9d , 194 , 2 } , { 0x023a , 2565 , 1 } , { 0x039d , 783 , 1 } , { 0x1e5a , 1847 , 1 } , { 0xab9d , 1583 , 1 } , { 0x015a , 300 , 1 } , { 0x10c9d , 3444 , 1 } , { 0x1e9b , 1856 , 1 } , { 0x24cd , 2412 , 1 } , { 0x005a , 74 , 1 } , { 0x1f9b , 184 , 2 } , { 0xa75a , 3057 , 1 } , { 0x039b , 776 , 1 } , { 0x1ece , 2007 , 1 } , { 0xab9b , 1577 , 1 } , { 0x1e99 , 42 , 2 } , { 0x10c9b , 3438 , 1 } , { 0x2cce , 2703 , 1 } , { 0x1f99 , 174 , 2 } , { 0x00ce , 120 , 1 } , { 0x0399 , 767 , 1 } , { 0xa65a , 2904 , 1 } , { 0xab99 , 1571 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c99 , 3432 , 1 } , { 0x0193 , 634 , 1 } , { 0x1f93 , 184 , 2 } , { 0x1e58 , 1844 , 1 } , { 0x0393 , 746 , 1 } , { 0x0158 , 297 , 1 } , { 0xab93 , 1553 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c93 , 3414 , 1 } , { 0x0058 , 68 , 1 } , { 0x042d , 977 , 1 } , { 0xa758 , 3054 , 1 } , { 0x1f2d , 2139 , 1 } , { 0x2c2d , 2556 , 1 } , { 0x118bb , 3591 , 1 } , { 0x0191 , 369 , 1 } , { 0x1f91 , 174 , 2 } , { 0x118b9 , 3585 , 1 } , { 0x0391 , 739 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab91 , 1547 , 1 } , { 0xa658 , 2901 , 1 } , { 0x10c91 , 3408 , 1 } , { 0x018f , 625 , 1 } , { 0x1f8f , 164 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x038f , 836 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8f , 1541 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x10c8f , 3402 , 1 } , { 0x018b , 366 , 1 } , { 0x1f8b , 144 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x0187 , 363 , 1 } , { 0x1f87 , 164 , 2 } , { 0xab8b , 1529 , 1 } , { 0xa78b , 3111 , 1 } , { 0x10c8b , 3390 , 1 } , { 0xab87 , 1517 , 1 } , { 0x04c1 , 1166 , 1 } , { 0x10c87 , 3378 , 1 } , { 0x1e7e , 1902 , 1 } , { 0x047e , 1079 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x00c1 , 80 , 1 } , { 0x2c7e , 580 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab7e , 1490 , 1 } , { 0xa77e , 3096 , 1 } , { 0x1e76 , 1890 , 1 } , { 0x0476 , 1067 , 1 } , { 0x0176 , 342 , 1 } , { 0x1e42 , 1811 , 1 } , { 0x10c1 , 2844 , 1 } , { 0x0376 , 715 , 1 } , { 0x1e36 , 1793 , 1 } , { 0xab76 , 1466 , 1 } , { 0x0136 , 249 , 1 } , { 0x0042 , 3 , 1 } , { 0x1e3e , 1805 , 1 } , { 0xa742 , 3021 , 1 } , { 0x1e38 , 1796 , 1 } , { 0x1f3e , 2166 , 1 } , { 0xa736 , 3003 , 1 } , { 0x1f38 , 2148 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0587 , 105 , 2 } , { 0xa73e , 3015 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xa738 , 3006 , 1 } , { 0xa642 , 2868 , 1 } , { 0x1e5c , 1850 , 1 } , { 0x1e34 , 1790 , 1 } , { 0x015c , 303 , 1 } , { 0x0134 , 246 , 1 } , { 0x1ef6 , 2067 , 1 } , { 0x04f6 , 1247 , 1 } , { 0x01f6 , 372 , 1 } , { 0x1ff6 , 92 , 2 } , { 0xa75c , 3060 , 1 } , { 0xa734 , 3000 , 1 } , { 0x1ef0 , 2058 , 1 } , { 0x04f0 , 1238 , 1 } , { 0x01f0 , 20 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x1e30 , 1784 , 1 } , { 0x03f0 , 772 , 1 } , { 0x0130 , 261 , 2 } , { 0x0542 , 1385 , 1 } , { 0xa65c , 2907 , 1 } , { 0x1f83 , 144 , 2 } , { 0x0536 , 1349 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xab83 , 1505 , 1 } , { 0x053e , 1373 , 1 } , { 0x10c83 , 3366 , 1 } , { 0x0538 , 1355 , 1 } , { 0x1eee , 2055 , 1 } , { 0x04ee , 1235 , 1 } , { 0x01ee , 480 , 1 } , { 0x1f8d , 154 , 2 } , { 0xffffffff , - 1 , 0 } , { 0x03ee , 875 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab8d , 1535 , 1 } , { 0xa78d , 643 , 1 } , { 0x10c8d , 3396 , 1 } , { 0x0534 , 1343 , 1 } , { 0x0181 , 613 , 1 } , { 0x1f81 , 134 , 2 } , { 0x013d , 258 , 1 } , { 0x1f3d , 2163 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xab81 , 1499 , 1 } , { 0x017f , 52 , 1 } , { 0x10c81 , 3360 , 1 } , { 0x2c7f , 583 , 1 } , { 0x037f , 881 , 1 } , { 0xff2d , 3195 , 1 } , { 0xab7f , 1493 , 1 } , { 0x1e74 , 1887 , 1 } , { 0x0474 , 1064 , 1 } , { 0x0174 , 339 , 1 } , { 0x1e3c , 1802 , 1 } , { 0x0149 , 46 , 2 } , { 0x1f49 , 2175 , 1 } , { 0x1f3c , 2160 , 1 } , { 0xab74 , 1460 , 1 } , { 0x0049 , 3606 , 1 } , { 0x0143 , 267 , 1 } , { 0x24cc , 2409 , 1 } , { 0xa73c , 3012 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0043 , 6 , 1 } , { 0x0141 , 264 , 1 } , { 0x24c6 , 2391 , 1 } , { 0x013b , 255 , 1 } , { 0x1f3b , 2157 , 1 } , { 0x0041 , 0 , 1 } , { 0x0139 , 252 , 1 } , { 0x1f39 , 2151 , 1 } , { 0x24c5 , 2388 , 1 } , { 0x24bb , 2358 , 1 } , { 0x13fa , 1694 , 1 } , { 0x053d , 1370 , 1 } , { 0x24b9 , 2352 , 1 } , { 0x0429 , 965 , 1 } , { 0x2183 , 2340 , 1 } , { 0x1f29 , 2127 , 1 } , { 0x2c29 , 2544 , 1 } , { 0x24c3 , 2382 , 1 } , { 0x10427 , 3354 , 1 } , { 0x10425 , 3348 , 1 } , { 0x0427 , 959 , 1 } , { 0x0425 , 953 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c27 , 2538 , 1 } , { 0x2c25 , 2532 , 1 } , { 0x0549 , 1406 , 1 } , { 0x053c , 1367 , 1 } , { 0x10423 , 3342 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0423 , 947 , 1 } , { 0x0543 , 1388 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c23 , 2526 , 1 } , { 0xff36 , 3222 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0541 , 1382 , 1 } , { 0x10421 , 3336 , 1 } , { 0x053b , 1364 , 1 } , { 0x0421 , 941 , 1 } , { 0xff38 , 3228 , 1 } , { 0x0539 , 1358 , 1 } , { 0x2c21 , 2520 , 1 } , { 0x10419 , 3312 , 1 } , { 0x10417 , 3306 , 1 } , { 0x0419 , 917 , 1 } , { 0x0417 , 911 , 1 } , { 0x1f19 , 2109 , 1 } , { 0x2c19 , 2496 , 1 } , { 0x2c17 , 2490 , 1 } , { 0x023e , 2568 , 1 } , { 0xff34 , 3216 , 1 } , { 0x10415 , 3300 , 1 } , { 0x10413 , 3294 , 1 } , { 0x0415 , 905 , 1 } , { 0x0413 , 899 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c15 , 2484 , 1 } , { 0x2c13 , 2478 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x24ce , 2415 , 1 } , { 0x1040f , 3282 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040f , 1031 , 1 } , { 0xff30 , 3204 , 1 } , { 0x1f0f , 2103 , 1 } , { 0x2c0f , 2466 , 1 } , { 0x1040d , 3276 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x040d , 1025 , 1 } , { 0x0147 , 273 , 1 } , { 0x1f0d , 2097 , 1 } , { 0x2c0d , 2460 , 1 } , { 0x1040b , 3270 , 1 } , { 0x0047 , 18 , 1 } , { 0x040b , 1019 , 1 } , { 0x0230 , 571 , 1 } , { 0x1f0b , 2091 , 1 } , { 0x2c0b , 2454 , 1 } , { 0x10409 , 3264 , 1 } , { 0x10405 , 3252 , 1 } , { 0x0409 , 1013 , 1 } , { 0x0405 , 1001 , 1 } , { 0x1f09 , 2085 , 1 } , { 0x2c09 , 2448 , 1 } , { 0x2c05 , 2436 , 1 } , { 0x10403 , 3246 , 1 } , { 0x10401 , 3240 , 1 } , { 0x0403 , 995 , 1 } , { 0x0401 , 989 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c03 , 2430 , 1 } , { 0x2c01 , 2424 , 1 } , { 0x13f9 , 1691 , 1 } , { 0x042f , 983 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x1f2f , 2145 , 1 } , { 0x1041f , 3330 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x041f , 935 , 1 } , { 0x023d , 378 , 1 } , { 0x10411 , 3288 , 1 } , { 0x2c1f , 2514 , 1 } , { 0x0411 , 893 , 1 } , { 0x0547 , 1400 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c11 , 2472 , 1 } , { 0x10407 , 3258 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0407 , 1007 , 1 } , { 0x24c1 , 2376 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x2c07 , 2442 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x13f8 , 1688 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff39 , 3231 , 1 } , { 0xffffffff , - 1 , 0 } , { 0x0243 , 354 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0x0241 , 586 , 1 } , { 0xff29 , 3183 , 1 } , { 0x023b , 577 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff27 , 3177 , 1 } , { 0xff25 , 3171 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff23 , 3165 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff21 , 3159 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb17 , 117 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xff2f , 3201 , 1 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb15 , 113 , 2 } , { 0xfb13 , 121 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb05 , 29 , 2 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xffffffff , - 1 , 0 } , { 0xfb03 , 0 , 3 } , { 0xfb01 , 8 , 2 } } ; if ( 0 == 0 ) { int key = hash ( & code ) ; if ( key <= MAX_HASH_VALUE && key >= 0 ) { OnigCodePoint gcode = wordlist [ key ] . code ; <S2SV_StartBug> if ( code == gcode ) <S2SV_EndBug> return & wordlist [ key ] ; } } return 0 ; }
","<S2SV_ModStart> code == gcode && wordlist [ key ] . index >= 0
",kkos@oniguruma/166a6c3999bf06b4de0ab4ce6b088a468cc4029f,CVE-2017-9225,https://github.com/kkos/oniguruma/commit/166a6c3999bf06b4de0ab4ce6b088a468cc4029f,2017-05-24T15:29Z
CWE-119,"CWE-119 static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , NULL , <S2SV_ModEnd> data ) ;
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-476,"CWE-476 static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; <S2SV_StartBug> freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; <S2SV_EndBug> if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
","<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
",torvalds@linux/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,CVE-2018-10074,https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311,2018-04-12T18:29Z
CWE-125,"CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z
CWE-189,"CWE-189 <S2SV_StartBug> static void <S2SV_EndBug> _copy_from_pages ( char * p , struct page * * pages , size_t pgbase , size_t len ) { struct page * * pgfrom ; char * vfrom ; size_t copy ; pgfrom = pages + ( pgbase >> PAGE_CACHE_SHIFT ) ; pgbase &= ~ PAGE_CACHE_MASK ; do { copy = PAGE_CACHE_SIZE - pgbase ; if ( copy > len ) copy = len ; vfrom = kmap_atomic ( * pgfrom , KM_USER0 ) ; memcpy ( p , vfrom + pgbase , copy ) ; kunmap_atomic ( vfrom , KM_USER0 ) ; pgbase += copy ; if ( pgbase == PAGE_CACHE_SIZE ) { pgbase = 0 ; pgfrom ++ ; } p += copy ; } while ( ( len -= copy ) != 0 ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void _copy_from_pages (
",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
CWE-20,"CWE-20 static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; <S2SV_StartBug> int copied , err ; <S2SV_EndBug> struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO_UDP ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP ; else if ( sinfo -> gso_type & SKB_GSO_FCOE ) goto out_free ; else BUG ( ) ; if ( sinfo -> gso_type & SKB_GSO_TCP_ECN ) vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN ; } else vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_NEEDS_CSUM ; vnet_hdr . csum_start = skb_checksum_start_offset ( skb ) ; vnet_hdr . csum_offset = skb -> csum_offset ; } else if ( skb -> ip_summed == CHECKSUM_UNNECESSARY ) { vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID ; } err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ) ; if ( err < 0 ) goto out_free ; } <S2SV_StartBug> sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_EndBug> <S2SV_StartBug> if ( sock -> type == SOCK_PACKET ) <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_pkt ) ; <S2SV_StartBug> else <S2SV_EndBug> msg -> msg_namelen = sll -> sll_halen + offsetof ( struct sockaddr_ll , sll_addr ) ; <S2SV_StartBug> copied = skb -> len ; <S2SV_EndBug> if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; <S2SV_StartBug> if ( msg -> msg_name ) <S2SV_EndBug> memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , <S2SV_StartBug> msg -> msg_namelen ) ; <S2SV_EndBug> if ( pkt_sk ( sk ) -> auxdata ) { struct tpacket_auxdata aux ; aux . tp_status = TP_STATUS_USER ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) aux . tp_status |= TP_STATUS_CSUMNOTREADY ; aux . tp_len = PACKET_SKB_CB ( skb ) -> origlen ; aux . tp_snaplen = skb -> len ; aux . tp_mac = 0 ; aux . tp_net = skb_network_offset ( skb ) ; if ( vlan_tx_tag_present ( skb ) ) { aux . tp_vlan_tci = vlan_tx_tag_get ( skb ) ; aux . tp_status |= TP_STATUS_VLAN_VALID ; } else { aux . tp_vlan_tci = 0 ; } aux . tp_padding = 0 ; put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ) ; } err = vnet_hdr_len + ( ( flags & MSG_TRUNC ) ? skb -> len : copied ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
","<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-264,"CWE-264 static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; <S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }
","<S2SV_ModStart> ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return
",torvalds@linux/e3211c120a85b792978bcb4be7b2886df18d27f0,CVE-2013-1959,https://github.com/torvalds/linux/commit/e3211c120a85b792978bcb4be7b2886df18d27f0,2013-05-03T11:57Z
CWE-120,"CWE-120 static char * get_next_file ( FILE * VFile , char * ptr ) { <S2SV_StartBug> char * ret ; <S2SV_EndBug> ret = fgets ( ptr , PATH_MAX , VFile ) ; if ( ! ret ) return NULL ; <S2SV_StartBug> if ( ptr [ strlen ( ptr ) - 1 ] == '\\n' ) <S2SV_EndBug> <S2SV_StartBug> ptr [ strlen ( ptr ) - 1 ] = '\\0' ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> char * ret ; size_t len <S2SV_ModStart> return NULL ; len = <S2SV_ModEnd> strlen ( ptr <S2SV_ModStart> ( ptr ) ; if ( len > 0 && ptr [ len <S2SV_ModStart> ) ptr [ len <S2SV_ModEnd> - 1 ]
",the-tcpdump-group@tcpdump/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,CVE-2018-14879,https://github.com/the-tcpdump-group/tcpdump/commit/9ba91381954ad325ea4fd26b9c65a8bd9a2a85b6,2019-10-03T16:15Z
CWE-200,"CWE-200 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state = & env -> cur_state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs = state -> regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; init_reg_state ( regs ) ; insn_idx = 0 ; env -> varlen_map_value_access = false ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( ""invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n"" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n"" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( log_level ) { if ( do_print_state ) verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n"" , prev_insn_idx , insn_idx ) ; else verbose ( ""%d:<S2SV_blank>safe\\n"" , insn_idx ) ; } goto process_bpf_exit ; } if ( log_level && do_print_state ) { verbose ( ""\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:"" , prev_insn_idx , insn_idx ) ; print_verifier_state ( & env -> cur_state ) ; do_print_state = false ; } if ( log_level ) { verbose ( ""%d:<S2SV_blank>"" , insn_idx ) ; <S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; if ( BPF_SIZE ( insn -> code ) != BPF_W && BPF_SIZE ( insn -> code ) != BPF_DW ) { insn_idx ++ ; continue ; } prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( ""same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n"" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( ""BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( ""BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( ""R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n"" ) ; return - EACCES ; } process_bpf_exit : insn_idx = pop_stack ( env , & prev_insn_idx ) ; if ( insn_idx < 0 ) { break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( ""invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n"" ) ; return - EINVAL ; } reset_reg_range_values ( regs , insn -> dst_reg ) ; } else { verbose ( ""unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n"" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( ""processed<S2SV_blank>%d<S2SV_blank>insns\\n"" , insn_processed ) ; return 0 ; }
","<S2SV_ModStart> ; print_bpf_insn ( env ,
",torvalds@linux/0d0e57697f162da4aa218b5feafe614fb666db07,CVE-2017-9150,https://github.com/torvalds/linux/commit/0d0e57697f162da4aa218b5feafe614fb666db07,2017-05-22T22:29Z
CWE-200,"CWE-200 static int udf_encode_fh ( struct inode * inode , __u32 * fh , int * lenp , struct inode * parent ) { int len = * lenp ; struct kernel_lb_addr location = UDF_I ( inode ) -> i_location ; struct fid * fid = ( struct fid * ) fh ; int type = FILEID_UDF_WITHOUT_PARENT ; if ( parent && ( len < 5 ) ) { * lenp = 5 ; return 255 ; } else if ( len < 3 ) { * lenp = 3 ; return 255 ; } * lenp = 3 ; fid -> udf . block = location . logicalBlockNum ; fid -> udf . partref = location . partitionReferenceNum ; <S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { location = UDF_I ( parent ) -> i_location ; fid -> udf . parent_block = location . logicalBlockNum ; fid -> udf . parent_partref = location . partitionReferenceNum ; fid -> udf . parent_generation = inode -> i_generation ; * lenp = 5 ; type = FILEID_UDF_WITH_PARENT ; } return type ; }
","<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
",torvalds@linux/0143fc5e9f6f5aad4764801015bc8d4b4a278200,CVE-2012-6548,https://github.com/torvalds/linux/commit/0143fc5e9f6f5aad4764801015bc8d4b4a278200,2013-03-15T20:55Z
CWE-119,"CWE-119 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> Quantum index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/61135001a625364e29bdce83832f043eebde7b5a,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/61135001a625364e29bdce83832f043eebde7b5a,2019-07-05T01:15Z
CWE-189,"CWE-189 static void php_imagepolygon ( INTERNAL_FUNCTION_PARAMETERS , int filled ) { zval * IM , * POINTS ; long NPOINTS , COL ; zval * * var = NULL ; gdImagePtr im ; gdPointPtr points ; int npoints , col , nelem , i ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rall"" , & IM , & POINTS , & NPOINTS , & COL ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; npoints = NPOINTS ; col = COL ; nelem = zend_hash_num_elements ( Z_ARRVAL_P ( POINTS ) ) ; if ( nelem < 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>at<S2SV_blank>least<S2SV_blank>3<S2SV_blank>points<S2SV_blank>in<S2SV_blank>your<S2SV_blank>array"" ) ; RETURN_FALSE ; } if ( npoints <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>give<S2SV_blank>a<S2SV_blank>positive<S2SV_blank>number<S2SV_blank>of<S2SV_blank>points"" ) ; RETURN_FALSE ; } if ( nelem < npoints * 2 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Trying<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%d<S2SV_blank>points<S2SV_blank>in<S2SV_blank>array<S2SV_blank>with<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>points"" , npoints , nelem / 2 ) ; RETURN_FALSE ; } points = ( gdPointPtr ) safe_emalloc ( npoints , sizeof ( gdPoint ) , 0 ) ; for ( i = 0 ; i < npoints ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) , ( i * 2 ) , ( void * * ) & var ) == SUCCESS ) { <S2SV_StartBug> SEPARATE_ZVAL ( ( var ) ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . x = Z_LVAL_PP ( var ) ; <S2SV_EndBug> } if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) , ( i * 2 ) + 1 , ( void * * ) & var ) == SUCCESS ) { <S2SV_StartBug> SEPARATE_ZVAL ( var ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_long ( * var ) ; <S2SV_EndBug> <S2SV_StartBug> points [ i ] . y = Z_LVAL_PP ( var ) ; <S2SV_EndBug> } } <S2SV_StartBug> if ( filled ) { <S2SV_EndBug> gdImageFilledPolygon ( im , points , npoints , col ) ; } else { gdImagePolygon ( im , points , npoints , col ) ; } efree ( points ) ; RETURN_TRUE ; }
","<S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; convert_to_long <S2SV_ModStart> ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> var ) ; } <S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; convert_to_long <S2SV_ModStart> ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> ; } } }
",php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z
CWE-415,"CWE-415 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
","<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
",php@php-src/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,CVE-2019-6978,https://github.com/php/php-src/commit/089f7c0bc28d399b0420aa6ef058e4c1c120b2ae,2019-01-28T08:29Z
CWE-119,"CWE-119 static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , <S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } <S2SV_StartBug> } <S2SV_EndBug> if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else { <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } <S2SV_StartBug> } <S2SV_EndBug> } else { vpx_memset ( above_row , 127 , bs * 2 ) ; <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug> } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }
","<S2SV_ModStart> int dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , TX_SIZE <S2SV_ModStart> int i ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> uint8_t , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; uint8_t <S2SV_ModStart> plane ] ; <S2SV_ModEnd> if ( plane <S2SV_ModStart> + y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( left_available <S2SV_ModStart> ; } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> ( x0 + <S2SV_ModEnd> bs <= frame_width <S2SV_ModStart> frame_width ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width ) <S2SV_ModStart> - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> if ( bs <S2SV_ModStart> 4 && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ - <S2SV_ModStart> 129 ; } else { memset <S2SV_ModEnd> ( above_row , <S2SV_ModStart> = 127 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void decode_mb_mode_mvs ( VP8D_COMP * pbi , MODE_INFO * mi , MB_MODE_INFO * mbmi ) <S2SV_StartBug> { <S2SV_EndBug> if ( pbi -> mb . update_mb_segmentation_map ) read_mb_features ( & pbi -> mbc [ 8 ] , & mi -> mbmi , & pbi -> mb ) ; else if ( pbi -> common . frame_type == KEY_FRAME ) mi -> mbmi . segment_id = 0 ; if ( pbi -> common . mb_no_coeff_skip ) mi -> mbmi . mb_skip_coeff = vp8_read ( & pbi -> mbc [ 8 ] , pbi -> prob_skip_false ) ; else mi -> mbmi . mb_skip_coeff = 0 ; mi -> mbmi . is_4x4 = 0 ; if ( pbi -> common . frame_type == KEY_FRAME ) read_kf_modes ( pbi , mi ) ; else read_mb_modes_mv ( pbi , mi , & mi -> mbmi ) ; }
","<S2SV_ModStart> mbmi ) { ( void ) mbmi ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static inline bool unconditional ( const struct ipt_ip * ip ) <S2SV_EndBug> { static const struct ipt_ip uncond ; <S2SV_StartBug> return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; <S2SV_EndBug> # undef FWINV }
","<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-20,"CWE-20 static int bnep_sock_ioctl ( struct socket * sock , unsigned int cmd , unsigned long arg ) { struct bnep_connlist_req cl ; struct bnep_connadd_req ca ; struct bnep_conndel_req cd ; struct bnep_conninfo ci ; struct socket * nsock ; void __user * argp = ( void __user * ) arg ; int err ; BT_DBG ( ""cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%lx"" , cmd , arg ) ; switch ( cmd ) { case BNEPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; nsock = sockfd_lookup ( ca . sock , & err ) ; if ( ! nsock ) return err ; if ( nsock -> sk -> sk_state != BT_CONNECTED ) { sockfd_put ( nsock ) ; return - EBADFD ; } <S2SV_StartBug> err = bnep_add_connection ( & ca , nsock ) ; <S2SV_EndBug> if ( ! err ) { if ( copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; } else sockfd_put ( nsock ) ; return err ; case BNEPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EACCES ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return bnep_del_connection ( & cd ) ; case BNEPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = bnep_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case BNEPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = bnep_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; default : return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
",torvalds@linux/43629f8f5ea32a998d06d1bb41eefa0e821ff573,CVE-2011-1079,https://github.com/torvalds/linux/commit/43629f8f5ea32a998d06d1bb41eefa0e821ff573,2012-06-21T23:55Z
CWE-254,"CWE-254 static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <S2SV_StartBug> return true ; <S2SV_EndBug> }
","<S2SV_ModStart> ) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/db29a9508a9246e77087c5531e45b2c88ec6988b,CVE-2014-8160,https://github.com/torvalds/linux/commit/db29a9508a9246e77087c5531e45b2c88ec6988b,2015-03-02T11:59Z
CWE-119,"CWE-119 static void estimate_missing_mvs ( MB_OVERLAP * overlaps , MODE_INFO * mi , MODE_INFO * prev_mi , int mb_rows , int mb_cols , unsigned int first_corrupt ) { int mb_row , mb_col ; <S2SV_StartBug> vpx_memset ( overlaps , 0 , sizeof ( MB_OVERLAP ) * mb_rows * mb_cols ) ; <S2SV_EndBug> for ( mb_row = 0 ; mb_row < mb_rows ; ++ mb_row ) { for ( mb_col = 0 ; mb_col < mb_cols ; ++ mb_col ) { if ( prev_mi -> mbmi . ref_frame == LAST_FRAME ) { calc_prev_mb_overlaps ( overlaps , prev_mi , mb_row , mb_col , mb_rows , mb_cols ) ; } ++ prev_mi ; } ++ prev_mi ; } mb_row = first_corrupt / mb_cols ; mb_col = first_corrupt - mb_row * mb_cols ; mi += mb_row * ( mb_cols + 1 ) + mb_col ; for ( ; mb_row < mb_rows ; ++ mb_row ) { int mb_to_top_edge = - ( ( mb_row * 16 ) ) << 3 ; int mb_to_bottom_edge = ( ( mb_rows - 1 - mb_row ) * 16 ) << 3 ; for ( ; mb_col < mb_cols ; ++ mb_col ) { int mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; int mb_to_right_edge = ( ( mb_cols - 1 - mb_col ) * 16 ) << 3 ; const B_OVERLAP * block_overlaps = overlaps [ mb_row * mb_cols + mb_col ] . overlaps ; mi -> mbmi . ref_frame = LAST_FRAME ; mi -> mbmi . mode = SPLITMV ; mi -> mbmi . uv_mode = DC_PRED ; mi -> mbmi . partitioning = 3 ; mi -> mbmi . segment_id = 0 ; estimate_mb_mvs ( block_overlaps , mi , mb_to_left_edge , mb_to_right_edge , mb_to_top_edge , mb_to_bottom_edge ) ; ++ mi ; } mb_col = 0 ; ++ mi ; } }
","<S2SV_ModStart> , mb_col ; memset <S2SV_ModEnd> ( overlaps ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'""\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'""\' ) ) end ++ ; } <S2SV_StartBug> end ++ ; <S2SV_EndBug> } if ( current == end ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element -> pattern = ctxt -> base ; element -> nsList = xmlGetNsList ( doc , node ) ; j = 0 ; if ( element -> nsList != NULL ) { while ( element -> nsList [ j ] != NULL ) j ++ ; } element -> nsNr = j ; # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsing<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; # endif element -> priority = 0 ; xsltCompileLocationPathPattern ( ctxt , novar ) ; if ( ctxt -> error ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>compile<S2SV_blank>\'%s\'\\n"" , element -> pattern ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltReverseCompMatch ( ctxt , element ) ; if ( element -> priority == 0 ) { if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_ELEM ) || ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) || ( element -> steps [ 0 ] . op == XSLT_OP_PI ) ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value2 != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_NS ) && ( element -> steps [ 0 ] . value != NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.25 ; } else if ( ( element -> steps [ 0 ] . op == XSLT_OP_ATTR ) && ( element -> steps [ 0 ] . value == NULL ) && ( element -> steps [ 0 ] . value2 == NULL ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else if ( ( ( element -> steps [ 0 ] . op == XSLT_OP_PI ) || ( element -> steps [ 0 ] . op == XSLT_OP_TEXT ) || ( element -> steps [ 0 ] . op == XSLT_OP_ALL ) || ( element -> steps [ 0 ] . op == XSLT_OP_NODE ) || ( element -> steps [ 0 ] . op == XSLT_OP_COMMENT ) ) && ( element -> steps [ 1 ] . op == XSLT_OP_END ) ) { element -> priority = - 0.5 ; } else { element -> priority = 0.5 ; } } # ifdef WITH_XSLT_DEBUG_PATTERN xsltGenericDebug ( xsltGenericDebugContext , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>parsed<S2SV_blank>%s,<S2SV_blank>default<S2SV_blank>priority<S2SV_blank>%f\\n"" , element -> pattern , element -> priority ) ; # endif if ( pattern [ end ] == '|' ) end ++ ; current = end ; } if ( end == 0 ) { xsltTransformError ( NULL , style , node , ""xsltCompilePattern<S2SV_blank>:<S2SV_blank>NULL<S2SV_blank>pattern\\n"" ) ; if ( style != NULL ) style -> errors ++ ; goto error ; } xsltFreeParserContext ( ctxt ) ; return ( first ) ; error : if ( ctxt != NULL ) xsltFreeParserContext ( ctxt ) ; if ( first != NULL ) xsltFreeCompMatchList ( first ) ; return ( NULL ) ; }
","<S2SV_ModStart> ++ ; } if ( pattern [ end ] == 0 ) break ;
",chromium@chromium/094c773bb6c144f07b004ff3d1886100f157f4f6,,https://github.com/chromium/chromium/commit/094c773bb6c144f07b004ff3d1886100f157f4f6, 
CWE-125,"CWE-125 static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; <S2SV_StartBug> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; <S2SV_EndBug> <S2SV_StartBug> struct search_domain * dom ; <S2SV_EndBug> for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }
","<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom
",libevent@libevent/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,CVE-2016-10197,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,2017-03-15T15:59Z
CWE-20,"CWE-20 static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) { krb5_error_code ret ; char * ptr ; unsigned int plen , vno ; krb5_data ap_req , ap_rep = empty_data ( ) ; krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ; krb5_auth_context auth_context = NULL ; krb5_principal changepw = NULL ; krb5_principal client , target = NULL ; krb5_ticket * ticket = NULL ; krb5_replay_data replay ; krb5_error krberror ; int numresult ; char strresult [ 1024 ] ; char * clientstr = NULL , * targetstr = NULL ; const char * errmsg = NULL ; size_t clen ; char * cdots ; struct sockaddr_storage ss ; socklen_t salen ; char addrbuf [ 100 ] ; krb5_address * addr = remote_faddr -> address ; * rep = empty_data ( ) ; if ( req -> length < 4 ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>was<S2SV_blank>truncated"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ptr = req -> data ; plen = ( * ptr ++ & 0xff ) ; plen = ( plen << 8 ) | ( * ptr ++ & 0xff ) ; if ( plen != req -> length ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>length<S2SV_blank>was<S2SV_blank>inconsistent"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } vno = ( * ptr ++ & 0xff ) ; vno = ( vno << 8 ) | ( * ptr ++ & 0xff ) ; if ( vno != 1 && vno != RFC3244_VERSION ) { ret = KRB5KDC_ERR_BAD_PVNO ; numresult = KRB5_KPASSWD_BAD_VERSION ; snprintf ( strresult , sizeof ( strresult ) , ""Request<S2SV_blank>contained<S2SV_blank>unknown<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>number<S2SV_blank>%d"" , vno ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ap_req . length = ( * ptr ++ & 0xff ) ; ap_req . length = ( ap_req . length << 8 ) | ( * ptr ++ & 0xff ) ; if ( ptr + ap_req . length >= req -> data + req -> length ) { ret = KRB5KRB_AP_ERR_MODIFIED ; numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Request<S2SV_blank>was<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>AP-REQ"" , sizeof ( strresult ) ) ; <S2SV_StartBug> goto chpwfail ; <S2SV_EndBug> } ap_req . data = ptr ; ptr += ap_req . length ; ret = krb5_auth_con_init ( context , & auth_context ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>initializing<S2SV_blank>auth<S2SV_blank>context"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , ""kadmin"" , ""changepw"" , NULL ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>building<S2SV_blank>kadmin/changepw<S2SV_blank>principal"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_rd_req ( context , & auth_context , & ap_req , changepw , keytab , NULL , & ticket ) ; if ( ret ) { numresult = KRB5_KPASSWD_AUTHERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>reading<S2SV_blank>application<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } ret = krb5_mk_rep ( context , auth_context , & ap_rep ) ; if ( ret ) { numresult = KRB5_KPASSWD_AUTHERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>replying<S2SV_blank>to<S2SV_blank>application<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } cipher . length = ( req -> data + req -> length ) - ptr ; cipher . data = ptr ; ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>decrypting<S2SV_blank>request"" , sizeof ( strresult ) ) ; goto chpwfail ; } client = ticket -> enc_part2 -> client ; if ( vno == RFC3244_VERSION ) { krb5_data * clear_data ; ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ; if ( ret != 0 ) { numresult = KRB5_KPASSWD_MALFORMED ; strlcpy ( strresult , ""Failed<S2SV_blank>decoding<S2SV_blank>ChangePasswdData"" , sizeof ( strresult ) ) ; goto chpwfail ; } zapfree ( clear . data , clear . length ) ; clear = * clear_data ; free ( clear_data ) ; if ( target != NULL ) { ret = krb5_unparse_name ( context , target , & targetstr ) ; if ( ret != 0 ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>unparsing<S2SV_blank>target<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log"" , sizeof ( strresult ) ) ; goto chpwfail ; } } } ret = krb5_unparse_name ( context , client , & clientstr ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>unparsing<S2SV_blank>client<S2SV_blank>name<S2SV_blank>for<S2SV_blank>log"" , sizeof ( strresult ) ) ; goto chpwfail ; } if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) { numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED ; strlcpy ( strresult , ""Ticket<S2SV_blank>must<S2SV_blank>be<S2SV_blank>derived<S2SV_blank>from<S2SV_blank>a<S2SV_blank>password"" , sizeof ( strresult ) ) ; goto chpwfail ; } ptr = k5memdup0 ( clear . data , clear . length , & ret ) ; ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ; if ( ret ) errmsg = krb5_get_error_message ( context , ret ) ; zapfree ( clear . data , clear . length ) ; zapfree ( ptr , clear . length ) ; clear = empty_data ( ) ; clen = strlen ( clientstr ) ; trunc_name ( & clen , & cdots ) ; switch ( addr -> addrtype ) { case ADDRTYPE_INET : { struct sockaddr_in * sin = ss2sin ( & ss ) ; sin -> sin_family = AF_INET ; memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ; sin -> sin_port = htons ( remote_faddr -> port ) ; salen = sizeof ( * sin ) ; break ; } case ADDRTYPE_INET6 : { struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ; sin6 -> sin6_family = AF_INET6 ; memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ; sin6 -> sin6_port = htons ( remote_faddr -> port ) ; salen = sizeof ( * sin6 ) ; break ; } default : { struct sockaddr * sa = ss2sa ( & ss ) ; sa -> sa_family = AF_UNSPEC ; salen = sizeof ( * sa ) ; break ; } } if ( getnameinfo ( ss2sa ( & ss ) , salen , addrbuf , sizeof ( addrbuf ) , NULL , 0 , NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) strlcpy ( addrbuf , ""<unprintable>"" , sizeof ( addrbuf ) ) ; if ( vno == RFC3244_VERSION ) { size_t tlen ; char * tdots ; const char * targetp ; if ( target == NULL ) { tlen = clen ; tdots = cdots ; targetp = targetstr ; } else { tlen = strlen ( targetstr ) ; trunc_name ( & tlen , & tdots ) ; targetp = clientstr ; } krb5_klog_syslog ( LOG_NOTICE , _ ( ""setpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>by<S2SV_blank>%.*s%s<S2SV_blank>for<S2SV_blank>"" ""%.*s%s:<S2SV_blank>%s"" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : ""success"" ) ; } else { krb5_klog_syslog ( LOG_NOTICE , _ ( ""chpw<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%.*s%s:<S2SV_blank>%s"" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : ""success"" ) ; } switch ( ret ) { case KADM5_AUTH_CHANGEPW : numresult = KRB5_KPASSWD_ACCESSDENIED ; break ; case KADM5_PASS_Q_TOOSHORT : case KADM5_PASS_REUSE : case KADM5_PASS_Q_CLASS : case KADM5_PASS_Q_DICT : case KADM5_PASS_Q_GENERIC : case KADM5_PASS_TOOSOON : numresult = KRB5_KPASSWD_SOFTERROR ; break ; case 0 : numresult = KRB5_KPASSWD_SUCCESS ; strlcpy ( strresult , """" , sizeof ( strresult ) ) ; break ; default : numresult = KRB5_KPASSWD_HARDERROR ; break ; } chpwfail : clear . length = 2 + strlen ( strresult ) ; clear . data = ( char * ) malloc ( clear . length ) ; ptr = clear . data ; * ptr ++ = ( numresult >> 8 ) & 0xff ; * ptr ++ = numresult & 0xff ; memcpy ( ptr , strresult , strlen ( strresult ) ) ; cipher = empty_data ( ) ; if ( ap_rep . length ) { ret = krb5_auth_con_setaddrs ( context , auth_context , local_faddr -> address , NULL ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>storing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>internet<S2SV_blank>addresses"" , sizeof ( strresult ) ) ; } else { ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ; if ( ret ) { numresult = KRB5_KPASSWD_HARDERROR ; strlcpy ( strresult , ""Failed<S2SV_blank>encrypting<S2SV_blank>reply"" , sizeof ( strresult ) ) ; } } } if ( cipher . length == 0 ) { if ( ap_rep . length ) { free ( ap_rep . data ) ; ap_rep = empty_data ( ) ; } krberror . ctime = 0 ; krberror . cusec = 0 ; krberror . susec = 0 ; ret = krb5_timeofday ( context , & krberror . stime ) ; if ( ret ) goto bailout ; krberror . error = ret ; krberror . error -= ERROR_TABLE_BASE_krb5 ; if ( krberror . error < 0 || krberror . error > 128 ) krberror . error = KRB_ERR_GENERIC ; krberror . client = NULL ; ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , ""kadmin"" , ""changepw"" , NULL ) ; if ( ret ) goto bailout ; krberror . text . length = 0 ; krberror . e_data = clear ; ret = krb5_mk_error ( context , & krberror , & cipher ) ; krb5_free_principal ( context , krberror . server ) ; if ( ret ) goto bailout ; } ret = alloc_data ( rep , 6 + ap_rep . length + cipher . length ) ; if ( ret ) goto bailout ; ptr = rep -> data ; * ptr ++ = ( rep -> length >> 8 ) & 0xff ; * ptr ++ = rep -> length & 0xff ; * ptr ++ = 0 ; * ptr ++ = 1 ; * ptr ++ = ( ap_rep . length >> 8 ) & 0xff ; * ptr ++ = ap_rep . length & 0xff ; if ( ap_rep . length ) { memcpy ( ptr , ap_rep . data , ap_rep . length ) ; ptr += ap_rep . length ; } memcpy ( ptr , cipher . data , cipher . length ) ; bailout : krb5_auth_con_free ( context , auth_context ) ; krb5_free_principal ( context , changepw ) ; krb5_free_ticket ( context , ticket ) ; free ( ap_rep . data ) ; free ( clear . data ) ; free ( cipher . data ) ; krb5_free_principal ( context , target ) ; krb5_free_unparsed_name ( context , targetstr ) ; krb5_free_unparsed_name ( context , clientstr ) ; krb5_free_error_message ( context , errmsg ) ; return ret ; }
","<S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } vno <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req
",krb5@krb5/cf1a0c411b2668c57c41e9c4efd15ba17b6b322c,CVE-2002-2443,https://github.com/krb5/krb5/commit/cf1a0c411b2668c57c41e9c4efd15ba17b6b322c,2013-05-29T14:29Z
CWE-119,"CWE-119 static int netlbl_cipsov4_add_common ( struct genl_info * info , struct cipso_v4_doi * doi_def ) { struct nlattr * nla ; int nla_rem ; u32 iter = 0 ; doi_def -> doi = nla_get_u32 ( info -> attrs [ NLBL_CIPSOV4_A_DOI ] ) ; if ( nla_validate_nested ( info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , NLBL_CIPSOV4_A_MAX , netlbl_cipsov4_genl_policy ) != 0 ) return - EINVAL ; nla_for_each_nested ( nla , info -> attrs [ NLBL_CIPSOV4_A_TAGLST ] , nla_rem ) if ( nla -> nla_type == NLBL_CIPSOV4_A_TAG ) { <S2SV_StartBug> if ( iter > CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> return - EINVAL ; doi_def -> tags [ iter ++ ] = nla_get_u8 ( nla ) ; } <S2SV_StartBug> if ( iter < CIPSO_V4_TAG_MAXCNT ) <S2SV_EndBug> <S2SV_StartBug> doi_def -> tags [ iter ] = CIPSO_V4_TAG_INVALID ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++
",torvalds@linux/2a2f11c227bdf292b3a2900ad04139d301b56ac4,CVE-2007-6762,https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4,2019-07-27T22:15Z
CWE-20,"CWE-20 error_t ftpClientOpenDir ( FtpClientContext * context , const char_t * path ) { error_t error ; if ( context == NULL || path == NULL ) return ERROR_INVALID_PARAMETER ; error = NO_ERROR ; while ( ! error ) { if ( context -> state == FTP_CLIENT_STATE_CONNECTED ) { error = ftpClientFormatCommand ( context , ""TYPE"" , ""A"" ) ; if ( ! error ) { ftpClientChangeState ( context , FTP_CLIENT_STATE_SUB_COMMAND_1 ) ; } } else if ( context -> state == FTP_CLIENT_STATE_SUB_COMMAND_1 ) { error = ftpClientSendCommand ( context ) ; if ( ! error ) { if ( FTP_REPLY_CODE_2YZ ( context -> replyCode ) ) { ftpClientChangeState ( context , FTP_CLIENT_STATE_SUB_COMMAND_2 ) ; } else { error = ERROR_UNEXPECTED_RESPONSE ; } } } else if ( context -> state == FTP_CLIENT_STATE_SUB_COMMAND_2 || context -> state == FTP_CLIENT_STATE_SUB_COMMAND_3 || context -> state == FTP_CLIENT_STATE_SUB_COMMAND_4 || context -> state == FTP_CLIENT_STATE_SUB_COMMAND_5 || context -> state == FTP_CLIENT_STATE_SUB_COMMAND_6 || context -> state == FTP_CLIENT_STATE_CONNECTING_TCP || context -> state == FTP_CLIENT_STATE_SUB_COMMAND_8 || context -> state == FTP_CLIENT_STATE_ACCEPTING_TCP || context -> state == FTP_CLIENT_STATE_CONNECTING_TLS ) { error = ftpClientInitDataTransfer ( context , FALSE ) ; } else if ( context -> state == FTP_CLIENT_STATE_SUB_COMMAND_7 ) { if ( ! osStrcmp ( path , ""."" ) ) <S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> ftpClientFormatCommand ( context , ""LIST"" , path ) ; <S2SV_EndBug> if ( ! error ) { ftpClientChangeState ( context , FTP_CLIENT_STATE_SUB_COMMAND_8 ) ; } } else if ( context -> state == FTP_CLIENT_STATE_SUB_COMMAND_9 ) { context -> bufferPos = 0 ; context -> commandLen = 0 ; context -> replyLen = 0 ; ftpClientChangeState ( context , FTP_CLIENT_STATE_READING_DATA ) ; break ; } else { error = ERROR_WRONG_STATE ; } } if ( error == ERROR_WOULD_BLOCK || error == ERROR_TIMEOUT ) { error = ftpClientCheckTimeout ( context ) ; } if ( error != NO_ERROR && error != ERROR_WOULD_BLOCK ) { ftpClientCloseChannel ( & context -> dataChannel ) ; ftpClientChangeState ( context , FTP_CLIENT_STATE_CONNECTED ) ; } return error ; }
","<S2SV_ModStart> ""."" ) ) { <S2SV_ModStart> NULL ) ; } else { <S2SV_ModEnd> ftpClientFormatCommand ( context <S2SV_ModStart> path ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-190,"CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++ ) { im -> open [ i ] = 1 ; im -> red [ i ] = 0 ; im -> green [ i ] = 0 ; im -> blue [ i ] = 0 ; } im -> trueColor = 0 ; im -> tpixels = 0 ; im -> cx1 = 0 ; im -> cy1 = 0 ; im -> cx2 = im -> sx - 1 ; im -> cy2 = im -> sy - 1 ; im -> interpolation = NULL ; im -> interpolation_id = GD_BILINEAR_FIXED ; return im ; }
","<S2SV_ModStart> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
",php@php-src/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6,CVE-2016-5767,https://github.com/php/php-src/commit/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6?w=1,2016-08-07T10:59Z
CWE-190,"CWE-190 static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-119,"CWE-119 int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; <S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }
","<S2SV_ModStart> ( cpi -> oxcf . <S2SV_ModStart> -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q = <S2SV_ModStart> { if ( <S2SV_ModEnd> cpi -> sf
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) <S2SV_StartBug> return - E_NOTHANDLED ; <S2SV_EndBug> fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'t<S2SV_blank>create<S2SV_blank>file<S2SV_blank>%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""<S2SV_blank>Writing<S2SV_blank>output<S2SV_blank>to<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; fprintf ( stdout , ""<S2SV_blank>-><S2SV_blank>Script<S2SV_blank>encoded<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>instructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
","<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
",LocutusOfBorg@ettercap/626dc56686f15f2dda13c48f78c2a666cb6d8506,CVE-2017-6430,https://github.com/LocutusOfBorg/ettercap/commit/626dc56686f15f2dda13c48f78c2a666cb6d8506,2017-03-15T15:59Z
CWE-400,"CWE-400 static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return ERR_PTR ( - ENOSPC ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( - ENOMEM ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = NULL ; INIT_LIST_HEAD ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; <S2SV_StartBug> return new_ns ; <S2SV_EndBug> }
","<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
CWE-284,"CWE-284 int main ( int argc , char * * argv ) { MYSQL mysql ; option_string * eptr ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( ""my"" , load_default_groups , & argc , & argv ) ) { my_end ( 0 ) ; exit ( 1 ) ; } my_getopt_use_args_separator = FALSE ; defaults_argv = argv ; if ( get_options ( & argc , & argv ) ) { free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } if ( auto_generate_sql ) srandom ( ( uint ) time ( NULL ) ) ; delimiter_length = strlen ( delimiter ) ; if ( argc > 2 ) { fprintf ( stderr , ""%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n"" , my_progname ) ; free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } # endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , ""program_name"" , ""mysqlslap"" ) ; if ( using_opt_enable_cleartext_plugin ) mysql_options ( & mysql , MYSQL_ENABLE_CLEARTEXT_PLUGIN , ( char * ) & opt_enable_cleartext_plugin ) ; if ( ! opt_only_print ) { if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , NULL , opt_mysql_port , opt_mysql_unix_port , connect_flags ) ) ) { fprintf ( stderr , ""%s:<S2SV_blank>Error<S2SV_blank>when<S2SV_blank>connecting<S2SV_blank>to<S2SV_blank>server:<S2SV_blank>%s\\n"" , my_progname , mysql_error ( & mysql ) ) ; free_defaults ( defaults_argv ) ; my_end ( 0 ) ; exit ( 1 ) ; } } pthread_mutex_init ( & counter_mutex , NULL ) ; pthread_cond_init ( & count_threshhold , NULL ) ; pthread_mutex_init ( & sleeper_mutex , NULL ) ; pthread_cond_init ( & sleep_threshhold , NULL ) ; eptr = engine_options ; do { uint * current ; if ( verbose >= 2 ) printf ( ""Starting<S2SV_blank>Concurrency<S2SV_blank>Test\\n"" ) ; if ( * concurrency ) { for ( current = concurrency ; current && * current ; current ++ ) concurrency_loop ( & mysql , * current , eptr ) ; } else { uint infinite = 1 ; do { concurrency_loop ( & mysql , infinite , eptr ) ; } while ( infinite ++ ) ; } if ( ! opt_preserve ) drop_schema ( & mysql , create_schema_string ) ; } while ( eptr ? ( eptr = eptr -> next ) : 0 ) ; pthread_mutex_destroy ( & counter_mutex ) ; pthread_cond_destroy ( & count_threshhold ) ; pthread_mutex_destroy ( & sleeper_mutex ) ; pthread_cond_destroy ( & sleep_threshhold ) ; if ( ! opt_only_print ) mysql_close ( & mysql ) ; my_free ( opt_password ) ; my_free ( concurrency ) ; statement_cleanup ( create_statements ) ; statement_cleanup ( query_statements ) ; statement_cleanup ( pre_statements ) ; statement_cleanup ( post_statements ) ; option_cleanup ( engine_options ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) my_free ( shared_memory_base_name ) ; # endif free_defaults ( defaults_argv ) ; my_end ( my_end_arg ) ; return 0 ; }
","<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> if ( opt_protocol
",mysql@mysql-server/3bd5589e1a5a93f9c224badf983cd65c45215390,CVE-2015-3152,https://github.com/mysql/mysql-server/commit/3bd5589e1a5a93f9c224badf983cd65c45215390,2016-05-16T10:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { <S2SV_EndBug> const JsVarFloat stopAtError = 0.0000001 ; <S2SV_StartBug> if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; <S2SV_EndBug> else if ( ! isfinite ( val ) ) { <S2SV_StartBug> if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; <S2SV_EndBug> <S2SV_StartBug> else strncpy ( str , ""Infinity"" , len ) ; <S2SV_EndBug> } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; fractionalDigits -- ; } } # endif * ( str ++ ) = 0 ; } }
","<S2SV_ModStart> fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> val ) ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""NaN"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> < 0 ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""-Infinity"" <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , ""Infinity"" <S2SV_ModEnd> ) ; }
",espruino@Espruino/0a7619875bf79877907205f6bee08465b89ff10b,CVE-2018-11595,https://github.com/espruino/Espruino/commit/0a7619875bf79877907205f6bee08465b89ff10b,2018-05-31T16:29Z
CWE-552,"CWE-552 static ssize_t _hostsock_sendmsg ( oe_fd_t * sock_ , const struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> oe_errno = 0 ; if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , flags ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_for_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int has_type_comment ; string type_comment ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>for<S2SV_blank>loops<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT ; if ( NCH ( n ) == 9 + has_type_comment ) { seq = ast_for_suite ( c , CHILD ( n , 8 + has_type_comment ) ) ; if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; suite_seq = ast_for_suite ( c , CHILD ( n , 5 + has_type_comment ) ) ; if ( ! suite_seq ) return NULL ; if ( has_type_comment ) type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; else type_comment = NULL ; if ( is_async ) return AsyncFor ( target , expression , suite_seq , seq , <S2SV_StartBug> type_comment , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> c -> c_arena ) ; else return For ( target , expression , suite_seq , seq , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
",haakonnessjoen@MAC-Telnet/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,CVE-2016-7115,https://github.com/haakonnessjoen/MAC-Telnet/commit/b69d11727d4f0f8cf719c79e3fb700f55ca03e9a,2016-08-30T17:59Z
CWE-254,"CWE-254 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data ( dec_state_t * ps_dec ) { stream_t * ps_stream ; UWORD32 u4_start_code ; IMPEG2D_ERROR_CODES_T e_error ; e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) && <S2SV_StartBug> ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE == e_error ) <S2SV_EndBug> { if ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_dec_user_data ( ps_dec ) ; } else { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , EXT_ID_LEN ) ; switch ( u4_start_code ) { case SEQ_DISPLAY_EXT_ID : impeg2d_dec_seq_disp_ext ( ps_dec ) ; break ; case SEQ_SCALABLE_EXT_ID : e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED ; break ; default : impeg2d_bit_stream_flush ( ps_stream , EXT_ID_LEN ) ; impeg2d_peek_next_start_code ( ps_dec ) ; break ; } } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } return e_error ; }
","<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
",external@libmpeg2/ffab15eb80630dc799eb410855c93525b75233c3,CVE-2016-0824,https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3,2016-03-12T21:59Z
CWE-000,"CWE-000 static struct inode * ext4_alloc_inode ( struct super_block * sb ) { struct ext4_inode_info * ei ; ei = kmem_cache_alloc ( ext4_inode_cachep , GFP_NOFS ) ; if ( ! ei ) return NULL ; ei -> vfs_inode . i_version = 1 ; ei -> vfs_inode . i_data . writeback_index = 0 ; memset ( & ei -> i_cached_extent , 0 , sizeof ( struct ext4_ext_cache ) ) ; INIT_LIST_HEAD ( & ei -> i_prealloc_list ) ; spin_lock_init ( & ei -> i_prealloc_lock ) ; jbd2_journal_init_jbd_inode ( & ei -> jinode , & ei -> vfs_inode ) ; ei -> i_reserved_data_blocks = 0 ; ei -> i_reserved_meta_blocks = 0 ; ei -> i_allocated_meta_blocks = 0 ; ei -> i_da_metadata_calc_len = 0 ; ei -> i_delalloc_reserved_flag = 0 ; spin_lock_init ( & ( ei -> i_block_reservation_lock ) ) ; # ifdef CONFIG_QUOTA ei -> i_reserved_quota = 0 ; # endif INIT_LIST_HEAD ( & ei -> i_completed_io_list ) ; <S2SV_StartBug> ei -> cur_aio_dio = NULL ; <S2SV_EndBug> ei -> i_sync_tid = 0 ; ei -> i_datasync_tid = 0 ; return & ei -> vfs_inode ; }
","<S2SV_ModStart> i_completed_io_list ) ; spin_lock_init ( & ei -> i_completed_io_lock ) ;
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-77,"CWE-77 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <S2SV_StartBug> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <S2SV_EndBug> { mutt_error ( _ ( ""Bad<S2SV_blank>mailbox<S2SV_blank>name"" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , ""INBOX"" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <S2SV_StartBug> snprintf ( mbox , sizeof ( mbox ) , ""%smailboxes<S2SV_blank>\\""%s\\"""" , subscribe ? """" : ""un"" , path ) ; <S2SV_EndBug> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , ""Error<S2SV_blank>adding<S2SV_blank>subscribed<S2SV_blank>mailbox:<S2SV_blank>%s\\n"" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( ""Subscribing<S2SV_blank>to<S2SV_blank>%s..."" ) , buf ) ; else mutt_message ( _ ( ""Unsubscribing<S2SV_blank>from<S2SV_blank>%s..."" ) , buf ) ; imap_munge_mbox_name ( idata , mbox , sizeof ( mbox ) , buf ) ; snprintf ( buf , sizeof ( buf ) , ""%sSUBSCRIBE<S2SV_blank>%s"" , subscribe ? """" : ""UN"" , mbox ) ; if ( imap_exec ( idata , buf , 0 ) < 0 ) goto fail ; imap_unmunge_mbox_name ( idata , mx . mbox ) ; if ( subscribe ) mutt_message ( _ ( ""Subscribed<S2SV_blank>to<S2SV_blank>%s"" ) , mx . mbox ) ; else mutt_message ( _ ( ""Unsubscribed<S2SV_blank>from<S2SV_blank>%s"" ) , mx . mbox ) ; FREE ( & mx . mbox ) ; return 0 ; fail : FREE ( & mx . mbox ) ; return - 1 ; }
","<S2SV_ModStart> ImapMbox mx ; size_t len = 0 ; <S2SV_ModStart> errstr ) ; len = <S2SV_ModStart> mbox ) , ""%smailboxes<S2SV_blank>"" <S2SV_ModEnd> , subscribe ? <S2SV_ModStart> """" : ""un"" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> ) ; if
",neomutt@neomutt/95e80bf9ff10f68cb6443f760b85df4117cb15eb,CVE-2018-14354,https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb,2018-07-17T17:29Z
CWE-476,"CWE-476 static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
",torvalds@linux/371528caec553785c37f73fa3926ea0de84f986f,CVE-2012-1146,https://github.com/torvalds/linux/commit/371528caec553785c37f73fa3926ea0de84f986f,2012-05-17T11:00Z
CWE-787,"CWE-787 int tmx_check_pretran ( sip_msg_t * msg ) { unsigned int chid ; unsigned int slotid ; int dsize ; struct via_param * vbr ; str scallid ; str scseqmet ; str scseqnum ; str sftag ; str svbranch = { NULL , 0 } ; pretran_t * it ; if ( _tmx_ptran_table == NULL ) { LM_ERR ( ""pretran<S2SV_blank>hash<S2SV_blank>table<S2SV_blank>not<S2SV_blank>initialized<S2SV_blank>yet\\n"" ) ; return - 1 ; } if ( get_route_type ( ) != REQUEST_ROUTE ) { LM_ERR ( ""invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>in<S2SV_blank>request<S2SV_blank>route\\n"" ) ; return - 1 ; } if ( msg -> first_line . type != SIP_REQUEST ) { LM_ERR ( ""invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>a<S2SV_blank>sip<S2SV_blank>request\\n"" ) ; return - 1 ; } if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>required<S2SV_blank>headers\\n"" ) ; return - 1 ; } if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>cseq<S2SV_blank>headers\\n"" ) ; return - 1 ; } if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) { LM_DBG ( ""no<S2SV_blank>pre-transaction<S2SV_blank>management<S2SV_blank>for<S2SV_blank>ACK<S2SV_blank>or<S2SV_blank>CANCEL\\n"" ) ; return - 1 ; } if ( msg -> via1 == 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>Via<S2SV_blank>header\\n"" ) ; return - 1 ; } if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>From<S2SV_blank>header\\n"" ) ; return - 1 ; } if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>callid<S2SV_blank>headers\\n"" ) ; return - 1 ; } vbr = msg -> via1 -> branch ; scallid = msg -> callid -> body ; trim ( & scallid ) ; scseqmet = get_cseq ( msg ) -> method ; trim ( & scseqmet ) ; scseqnum = get_cseq ( msg ) -> number ; trim ( & scseqnum ) ; sftag = get_from ( msg ) -> tag_value ; trim ( & sftag ) ; chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ; slotid = chid & ( _tmx_ptran_size - 1 ) ; if ( unlikely ( _tmx_proc_ptran == NULL ) ) { _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ; if ( _tmx_proc_ptran == NULL ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>structure\\n"" ) ; return - 1 ; } memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ; _tmx_proc_ptran -> pid = my_pid ( ) ; } dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ; if ( likely ( vbr != NULL ) ) { svbranch = vbr -> value ; trim ( & svbranch ) ; <S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> } if ( dsize < 256 ) dsize = 256 ; tmx_pretran_unlink ( ) ; if ( dsize > _tmx_proc_ptran -> dbuf . len ) { if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ; _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ; if ( _tmx_proc_ptran -> dbuf . s == NULL ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>data\\n"" ) ; return - 1 ; } _tmx_proc_ptran -> dbuf . len = dsize ; } _tmx_proc_ptran -> hid = chid ; _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ; _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ; memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ; _tmx_proc_ptran -> callid . len = scallid . len ; _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ; _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ; memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ; _tmx_proc_ptran -> ftag . len = sftag . len ; _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ; _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ; _tmx_proc_ptran -> cseqnum . len = scseqnum . len ; _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ; _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ; _tmx_proc_ptran -> cseqmet . len = scseqmet . len ; _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ; if ( likely ( vbr != NULL ) ) { _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ; memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ; _tmx_proc_ptran -> vbranch . len = svbranch . len ; _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ; } else { _tmx_proc_ptran -> vbranch . s = NULL ; _tmx_proc_ptran -> vbranch . len = 0 ; } lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ; it = _tmx_ptran_table [ slotid ] . plist ; tmx_pretran_link_safe ( slotid ) ; for ( ; it != NULL ; it = it -> next ) { if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) { if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ; if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ; } if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ; if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ; LM_DBG ( ""matched<S2SV_blank>another<S2SV_blank>pre-transaction<S2SV_blank>by<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>[%.*s]\\n"" , it -> pid , it -> callid . len , it -> callid . s ) ; lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 1 ; } lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 0 ; }
","<S2SV_ModStart> svbranch . len + 1
",kamailio@kamailio/e1d8008a09d9390ebaf698abe8909e10dfec4097,CVE-2018-8828,https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097,2018-03-20T20:29Z
CWE-119,"CWE-119 static int msg_parse_fetch ( struct ImapHeader * h , char * s ) { char tmp [ SHORT_STRING ] ; char * ptmp = NULL ; if ( ! s ) return - 1 ; while ( * s ) { SKIPWS ( s ) ; if ( mutt_str_strncasecmp ( ""FLAGS"" , s , 5 ) == 0 ) { s = msg_parse_flags ( h , s ) ; if ( ! s ) return - 1 ; } else if ( mutt_str_strncasecmp ( ""UID"" , s , 3 ) == 0 ) { s += 3 ; SKIPWS ( s ) ; if ( mutt_str_atoui ( s , & h -> data -> uid ) < 0 ) return - 1 ; s = imap_next_word ( s ) ; } else if ( mutt_str_strncasecmp ( ""INTERNALDATE"" , s , 12 ) == 0 ) { s += 12 ; SKIPWS ( s ) ; if ( * s != \'\\""\' ) { mutt_debug ( 1 , ""bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n"" , s ) ; return - 1 ; } s ++ ; ptmp = tmp ; <S2SV_StartBug> while ( * s && * s != \'\\""\' ) <S2SV_EndBug> * ptmp ++ = * s ++ ; if ( * s != \'\\""\' ) return - 1 ; s ++ ; * ptmp = '\\0' ; h -> received = mutt_date_parse_imap ( tmp ) ; } else if ( mutt_str_strncasecmp ( ""RFC822.SIZE"" , s , 11 ) == 0 ) { s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> * ptmp ++ = * s ++ ; * ptmp = '\\0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) return - 1 ; } else if ( ( mutt_str_strncasecmp ( ""BODY"" , s , 4 ) == 0 ) || ( mutt_str_strncasecmp ( ""RFC822.HEADER"" , s , 13 ) == 0 ) ) { return - 2 ; } else if ( * s == ')' ) s ++ ; else if ( * s ) { imap_error ( ""msg_parse_fetch"" , s ) ; return - 1 ; } } return 0 ; }
","<S2SV_ModStart> * s && ( <S2SV_ModStart> s != \'\\""\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )
",neomutt@neomutt/1b0f0d0988e6df4e32e9f4bf8780846ea95d4485,CVE-2018-14358,https://github.com/neomutt/neomutt/commit/1b0f0d0988e6df4e32e9f4bf8780846ea95d4485,2018-07-17T17:29Z
CWE-000,"CWE-000 static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . bits_per_pixel = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ] . size = ReadBlobLSBLong ( image ) ; icon_file . directory [ i ] . offset = ReadBlobLSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } one = 1 ; for ( i = 0 ; i < icon_file . count ; i ++ ) { offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) icon_file . directory [ i ] . offset , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . size = ReadBlobLSBLong ( image ) ; icon_info . width = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) ) ; icon_info . height = ( unsigned char ) ( ( int ) ReadBlobLSBLong ( image ) / 2 ) ; icon_info . planes = ReadBlobLSBShort ( image ) ; icon_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( ( icon_info . planes == 18505 ) && ( icon_info . bits_per_pixel == 21060 ) ) || ( icon_info . size == 0x474e5089 ) ) { Image * icon_image ; ImageInfo * read_info ; size_t length ; unsigned char * png ; <S2SV_StartBug> length = icon_file . directory [ i ] . size ; <S2SV_EndBug> png = ( unsigned char * ) AcquireQuantumMemory ( length + 16 , sizeof ( * png ) ) ; if ( png == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) CopyMagickMemory ( png , ""\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015"" , 12 ) ; png [ 12 ] = ( unsigned char ) icon_info . planes ; png [ 13 ] = ( unsigned char ) ( icon_info . planes >> 8 ) ; png [ 14 ] = ( unsigned char ) icon_info . bits_per_pixel ; png [ 15 ] = ( unsigned char ) ( icon_info . bits_per_pixel >> 8 ) ; count = ReadBlob ( image , length - 16 , png + 16 ) ; icon_image = ( Image * ) NULL ; if ( count > 0 ) { read_info = CloneImageInfo ( image_info ) ; ( void ) CopyMagickString ( read_info -> magick , ""PNG"" , MagickPathExtent ) ; icon_image = BlobToImage ( read_info , png , length + 16 , exception ) ; read_info = DestroyImageInfo ( read_info ) ; } png = ( unsigned char * ) RelinquishMagickMemory ( png ) ; if ( icon_image == ( Image * ) NULL ) { if ( count != ( ssize_t ) ( length - 16 ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } DestroyBlob ( icon_image ) ; icon_image -> blob = ReferenceBlob ( image -> blob ) ; ReplaceImageInList ( & image , icon_image ) ; } else { if ( icon_info . bits_per_pixel > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; icon_info . compression = ReadBlobLSBLong ( image ) ; icon_info . image_size = ReadBlobLSBLong ( image ) ; icon_info . x_pixels = ReadBlobLSBLong ( image ) ; icon_info . y_pixels = ReadBlobLSBLong ( image ) ; icon_info . number_colors = ReadBlobLSBLong ( image ) ; icon_info . colors_important = ReadBlobLSBLong ( image ) ; image -> alpha_trait = BlendPixelTrait ; image -> columns = ( size_t ) icon_file . directory [ i ] . width ; if ( ( ssize_t ) image -> columns > icon_info . width ) image -> columns = ( size_t ) icon_info . width ; if ( image -> columns == 0 ) image -> columns = 256 ; image -> rows = ( size_t ) icon_file . directory [ i ] . height ; if ( ( ssize_t ) image -> rows > icon_info . height ) image -> rows = ( size_t ) icon_info . height ; if ( image -> rows == 0 ) image -> rows = 256 ; image -> depth = icon_info . bits_per_pixel ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank>scene<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) i ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>size<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . size ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>width<S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . width ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>height<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_file . directory [ i ] . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>colors<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . number_colors ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>planes<S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . planes ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>bpp<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%.20g"" , ( double ) icon_info . bits_per_pixel ) ; } if ( ( icon_info . number_colors != 0 ) || ( icon_info . bits_per_pixel <= 16U ) ) { image -> storage_class = PseudoClass ; image -> colors = icon_info . number_colors ; if ( image -> colors == 0 ) image -> colors = one << icon_info . bits_per_pixel ; } if ( image -> storage_class == PseudoClass ) { register ssize_t i ; unsigned char * icon_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; icon_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4UL * sizeof ( * icon_colormap ) ) ; if ( icon_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) ( 4 * image -> colors ) , icon_colormap ) ; if ( count != ( ssize_t ) ( 4 * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = icon_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( Quantum ) ScaleCharToQuantum ( * p ++ ) ; p ++ ; } icon_colormap = ( unsigned char * ) RelinquishMagickMemory ( icon_colormap ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_line = ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) >> 3 ; ( void ) bytes_per_line ; scanline_pad = ( ( ( ( image -> columns * icon_info . bits_per_pixel ) + 31 ) & ~ 31 ) - ( image -> columns * icon_info . bits_per_pixel ) ) >> 3 ; switch ( icon_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelIndex ( image , ( ( byte & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) , q ) ; q += GetPixelChannels ( image ) ; } } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; SetPixelIndex ( image , ( ( byte ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , ( ( byte >> 4 ) & 0xf ) , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 8 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 16 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { byte = ( size_t ) ReadBlobByte ( image ) ; byte |= ( size_t ) ( ReadBlobByte ( image ) << 8 ) ; SetPixelIndex ( image , byte , q ) ; q += GetPixelChannels ( image ) ; } for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; if ( icon_info . bits_per_pixel == 32 ) SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( icon_info . bits_per_pixel == 24 ) for ( x = 0 ; x < ( ssize_t ) scanline_pad ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( image_info -> ping == MagickFalse ) ( void ) SyncImage ( image , exception ) ; if ( icon_info . bits_per_pixel != 32 ) { image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 8 ) != 0 ) { byte = ( size_t ) ReadBlobByte ( image ) ; for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { SetPixelAlpha ( image , ( ( ( byte & ( 0x80 >> bit ) ) != 0 ) ? TransparentAlpha : OpaqueAlpha ) , q ) ; q += GetPixelChannels ( image ) ; } } if ( ( image -> columns % 32 ) != 0 ) for ( x = 0 ; x < ( ssize_t ) ( ( 32 - ( image -> columns % 32 ) ) / 8 ) ; x ++ ) ( void ) ReadBlobByte ( image ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( i < ( ssize_t ) ( icon_file . count - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" )
",ImageMagick@ImageMagick/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,CVE-2015-8896,https://github.com/ImageMagick/ImageMagick/commit/0f6fc2d5bf8f500820c3dbcf0d23ee14f2d9f734,2017-03-15T19:59Z
CWE-834,"CWE-834 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MagickPathExtent ] , name [ MagickPathExtent ] ; Image <S2SV_StartBug> * image ; <S2SV_EndBug> MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , <S2SV_StartBug> value , <S2SV_EndBug> version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define<S2SV_blank>%32s<S2SV_blank>%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( sscanf ( buffer , ""static<S2SV_blank>short<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 10 ; else if ( sscanf ( buffer , ""static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else if ( sscanf ( buffer , ""static<S2SV_blank>char<S2SV_blank>%32s<S2SV_blank>=<S2SV_blank>{"" , name ) == 1 ) version = 11 ; else continue ; p = ( unsigned char * ) strrchr ( name , '_' ) ; if ( p == ( unsigned char * ) NULL ) p = ( unsigned char * ) name ; else p ++ ; if ( LocaleCompare ( ""bits[]"" , ( char * ) p ) == 0 ) break ; } if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> image -> colormap [ 0 ] . red = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . green = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 0 ] . blue = QuantumRange ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . red = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . green = ( Quantum ) 0 ; <S2SV_EndBug> <S2SV_StartBug> image -> colormap [ 1 ] . blue = ( Quantum ) 0 ; <S2SV_EndBug> if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; hex_digits [ ( int ) '0' ] = 0 ; hex_digits [ ( int ) '1' ] = 1 ; hex_digits [ ( int ) '2' ] = 2 ; hex_digits [ ( int ) '3' ] = 3 ; hex_digits [ ( int ) '4' ] = 4 ; hex_digits [ ( int ) '5' ] = 5 ; hex_digits [ ( int ) '6' ] = 6 ; hex_digits [ ( int ) '7' ] = 7 ; hex_digits [ ( int ) '8' ] = 8 ; hex_digits [ ( int ) '9' ] = 9 ; hex_digits [ ( int ) 'A' ] = 10 ; hex_digits [ ( int ) 'B' ] = 11 ; hex_digits [ ( int ) 'C' ] = 12 ; hex_digits [ ( int ) 'D' ] = 13 ; hex_digits [ ( int ) 'E' ] = 14 ; hex_digits [ ( int ) 'F' ] = 15 ; hex_digits [ ( int ) 'a' ] = 10 ; hex_digits [ ( int ) 'b' ] = 11 ; hex_digits [ ( int ) 'c' ] = 12 ; hex_digits [ ( int ) 'd' ] = 13 ; hex_digits [ ( int ) 'e' ] = 14 ; hex_digits [ ( int ) 'f' ] = 15 ; hex_digits [ ( int ) 'x' ] = 0 ; hex_digits [ ( int ) '<S2SV_blank>' ] = ( - 1 ) ; hex_digits [ ( int ) ',' ] = ( - 1 ) ; hex_digits [ ( int ) '}' ] = ( - 1 ) ; hex_digits [ ( int ) '\\n' ] = ( - 1 ) ; hex_digits [ ( int ) '\\t' ] = ( - 1 ) ; padding = 0 ; if ( ( ( image -> columns % 16 ) != 0 ) && ( ( image -> columns % 16 ) < 9 ) && ( version == 10 ) ) padding = 1 ; bytes_per_line = ( unsigned int ) ( image -> columns + 7 ) / 8 + padding ; length = ( unsigned int ) image -> rows ; data = ( unsigned char * ) AcquireQuantumMemory ( length , bytes_per_line * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; if ( version == 10 ) for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; ( i += 2 ) ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> if ( ( padding == 0 ) || ( ( ( i + 2 ) % bytes_per_line ) != 0 ) ) <S2SV_StartBug> * p ++ = ( unsigned char ) ( value >> 8 ) ; <S2SV_EndBug> } else for ( i = 0 ; i < ( ssize_t ) ( bytes_per_line * image -> rows ) ; i ++ ) { <S2SV_StartBug> value = XBMInteger ( image , hex_digits ) ; <S2SV_EndBug> <S2SV_StartBug> * p ++ = ( unsigned char ) value ; <S2SV_EndBug> } p = data ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; bit = 0 ; byte = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( bit == 0 ) <S2SV_StartBug> byte = ( size_t ) ( * p ++ ) ; <S2SV_EndBug> SetPixelIndex ( image , ( Quantum ) ( ( byte & 0x01 ) != 0 ? 0x01 : 0x00 ) , q ) ; bit ++ ; byte >>= 1 ; if ( bit == 8 ) bit = 0 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ( void ) SyncImage ( image , exception ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> , padding , <S2SV_ModEnd> version , width <S2SV_ModStart> . red = ( MagickRealType ) <S2SV_ModStart> . green = ( MagickRealType ) <S2SV_ModStart> . blue = ( MagickRealType ) <S2SV_ModStart> . red = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . green = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . blue = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> ++ ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
",ImageMagick@ImageMagick/d9a8234d211da30baf9526fbebe9a8438ea7e11c,CVE-2017-14175,https://github.com/ImageMagick/ImageMagick/commit/d9a8234d211da30baf9526fbebe9a8438ea7e11c,2017-09-07T06:29Z
CWE-59,"CWE-59 static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }
","<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,
",rpm-software-management@rpm/404ef011c300207cdb1e531670384564aae04bdc,CVE-2017-7501,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,2017-11-22T22:29Z
CWE-119,"CWE-119 static int wdm_post_reset ( struct usb_interface * intf ) { struct wdm_device * desc = wdm_find_device ( intf ) ; <S2SV_StartBug> int rv ; <S2SV_EndBug> clear_bit ( WDM_RESETTING , & desc -> flags ) ; rv = recover_from_urb_loss ( desc ) ; mutex_unlock ( & desc -> wlock ) ; mutex_unlock ( & desc -> rlock ) ; return 0 ; }
","<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
",torvalds@linux/c0f5ecee4e741667b2493c742b60b6218d40b3aa,CVE-2013-1860,https://github.com/torvalds/linux/commit/c0f5ecee4e741667b2493c742b60b6218d40b3aa,2013-03-22T11:59Z
CWE-362,"CWE-362 void sctp_generate_proto_unreach_event ( unsigned long data ) { struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> proto_unreach_timer , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; sctp_do_sm ( net , SCTP_EVENT_T_OTHER , SCTP_ST_OTHER ( SCTP_EVENT_ICMP_PROTO_UNREACH ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_association_put ( asoc ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
CWE-119,"CWE-119 int au1100fb_fb_mmap ( struct fb_info * fbi , struct vm_area_struct * vma ) { struct au1100fb_device * fbdev ; <S2SV_StartBug> unsigned int len ; <S2SV_EndBug> unsigned long start = 0 , off ; <S2SV_StartBug> fbdev = to_au1100fb_device ( fbi ) ; <S2SV_EndBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= ( 6 << 9 ) ; <S2SV_StartBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <S2SV_EndBug> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) { return - EAGAIN ; } return 0 ; }
","<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/7314e613d5ff9f0934f7a0f74ed7973b903315d1,CVE-2013-6763,https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1,2013-11-12T14:35Z
CWE-125,"CWE-125 static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>src<S2SV_blank>%s,<S2SV_blank>dst<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case IPCPOPT_IPCOMP_HDRCOMP : if ( len < IPCPOPT_IPCOMP_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>%u)"" , IPCPOPT_IPCOMP_MINLEN ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , IPCPOPT_IPCOMP_MINLEN ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TCP<S2SV_blank>Space<S2SV_blank>%u,<S2SV_blank>non-TCP<S2SV_blank>Space<S2SV_blank>%u"" "",<S2SV_blank>maxPeriod<S2SV_blank>%u,<S2SV_blank>maxTime<S2SV_blank>%u,<S2SV_blank>maxHdr<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 4 ) , EXTRACT_16BITS ( p + 6 ) , EXTRACT_16BITS ( p + 8 ) , EXTRACT_16BITS ( p + 10 ) , EXTRACT_16BITS ( p + 12 ) ) ) ; if ( len > IPCPOPT_IPCOMP_MINLEN ) { ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN ; p += IPCPOPT_IPCOMP_MINLEN ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Suboptions,<S2SV_blank>length<S2SV_blank>%u"" , ipcomp_subopttotallen ) ) ; while ( ipcomp_subopttotallen >= 2 ) { ND_TCHECK2 ( * p , 2 ) ; ipcomp_subopt = * p ; ipcomp_suboptlen = * ( p + 1 ) ; if ( ipcomp_subopt == 0 || ipcomp_suboptlen == 0 ) break ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>Suboption<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ipcpopt_compproto_subopt_values , ""Unknown"" , ipcomp_subopt ) , ipcomp_subopt , ipcomp_suboptlen ) ) ; ipcomp_subopttotallen -= ipcomp_suboptlen ; p += ipcomp_suboptlen ; } } break ; default : break ; } break ; case IPCPOPT_ADDR : case IPCPOPT_MOBILE4 : case IPCPOPT_PRIDNS : case IPCPOPT_PRINBNS : case IPCPOPT_SECDNS : case IPCPOPT_SECNBNS : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ipcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z
CWE-20,"CWE-20 bool_t enc28j60IrqHandler ( NetInterface * interface ) { bool_t flag ; uint8_t status ; flag = FALSE ; <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> <S2SV_StartBug> status = enc28j60ReadReg ( interface , ENC28J60_REG_EIR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & EIR_LINKIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_LINKIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & EIR_PKTIF ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIE , EIE_PKTIE ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & ( EIR_TXIF | EIE_TXERIE ) ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_EIR , EIR_TXIF | EIE_TXERIE ) ; <S2SV_EndBug> flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_EIE , EIE_INTIE ) ; <S2SV_EndBug> return flag ; }
","<S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , ENC28J60_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC28J60_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> } if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_PKTIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> status & ( ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ) != <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ; flag <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-264,"CWE-264 <S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
CWE-000,"CWE-000 void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( ""tcp_sack_option"" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }
","<S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
",openbsd@src/ed8fdce754a5d8d14c09e989d8877707bd43906f,CVE-2019-8460,https://github.com/openbsd/src/commit/ed8fdce754a5d8d14c09e989d8877707bd43906f,2019-08-26T20:15Z
CWE-119,"CWE-119 static void write_uncompressed_header ( VP9_COMP * cpi , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; <S2SV_EndBug> write_profile ( cm -> profile , wb ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_type ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> show_frame ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ; <S2SV_EndBug> if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> const COLOR_SPACE cs = UNKNOWN ; <S2SV_EndBug> write_sync_code ( wb ) ; <S2SV_StartBug> if ( cm -> profile > PROFILE_1 ) { <S2SV_EndBug> assert ( cm -> bit_depth > BITS_8 ) ; vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; } vp9_wb_write_literal ( wb , cs , 3 ) ; if ( cs != SRGB ) { vp9_wb_write_bit ( wb , 0 ) ; if ( cm -> profile >= PROFILE_1 ) { vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; vp9_wb_write_bit ( wb , 0 ) ; } } else { <S2SV_StartBug> assert ( cm -> profile == PROFILE_1 ) ; <S2SV_EndBug> vp9_wb_write_bit ( wb , 0 ) ; } write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vp9_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { write_sync_code ( wb ) ; vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; } else { MV_REFERENCE_FRAME ref_frame ; <S2SV_StartBug> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; <S2SV_EndBug> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , <S2SV_EndBug> REF_FRAMES_LOG2 ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; <S2SV_EndBug> } write_frame_size_with_refs ( cpi , wb ) ; <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; <S2SV_EndBug> <S2SV_StartBug> fix_interp_filter ( cm ) ; <S2SV_EndBug> write_interp_filter ( cm -> interp_filter , wb ) ; } } if ( ! cm -> error_resilient_mode ) { <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; <S2SV_EndBug> encode_loopfilter ( & cm -> lf , wb ) ; encode_quantization ( cm , wb ) ; <S2SV_StartBug> encode_segmentation ( cpi , wb ) ; <S2SV_EndBug> write_tile_info ( cm , wb ) ; }
","<S2SV_ModStart> cpi , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> wb ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> 0 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> frame_type ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> show_frame ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> KEY_FRAME ) { write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> write_sync_code ( wb <S2SV_ModStart> -> profile > PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { <S2SV_ModEnd> MV_REFERENCE_FRAME ref_frame ; <S2SV_ModStart> MV_REFERENCE_FRAME ref_frame ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ref_frame ) { assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> ( cpi , <S2SV_ModStart> REF_FRAMES_LOG2 ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> wb ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> fix_interp_filter ( cm , cpi -> td . counts <S2SV_ModStart> error_resilient_mode ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> refresh_frame_context ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb , <S2SV_ModStart> ) ; } vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> ; encode_segmentation ( cm , xd <S2SV_ModEnd> , wb )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = ""Tunnel<S2SV_blank>Encap"" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> case BGP_ATTR_VNC : attrname = ""VNC"" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( ""%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it"" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
",FRRouting@frr/943d595a018e69b550db08cccba1d0778a86705a,CVE-2019-5892,https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a,2019-01-10T17:29Z
CWE-400,"CWE-400 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-264,"CWE-264 static int validate_group ( struct perf_event * event ) { struct perf_event * sibling , * leader = event -> group_leader ; struct pmu_hw_events fake_pmu ; DECLARE_BITMAP ( fake_used_mask , ARMPMU_MAX_HWEVENTS ) ; memset ( fake_used_mask , 0 , sizeof ( fake_used_mask ) ) ; fake_pmu . used_mask = fake_used_mask ; <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , leader ) ) <S2SV_EndBug> return - EINVAL ; list_for_each_entry ( sibling , & leader -> sibling_list , group_entry ) { <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , sibling ) ) <S2SV_EndBug> return - EINVAL ; } <S2SV_StartBug> if ( ! validate_event ( & fake_pmu , event ) ) <S2SV_EndBug> return - EINVAL ; return 0 ; }
","<S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu ,
",torvalds@linux/8fff105e13041e49b82f92eef034f363a6b1c071,CVE-2015-8955,https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071,2016-10-10T10:59Z
CWE-732,"CWE-732 static M_bool M_fs_check_overwrite_allowed ( const char * p1 , const char * p2 , M_uint32 mode ) { M_fs_info_t * info = NULL ; char * pold = NULL ; char * pnew = NULL ; M_fs_type_t type ; M_bool ret = M_TRUE ; if ( mode & M_FS_FILE_MODE_OVERWRITE ) return M_TRUE ; if ( M_fs_info ( & info , p1 , M_FS_PATH_INFO_FLAGS_BASIC ) != M_FS_ERROR_SUCCESS ) return M_FALSE ; type = M_fs_info_get_type ( info ) ; M_fs_info_destroy ( info ) ; if ( type != M_FS_TYPE_DIR ) { if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } } pold = M_fs_path_basename ( p1 , M_FS_SYSTEM_AUTO ) ; pnew = M_fs_path_join ( p2 , pnew , M_FS_SYSTEM_AUTO ) ; if ( M_fs_perms_can_access ( pnew , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } done : M_free ( pnew ) ; M_free ( pold ) ; return ret ; }
","
",Monetra@mstdlib/db124b8f607dd0a40a9aef2d4d468fad433522a7,CVE-2018-14043,https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7,2018-07-13T14:29Z
CWE-134,"CWE-134 void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-autoscale-max"" , no_argument , 0 , 'M' } , { ""zoom"" , required_argument , 0 , 'm' } , { ""no-gridfit"" , no_argument , 0 , 'N' } , { ""font"" , required_argument , 0 , 'n' } , { ""logarithmic"" , no_argument , 0 , 'o' } , { ""pango-markup"" , no_argument , 0 , 'P' } , { ""font-render-mode"" , required_argument , 0 , 'R' } , { ""rigid"" , no_argument , 0 , 'r' } , { ""step"" , required_argument , 0 , 'S' } , { ""start"" , required_argument , 0 , 's' } , { ""tabwidth"" , required_argument , 0 , 'T' } , { ""title"" , required_argument , 0 , 't' } , { ""upper-limit"" , required_argument , 0 , 'u' } , { ""vertical-label"" , required_argument , 0 , 'v' } , { ""watermark"" , required_argument , 0 , 'W' } , { ""width"" , required_argument , 0 , 'w' } , { ""units-exponent"" , required_argument , 0 , 'X' } , { ""x-grid"" , required_argument , 0 , 'x' } , { ""alt-y-grid"" , no_argument , 0 , 'Y' } , { ""y-grid"" , required_argument , 0 , 'y' } , { ""lazy"" , no_argument , 0 , 'z' } , { ""units"" , required_argument , 0 , LONGOPT_UNITS_SI } , { ""alt-y-mrtg"" , no_argument , 0 , 1000 } , { ""disable-rrdtool-tag"" , no_argument , 0 , 1001 } , { ""right-axis"" , required_argument , 0 , 1002 } , { ""right-axis-label"" , required_argument , 0 , 1003 } , { ""right-axis-format"" , required_argument , 0 , 1004 } , { ""legend-position"" , required_argument , 0 , 1005 } , { ""legend-direction"" , required_argument , 0 , 1006 } , { ""border"" , required_argument , 0 , 1007 } , { ""grid-dash"" , required_argument , 0 , 1008 } , { ""dynamic-labels"" , no_argument , 0 , 1009 } , { ""left-axis-format"" , required_argument , 0 , 1010 } , { 0 , 0 , 0 , 0 } } ; optind = 0 ; opterr = 0 ; rrd_parsetime ( ""end-24h"" , & start_tv ) ; rrd_parsetime ( ""now"" , & end_tv ) ; while ( 1 ) { int option_index = 0 ; int opt ; int col_start , col_end ; opt = getopt_long ( argc , argv , ""Aa:B:b:c:Dd:Ee:Ff:G:gh:IiJjL:l:Mm:Nn:oPR:rS:s:T:t:u:v:W:w:X:x:Yy:z"" , long_options , & option_index ) ; if ( opt == EOF ) break ; switch ( opt ) { case 'I' : im -> extra_flags |= NOMINOR ; break ; case 'Y' : im -> extra_flags |= ALTYGRID ; break ; case 'A' : im -> extra_flags |= ALTAUTOSCALE ; break ; case 'J' : im -> extra_flags |= ALTAUTOSCALE_MIN ; break ; case 'M' : im -> extra_flags |= ALTAUTOSCALE_MAX ; break ; case 'j' : im -> extra_flags |= ONLY_GRAPH ; break ; case 'g' : im -> extra_flags |= NOLEGEND ; break ; case 1005 : if ( strcmp ( optarg , ""north"" ) == 0 ) { im -> legendposition = NORTH ; } else if ( strcmp ( optarg , ""west"" ) == 0 ) { im -> legendposition = WEST ; } else if ( strcmp ( optarg , ""south"" ) == 0 ) { im -> legendposition = SOUTH ; } else if ( strcmp ( optarg , ""east"" ) == 0 ) { im -> legendposition = EAST ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 1006 : if ( strcmp ( optarg , ""topdown"" ) == 0 ) { im -> legenddirection = TOP_DOWN ; } else if ( strcmp ( optarg , ""bottomup"" ) == 0 ) { im -> legenddirection = BOTTOM_UP ; } else { rrd_set_error ( ""unknown<S2SV_blank>legend-position<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'F' : im -> extra_flags |= FORCE_RULES_LEGEND ; break ; case 1001 : im -> extra_flags |= NO_RRDTOOL_TAG ; break ; case LONGOPT_UNITS_SI : if ( im -> extra_flags & FORCE_UNITS ) { rrd_set_error ( ""--units<S2SV_blank>can<S2SV_blank>only<S2SV_blank>be<S2SV_blank>used<S2SV_blank>once!"" ) ; return ; } if ( strcmp ( optarg , ""si"" ) == 0 ) im -> extra_flags |= FORCE_UNITS_SI ; else { rrd_set_error ( ""invalid<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>--units:<S2SV_blank>%s"" , optarg ) ; return ; } break ; case 'X' : im -> unitsexponent = atoi ( optarg ) ; break ; case 'L' : im -> unitslength = atoi ( optarg ) ; im -> forceleftspace = 1 ; break ; case 'T' : im -> tabwidth = atof ( optarg ) ; break ; case 'S' : im -> step = atoi ( optarg ) ; break ; case 'N' : im -> gridfit = 0 ; break ; case 'P' : im -> with_markup = 1 ; break ; case 's' : if ( ( parsetime_error = rrd_parsetime ( optarg , & start_tv ) ) ) { rrd_set_error ( ""start<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'e' : if ( ( parsetime_error = rrd_parsetime ( optarg , & end_tv ) ) ) { rrd_set_error ( ""end<S2SV_blank>time:<S2SV_blank>%s"" , parsetime_error ) ; return ; } break ; case 'x' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_x_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%10[A-Z]:%ld:%10[A-Z]:%ld:%10[A-Z]:%ld:%ld:%n"" , scan_gtm , & im -> xlab_user . gridst , scan_mtm , & im -> xlab_user . mgridst , scan_ltm , & im -> xlab_user . labst , & im -> xlab_user . precis , & stroff ) == 7 && stroff != 0 ) { strncpy ( im -> xlab_form , optarg + stroff , sizeof ( im -> xlab_form ) - 1 ) ; im -> xlab_form [ sizeof ( im -> xlab_form ) - 1 ] = '\\0' ; if ( ( int ) ( im -> xlab_user . gridtm = tmt_conv ( scan_gtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_gtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . mgridtm = tmt_conv ( scan_mtm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_mtm ) ; return ; } else if ( ( int ) ( im -> xlab_user . labtm = tmt_conv ( scan_ltm ) ) == - 1 ) { rrd_set_error ( ""unknown<S2SV_blank>keyword<S2SV_blank>%s"" , scan_ltm ) ; return ; } im -> xlab_user . minsec = 1 ; im -> xlab_user . stst = im -> xlab_form ; } else { rrd_set_error ( ""invalid<S2SV_blank>x-grid<S2SV_blank>format"" ) ; return ; } break ; case 'y' : if ( strcmp ( optarg , ""none"" ) == 0 ) { im -> draw_y_grid = 0 ; break ; } ; if ( sscanf ( optarg , ""%lf:%d"" , & im -> ygridstep , & im -> ylabfact ) == 2 ) { if ( im -> ygridstep <= 0 ) { rrd_set_error ( ""grid<S2SV_blank>step<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } else if ( im -> ylabfact < 1 ) { rrd_set_error ( ""label<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>y-grid<S2SV_blank>format"" ) ; return ; } break ; case 1007 : im -> draw_3d_border = atoi ( optarg ) ; break ; case 1008 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> grid_dash_on , & im -> grid_dash_off ) != 2 ) { rrd_set_error ( ""expected<S2SV_blank>grid-dash<S2SV_blank>format<S2SV_blank>float:float"" ) ; return ; } break ; case 1009 : im -> dynamic_labels = 1 ; break ; case 1002 : if ( sscanf ( optarg , ""%lf:%lf"" , & im -> second_axis_scale , & im -> second_axis_shift ) == 2 ) { if ( im -> second_axis_scale == 0 ) { rrd_set_error ( ""the<S2SV_blank>second_axis_scale<S2SV_blank><S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>0"" ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>right-axis<S2SV_blank>format<S2SV_blank>expected<S2SV_blank>scale:shift"" ) ; return ; } break ; case 1003 : strncpy ( im -> second_axis_legend , optarg , 150 ) ; im -> second_axis_legend [ 150 ] = '\\0' ; break ; case 1004 : <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> second_axis_format , optarg , 150 ) ; im -> second_axis_format [ 150 ] = '\\0' ; break ; case 1010 : <S2SV_StartBug> if ( bad_format ( optarg ) ) { <S2SV_EndBug> rrd_set_error ( ""use<S2SV_blank>either<S2SV_blank>%le<S2SV_blank>or<S2SV_blank>%lf<S2SV_blank>formats"" ) ; return ; } strncpy ( im -> primary_axis_format , optarg , 150 ) ; im -> primary_axis_format [ 150 ] = '\\0' ; break ; case 'v' : strncpy ( im -> ylegend , optarg , 150 ) ; im -> ylegend [ 150 ] = '\\0' ; break ; case 'u' : im -> maxval = atof ( optarg ) ; break ; case 'l' : im -> minval = atof ( optarg ) ; break ; case 'b' : im -> base = atol ( optarg ) ; if ( im -> base != 1024 && im -> base != 1000 ) { rrd_set_error ( ""the<S2SV_blank>only<S2SV_blank>sensible<S2SV_blank>value<S2SV_blank>for<S2SV_blank>base<S2SV_blank>apart<S2SV_blank>from<S2SV_blank>1000<S2SV_blank>is<S2SV_blank>1024"" ) ; return ; } break ; case 'w' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""width<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> xsize = long_tmp ; break ; case 'h' : long_tmp = atol ( optarg ) ; if ( long_tmp < 10 ) { rrd_set_error ( ""height<S2SV_blank>below<S2SV_blank>10<S2SV_blank>pixels"" ) ; return ; } im -> ysize = long_tmp ; break ; case 'D' : im -> extra_flags |= FULL_SIZE_MODE ; break ; case 'i' : break ; case 'r' : im -> rigid = 1 ; break ; case 'f' : im -> imginfo = optarg ; break ; case 'a' : if ( ( int ) ( im -> imgformat = if_conv ( optarg ) ) == - 1 ) { rrd_set_error ( ""unsupported<S2SV_blank>graphics<S2SV_blank>format<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'z' : im -> lazy = 1 ; break ; case 'E' : im -> slopemode = 1 ; break ; case 'o' : im -> logarithmic = 1 ; break ; case 'c' : if ( sscanf ( optarg , ""%10[A-Z]#%n%8lx%n"" , col_nam , & col_start , & color , & col_end ) == 2 ) { int ci ; int col_len = col_end - col_start ; switch ( col_len ) { case 3 : color = ( ( ( color & 0xF00 ) * 0x110000 ) | ( ( color & 0x0F0 ) * 0x011000 ) | ( ( color & 0x00F ) * 0x001100 ) | 0x000000FF ) ; break ; case 4 : color = ( ( ( color & 0xF000 ) * 0x11000 ) | ( ( color & 0x0F00 ) * 0x01100 ) | ( ( color & 0x00F0 ) * 0x00110 ) | ( ( color & 0x000F ) * 0x00011 ) ) ; break ; case 6 : color = ( color << 8 ) + 0xff ; break ; case 8 : break ; default : rrd_set_error ( ""the<S2SV_blank>color<S2SV_blank>format<S2SV_blank>is<S2SV_blank>#RRGGBB[AA]"" ) ; return ; } if ( ( ci = grc_conv ( col_nam ) ) != - 1 ) { im -> graph_col [ ci ] = gfx_hex_to_col ( color ) ; } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>name<S2SV_blank>\'%s\'"" , col_nam ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>color<S2SV_blank>def<S2SV_blank>format"" ) ; return ; } break ; case 'n' : { char prop [ 15 ] ; double size = 1 ; int end ; if ( sscanf ( optarg , ""%10[A-Z]:%lf%n"" , prop , & size , & end ) >= 2 ) { int sindex , propidx ; if ( ( sindex = text_prop_conv ( prop ) ) != - 1 ) { for ( propidx = sindex ; propidx < TEXT_PROP_LAST ; propidx ++ ) { if ( size > 0 ) { rrd_set_font_desc ( im , propidx , NULL , size ) ; } if ( ( int ) strlen ( optarg ) > end + 2 ) { if ( optarg [ end ] == ':' ) { rrd_set_font_desc ( im , propidx , optarg + end + 1 , 0 ) ; } else { rrd_set_error ( ""expected<S2SV_blank>:<S2SV_blank>after<S2SV_blank>font<S2SV_blank>size<S2SV_blank>in<S2SV_blank>\'%s\'"" , optarg ) ; return ; } } if ( propidx == sindex && sindex != 0 ) break ; } } else { rrd_set_error ( ""invalid<S2SV_blank>fonttag<S2SV_blank>\'%s\'"" , prop ) ; return ; } } else { rrd_set_error ( ""invalid<S2SV_blank>text<S2SV_blank>property<S2SV_blank>format"" ) ; return ; } break ; } case 'm' : im -> zoom = atof ( optarg ) ; if ( im -> zoom <= 0.0 ) { rrd_set_error ( ""zoom<S2SV_blank>factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0"" ) ; return ; } break ; case 't' : strncpy ( im -> title , optarg , 150 ) ; im -> title [ 150 ] = '\\0' ; break ; case 'R' : if ( strcmp ( optarg , ""normal"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else if ( strcmp ( optarg , ""light"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_GRAY ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_SLIGHT ) ; } else if ( strcmp ( optarg , ""mono"" ) == 0 ) { cairo_font_options_set_antialias ( im -> font_options , CAIRO_ANTIALIAS_NONE ) ; cairo_font_options_set_hint_style ( im -> font_options , CAIRO_HINT_STYLE_FULL ) ; } else { rrd_set_error ( ""unknown<S2SV_blank>font-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'G' : if ( strcmp ( optarg , ""normal"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_GRAY ; else if ( strcmp ( optarg , ""mono"" ) == 0 ) im -> graph_antialias = CAIRO_ANTIALIAS_NONE ; else { rrd_set_error ( ""unknown<S2SV_blank>graph-render-mode<S2SV_blank>\'%s\'"" , optarg ) ; return ; } break ; case 'B' : break ; case 'W' : strncpy ( im -> watermark , optarg , 100 ) ; im -> watermark [ 99 ] = '\\0' ; break ; case 'd' : { if ( im -> daemon_addr != NULL ) { rrd_set_error ( ""You<S2SV_blank>cannot<S2SV_blank>specify<S2SV_blank>--daemon<S2SV_blank>"" ""more<S2SV_blank>than<S2SV_blank>once."" ) ; return ; } im -> daemon_addr = strdup ( optarg ) ; if ( im -> daemon_addr == NULL ) { rrd_set_error ( ""strdup<S2SV_blank>failed"" ) ; return ; } break ; } case '?' : if ( optopt != 0 ) rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%c\'"" , optopt ) ; else rrd_set_error ( ""unknown<S2SV_blank>option<S2SV_blank>\'%s\'"" , argv [ optind - 1 ] ) ; return ; } } { int status = rrdc_connect ( im -> daemon_addr ) ; if ( status != 0 ) return ; } pango_cairo_context_set_font_options ( pango_layout_get_context ( im -> layout ) , im -> font_options ) ; pango_layout_context_changed ( im -> layout ) ; if ( im -> logarithmic && im -> minval <= 0 ) { rrd_set_error ( ""for<S2SV_blank>a<S2SV_blank>logarithmic<S2SV_blank>yaxis<S2SV_blank>you<S2SV_blank>must<S2SV_blank>specify<S2SV_blank>a<S2SV_blank>lower-limit<S2SV_blank>><S2SV_blank>0"" ) ; return ; } if ( rrd_proc_start_end ( & start_tv , & end_tv , & start_tmp , & end_tmp ) == - 1 ) { return ; } if ( start_tmp < 3600 * 24 * 365 * 10 ) { rrd_set_error ( ""the<S2SV_blank>first<S2SV_blank>entry<S2SV_blank>to<S2SV_blank>fetch<S2SV_blank>should<S2SV_blank>be<S2SV_blank>after<S2SV_blank>1980<S2SV_blank>(%ld)"" , start_tmp ) ; return ; } if ( end_tmp < start_tmp ) { rrd_set_error ( ""start<S2SV_blank>(%ld)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>end<S2SV_blank>(%ld)"" , start_tmp , end_tmp ) ; return ; } im -> start = start_tmp ; im -> end = end_tmp ; im -> step = max ( ( long ) im -> step , ( im -> end - im -> start ) / im -> xsize ) ; }
","<S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; }
",oetiker@rrdtool-1.x/85261a013112e278c90224033f5b0592ee387786,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/85261a013112e278c90224033f5b0592ee387786,2020-02-12T02:15Z
CWE-000,"CWE-000 int get_devices_from_authfile ( const char * authfile , const char * username , unsigned max_devs , int verbose , FILE * debug_file , device_t * devices , unsigned * n_devs ) { char * buf = NULL ; char * s_user , * s_token ; int retval = 0 ; int fd = - 1 ; struct stat st ; struct passwd * pw = NULL , pw_s ; char buffer [ BUFSIZE ] ; int gpu_ret ; FILE * opwfile = NULL ; unsigned i , j ; * n_devs = 0 ; <S2SV_StartBug> fd = open ( authfile , O_RDONLY , 0 ) ; <S2SV_EndBug> if ( fd < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; goto err ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; goto err ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , authfile ) ; goto err ; } if ( st . st_size == 0 ) { if ( verbose ) D ( debug_file , ""File<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>empty"" , authfile ) ; goto err ; } gpu_ret = getpwuid_r ( st . st_uid , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpu_ret != 0 || pw == NULL ) { D ( debug_file , ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>uid<S2SV_blank>%u,<S2SV_blank>(%s)"" , st . st_uid , strerror ( errno ) ) ; goto err ; } if ( strcmp ( pw -> pw_name , username ) != 0 && strcmp ( pw -> pw_name , ""root"" ) != 0 ) { if ( strcmp ( username , ""root"" ) != 0 ) { D ( debug_file , ""The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>%s<S2SV_blank>nor<S2SV_blank>root"" , username ) ; } else { D ( debug_file , ""The<S2SV_blank>owner<S2SV_blank>of<S2SV_blank>the<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>root"" ) ; } goto err ; } opwfile = fdopen ( fd , ""r"" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , ""fdopen:<S2SV_blank>%s"" , strerror ( errno ) ) ; <S2SV_StartBug> goto err ; <S2SV_EndBug> } buf = malloc ( sizeof ( char ) * ( DEVSIZE * max_devs ) ) ; if ( ! buf ) { if ( verbose ) D ( debug_file , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto err ; } retval = - 2 ; while ( fgets ( buf , ( int ) ( DEVSIZE * ( max_devs - 1 ) ) , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; s_user = strtok_r ( buf , "":"" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , ""Matched<S2SV_blank>user:<S2SV_blank>%s"" , s_user ) ; retval = - 1 ; for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; i = 0 ; while ( ( s_token = strtok_r ( NULL , "","" , & saveptr ) ) ) { devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; if ( ( * n_devs ) ++ > MAX_DEVS - 1 ) { * n_devs = MAX_DEVS ; if ( verbose ) D ( debug_file , ""Found<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d<S2SV_blank>devices,<S2SV_blank>ignoring<S2SV_blank>the<S2SV_blank>remaining<S2SV_blank>ones"" , MAX_DEVS ) ; break ; } if ( verbose ) D ( debug_file , ""KeyHandle<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s"" , i + 1 , s_token ) ; devices [ i ] . keyHandle = strdup ( s_token ) ; if ( ! devices [ i ] . keyHandle ) { if ( verbose ) D ( debug_file , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>keyHandle<S2SV_blank>number<S2SV_blank>%d"" , i ) ; goto err ; } s_token = strtok_r ( NULL , "":"" , & saveptr ) ; if ( ! s_token ) { if ( verbose ) D ( debug_file , ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d"" , i + 1 ) ; goto err ; } if ( verbose ) D ( debug_file , ""publicKey<S2SV_blank>for<S2SV_blank>device<S2SV_blank>number<S2SV_blank>%d:<S2SV_blank>%s"" , i + 1 , s_token ) ; if ( strlen ( s_token ) % 2 != 0 ) { if ( verbose ) D ( debug_file , ""Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>even"" , i + 1 ) ; goto err ; } devices [ i ] . key_len = strlen ( s_token ) / 2 ; if ( verbose ) D ( debug_file , ""Length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>%zu"" , i + 1 , devices [ i ] . key_len ) ; devices [ i ] . publicKey = malloc ( ( sizeof ( unsigned char ) * devices [ i ] . key_len ) ) ; if ( ! devices [ i ] . publicKey ) { if ( verbose ) D ( debug_file , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>publicKey<S2SV_blank>number<S2SV_blank>%d"" , i ) ; goto err ; } for ( j = 0 ; j < devices [ i ] . key_len ; j ++ ) { unsigned int x ; if ( sscanf ( & s_token [ 2 * j ] , ""%2x"" , & x ) != 1 ) { if ( verbose ) D ( debug_file , ""Invalid<S2SV_blank>hex<S2SV_blank>number<S2SV_blank>in<S2SV_blank>key"" ) ; goto err ; } devices [ i ] . publicKey [ j ] = ( unsigned char ) x ; } i ++ ; } } } if ( verbose ) D ( debug_file , ""Found<S2SV_blank>%d<S2SV_blank>device(s)<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , * n_devs , username ) ; retval = 1 ; goto out ; err : for ( i = 0 ; i < * n_devs ; i ++ ) { free ( devices [ i ] . keyHandle ) ; free ( devices [ i ] . publicKey ) ; devices [ i ] . keyHandle = NULL ; devices [ i ] . publicKey = NULL ; } * n_devs = 0 ; out : if ( buf ) { free ( buf ) ; buf = NULL ; } if ( opwfile ) fclose ( opwfile ) ; <S2SV_StartBug> else if ( fd >= 0 ) <S2SV_EndBug> close ( fd ) ; return retval ; }
","<S2SV_ModStart> authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; goto err ; } else { fd = - 1 <S2SV_ModStart> opwfile ) ; <S2SV_ModEnd> if ( fd <S2SV_ModStart> if ( fd != - 1 <S2SV_ModEnd> ) close (
",Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62,CVE-2019-12210,https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62,2019-06-04T21:29Z
CWE-264,"CWE-264 void hostap_setup_dev ( struct net_device * dev , local_info_t * local , int type ) { struct hostap_interface * iface ; iface = netdev_priv ( dev ) ; <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> if ( iface ) { iface -> wireless_data . spy_data = & iface -> spy_data ; dev -> wireless_data = & iface -> wireless_data ; } dev -> wireless_handlers = & hostap_iw_handler_def ; dev -> watchdog_timeo = TX_TIMEOUT ; switch ( type ) { case HOSTAP_INTERFACE_AP : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_mgmt_netdev_ops ; dev -> type = ARPHRD_IEEE80211 ; dev -> header_ops = & hostap_80211_ops ; break ; case HOSTAP_INTERFACE_MASTER : dev -> netdev_ops = & hostap_master_ops ; break ; default : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_netdev_ops ; } dev -> mtu = local -> mtu ; SET_ETHTOOL_OPS ( dev , & prism2_ethtool_ops ) ; }
","<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-352,"CWE-352 static void doPost ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; <S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> handle_run ( req , res ) ; else if ( ACTION ( STATUS ) ) print_status ( req , res , 1 ) ; else if ( ACTION ( STATUS2 ) ) print_status ( req , res , 2 ) ; else if ( ACTION ( SUMMARY ) ) print_summary ( req , res ) ; else if ( ACTION ( REPORT ) ) _printReport ( req , res ) ; else if ( ACTION ( DOACTION ) ) <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> else <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
CWE-190,"CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-362,"CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
","<S2SV_ModStart> dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> cd -> fd
",torvalds@linux/cfa39381173d5f969daf43582c95ad679189cbc9,CVE-2019-6974,https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9,2019-02-15T15:29Z
CWE-190,"CWE-190 PHPAPI PHP_FUNCTION ( fread ) { zval * arg1 ; long len ; php_stream * stream ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rl"" , & arg1 , & len ) == FAILURE ) { RETURN_FALSE ; } PHP_STREAM_TO_ZVAL ( stream , & arg1 ) ; if ( len <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0"" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( len + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( stream , Z_STRVAL_P ( return_value ) , len ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
","<S2SV_ModStart> RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d"" , INT_MAX ) ; RETURN_FALSE ; }
",php@php-src/abd159cce48f3e34f08e4751c568e09677d5ec9c,CVE-2016-5096,https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c,2016-08-07T10:59Z
CWE-119,"CWE-119 int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) { return 1 ; } WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; if ( ! ( n > 0 && n < buf_len ) ) { goto err ; } if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) { goto err ; } int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; if ( ! ( op -> len + n <= buf_len ) ) { goto beach ; } op -> len += n ; } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; if ( ! ( n > 0 && n + op -> len < buf_len ) ) { goto beach ; } op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) + 10 < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> int optxtlen = strlen ( op -> txt ) ; <S2SV_EndBug> snprintf ( op -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; <S2SV_EndBug> free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }
","<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , ""%d<S2SV_blank>"" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , ""%d"" ,
",radare@radare2/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7,CVE-2018-11378,https://github.com/radare/radare2/commit/bd276ef2fd8ac3401e65be7c126a43175ccfbcd7,2018-05-22T19:29Z
CWE-20,"CWE-20 static int ssl_scan_clienthello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; PACKET extensions ; * al = SSL_AD_DECODE_ERROR ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; s -> s3 -> alpn_selected_len = 0 ; OPENSSL_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = NULL ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif # ifndef OPENSSL_NO_EC if ( s -> options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG ) ssl_check_for_safari ( s , pkt ) ; # endif OPENSSL_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = NULL ; <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> # ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = NULL ; # endif s -> srtp_profile = NULL ; if ( PACKET_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! PACKET_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( PACKET_get_net_2 ( & extensions , & type ) ) { PACKET extension ; if ( ! PACKET_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { unsigned int servname_type ; PACKET sni , hostname ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( PACKET_contains_zero_byte ( & hostname ) ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) { PACKET srp_I ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ; if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ; if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { PACKET ec_point_format_list ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } else if ( type == TLSEXT_TYPE_elliptic_curves ) { PACKET elliptic_curve_list ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } else if ( type == TLSEXT_TYPE_signature_algorithms ) { PACKET supported_sig_algs ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == TLSEXT_TYPE_status_request ) { if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) { const unsigned char * ext_data ; PACKET responder_id_list , exts ; if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } while ( PACKET_remaining ( & responder_id_list ) > 0 ) { OCSP_RESPID * id ; PACKET responder_id ; const unsigned char * id_data ; if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = PACKET_data ( & responder_id ) ; id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ; if ( id == NULL ) return 0 ; if ( id_data != PACKET_end ( & responder_id ) ) { OCSP_RESPID_free ( id ) ; return 0 ; } if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) { OCSP_RESPID_free ( id ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( PACKET_remaining ( & exts ) > 0 ) { ext_data = PACKET_data ( & exts ) ; sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ; s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } return 1 ; }
","<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z
CWE-416,"CWE-416 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; image2 = ( Image * ) NULL ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image = ReadMATImageV4 ( image_info , image , exception ) ; if ( image == NULL ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; return ( ( Image * ) NULL ) ; } goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; <S2SV_StartBug> while ( ! EOFBlob ( image ) ) <S2SV_EndBug> { Frames = 1 ; <S2SV_StartBug> if ( filepos != ( unsigned int ) filepos ) <S2SV_EndBug> break ; if ( SeekBlob ( image , filepos , SEEK_SET ) != filepos ) break ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; <S2SV_StartBug> if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) <S2SV_EndBug> goto MATLAB_KO ; filepos += ( MagickOffsetType ) MATLAB_HDR . ObjectSize + 4 + 4 ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; clone_info = CloneImageInfo ( image_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( image2 != image ) DeleteImageFromList ( & image2 ) ; # endif continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( AcquireMagickResource ( ListLengthResource , Frames ) == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , ""ListLengthExceedsLimit"" ) ; } break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) { if ( ( image2 != ( Image * ) NULL ) && ( image2 != image ) ) { CloseBlob ( image2 ) ; DeleteImageFromList ( & image2 ) ; } if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ( ( size_t ) size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; if ( ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) != 4 ) goto MATLAB_KO ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; } if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; image -> colors = GetQuantumRange ( image -> depth ) ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned int ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } ( void ) SetImageBackgroundColor ( image , exception ) ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) { if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } ( void ) memset ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , <S2SV_StartBug> ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; <S2SV_EndBug> goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( i != ( long ) MATLAB_HDR . SizeY ) goto END_OF_READING ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) break ; AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; if ( ! EOFBlob ( image ) && TellBlob ( image ) < filepos ) goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } END_OF_READING : RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == ( Image * ) NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) return ( image ) ; }
","<S2SV_ModStart> ; while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> if ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break ; <S2SV_ModStart> + filepos ) >= <S2SV_ModEnd> GetBlobSize ( image <S2SV_ModStart> - 1 ) ) ; ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile""
",ImageMagick@ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0,CVE-2019-15140,https://github.com/ImageMagick/ImageMagick/commit/f7206618d27c2e69d977abf40e3035a33e5f6be0,2019-08-18T19:15Z
CWE-20,"CWE-20 error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> p = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""<S2SV_blank>?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { <S2SV_StartBug> q = strchr ( p + 1 , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
","<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-787,"CWE-787 <S2SV_StartBug> static UINT32 nsc_rle_encode ( BYTE * in , BYTE * out , UINT32 originalSize ) <S2SV_EndBug> { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
","<S2SV_ModStart> UINT32 nsc_rle_encode ( const
",FreeRDP@FreeRDP/d1112c279bd1a327e8e4d0b5f371458bf2579659,CVE-2018-8788,https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659,2018-11-29T18:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void vp8_init_ctx ( vpx_codec_ctx_t * ctx , const vpx_codec_mmap_t * mmap ) <S2SV_EndBug> { int i ; <S2SV_StartBug> ctx -> priv = mmap -> base ; <S2SV_EndBug> ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = mmap -> base ; for ( i = 0 ; i < NELEMENTS ( ctx -> priv -> alg_priv -> mmaps ) ; i ++ ) ctx -> priv -> alg_priv -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> priv -> alg_priv -> mmaps [ 0 ] = * mmap ; ctx -> priv -> alg_priv -> si . sz = sizeof ( ctx -> priv -> alg_priv -> si ) ; ctx -> priv -> alg_priv -> decrypt_cb = NULL ; ctx -> priv -> alg_priv -> decrypt_state = NULL ; ctx -> priv -> init_flags = ctx -> init_flags ; <S2SV_StartBug> if ( ctx -> config . dec ) <S2SV_EndBug> { <S2SV_StartBug> ctx -> priv -> alg_priv -> cfg = * ctx -> config . dec ; <S2SV_EndBug> <S2SV_StartBug> ctx -> config . dec = & ctx -> priv -> alg_priv -> cfg ; <S2SV_EndBug> } }
","<S2SV_ModStart> vpx_codec_ctx_t * ctx ) { vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> -> priv = ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> ; ctx -> <S2SV_ModStart> -> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> decrypt_cb = NULL ; priv -> decrypt_state = NULL ; <S2SV_ModStart> dec ) { priv <S2SV_ModEnd> -> cfg = <S2SV_ModStart> dec = & priv <S2SV_ModEnd> -> cfg ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 static int readSeparateStripsIntoBuffer ( TIFF * in , uint8 * obuf , uint32 length , uint32 width , uint16 spp , struct dump_opts * dump ) { <S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> int32 bytes_read = 0 ; <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> uint32 src_rowsize , dst_rowsize , rows_processed , rps ; uint32 rows_this_strip = 0 ; tsample_t s ; tstrip_t strip ; tsize_t scanlinesize = TIFFScanlineSize ( in ) ; tsize_t stripsize = TIFFStripSize ( in ) ; unsigned char * srcbuffs [ MAX_SAMPLES ] ; unsigned char * buff = NULL ; unsigned char * dst = NULL ; if ( obuf == NULL ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Invalid<S2SV_blank>buffer<S2SV_blank>argument"" ) ; return ( 0 ) ; } memset ( srcbuffs , '\\0' , sizeof ( srcbuffs ) ) ; TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; if ( rps > length ) rps = length ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; src_rowsize = ( ( bps * width ) + 7 ) / 8 ; dst_rowsize = ( ( bps * width * spp ) + 7 ) / 8 ; dst = obuf ; if ( ( dump -> infile != NULL ) && ( dump -> level == 3 ) ) { dump_info ( dump -> infile , dump -> format , """" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Scanline<S2SV_blank>size,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , scanlinesize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d,<S2SV_blank>Shift<S2SV_blank>width<S2SV_blank>%d"" , bps , spp , shift_width ) ; } nstrips = TIFFNumberOfStrips ( in ) ; strips_per_sample = nstrips / spp ; for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { srcbuffs [ s ] = NULL ; buff = _TIFFmalloc ( stripsize ) ; if ( ! buff ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>strip<S2SV_blank>read<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , s ) ; for ( i = 0 ; i < s ; i ++ ) _TIFFfree ( srcbuffs [ i ] ) ; return 0 ; } srcbuffs [ s ] = buff ; } rows_processed = 0 ; for ( j = 0 ; ( j < strips_per_sample ) && ( result == 1 ) ; j ++ ) { for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; strip = ( s * strips_per_sample ) + j ; bytes_read = TIFFReadEncodedStrip ( in , strip , buff , stripsize ) ; rows_this_strip = bytes_read / src_rowsize ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , ( unsigned long ) strip , s + 1 ) ; result = 0 ; break ; } # ifdef DEVELMODE TIFFError ( """" , ""Strip<S2SV_blank>%2d,<S2SV_blank>read<S2SV_blank>%5d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>%4d<S2SV_blank>scanlines,<S2SV_blank>shift<S2SV_blank>width<S2SV_blank>%d"" , strip , bytes_read , rows_this_strip , shift_width ) ; # endif } if ( rps > rows_this_strip ) rps = rows_this_strip ; dst = obuf + ( dst_rowsize * rows_processed ) ; if ( ( bps % 8 ) == 0 ) { if ( combineSeparateSamplesBytes ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } } else { switch ( shift_width ) { case 1 : if ( combineSeparateSamples8bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 2 : if ( combineSeparateSamples16bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 3 : if ( combineSeparateSamples24bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 4 : case 5 : case 6 : case 7 : case 8 : if ( combineSeparateSamples32bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; default : TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth:<S2SV_blank>%d"" , bps ) ; result = 0 ; break ; } } if ( ( rows_processed + rps ) > length ) { rows_processed = length ; rps = length - rows_processed ; } else rows_processed += rps ; } for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; if ( buff != NULL ) _TIFFfree ( buff ) ; } return ( result ) ; }
","<S2SV_ModStart> int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 bytes_read <S2SV_ModStart> uint16 bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ; uint32
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z
CWE-125,"CWE-125 static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , ch -> n_end_lineno , ch -> n_end_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }
","<S2SV_ModStart> ; if ( i < NCH ( n ) &&
",python@typed_ast/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,CVE-2019-19275,https://github.com/python/typed_ast/commit/a4d78362397fc3bced6ea80fbc7b5f4827aec55e,2019-11-26T15:15Z
CWE-16,"CWE-16 <S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> char buf [ 65 ] ; if ( current -> personality & UNAME26 ) { <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> int ndots = 0 ; <S2SV_StartBug> unsigned v ; <S2SV_EndBug> while ( * rest ) { if ( * rest == '.' && ++ ndots >= 3 ) break ; if ( ! isdigit ( * rest ) && * rest != '.' ) break ; rest ++ ; } v = ( ( LINUX_VERSION_CODE >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> snprintf ( buf , len , ""2.6.%u%s"" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> } return ret ; }
","<S2SV_ModStart> * release , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> UNAME26 ) { const <S2SV_ModStart> rest = UTS_RELEASE ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned v ; size_t copy <S2SV_ModStart> + 40 ; copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , copy <S2SV_ModEnd> , ""2.6.%u%s"" , <S2SV_ModStart> , buf , copy + 1 <S2SV_ModEnd> ) ; }
",torvalds@linux/2702b1526c7278c4d65d78de209a465d4de2885e,CVE-2012-0957,https://github.com/torvalds/linux/commit/2702b1526c7278c4d65d78de209a465d4de2885e,2012-12-21T11:47Z
CWE-264,"CWE-264 static void * arm_coherent_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <S2SV_StartBug> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <S2SV_EndBug> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , true , __builtin_return_address ( 0 ) ) ; }
","<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
",torvalds@linux/0ea1ec713f04bdfac343c9702b21cd3a7c711826,CVE-2014-9888,https://github.com/torvalds/linux/commit/0ea1ec713f04bdfac343c9702b21cd3a7c711826,2016-08-06T10:59Z
CWE-200,"CWE-200 static int get_linux_shareopts ( const char * shareopts , char * * plinux_opts ) { int rc ; assert ( plinux_opts != NULL ) ; * plinux_opts = NULL ; ( void ) add_linux_shareopt ( plinux_opts , ""no_subtree_check"" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , ""no_root_squash"" , NULL ) ; ( void ) add_linux_shareopt ( plinux_opts , ""mountpoint"" , NULL ) ; <S2SV_StartBug> rc = foreach_nfs_shareopt ( shareopts , get_linux_shareopts_cb , <S2SV_EndBug> plinux_opts ) ; if ( rc != SA_OK ) { free ( * plinux_opts ) ; * plinux_opts = NULL ; } return ( rc ) ; }
","<S2SV_ModStart> ; rc = foreach_shareopt <S2SV_ModEnd> ( shareopts ,
",FransUrbo@zfs/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4,CVE-2015-3400,https://github.com/FransUrbo/zfs/commit/99aa4d2b4fd12c6bef62d02ffd1b375ddd42fcf4,2017-10-18T15:29Z
CWE-119,"CWE-119 static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ; <S2SV_StartBug> vpx_memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; <S2SV_StartBug> vpx_memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } if ( pbi -> decoded_key_frame && pbi -> ec_enabled && ! pbi -> ec_active ) pbi -> ec_active = 1 ; } xd -> left_context = & pc -> left_context ; xd -> mode_info_context = pc -> mi ; xd -> frame_type = pc -> frame_type ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_stride = pc -> mode_info_stride ; xd -> corrupted = 0 ; xd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; }
","<S2SV_ModStart> KEY_FRAME ) { memcpy <S2SV_ModEnd> ( pc -> <S2SV_ModStart> pc ) ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = SEGMENT_DELTADATA ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; <S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n"" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }
","<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets"" ) ; return AVERROR_PATCHWELCOME ; }
",FFmpeg@FFmpeg/780669ef7c23c00836a24921fcc6b03be2b8ca4a,CVE-2013-7012,https://github.com/FFmpeg/FFmpeg/commit/780669ef7c23c00836a24921fcc6b03be2b8ca4a,2013-12-09T16:36Z
CWE-20,"CWE-20 error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ; <S2SV_StartBug> uint16_t n ; <S2SV_EndBug> uint32_t status ; <S2SV_StartBug> Enc624j600Context * context ; <S2SV_EndBug> context = ( Enc624j600Context * ) interface -> nicContext ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_PKTCNT ) <S2SV_EndBug> { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXRDPT , context -> nextPacket ) ; <S2SV_EndBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , <S2SV_StartBug> ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <S2SV_EndBug> context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & status , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; <S2SV_StartBug> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , n ) ; <S2SV_EndBug> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; <S2SV_EndBug> } else { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ERXTAIL , context -> nextPacket - 2 ) ; <S2SV_EndBug> } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_PKTDEC ) ; <S2SV_EndBug> } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; <S2SV_StartBug> nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; <S2SV_EndBug> } return error ; }
","<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint32_t status <S2SV_ModStart> uint32_t status ; uint8_t header [ 8 ] ; <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> ) { enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_ERXRDPT <S2SV_ModEnd> , context -> <S2SV_ModStart> , ENC624J600_CMD_RRXDATA , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> ENC624J600_RX_BUFFER_STOP ) ; <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> context -> nextPacket <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-476,"CWE-476 GF_Err HintFile ( GF_ISOFile * file , u32 MTUSize , u32 max_ptime , u32 rtp_rate , u32 base_flags , Bool copy_data , Bool interleave , Bool regular_iod , Bool single_group , Bool hint_no_offset ) { GF_ESD * esd ; GF_InitialObjectDescriptor * iod ; u32 i , val , res , streamType ; u32 sl_mode , prev_ocr , single_ocr , nb_done , tot_bw , bw , flags , spec_type ; GF_Err e ; char szPayload [ 30 ] ; GF_RTPHinter * hinter ; Bool copy , has_iod , single_av ; u8 init_payt = BASE_PAYT ; u32 mtype ; GF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE ; u32 media_group = 0 ; u8 media_prio = 0 ; tot_bw = 0 ; prev_ocr = 0 ; single_ocr = 1 ; has_iod = 1 ; iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) has_iod = 0 ; else { if ( ! gf_list_count ( iod -> ESDescriptors ) ) has_iod = 0 ; gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } spec_type = gf_isom_guess_specification ( file ) ; single_av = single_group ? 1 : gf_isom_is_single_av ( file ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { res = gf_isom_get_media_type ( file , i + 1 ) ; if ( ( res == GF_ISOM_MEDIA_SCENE ) || ( res == GF_ISOM_MEDIA_OD ) ) { if ( gf_isom_is_track_in_root_od ( file , i + 1 ) ) { gf_isom_set_default_sync_track ( file , i + 1 ) ; break ; } } } nb_done = 0 ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { sl_mode = base_flags ; copy = copy_data ; if ( ! gf_isom_get_sample_count ( file , i + 1 ) ) continue ; if ( ! gf_isom_is_track_enabled ( file , i + 1 ) ) { M4_LOG ( GF_LOG_INFO , ( ""Track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>disabled<S2SV_blank>-<S2SV_blank>skipping<S2SV_blank>hint\\n"" , gf_isom_get_track_id ( file , i + 1 ) ) ) ; continue ; } mtype = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mtype ) { case GF_ISOM_MEDIA_VISUAL : if ( single_av ) { media_group = 2 ; media_prio = 2 ; } break ; case GF_ISOM_MEDIA_AUXV : if ( single_av ) { media_group = 2 ; media_prio = 3 ; } break ; case GF_ISOM_MEDIA_PICT : if ( single_av ) { media_group = 2 ; media_prio = 4 ; } break ; case GF_ISOM_MEDIA_AUDIO : if ( single_av ) { media_group = 2 ; media_prio = 1 ; } break ; case GF_ISOM_MEDIA_HINT : continue ; default : if ( spec_type == GF_ISOM_BRAND_ISMA ) continue ; } mtype = gf_isom_get_media_subtype ( file , i + 1 , 1 ) ; if ( ( mtype == GF_ISOM_SUBTYPE_MPEG4 ) || ( mtype == GF_ISOM_SUBTYPE_MPEG4_CRYP ) ) mtype = gf_isom_get_mpeg4_subtype ( file , i + 1 , 1 ) ; if ( ! single_av ) { media_group ++ ; media_prio = 1 ; } streamType = 0 ; esd = gf_isom_get_esd ( file , i + 1 , 1 ) ; <S2SV_StartBug> if ( esd ) { <S2SV_EndBug> streamType = esd -> decoderConfig -> streamType ; if ( ! prev_ocr ) { prev_ocr = esd -> OCRESID ; if ( ! esd -> OCRESID ) prev_ocr = esd -> ESID ; } else if ( esd -> OCRESID && prev_ocr != esd -> OCRESID ) { single_ocr = 0 ; } if ( streamType == 1 ) copy = 1 ; } gf_odf_desc_del ( ( GF_Descriptor * ) esd ) ; if ( ! regular_iod && gf_isom_is_track_in_root_od ( file , i + 1 ) ) { if ( gf_isom_get_sample_count ( file , i + 1 ) == 1 ) { GF_ISOSample * samp = gf_isom_get_sample ( file , i + 1 , 1 , & val ) ; if ( streamType ) { res = gf_hinter_can_embbed_data ( samp -> data , samp -> dataLength , streamType ) ; } else { res = 0 ; } if ( samp ) gf_isom_sample_del ( & samp ) ; if ( res ) continue ; } } if ( interleave ) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING ; hinter = gf_hinter_track_new ( file , i + 1 , MTUSize , max_ptime , rtp_rate , sl_mode , init_payt , copy , media_group , media_prio , & e ) ; if ( ! hinter ) { if ( e ) { M4_LOG ( nb_done ? GF_LOG_WARNING : GF_LOG_ERROR , ( ""Cannot<S2SV_blank>create<S2SV_blank>hinter<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ) ; if ( ! nb_done ) return e ; } continue ; } if ( hint_no_offset ) gf_hinter_track_force_no_offsets ( hinter ) ; bw = gf_hinter_track_get_bandwidth ( hinter ) ; tot_bw += bw ; flags = gf_hinter_track_get_flags ( hinter ) ; gf_isom_set_nalu_extract_mode ( file , i + 1 , GF_ISOM_NALU_EXTRACT_LAYER_ONLY ) ; gf_hinter_track_get_payload_name ( hinter , szPayload ) ; M4_LOG ( GF_LOG_INFO , ( ""Hinting<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>-<S2SV_blank>Type<S2SV_blank>\\""%s:%s\\""<S2SV_blank>(%s)<S2SV_blank>-<S2SV_blank>BW<S2SV_blank>%d<S2SV_blank>kbps\\n"" , gf_isom_get_track_id ( file , i + 1 ) , gf_4cc_to_str ( mtype ) , gf_4cc_to_str ( mtype ) , szPayload , bw ) ) ; if ( flags & GP_RTP_PCK_SYSTEMS_CAROUSEL ) M4_LOG ( GF_LOG_INFO , ( ""\\tMPEG-4<S2SV_blank>Systems<S2SV_blank>stream<S2SV_blank>carousel<S2SV_blank>enabled\\n"" ) ) ; e = gf_hinter_track_process ( hinter ) ; if ( ! e ) e = gf_hinter_track_finalize ( hinter , has_iod ) ; gf_hinter_track_del ( hinter ) ; if ( e ) { M4_LOG ( GF_LOG_ERROR , ( ""Error<S2SV_blank>while<S2SV_blank>hinting<S2SV_blank>(%s)\\n"" , gf_error_to_string ( e ) ) ) ; if ( ! nb_done ) return e ; } init_payt ++ ; nb_done ++ ; } if ( has_iod ) { iod_mode = GF_SDP_IOD_ISMA ; if ( regular_iod ) iod_mode = GF_SDP_IOD_REGULAR ; } else { iod_mode = GF_SDP_IOD_NONE ; } gf_hinter_finalize ( file , iod_mode , tot_bw ) ; if ( ! single_ocr ) M4_LOG ( GF_LOG_WARNING , ( ""Warning:<S2SV_blank>at<S2SV_blank>least<S2SV_blank>2<S2SV_blank>timelines<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file\\nThis<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>servers/players\\n\\n"" ) ) ; return GF_OK ; }
","<S2SV_ModStart> if ( esd && esd -> decoderConfig
",gpac@gpac/87afe070cd6866df7fe80f11b26ef75161de85e0,CVE-2021-31257,https://github.com/gpac/gpac/commit/87afe070cd6866df7fe80f11b26ef75161de85e0,2021-04-19T19:15Z
CWE-362,"CWE-362 static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;
",torvalds@linux/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,CVE-2020-27675,https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2,2020-10-22T21:15Z
CWE-22,"CWE-22 static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Marking<S2SV_blank>messages<S2SV_blank>deleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE<S2SV_blank>%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { <S2SV_StartBug> mutt_bcache_del ( pop_data -> bcache , ctx -> hdrs [ i ] -> data ) ; <S2SV_EndBug> # ifdef USE_HCACHE mutt_hcache_delete ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE_HCACHE mutt_hcache_close ( hc ) ; # endif if ( ret == 0 ) { mutt_str_strfcpy ( buf , ""QUIT\\r\\n"" , sizeof ( buf ) ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; } if ( ret == 0 ) { pop_data -> clear_cache = true ; pop_clear_cache ( pop_data ) ; pop_data -> status = POP_DISCONNECTED ; return 0 ; } if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } } }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-287,"CWE-287 int oidc_oauth_check_userid ( request_rec * r , oidc_cfg * c ) { if ( ! ap_is_initial_req ( r ) ) { if ( r -> main != NULL ) r -> user = r -> main -> user ; else if ( r -> prev != NULL ) r -> user = r -> prev -> user ; if ( r -> user != NULL ) { oidc_debug ( r , ""recycling<S2SV_blank>user<S2SV_blank>\'%s\'<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>request<S2SV_blank>for<S2SV_blank>sub-request"" , r -> user ) ; return OK ; } } else if ( ( c -> redirect_uri != NULL ) && ( oidc_util_request_matches_url ( r , c -> redirect_uri ) ) ) { if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } } const char * access_token = NULL ; if ( oidc_oauth_get_bearer_token ( r , & access_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_request"" , ""No<S2SV_blank>bearer<S2SV_blank>token<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>request"" ) ; json_t * token = NULL ; char * s_token = NULL ; if ( c -> oauth . introspection_endpoint_url != NULL ) { if ( oidc_oauth_resolve_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Reference<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>introspected"" ) ; } else { if ( oidc_oauth_validate_jwt_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""JWT<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>validated"" ) ; } if ( token == NULL ) { oidc_error ( r , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>claims<S2SV_blank>(token<S2SV_blank>==<S2SV_blank>NULL)"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""No<S2SV_blank>claims<S2SV_blank>could<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>from<S2SV_blank>the<S2SV_blank>token"" ) ; } oidc_request_state_set ( r , OIDC_CLAIMS_SESSION_KEY , ( const char * ) s_token ) ; if ( oidc_oauth_set_remote_user ( r , c , token ) == FALSE ) { oidc_error ( r , ""remote<S2SV_blank>user<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set,<S2SV_blank>aborting<S2SV_blank>with<S2SV_blank>HTTP_UNAUTHORIZED"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user"" ) ; } <S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ; int pass_envvars = oidc_cfg_dir_pass_info_in_envvars ( r ) ; if ( ( r -> user != NULL ) && ( authn_header != NULL ) ) { oidc_debug ( r , ""setting<S2SV_blank>authn<S2SV_blank>header<S2SV_blank>(%s)<S2SV_blank>to:<S2SV_blank>%s"" , authn_header , r -> user ) ; apr_table_set ( r -> headers_in , authn_header , r -> user ) ; } oidc_util_set_app_infos ( r , token , c -> claim_prefix , c -> claim_delimiter , pass_headers , pass_envvars ) ; if ( access_token != NULL ) { oidc_util_set_app_info ( r , ""access_token"" , access_token , OIDC_DEFAULT_HEADER_PREFIX , pass_headers , pass_envvars ) ; } json_decref ( token ) ; return OK ; }
","<S2SV_ModStart> ) ; } oidc_scrub_headers ( r ) ;
",pingidentity@mod_auth_openidc/21e3728a825c41ab41efa75e664108051bb9665e,CVE-2017-6413,https://github.com/pingidentity/mod_auth_openidc/commit/21e3728a825c41ab41efa75e664108051bb9665e,2017-03-02T06:59Z
CWE-264,"CWE-264 static bool caller_is_in_ancestor ( pid_t pid , const char * contrl , const char * cg , char * * nextcg ) { <S2SV_StartBug> char fnam [ PROCLEN ] ; <S2SV_EndBug> FILE * f ; bool answer = false ; <S2SV_StartBug> char * line = NULL ; <S2SV_EndBug> size_t len = 0 ; int ret ; ret = snprintf ( fnam , PROCLEN , ""/proc/%d/cgroup"" , pid ) ; if ( ret < 0 || ret >= PROCLEN ) return false ; if ( ! ( f = fopen ( fnam , ""r"" ) ) ) return false ; while ( getline ( & line , & len , f ) != - 1 ) { char * c1 , * c2 , * linecmp ; if ( ! line [ 0 ] ) continue ; c1 = strchr ( line , ':' ) ; if ( ! c1 ) goto out ; c1 ++ ; c2 = strchr ( c1 , ':' ) ; if ( ! c2 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> * c2 = '\\0' ; if ( strcmp ( c1 , contrl ) != 0 ) continue ; c2 ++ ; stripnewline ( c2 ) ; prune_init_slice ( c2 ) ; linecmp = * cg == '/' ? c2 : c2 + 1 ; if ( strncmp ( linecmp , cg , strlen ( linecmp ) ) != 0 ) { <S2SV_StartBug> if ( nextcg ) <S2SV_EndBug> * nextcg = get_next_cgroup_dir ( linecmp , cg ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } answer = true ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } out : fclose ( f ) ; free ( line ) ; return answer ; }
","<S2SV_ModStart> nextcg ) { <S2SV_ModEnd> bool answer = <S2SV_ModStart> ; char * c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! c2 ) return false <S2SV_ModEnd> ; prune_init_slice ( <S2SV_ModStart> ( nextcg ) { <S2SV_ModStart> cg ) ; } <S2SV_ModStart> = true ; out : free ( c2 <S2SV_ModEnd> ) ; return
",lxc@lxcfs/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,CVE-2015-1342,https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7,2015-12-07T20:59Z
CWE-119,"CWE-119 static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , ""Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , ""Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; <S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d"" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated"" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , ""Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object"" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d"" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , ""Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing"" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }
","<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-284,"CWE-284 static void _prolog_error ( batch_job_launch_msg_t * req , int rc ) { char * err_name_ptr , err_name [ 256 ] , path_name [ MAXPATHLEN ] ; char * fmt_char ; int fd ; if ( req -> std_err || req -> std_out ) { if ( req -> std_err ) strncpy ( err_name , req -> std_err , sizeof ( err_name ) ) ; else strncpy ( err_name , req -> std_out , sizeof ( err_name ) ) ; if ( ( fmt_char = strchr ( err_name , ( int ) '%' ) ) && ( fmt_char [ 1 ] == 'j' ) && ! strchr ( fmt_char + 1 , ( int ) '%' ) ) { char tmp_name [ 256 ] ; fmt_char [ 1 ] = 'u' ; snprintf ( tmp_name , sizeof ( tmp_name ) , err_name , req -> job_id ) ; strncpy ( err_name , tmp_name , sizeof ( err_name ) ) ; } } else { snprintf ( err_name , sizeof ( err_name ) , ""slurm-%u.out"" , req -> job_id ) ; } err_name_ptr = err_name ; if ( err_name_ptr [ 0 ] == '/' ) snprintf ( path_name , MAXPATHLEN , ""%s"" , err_name_ptr ) ; else if ( req -> work_dir ) snprintf ( path_name , MAXPATHLEN , ""%s/%s"" , req -> work_dir , err_name_ptr ) ; else snprintf ( path_name , MAXPATHLEN , ""/%s"" , err_name_ptr ) ; <S2SV_StartBug> if ( ( fd = open ( path_name , ( O_CREAT | O_APPEND | O_WRONLY ) , 0644 ) ) == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>%s"" , path_name , <S2SV_EndBug> slurm_strerror ( errno ) ) ; return ; } snprintf ( err_name , sizeof ( err_name ) , ""Error<S2SV_blank>running<S2SV_blank>slurm<S2SV_blank>prolog:<S2SV_blank>%d\\n"" , WEXITSTATUS ( rc ) ) ; safe_write ( fd , err_name , strlen ( err_name ) ) ; if ( fchown ( fd , ( uid_t ) req -> uid , ( gid_t ) req -> gid ) == - 1 ) { snprintf ( err_name , sizeof ( err_name ) , ""Couldn\'t<S2SV_blank>change<S2SV_blank>fd<S2SV_blank>owner<S2SV_blank>to<S2SV_blank>%u:%u:<S2SV_blank>%m\\n"" , req -> uid , req -> gid ) ; } rwfail : close ( fd ) ; }
","<S2SV_ModStart> ( fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) == <S2SV_ModStart> { error ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied"" , path_name <S2SV_ModEnd> ) ; return
",SchedMD@slurm/92362a92fffe60187df61f99ab11c249d44120ee,CVE-2016-10030,https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee,2017-01-05T11:59Z
CWE-119,"CWE-119 TEE_Result syscall_asymm_verify ( unsigned long state , const struct utee_attribute * usr_params , size_t num_params , const void * data , size_t data_len , const void * sig , size_t sig_len ) { TEE_Result res ; struct tee_cryp_state * cs ; struct tee_ta_session * sess ; struct tee_obj * o ; size_t hash_size ; int salt_len = 0 ; TEE_Attribute * params = NULL ; uint32_t hash_algo ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; if ( cs -> mode != TEE_MODE_VERIFY ) return TEE_ERROR_BAD_PARAMETERS ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) data , data_len ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) sig , sig_len ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * num_params ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , num_params , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & o ) ; if ( res != TEE_SUCCESS ) goto out ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) == 0 ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) ) { case TEE_MAIN_ALGO_RSA : if ( cs -> algo != TEE_ALG_RSASSA_PKCS1_V1_5 ) { hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len != hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } salt_len = pkcs1_get_salt_len ( params , num_params , hash_size ) ; } res = crypto_acipher_rsassa_verify ( cs -> algo , o -> attr , salt_len , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_DSA : hash_algo = TEE_DIGEST_HASH_TO_ALGO ( cs -> algo ) ; res = tee_hash_get_digest_size ( hash_algo , & hash_size ) ; if ( res != TEE_SUCCESS ) break ; if ( data_len > hash_size ) { res = TEE_ERROR_BAD_PARAMETERS ; break ; } res = crypto_acipher_dsa_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; case TEE_MAIN_ALGO_ECDSA : res = crypto_acipher_ecc_verify ( cs -> algo , o -> attr , data , data_len , sig , sig_len ) ; break ; default : res = TEE_ERROR_NOT_SUPPORTED ; } out : free ( params ) ; return res ; }
","<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
",OP-TEE@optee_os/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8,CVE-2019-1010298,https://github.com/OP-TEE/optee_os/commit/70697bf3c5dc3d201341b01a1a8e5bc6d2fb48f8,2019-07-15T18:15Z
CWE-20,"CWE-20 <S2SV_StartBug> static char * <S2SV_EndBug> base64_decode_string ( const char * enc ) { <S2SV_StartBug> if ( enc == NULL ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> char * dec = g_strdup ( enc ) ; <S2SV_EndBug> gsize len ; <S2SV_StartBug> g_base64_decode_inplace ( dec , & len ) ; <S2SV_EndBug> dec [ len ] = '\\0' ; return dec ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static gchar <S2SV_ModEnd> * base64_decode_string ( <S2SV_ModStart> enc ) { gchar * dec ; gsize len ; <S2SV_ModStart> return NULL ; dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> , & len <S2SV_ModStart> len ) ; if ( dec )
",cockpit-project@cockpit/c51f6177576d7e12614c64d316cf0b67addd17c9,CVE-2019-3804,https://github.com/cockpit-project/cockpit/commit/c51f6177576d7e12614c64d316cf0b67addd17c9,2019-03-26T18:29Z
CWE-89,"CWE-89 static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
","<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> ""localhost"" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (
",bagder@curl/75ca568fa1c19de4c5358fed246686de8467c238,CVE-2012-0036,https://github.com/bagder/curl/commit/75ca568fa1c19de4c5358fed246686de8467c238,2012-04-13T20:55Z
CWE-20,"CWE-20 error_t rawSocketSendEthPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; # if ( ETH_SUPPORT == ENABLED ) size_t length ; NetBuffer * buffer ; NetInterface * interface ; <S2SV_StartBug> if ( socket -> interface != NULL ) <S2SV_EndBug> { interface = socket -> interface ; } else { interface = netGetDefaultInterface ( ) ; } interface = nicGetPhysicalInterface ( interface ) ; if ( interface -> nicDriver != NULL && interface -> nicDriver -> type == NIC_TYPE_ETHERNET ) { buffer = netBufferAlloc ( 0 ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; length = message -> length ; error = netBufferAppend ( buffer , message -> data , length ) ; if ( ! error ) { if ( ! interface -> nicDriver -> autoPadding ) { if ( length < ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) ) { size_t n ; n = ( ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE ) - length ; error = netBufferAppend ( buffer , ethPadding , n ) ; length += n ; } } } if ( ! error ) { if ( ! interface -> nicDriver -> autoCrcCalc ) { uint32_t crc ; crc = ethCalcCrcEx ( buffer , 0 , length ) ; crc = htole32 ( crc ) ; error = netBufferAppend ( buffer , & crc , sizeof ( crc ) ) ; length += sizeof ( crc ) ; } } if ( ! error ) { NetTxAncillary ancillary ; ancillary = NET_DEFAULT_TX_ANCILLARY ; # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif TRACE_DEBUG ( ""Sending<S2SV_blank>raw<S2SV_blank>Ethernet<S2SV_blank>frame<S2SV_blank>(%"" PRIuSIZE ""<S2SV_blank>bytes)...\\r\\n"" , length ) ; error = nicSendPacket ( interface , buffer , 0 , & ancillary ) ; } netBufferFree ( buffer ) ; } else # endif { error = ERROR_INVALID_INTERFACE ; } return error ; }
","<S2SV_ModStart> * interface ; if ( message -> interface != NULL ) { interface = message -> interface ; } else
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
","<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
",neomutt@neomutt/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,CVE-2021-32055,https://github.com/neomutt/neomutt/commit/fa1db5785e5cfd9d3cd27b7571b9fe268d2ec2dc,2021-05-05T16:15Z
CWE-264,"CWE-264 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <S2SV_StartBug> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }
","<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,
",torvalds@linux/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,2014-11-10T11:55Z
CWE-611,"CWE-611 <S2SV_StartBug> static VALUE read_memory ( VALUE klass , VALUE content ) <S2SV_EndBug> { xmlSchemaPtr schema ; <S2SV_StartBug> xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt ( <S2SV_EndBug> ( const char * ) StringValuePtr ( content ) , ( int ) RSTRING_LEN ( content ) <S2SV_StartBug> ) ; <S2SV_EndBug> VALUE rb_schema ; VALUE errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>document"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; <S2SV_StartBug> return rb_schema ; <S2SV_EndBug> }
","<S2SV_ModStart> VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; int parse_options_int ; xmlSchemaParserCtxtPtr ctx ; <S2SV_ModEnd> xmlSchemaPtr schema ; <S2SV_ModStart> xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( ""to_i"" ) , 0 ) ) ; <S2SV_ModEnd> ctx = xmlSchemaNewMemParserCtxt <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ;
",sparklemotion@nokogiri/9c87439d9afa14a365ff13e73adc809cb2c3d97b,CVE-2020-26247,https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b,2020-12-30T19:15Z
CWE-20,"CWE-20 static int set_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; __uint128_t tmp ; void * valp = & tmp ; u64 off ; int err = 0 ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( KVM_REG_SIZE ( reg -> id ) > sizeof ( tmp ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( valp , uaddr , KVM_REG_SIZE ( reg -> id ) ) ) { err = - EFAULT ; goto out ; } if ( off == KVM_REG_ARM_CORE_REG ( regs . pstate ) ) { u32 mode = ( * ( u32 * ) valp ) & PSR_AA32_MODE_MASK ; switch ( mode ) { case PSR_AA32_MODE_USR : case PSR_AA32_MODE_FIQ : case PSR_AA32_MODE_IRQ : case PSR_AA32_MODE_SVC : case PSR_AA32_MODE_ABT : case PSR_AA32_MODE_UND : case PSR_MODE_EL0t : case PSR_MODE_EL1t : case PSR_MODE_EL1h : break ; default : err = - EINVAL ; goto out ; } } memcpy ( ( u32 * ) regs + off , valp , KVM_REG_SIZE ( reg -> id ) ) ; out : return err ; }
","<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
",torvalds@linux/d26c25a9d19b5976b319af528886f89cf455692d,CVE-2018-18021,https://github.com/torvalds/linux/commit/d26c25a9d19b5976b319af528886f89cf455692d,2018-10-07T06:29Z
CWE-77,"CWE-77 static void print_value ( int output , int num , const char * devname , const char * value , const char * name , size_t valsz ) { if ( output & OUTPUT_VALUE_ONLY ) { fputs ( value , stdout ) ; fputc ( '\\n' , stdout ) ; } else if ( output & OUTPUT_UDEV_LIST ) { print_udev_format ( name , value ) ; } else if ( output & OUTPUT_EXPORT_LIST ) { if ( num == 1 && devname ) printf ( ""DEVNAME=%s\\n"" , devname ) ; fputs ( name , stdout ) ; fputs ( ""="" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , NULL ) ; <S2SV_EndBug> fputs ( ""\\n"" , stdout ) ; } else { if ( num == 1 && devname ) printf ( ""%s:"" , devname ) ; fputs ( ""<S2SV_blank>"" , stdout ) ; fputs ( name , stdout ) ; fputs ( ""=\\"""" , stdout ) ; <S2SV_StartBug> safe_print ( value , valsz , ""\\"""" ) ; <S2SV_EndBug> fputs ( ""\\"""" , stdout ) ; } }
","<S2SV_ModStart> , valsz , ""<S2SV_blank>\\\\\\""\'$`<>"" <S2SV_ModEnd> ) ; fputs <S2SV_ModStart> , valsz , ""\\""\\\\"" ) ; fputs ( ""\\"""" <S2SV_ModEnd> , stdout )
",karelzak@util-linux/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,CVE-2014-9114,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,2017-03-31T16:59Z
CWE-20,"CWE-20 int do_ssl3_write ( SSL * s , int type , const unsigned char * buf , unsigned int * pipelens , unsigned int numpipes , int create_empty_fragment ) { unsigned char * outbuf [ SSL_MAX_PIPELINES ] , * plen [ SSL_MAX_PIPELINES ] ; SSL3_RECORD wr [ SSL_MAX_PIPELINES ] ; int i , mac_size , clear = 0 ; int prefix_len = 0 ; int eivlen ; size_t align = 0 ; SSL3_BUFFER * wb ; SSL_SESSION * sess ; unsigned int totlen = 0 ; unsigned int j ; for ( j = 0 ; j < numpipes ; j ++ ) totlen += pipelens [ j ] ; if ( RECORD_LAYER_write_pending ( & s -> rlayer ) ) return ( ssl3_write_pending ( s , type , buf , totlen ) ) ; if ( s -> s3 -> alert_dispatch ) { i = s -> method -> ssl_dispatch_alert ( s ) ; if ( i <= 0 ) return ( i ) ; } if ( s -> rlayer . numwpipes < numpipes ) if ( ! ssl3_setup_write_buffer ( s , numpipes , 0 ) ) return - 1 ; if ( totlen == 0 && ! create_empty_fragment ) return 0 ; sess = s -> session ; if ( ( sess == NULL ) || ( s -> enc_write_ctx == NULL ) || ( EVP_MD_CTX_md ( s -> write_hash ) == NULL ) ) { clear = s -> enc_write_ctx ? 0 : 1 ; mac_size = 0 ; } else { mac_size = EVP_MD_CTX_size ( s -> write_hash ) ; if ( mac_size < 0 ) goto err ; } if ( ! clear && ! create_empty_fragment && ! s -> s3 -> empty_fragment_done ) { if ( s -> s3 -> need_empty_fragments && type == SSL3_RT_APPLICATION_DATA ) { unsigned int tmppipelen = 0 ; prefix_len = do_ssl3_write ( s , type , buf , & tmppipelen , 1 , 1 ) ; if ( prefix_len <= 0 ) goto err ; if ( prefix_len > ( SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD ) ) { SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ; goto err ; } } s -> s3 -> empty_fragment_done = 1 ; } if ( create_empty_fragment ) { wb = & s -> rlayer . wbuf [ 0 ] ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + 2 * SSL3_RT_HEADER_LENGTH ; align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ; # endif outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + align ; SSL3_BUFFER_set_offset ( wb , align ) ; } else if ( prefix_len ) { wb = & s -> rlayer . wbuf [ 0 ] ; outbuf [ 0 ] = SSL3_BUFFER_get_buf ( wb ) + SSL3_BUFFER_get_offset ( wb ) + prefix_len ; } else { for ( j = 0 ; j < numpipes ; j ++ ) { wb = & s -> rlayer . wbuf [ j ] ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( size_t ) SSL3_BUFFER_get_buf ( wb ) + SSL3_RT_HEADER_LENGTH ; align = SSL3_ALIGN_PAYLOAD - 1 - ( ( align - 1 ) % SSL3_ALIGN_PAYLOAD ) ; # endif outbuf [ j ] = SSL3_BUFFER_get_buf ( wb ) + align ; SSL3_BUFFER_set_offset ( wb , align ) ; } } if ( s -> enc_write_ctx && SSL_USE_EXPLICIT_IV ( s ) ) { int mode = EVP_CIPHER_CTX_mode ( s -> enc_write_ctx ) ; if ( mode == EVP_CIPH_CBC_MODE ) { eivlen = EVP_CIPHER_CTX_iv_length ( s -> enc_write_ctx ) ; if ( eivlen <= 1 ) eivlen = 0 ; } else if ( mode == EVP_CIPH_GCM_MODE ) eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN ; else if ( mode == EVP_CIPH_CCM_MODE ) eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN ; else eivlen = 0 ; } else eivlen = 0 ; totlen = 0 ; memset ( wr , 0 , sizeof wr ) ; for ( j = 0 ; j < numpipes ; j ++ ) { * ( outbuf [ j ] ++ ) = type & 0xff ; SSL3_RECORD_set_type ( & wr [ j ] , type ) ; * ( outbuf [ j ] ++ ) = ( s -> version >> 8 ) ; if ( SSL_get_state ( s ) == TLS_ST_CW_CLNT_HELLO && ! s -> renegotiate && TLS1_get_version ( s ) > TLS1_VERSION ) * ( outbuf [ j ] ++ ) = 0x1 ; else * ( outbuf [ j ] ++ ) = s -> version & 0xff ; plen [ j ] = outbuf [ j ] ; outbuf [ j ] += 2 ; SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] + eivlen ) ; SSL3_RECORD_set_length ( & wr [ j ] , ( int ) pipelens [ j ] ) ; SSL3_RECORD_set_input ( & wr [ j ] , ( unsigned char * ) & buf [ totlen ] ) ; totlen += pipelens [ j ] ; if ( s -> compress != NULL ) { if ( ! ssl3_do_compress ( s , & wr [ j ] ) ) { SSLerr ( SSL_F_DO_SSL3_WRITE , SSL_R_COMPRESSION_FAILURE ) ; goto err ; } } else { memcpy ( wr [ j ] . data , wr [ j ] . input , wr [ j ] . length ) ; SSL3_RECORD_reset_input ( & wr [ j ] ) ; } <S2SV_StartBug> if ( ! SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ; SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ; } SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] ) ; SSL3_RECORD_reset_input ( & wr [ j ] ) ; if ( eivlen ) { SSL3_RECORD_add_length ( & wr [ j ] , eivlen ) ; } } if ( s -> method -> ssl3_enc -> enc ( s , wr , numpipes , 1 ) < 1 ) goto err ; for ( j = 0 ; j < numpipes ; j ++ ) { <S2SV_StartBug> if ( SSL_USE_ETM ( s ) && mac_size != 0 ) { <S2SV_EndBug> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ; SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ; } s2n ( SSL3_RECORD_get_length ( & wr [ j ] ) , plen [ j ] ) ; if ( s -> msg_callback ) s -> msg_callback ( 1 , 0 , SSL3_RT_HEADER , plen [ j ] - 5 , 5 , s , s -> msg_callback_arg ) ; SSL3_RECORD_set_type ( & wr [ j ] , type ) ; SSL3_RECORD_add_length ( & wr [ j ] , SSL3_RT_HEADER_LENGTH ) ; if ( create_empty_fragment ) { if ( j > 0 ) { SSLerr ( SSL_F_DO_SSL3_WRITE , ERR_R_INTERNAL_ERROR ) ; goto err ; } return SSL3_RECORD_get_length ( wr ) ; } SSL3_BUFFER_set_left ( & s -> rlayer . wbuf [ j ] , prefix_len + SSL3_RECORD_get_length ( & wr [ j ] ) ) ; } s -> rlayer . wpend_tot = totlen ; s -> rlayer . wpend_buf = buf ; s -> rlayer . wpend_type = type ; s -> rlayer . wpend_ret = totlen ; return ssl3_write_pending ( s , type , buf , totlen ) ; err : return - 1 ; }
","<S2SV_ModStart> if ( ! SSL_WRITE_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> { if ( SSL_WRITE_ETM <S2SV_ModEnd> ( s )
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static int read_frame_stats ( const struct twopass_rc * p , <S2SV_EndBug> FIRSTPASS_STATS * frame_stats , int offset ) { <S2SV_StartBug> const FIRSTPASS_STATS * fps_ptr = p -> stats_in ; <S2SV_EndBug> <S2SV_StartBug> if ( offset >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] >= p -> stats_in_end ) <S2SV_EndBug> return EOF ; <S2SV_StartBug> } else if ( offset < 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( & fps_ptr [ offset ] < p -> stats_in_start ) <S2SV_EndBug> return EOF ; } * frame_stats = fps_ptr [ offset ] ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static const FIRSTPASS_STATS * <S2SV_ModEnd> read_frame_stats ( const <S2SV_ModStart> read_frame_stats ( const TWO_PASS * p <S2SV_ModEnd> , int offset <S2SV_ModStart> offset ) { if ( <S2SV_ModEnd> ( offset >= <S2SV_ModStart> offset >= 0 && p -> stats_in + offset <S2SV_ModEnd> >= p -> <S2SV_ModStart> -> stats_in_end ) || <S2SV_ModEnd> ( offset < <S2SV_ModStart> offset < 0 && p -> stats_in + offset <S2SV_ModEnd> < p -> <S2SV_ModStart> -> stats_in_start ) ) { return NULL ; } return & p -> stats_in <S2SV_ModEnd> [ offset ] <S2SV_ModStart> offset ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int airspy_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct airspy * s ; int ret ; u8 u8tmp , buf [ BUF_SIZE ] ; s = kzalloc ( sizeof ( struct airspy ) , GFP_KERNEL ) ; if ( s == NULL ) { dev_err ( & intf -> dev , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>state\\n"" ) ; return - ENOMEM ; } mutex_init ( & s -> v4l2_lock ) ; mutex_init ( & s -> vb_queue_lock ) ; spin_lock_init ( & s -> queued_bufs_lock ) ; INIT_LIST_HEAD ( & s -> queued_bufs ) ; s -> dev = & intf -> dev ; s -> udev = interface_to_usbdev ( intf ) ; s -> f_adc = bands [ 0 ] . rangelow ; s -> f_rf = bands_rf [ 0 ] . rangelow ; s -> pixelformat = formats [ 0 ] . pixelformat ; s -> buffersize = formats [ 0 ] . buffersize ; ret = airspy_ctrl_msg ( s , CMD_BOARD_ID_READ , 0 , 0 , & u8tmp , 1 ) ; if ( ret == 0 ) ret = airspy_ctrl_msg ( s , CMD_VERSION_STRING_READ , 0 , 0 , buf , BUF_SIZE ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>detect<S2SV_blank>board\\n"" ) ; goto err_free_mem ; } buf [ BUF_SIZE - 1 ] = '\\0' ; dev_info ( s -> dev , ""Board<S2SV_blank>ID:<S2SV_blank>%02x\\n"" , u8tmp ) ; dev_info ( s -> dev , ""Firmware<S2SV_blank>version:<S2SV_blank>%s\\n"" , buf ) ; s -> vb_queue . type = V4L2_BUF_TYPE_SDR_CAPTURE ; s -> vb_queue . io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ ; s -> vb_queue . drv_priv = s ; s -> vb_queue . buf_struct_size = sizeof ( struct airspy_frame_buf ) ; s -> vb_queue . ops = & airspy_vb2_ops ; s -> vb_queue . mem_ops = & vb2_vmalloc_memops ; s -> vb_queue . timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC ; ret = vb2_queue_init ( & s -> vb_queue ) ; if ( ret ) { dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>vb2<S2SV_blank>queue\\n"" ) ; goto err_free_mem ; } s -> vdev = airspy_template ; s -> vdev . queue = & s -> vb_queue ; s -> vdev . queue -> lock = & s -> vb_queue_lock ; video_set_drvdata ( & s -> vdev , s ) ; s -> v4l2_dev . release = airspy_video_release ; ret = v4l2_device_register ( & intf -> dev , & s -> v4l2_dev ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>v4l2-device<S2SV_blank>(%d)\\n"" , ret ) ; goto err_free_mem ; } v4l2_ctrl_handler_init ( & s -> hdl , 5 ) ; s -> lna_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> lna_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_LNA_GAIN , 0 , 14 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> lna_gain_auto , 0 , false ) ; s -> mixer_gain_auto = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO , 0 , 1 , 1 , 0 ) ; s -> mixer_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_MIXER_GAIN , 0 , 15 , 1 , 8 ) ; v4l2_ctrl_auto_cluster ( 2 , & s -> mixer_gain_auto , 0 , false ) ; s -> if_gain = v4l2_ctrl_new_std ( & s -> hdl , & airspy_ctrl_ops , V4L2_CID_RF_TUNER_IF_GAIN , 0 , 15 , 1 , 0 ) ; if ( s -> hdl . error ) { ret = s -> hdl . error ; dev_err ( s -> dev , ""Could<S2SV_blank>not<S2SV_blank>initialize<S2SV_blank>controls\\n"" ) ; goto err_free_controls ; } v4l2_ctrl_handler_setup ( & s -> hdl ) ; s -> v4l2_dev . ctrl_handler = & s -> hdl ; s -> vdev . v4l2_dev = & s -> v4l2_dev ; s -> vdev . lock = & s -> v4l2_lock ; ret = video_register_device ( & s -> vdev , VFL_TYPE_SDR , - 1 ) ; if ( ret ) { dev_err ( s -> dev , ""Failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>as<S2SV_blank>video<S2SV_blank>device<S2SV_blank>(%d)\\n"" , ret ) ; <S2SV_StartBug> goto err_unregister_v4l2_dev ; <S2SV_EndBug> } dev_info ( s -> dev , ""Registered<S2SV_blank>as<S2SV_blank>%s\\n"" , video_device_node_name ( & s -> vdev ) ) ; dev_notice ( s -> dev , ""SDR<S2SV_blank>API<S2SV_blank>is<S2SV_blank>still<S2SV_blank>slightly<S2SV_blank>experimental<S2SV_blank>and<S2SV_blank>functionality<S2SV_blank>changes<S2SV_blank>may<S2SV_blank>follow\\n"" ) ; return 0 ; err_free_controls : v4l2_ctrl_handler_free ( & s -> hdl ) ; <S2SV_StartBug> err_unregister_v4l2_dev : <S2SV_EndBug> v4l2_device_unregister ( & s -> v4l2_dev ) ; err_free_mem : kfree ( s ) ; return ret ; }
","<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info <S2SV_ModStart> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( &
",torvalds@linux/aa93d1fee85c890a34f2510a310e55ee76a27848,CVE-2016-5400,https://github.com/torvalds/linux/commit/aa93d1fee85c890a34f2510a310e55ee76a27848,2016-08-06T20:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_set_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
",torvalds@linux/beb39db59d14990e401e235faf66a6b9b31240b0,CVE-2015-5366,https://github.com/torvalds/linux/commit/beb39db59d14990e401e235faf66a6b9b31240b0,2015-08-31T10:59Z
CWE-295,"CWE-295 NOEXPORT int options_file ( char * path , CONF_TYPE type , SERVICE_OPTIONS * * section_ptr ) { DISK_FILE * df ; char line_text [ CONFLINELEN ] , * errstr ; char config_line [ CONFLINELEN ] , * config_opt , * config_arg ; int i , line_number = 0 ; # ifndef USE_WIN32 int fd ; char * tmp_str ; # endif s_log ( LOG_NOTICE , ""Reading<S2SV_blank>configuration<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>%s"" , type == CONF_FD ? ""descriptor"" : ""file"" , path ) ; # ifndef USE_WIN32 if ( type == CONF_FD ) { fd = ( int ) strtol ( path , & tmp_str , 10 ) ; if ( tmp_str == path || * tmp_str ) { s_log ( LOG_ERR , ""Invalid<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>number"" ) ; print_syntax ( ) ; return 1 ; } df = file_fdopen ( fd ) ; } else # endif df = file_open ( path , FILE_MODE_READ ) ; if ( ! df ) { s_log ( LOG_ERR , ""Cannot<S2SV_blank>open<S2SV_blank>configuration<S2SV_blank>file"" ) ; if ( type != CONF_RELOAD ) print_syntax ( ) ; return 1 ; } while ( file_getline ( df , line_text , CONFLINELEN ) >= 0 ) { memcpy ( config_line , line_text , CONFLINELEN ) ; ++ line_number ; config_opt = config_line ; if ( line_number == 1 ) { if ( config_opt [ 0 ] == ( char ) 0xef && config_opt [ 1 ] == ( char ) 0xbb && config_opt [ 2 ] == ( char ) 0xbf ) { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>detected"" ) ; config_opt += 3 ; } else { s_log ( LOG_NOTICE , ""UTF-8<S2SV_blank>byte<S2SV_blank>order<S2SV_blank>mark<S2SV_blank>not<S2SV_blank>detected"" ) ; } } while ( isspace ( ( unsigned char ) * config_opt ) ) ++ config_opt ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; if ( config_opt [ 0 ] == '\\0' || config_opt [ 0 ] == '#' || config_opt [ 0 ] == ';' ) continue ; if ( config_opt [ 0 ] == '[' && config_opt [ strlen ( config_opt ) - 1 ] == ']' ) { if ( init_section ( 0 , section_ptr ) ) { file_close ( df ) ; return 1 ; } { SERVICE_OPTIONS * new_section ; new_section = str_alloc_detached ( sizeof ( SERVICE_OPTIONS ) ) ; new_section -> next = NULL ; ( * section_ptr ) -> next = new_section ; * section_ptr = new_section ; } ++ config_opt ; config_opt [ strlen ( config_opt ) - 1 ] = '\\0' ; ( * section_ptr ) -> servname = str_dup_detached ( config_opt ) ; ( * section_ptr ) -> session = NULL ; parse_service_option ( CMD_SET_COPY , section_ptr , NULL , NULL ) ; continue ; } config_arg = strchr ( config_line , '=' ) ; if ( ! config_arg ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>No<S2SV_blank>\'=\'<S2SV_blank>found"" , path , line_number , line_text ) ; file_close ( df ) ; return 1 ; } * config_arg ++ = '\\0' ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace ( ( unsigned char ) config_opt [ i ] ) ; -- i ) config_opt [ i ] = '\\0' ; while ( isspace ( ( unsigned char ) * config_arg ) ) ++ config_arg ; errstr = option_not_found ; if ( ! new_service_options . next ) <S2SV_StartBug> errstr = parse_global_option ( CMD_SET_VALUE , config_opt , config_arg ) ; <S2SV_EndBug> if ( errstr == option_not_found ) errstr = parse_service_option ( CMD_SET_VALUE , section_ptr , config_opt , config_arg ) ; if ( errstr ) { s_log ( LOG_ERR , ""%s:%d:<S2SV_blank>\\""%s\\"":<S2SV_blank>%s"" , path , line_number , line_text , errstr ) ; file_close ( df ) ; return 1 ; } } file_close ( df ) ; return 0 ; }
","<S2SV_ModStart> ( CMD_SET_VALUE , & new_global_options ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-20,"CWE-20 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * zap = NULL ; int ret ; ret = key_payload_reserve ( key , prep -> datalen ) ; if ( ret < 0 ) return ret ; key -> expiry = prep -> expiry ; <S2SV_StartBug> if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ; if ( zap ) call_rcu ( & zap -> rcu , user_free_payload_rcu ) ; return ret ; }
","<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-362,"CWE-362 int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; } <S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> goto out ; <S2SV_StartBug> } <S2SV_EndBug> if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE ""rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\n"" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE ""atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\n"" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( ""sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }
","<S2SV_ModStart> ) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;
",torvalds@linux/8c7188b23474cca017b3ef354c4a58456f68303a,CVE-2015-7990,https://github.com/torvalds/linux/commit/8c7188b23474cca017b3ef354c4a58456f68303a,2015-12-28T11:59Z
CWE-665,"CWE-665 int main ( int argc , char * * argv ) { int result ; int error = FALSE ; int display_license = FALSE ; int display_help = FALSE ; int c = 0 ; struct tm * tm , tm_s ; time_t now ; char datestring [ 256 ] ; nagios_macros * mac ; const char * worker_socket = NULL ; int i ; # ifdef HAVE_SIGACTION struct sigaction sig_action ; # endif # ifdef HAVE_GETOPT_H int option_index = 0 ; static struct option long_options [ ] = { { ""help"" , no_argument , 0 , 'h' } , { ""version"" , no_argument , 0 , 'V' } , { ""license"" , no_argument , 0 , 'V' } , { ""verify-config"" , no_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""test-scheduling"" , no_argument , 0 , 's' } , { ""precache-objects"" , no_argument , 0 , 'p' } , { ""use-precached-objects"" , no_argument , 0 , 'u' } , { ""enable-timing-point"" , no_argument , 0 , 'T' } , { ""worker"" , required_argument , 0 , 'W' } , { 0 , 0 , 0 , 0 } } ; # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) # endif memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; mac = get_global_macros ( ) ; if ( argc < 2 ) error = TRUE ; while ( 1 ) { c = getopt ( argc , argv , ""+hVvdspuxTW"" ) ; if ( c == - 1 || c == EOF ) break ; switch ( c ) { case '?' : case 'h' : display_help = TRUE ; break ; case 'V' : display_license = TRUE ; break ; case 'v' : verify_config ++ ; break ; case 's' : test_scheduling = TRUE ; break ; case 'd' : daemon_mode = TRUE ; break ; case 'p' : precache_objects = TRUE ; break ; case 'u' : use_precached_objects = TRUE ; break ; case 'T' : enable_timing_point = TRUE ; break ; case 'W' : worker_socket = optarg ; break ; case 'x' : printf ( ""Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\n"" ) ; break ; default : break ; } } # ifdef DEBUG_MEMORY mtrace ( ) ; # endif if ( worker_socket ) { exit ( nagios_core_worker ( worker_socket ) ) ; } init_main_cfg_vars ( 1 ) ; init_shared_cfg_vars ( 1 ) ; if ( daemon_mode == FALSE ) { printf ( ""\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\n"" , PROGRAM_VERSION ) ; printf ( ""Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\n"" ) ; printf ( ""Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\n"" ) ; printf ( ""Last<S2SV_blank>Modified:<S2SV_blank>%s\\n"" , PROGRAM_MODIFICATION_DATE ) ; printf ( ""License:<S2SV_blank>GPL\\n\\n"" ) ; printf ( ""Website:<S2SV_blank>https://www.nagios.org\\n"" ) ; } if ( display_license == TRUE ) { printf ( ""This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n"" ) ; printf ( ""it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\n"" ) ; printf ( ""published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\n\\n"" ) ; printf ( ""This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\n"" ) ; printf ( ""but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\n"" ) ; printf ( ""MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\n"" ) ; printf ( ""GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\n\\n"" ) ; printf ( ""You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\n"" ) ; printf ( ""along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\n"" ) ; printf ( ""Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\n\\n"" ) ; exit ( OK ) ; } if ( optind >= argc ) error = TRUE ; if ( error == TRUE || display_help == TRUE ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\n"" , argv [ 0 ] ) ; printf ( ""\\n"" ) ; printf ( ""Options:\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\n"" ) ; printf ( ""releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\n"" ) ; printf ( ""the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\n"" ) ; printf ( ""\\n"" ) ; exit ( ERROR ) ; } config_file = nspath_absolute ( argv [ optind ] , NULL ) ; if ( config_file == NULL ) { printf ( ""Error<S2SV_blank>allocating<S2SV_blank>memory.\\n"" ) ; exit ( ERROR ) ; } config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; # ifdef HAVE_SIGACTION sig_action . sa_sigaction = NULL ; sig_action . sa_handler = handle_sigxfsz ; sigfillset ( & sig_action . sa_mask ) ; sig_action . sa_flags = SA_NODEFER | SA_RESTART ; sigaction ( SIGXFSZ , & sig_action , NULL ) ; # else signal ( SIGXFSZ , handle_sigxfsz ) ; # endif if ( verify_config || test_scheduling || precache_objects ) { reset_variables ( ) ; set_loadctl_defaults ( ) ; if ( verify_config ) printf ( ""Reading<S2SV_blank>configuration<S2SV_blank>data...\\n"" ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\n"" ) ; if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ; exit ( EXIT_FAILURE ) ; } if ( ! verify_config && test_configured_paths ( ) == ERROR ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\n"" ) ; exit ( EXIT_FAILURE ) ; } result = read_all_object_data ( config_file ) ; if ( result != OK ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\n\\n"" ) ; if ( ! strstr ( config_file , ""nagios.cfg"" ) ) { printf ( ""\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\'%s\'\\n"" , DEFAULT_CONFIG_FILE ) ; } printf ( ""\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\n\\n"" ) ; printf ( ""Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\n\\n"" ) ; } result = pre_flight_check ( ) ; if ( result != OK ) { printf ( ""\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\n"" ) ; printf ( ""\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n"" ) ; printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( ""\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\n"" ) ; } if ( test_scheduling == TRUE ) { init_event_queue ( ) ; timing_point ( ""Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\n"" ) ; initialize_retention_data ( config_file ) ; read_initial_state_information ( ) ; timing_point ( ""Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\n"" ) ; init_timing_loop ( ) ; timing_point ( ""Timing<S2SV_blank>loop<S2SV_blank>initialized\\n"" ) ; display_scheduling_info ( ) ; } if ( precache_objects ) { result = fcache_objects ( object_precache_file ) ; timing_point ( ""Done<S2SV_blank>precaching<S2SV_blank>objects\\n"" ) ; if ( result == OK ) { printf ( ""Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\n%s\\n"" , object_precache_file ) ; } else { printf ( ""Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , object_precache_file , strerror ( errno ) ) ; } } cleanup ( ) ; timing_point ( ""Exiting\\n"" ) ; neb_free_module_list ( ) ; free ( config_file_dir ) ; free ( config_file ) ; exit ( result ) ; } else { if ( strchr ( argv [ 0 ] , '/' ) ) nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; else nagios_binary_path = strdup ( argv [ 0 ] ) ; if ( ! nagios_binary_path ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } do { wproc_num_workers_spawned = wproc_num_workers_online = 0 ; caught_signal = sigshutdown = FALSE ; sig_id = 0 ; reset_variables ( ) ; timing_point ( ""Variables<S2SV_blank>reset\\n"" ) ; nagios_pid = ( int ) getpid ( ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { logit ( NSLOG_CONFIG_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\'%s\'.<S2SV_blank>Aborting\\n"" , config_file ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\n"" ) ; program_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , ""%llu"" , ( unsigned long long ) program_start ) ; <S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting."" ) ; cleanup ( ) ; exit ( ERROR ) ; } if ( test_path_access ( nagios_binary_path , X_OK ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\n"" , nagios_binary_path , strerror ( errno ) ) ; logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( test_configured_paths ( ) == ERROR ) { <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> } if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } logit ( NSLOG_PROCESS_INFO , TRUE , ""Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\n"" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; now = time ( NULL ) ; tm = localtime_r ( & now , & tm_s ) ; strftime ( datestring , sizeof ( datestring ) , ""%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y"" , tm ) ; logit ( NSLOG_PROCESS_INFO , TRUE , ""Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s"" , datestring ) ; write_log_file_info ( NULL ) ; open_debug_log ( ) ; # ifdef USE_EVENT_BROKER neb_init_modules ( ) ; neb_init_callback_list ( ) ; # endif timing_point ( ""NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\n"" ) ; setup_sighandler ( ) ; if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\n"" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Query<S2SV_blank>handler<S2SV_blank>initialized\\n"" ) ; nerd_init ( ) ; timing_point ( ""NERD<S2SV_blank>initialized\\n"" ) ; if ( init_workers ( num_check_workers ) < 0 ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , ""Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\n"" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""%u<S2SV_blank>workers<S2SV_blank>spawned\\n"" , wproc_num_workers_spawned ) ; i = 0 ; while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { iobroker_poll ( nagios_iobs , 50 ) ; i ++ ; } timing_point ( ""%u<S2SV_blank>workers<S2SV_blank>connected\\n"" , wproc_num_workers_online ) ; set_loadctl_defaults ( ) ; # ifdef USE_EVENT_BROKER if ( neb_load_all_modules ( ) != OK ) { logit ( NSLOG_CONFIG_ERROR , ERROR , ""Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\n"" ) ; if ( daemon_dumps_core ) neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; exit ( EXIT_FAILURE ) ; } timing_point ( ""Modules<S2SV_blank>loaded\\n"" ) ; broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; timing_point ( ""First<S2SV_blank>callback<S2SV_blank>made\\n"" ) ; # endif if ( result == OK ) result = read_all_object_data ( config_file ) ; if ( result != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; else { if ( ( result = pre_flight_check ( ) ) != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\n"" , ( int ) getpid ( ) ) ; } if ( result != OK ) { if ( sigrestart == TRUE ) { cleanup_status_data ( TRUE ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; # endif cleanup ( ) ; exit ( ERROR ) ; } timing_point ( ""Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\n"" ) ; fcache_objects ( object_cache_file ) ; timing_point ( ""Objects<S2SV_blank>cached\\n"" ) ; init_event_queue ( ) ; timing_point ( ""Event<S2SV_blank>queue<S2SV_blank>initialized\\n"" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif if ( sigrestart == FALSE ) { initialize_status_data ( config_file ) ; timing_point ( ""Status<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; } initialize_downtime_data ( ) ; timing_point ( ""Downtime<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; initialize_retention_data ( config_file ) ; timing_point ( ""Retention<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; read_initial_state_information ( ) ; timing_point ( ""Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\n"" ) ; initialize_comment_data ( ) ; timing_point ( ""Comment<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; initialize_performance_data ( config_file ) ; timing_point ( ""Performance<S2SV_blank>data<S2SV_blank>initialized\\n"" ) ; init_timing_loop ( ) ; timing_point ( ""Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\n"" ) ; init_check_stats ( ) ; timing_point ( ""check<S2SV_blank>stats<S2SV_blank>initialized\\n"" ) ; check_for_nagios_updates ( FALSE , TRUE ) ; timing_point ( ""Update<S2SV_blank>check<S2SV_blank>concluded\\n"" ) ; update_all_status_data ( ) ; timing_point ( ""Status<S2SV_blank>data<S2SV_blank>updated\\n"" ) ; log_host_states ( INITIAL_STATES , NULL ) ; log_service_states ( INITIAL_STATES , NULL ) ; timing_point ( ""Initial<S2SV_blank>states<S2SV_blank>logged\\n"" ) ; sigrestart = FALSE ; launch_command_file_worker ( ) ; timing_point ( ""Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\n"" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif event_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , ""%llu"" , ( unsigned long long ) event_start ) ; timing_point ( ""Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\n"" ) ; event_execution_loop ( ) ; qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; if ( caught_signal == TRUE ) { if ( sig_id == SIGHUP ) logit ( NSLOG_PROCESS_INFO , TRUE , ""Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\n"" ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; if ( sigshutdown == TRUE ) broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; else if ( sigrestart == TRUE ) broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; # endif save_state_information ( FALSE ) ; cleanup_retention_data ( ) ; cleanup_performance_data ( ) ; cleanup_downtime_data ( ) ; if ( sigrestart == FALSE ) { cleanup_status_data ( TRUE ) ; } free_worker_memory ( WPROC_FORCE ) ; if ( sigshutdown == TRUE ) { iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; nagios_iobs = NULL ; logit ( NSLOG_PROCESS_INFO , TRUE , ""Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\n"" , ( int ) getpid ( ) ) ; } cleanup ( ) ; close_debug_log ( ) ; } while ( sigrestart == TRUE && sigshutdown == FALSE ) ; if ( daemon_mode == TRUE ) unlink ( lock_file ) ; my_free ( lock_file ) ; my_free ( config_file ) ; my_free ( config_file_dir ) ; my_free ( nagios_binary_path ) ; } return OK ; }
","<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , ""Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)"" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }
",NagiosEnterprises@nagioscore/1b197346d490df2e2d3b1dcce5ac6134ad0c8752,CVE-2017-12847,https://github.com/NagiosEnterprises/nagioscore/commit/1b197346d490df2e2d3b1dcce5ac6134ad0c8752,2017-08-23T21:29Z
CWE-119,"CWE-119 int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { int x ; int chunk ; UINT8 * out ; UINT8 * ptr ; ptr = buf ; chunk = 3 * state -> xsize ; for ( ; ; ) { if ( bytes < chunk ) return ptr - buf ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; <S2SV_StartBug> out += 4 ; <S2SV_EndBug> } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x + state -> xsize ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; <S2SV_StartBug> out += 4 ; <S2SV_EndBug> } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; ptr += chunk ; bytes -= chunk ; } }
","<S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state <S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state
",python-pillow@Pillow/ae453aa18b66af54e7ff716f4ccb33adca60afd4,CVE-2016-2533,https://github.com/python-pillow/Pillow/commit/ae453aa18b66af54e7ff716f4ccb33adca60afd4,2016-04-13T16:59Z
CWE-189,"CWE-189 PHP_FUNCTION ( imageaffinematrixconcat ) { double m1 [ 6 ] ; double m2 [ 6 ] ; double mr [ 6 ] ; zval * * tmp ; zval * z_m1 ; zval * z_m2 ; int i , nelems ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""aa"" , & z_m1 , & z_m2 ) == FAILURE ) { return ; } if ( ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m1 ) ) ) != 6 ) || ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_m2 ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affine<S2SV_blank>arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 6 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m1 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m1 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m1 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m1 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } if ( zend_hash_index_find ( Z_ARRVAL_P ( z_m2 ) , i , ( void * * ) & tmp ) == SUCCESS ) { switch ( Z_TYPE_PP ( tmp ) ) { case IS_LONG : m2 [ i ] = Z_LVAL_PP ( tmp ) ; break ; case IS_DOUBLE : m2 [ i ] = Z_DVAL_PP ( tmp ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> m2 [ i ] = Z_DVAL_PP ( tmp ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } } if ( gdAffineConcat ( mr , m1 , m2 ) != GD_TRUE ) { RETURN_FALSE ; } array_init ( return_value ) ; for ( i = 0 ; i < 6 ; i ++ ) { add_index_double ( return_value , i , mr [ i ] ) ; } }
","<S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; m1 <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; m2 <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default
",php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z
CWE-190,"CWE-190 jas_stream_t * jas_stream_memopen ( char * buf , int bufsize ) { <S2SV_StartBug> jas_stream_t * stream ; <S2SV_EndBug> jas_stream_memobj_t * obj ; JAS_DBGLOG ( 100 , ( ""jas_stream_memopen(%p,<S2SV_blank>%d)\\n"" , buf , bufsize ) ) ; <S2SV_StartBug> if ( ! ( stream = jas_stream_create ( ) ) ) { <S2SV_EndBug> return 0 ; } stream -> openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY ; jas_stream_initbuf ( stream , JAS_STREAM_FULLBUF , 0 , 0 ) ; stream -> ops_ = & jas_stream_memops ; if ( ! ( obj = jas_malloc ( sizeof ( jas_stream_memobj_t ) ) ) ) { jas_stream_destroy ( stream ) ; return 0 ; } stream -> obj_ = ( void * ) obj ; obj -> myalloc_ = 0 ; obj -> buf_ = 0 ; if ( bufsize <= 0 ) { <S2SV_StartBug> obj -> bufsize_ = 1024 ; <S2SV_EndBug> obj -> growable_ = 1 ; } else { <S2SV_StartBug> obj -> bufsize_ = bufsize ; <S2SV_EndBug> <S2SV_StartBug> obj -> growable_ = 0 ; <S2SV_EndBug> } if ( buf ) { obj -> buf_ = ( unsigned char * ) buf ; } else { obj -> buf_ = jas_malloc ( obj -> bufsize_ ) ; obj -> myalloc_ = 1 ; } if ( ! obj -> buf_ ) { jas_stream_close ( stream ) ; return 0 ; } JAS_DBGLOG ( 100 , ( ""jas_stream_memopen<S2SV_blank>buffer<S2SV_blank>buf=%p<S2SV_blank>myalloc=%d\\n"" , obj -> buf_ , obj -> myalloc_ ) ) ; if ( bufsize > 0 && buf ) { obj -> len_ = bufsize ; } else { obj -> len_ = 0 ; } obj -> pos_ = 0 ; return stream ; }
","<S2SV_ModStart> bufsize ) { char * new_buf ; size_t new_bufsize <S2SV_ModEnd> ; JAS_DBGLOG ( <S2SV_ModStart> ; if ( bufsize < 0 ) { jas_deprecated ( ""negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( ""Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n"" ) ; jas_deprecated ( ""A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>"" ""jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n"" ) ; } <S2SV_ModEnd> if ( bufsize <S2SV_ModStart> 0 ) { new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { new_bufsize <S2SV_ModEnd> = bufsize ; <S2SV_ModStart> = bufsize ; new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> ; } <S2SV_null>
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
CWE-399,"CWE-399 static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }
","<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-119,"CWE-119 static int cdrom_ioctl_media_changed ( struct cdrom_device_info * cdi , unsigned long arg ) { struct cdrom_changer_info * info ; int ret ; cd_dbg ( CD_DO_IOCTL , ""entering<S2SV_blank>CDROM_MEDIA_CHANGED\\n"" ) ; if ( ! CDROM_CAN ( CDC_MEDIA_CHANGED ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || arg == CDSL_CURRENT ) return media_changed ( cdi , 1 ) ; <S2SV_StartBug> if ( ( unsigned int ) arg >= cdi -> capacity ) <S2SV_EndBug> return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) return - ENOMEM ; ret = cdrom_read_mech_status ( cdi , info ) ; if ( ! ret ) ret = info -> slots [ arg ] . change ; kfree ( info ) ; return ret ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi
",torvalds@linux/9de4ee40547fd315d4a0ed1dd15a2fa3559ad707,CVE-2018-10940,https://github.com/torvalds/linux/commit/9de4ee40547fd315d4a0ed1dd15a2fa3559ad707,2018-05-09T17:29Z
CWE-264,"CWE-264 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_bindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , val * 2 , SOCK_MIN_SNDBUF ) ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , val * 2 , SOCK_MIN_RCVBUF ) ; break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET <S2SV_StartBug> if ( sk -> sk_protocol == IPPROTO_TCP ) <S2SV_EndBug> tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || capable ( CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( ""setsockopt"" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE , val & SOF_TIMESTAMPING_TX_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE , val & SOF_TIMESTAMPING_TX_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE , val & SOF_TIMESTAMPING_RX_HARDWARE ) ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE , val & SOF_TIMESTAMPING_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE , val & SOF_TIMESTAMPING_SYS_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE , val & SOF_TIMESTAMPING_RAW_HARDWARE ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }
","<S2SV_ModStart> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM
",torvalds@linux/3e10986d1d698140747fcfc2761ec9cb64c1d582,CVE-2012-6657,https://github.com/torvalds/linux/commit/3e10986d1d698140747fcfc2761ec9cb64c1d582,2014-09-28T10:55Z
CWE-200,"CWE-200 static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }
","<S2SV_ModStart> 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
",torvalds@linux/355b98553789b646ed97ad801a619ff898471b92,CVE-2019-10638,https://github.com/torvalds/linux/commit/355b98553789b646ed97ad801a619ff898471b92,2019-07-05T23:15Z
CWE-125,"CWE-125 static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%s<S2SV_blank>"" , t . t_no , idstr ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>#%d<S2SV_blank>id=%d<S2SV_blank>"" , t . t_no , t . t_id ) ) ; cp = ( const u_char * ) ( p + 1 ) ; ep2 = ( const u_char * ) p + item_len ; while ( cp < ep && cp < ep2 ) { <S2SV_StartBug> if ( map && nmap ) { <S2SV_EndBug> <S2SV_StartBug> cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , <S2SV_EndBug> map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 ) ; } if ( ep < ep2 ) ND_PRINT ( ( ndo , ""..."" ) ) ; return cp ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; return NULL ; }
","<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z
CWE-119,"CWE-119 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }
","<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-20182,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-03-15T18:29Z
CWE-000,"CWE-000 void vp8_decoder_remove_threads ( VP8D_COMP * pbi ) { if ( pbi -> b_multithreaded_rd ) { int i ; pbi -> b_multithreaded_rd = 0 ; <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> { sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; pthread_join ( pbi -> h_decoding_thread [ i ] , NULL ) ; } <S2SV_StartBug> for ( i = 0 ; i < pbi -> allocated_decoding_thread_count ; i ++ ) <S2SV_EndBug> { sem_destroy ( & pbi -> h_event_start_decoding [ i ] ) ; } sem_destroy ( & pbi -> h_event_end_decoding ) ; vpx_free ( pbi -> h_decoding_thread ) ; pbi -> h_decoding_thread = NULL ; vpx_free ( pbi -> h_event_start_decoding ) ; pbi -> h_event_start_decoding = NULL ; vpx_free ( pbi -> mb_row_di ) ; pbi -> mb_row_di = NULL ; vpx_free ( pbi -> de_thread_data ) ; pbi -> de_thread_data = NULL ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_post <S2SV_ModStart> -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_destroy <S2SV_ModStart> = NULL ; vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;
",external@libvpx/6886e8e0a9db2dbad723dc37a548233e004b33bc,CVE-2017-0393,https://android.googlesource.com/platform/external/libvpx/+/6886e8e0a9db2dbad723dc37a548233e004b33bc,2017-01-12T20:59Z
CWE-20,"CWE-20 error_t mqttSnClientSubscribe ( MqttSnClientContext * context , const char_t * topicName , MqttSnQosLevel qos ) { error_t error ; systime_t time ; if ( context == NULL || topicName == NULL ) return ERROR_INVALID_PARAMETER ; error = NO_ERROR ; while ( ! error ) { time = osGetSystemTime ( ) ; if ( context -> state == MQTT_SN_CLIENT_STATE_ACTIVE ) { mqttSnClientGenerateMessageId ( context ) ; context -> startTime = time ; error = mqttSnClientSendSubscribe ( context , topicName , qos ) ; } else if ( context -> state == MQTT_SN_CLIENT_STATE_SENDING_REQ ) { if ( timeCompare ( time , context -> startTime + context -> timeout ) >= 0 ) { context -> state = MQTT_SN_CLIENT_STATE_DISCONNECTING ; error = ERROR_TIMEOUT ; } else if ( timeCompare ( time , context -> retransmitStartTime + MQTT_SN_CLIENT_RETRY_TIMEOUT ) >= 0 ) { error = mqttSnClientSendSubscribe ( context , topicName , qos ) ; } else { error = mqttSnClientProcessEvents ( context , MQTT_SN_CLIENT_TICK_INTERVAL ) ; } } else if ( context -> state == MQTT_SN_CLIENT_STATE_RESP_RECEIVED ) { context -> state = MQTT_SN_CLIENT_STATE_ACTIVE ; if ( context -> msgType == MQTT_SN_MSG_TYPE_SUBACK ) { if ( context -> returnCode == MQTT_SN_RETURN_CODE_ACCEPTED ) { <S2SV_StartBug> if ( strchr ( topicName , '#' ) == NULL && strchr ( topicName , '+' ) == NULL ) <S2SV_EndBug> { error = mqttSnClientAddTopic ( context , topicName , context -> topicId ) ; } break ; } else { error = ERROR_REQUEST_REJECTED ; } } else { error = ERROR_UNEXPECTED_RESPONSE ; } } else { error = ERROR_NOT_CONNECTED ; } } return error ; }
","<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 static ssize_t k90_show_macro_mode ( struct device * dev , struct device_attribute * attr , char * buf ) { int ret ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; const char * macro_mode ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_GET_MODE , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 2 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>mode<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> switch ( data [ 0 ] ) { case K90_MACRO_MODE_HW : macro_mode = ""HW"" ; break ; case K90_MACRO_MODE_SW : macro_mode = ""SW"" ; break ; default : dev_warn ( dev , ""K90<S2SV_blank>in<S2SV_blank>unknown<S2SV_blank>mode:<S2SV_blank>%02hhx.\\n"" , data [ 0 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; }
","<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , ""%s\\n"" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/6d104af38b570d37aa32a5803b04c354f8ed513d,CVE-2017-5547,https://github.com/torvalds/linux/commit/6d104af38b570d37aa32a5803b04c354f8ed513d,2017-02-06T06:59Z
CWE-000,"CWE-000 int simple_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error ; if ( type == ACL_TYPE_ACCESS ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> <S2SV_StartBug> if ( error < 0 ) <S2SV_EndBug> return 0 ; if ( error == 0 ) acl = NULL ; } inode -> i_ctime = current_time ( inode ) ; set_cached_acl ( inode , type , acl ) ; return 0 ; }
","<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
",torvalds@linux/497de07d89c1410d76a15bec2bb41f24a2a89f31,CVE-2017-5551,https://github.com/torvalds/linux/commit/497de07d89c1410d76a15bec2bb41f24a2a89f31,2017-02-06T06:59Z
CWE-754,"CWE-754 STATIC int xfs_attr_shortform_addname ( xfs_da_args_t * args ) { int newsize , forkoff , retval ; trace_xfs_attr_sf_addname ( args ) ; retval = xfs_attr_shortform_lookup ( args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == - ENOATTR ) ) { return retval ; } else if ( retval == - EEXIST ) { if ( args -> flags & ATTR_CREATE ) return retval ; retval = xfs_attr_shortform_remove ( args ) ; <S2SV_StartBug> ASSERT ( retval == 0 ) ; <S2SV_EndBug> } if ( args -> namelen >= XFS_ATTR_SF_ENTSIZE_MAX || args -> valuelen >= XFS_ATTR_SF_ENTSIZE_MAX ) return - ENOSPC ; newsize = XFS_ATTR_SF_TOTSIZE ( args -> dp ) ; newsize += XFS_ATTR_SF_ENTSIZE_BYNAME ( args -> namelen , args -> valuelen ) ; forkoff = xfs_attr_shortform_bytesfit ( args -> dp , newsize ) ; if ( ! forkoff ) return - ENOSPC ; xfs_attr_shortform_add ( args , forkoff ) ; return 0 ; }
","<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
",torvalds@linux/7b38460dc8e4eafba06c78f8e37099d3b34d473c,CVE-2018-18690,https://github.com/torvalds/linux/commit/7b38460dc8e4eafba06c78f8e37099d3b34d473c,2018-10-26T18:29Z
CWE-772,"CWE-772 static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register Quantum * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; screen = AcquireImage ( image_info , exception ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; <S2SV_StartBug> status = SetImageExtent ( screen , screen -> columns , screen -> rows , exception ) ; <S2SV_EndBug> if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> if ( image == ( Image * ) NULL ) <S2SV_EndBug> image = screen ; else AppendImageToList ( & image , screen ) ; bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( HDC ) NULL ) { DeleteDC ( hDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; } ( void ) ResetMagickMemory ( & bmi , 0 , sizeof ( BITMAPINFO ) ) ; bmi . bmiHeader . biSize = sizeof ( BITMAPINFOHEADER ) ; bmi . bmiHeader . biWidth = ( LONG ) screen -> columns ; bmi . bmiHeader . biHeight = ( - 1 ) * ( LONG ) screen -> rows ; bmi . bmiHeader . biPlanes = 1 ; bmi . bmiHeader . biBitCount = 24 ; bmi . bmiHeader . biCompression = BI_RGB ; bitmap = CreateDIBSection ( hDC , & bmi , DIB_RGB_COLORS , ( void * * ) & p , NULL , 0 ) ; if ( bitmap == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } bitmapOld = ( HBITMAP ) SelectObject ( bitmapDC , bitmap ) ; if ( bitmapOld == ( HBITMAP ) NULL ) { DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; ThrowReaderException ( CoderError , ""UnableToCreateBitmap"" ) ; } BitBlt ( bitmapDC , 0 , 0 , ( int ) screen -> columns , ( int ) screen -> rows , hDC , 0 , 0 , SRCCOPY ) ; ( void ) SelectObject ( bitmapDC , bitmapOld ) ; for ( y = 0 ; y < ( ssize_t ) screen -> rows ; y ++ ) { q = QueueAuthenticPixels ( screen , 0 , y , screen -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) screen -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( p -> rgbtRed ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( p -> rgbtGreen ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( p -> rgbtBlue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( screen , exception ) == MagickFalse ) break ; } DeleteDC ( hDC ) ; DeleteDC ( bitmapDC ) ; DeleteObject ( bitmap ) ; } } # elif defined ( MAGICKCORE_X11_DELEGATE ) { const char * option ; XImportInfo ximage_info ; XGetImportInfo ( & ximage_info ) ; option = GetImageOption ( image_info , ""x:screen"" ) ; if ( option != ( const char * ) NULL ) ximage_info . screen = IsStringTrue ( option ) ; option = GetImageOption ( image_info , ""x:silent"" ) ; if ( option != ( const char * ) NULL ) ximage_info . silent = IsStringTrue ( option ) ; image = XImportImage ( image_info , & ximage_info , exception ) ; } # endif return ( image ) ; }
","<S2SV_ModStart> = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> bitmapDC = CreateCompatibleDC
",ImageMagick@ImageMagick/72a50e400d98d7a2fd610caedfeb9af043dc5582,CVE-2017-11447,https://github.com/ImageMagick/ImageMagick/commit/72a50e400d98d7a2fd610caedfeb9af043dc5582,2017-07-19T07:29Z
CWE-617,"CWE-617 <S2SV_StartBug> static void <S2SV_EndBug> pci_msix_table_init ( struct pci_vdev * dev , int table_entries ) { <S2SV_StartBug> int i , table_size ; <S2SV_EndBug> assert ( table_entries > 0 ) ; assert ( table_entries <= MAX_MSIX_TABLE_ENTRIES ) ; table_size = table_entries * MSIX_TABLE_ENTRY_SIZE ; dev -> msix . table = calloc ( 1 , table_size ) ; <S2SV_StartBug> assert ( dev -> msix . table != NULL ) ; <S2SV_EndBug> for ( i = 0 ; i < table_entries ; i ++ ) dev -> msix . table [ i ] . vector_control |= PCIM_MSIX_VCTRL_MASK ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> pci_msix_table_init ( struct <S2SV_ModStart> i , table_size <S2SV_ModEnd> ; table_size = <S2SV_ModStart> table_size ) ; if ( ! <S2SV_ModEnd> dev -> msix <S2SV_ModStart> msix . table ) { pr_err ( ""%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\n"" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> |= PCIM_MSIX_VCTRL_MASK ; return 0 ;
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-476,"CWE-476 static int hash_accept ( struct socket * sock , struct socket * newsock , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; struct ahash_request * req = & ctx -> req ; char state [ crypto_ahash_statesize ( crypto_ahash_reqtfm ( req ) ) ] ; struct sock * sk2 ; struct alg_sock * ask2 ; struct hash_ctx * ctx2 ; <S2SV_StartBug> int err ; <S2SV_EndBug> <S2SV_StartBug> err = crypto_ahash_export ( req , state ) ; <S2SV_EndBug> if ( err ) return err ; err = af_alg_accept ( ask -> parent , newsock ) ; if ( err ) return err ; sk2 = newsock -> sk ; ask2 = alg_sk ( sk2 ) ; ctx2 = ask2 -> private ; <S2SV_StartBug> ctx2 -> more = 1 ; <S2SV_EndBug> err = crypto_ahash_import ( & ctx2 -> req , state ) ; if ( err ) { sock_orphan ( sk2 ) ; sock_put ( sk2 ) ; } return err ; }
","<S2SV_ModStart> * ctx2 ; bool more ; <S2SV_ModStart> int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> crypto_ahash_export ( req <S2SV_ModStart> , state ) : 0 ; release_sock ( sk ) <S2SV_ModStart> -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err =
",torvalds@linux/4afa5f9617927453ac04b24b584f6c718dfb4f45,CVE-2016-8646,https://github.com/torvalds/linux/commit/4afa5f9617927453ac04b24b584f6c718dfb4f45,2016-11-28T03:59Z
CWE-400,"CWE-400 static void perf_output_wakeup ( struct perf_output_handle * handle ) { atomic_set ( & handle -> rb -> poll , POLL_IN ) ; <S2SV_StartBug> if ( handle -> nmi ) { <S2SV_EndBug> handle -> event -> pending_wakeup = 1 ; irq_work_queue ( & handle -> event -> pending ) ; <S2SV_StartBug> } else <S2SV_EndBug> perf_event_wakeup ( handle -> event ) ; }
","<S2SV_ModStart> POLL_IN ) ; <S2SV_ModEnd> handle -> event <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-399,"CWE-399 static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { <S2SV_StartBug> case DB_VECTOR : <S2SV_EndBug> dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }
","<S2SV_ModStart> ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
",torvalds@linux/54a20552e1eae07aa240fa370a0293e006b5faed,CVE-2015-5307,https://github.com/torvalds/linux/commit/54a20552e1eae07aa240fa370a0293e006b5faed,2015-11-16T11:59Z
CWE-119,"CWE-119 void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
","<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
","<S2SV_ModStart> <= w - ( int )
",FFmpeg@FFmpeg/454a11a1c9c686c78aa97954306fb63453299760,CVE-2013-7010,https://github.com/FFmpeg/FFmpeg/commit/454a11a1c9c686c78aa97954306fb63453299760,2013-12-09T16:36Z
CWE-189,"CWE-189 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t tail = ( i << 1 ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; <S2SV_StartBug> if ( q > e ) { <S2SV_EndBug> DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
","<S2SV_ModStart> if ( q < p ) { DPRINTF ( ( ""Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n"" , q , p ) ) ; goto out ; } if ( q
",file@file/0641e56be1af003aa02c7c6b0184466540637233,CVE-2014-3587,https://github.com/file/file/commit/0641e56be1af003aa02c7c6b0184466540637233,2014-08-23T01:55Z
CWE-264,"CWE-264 void mm_release ( struct task_struct * tsk , struct mm_struct * mm ) { <S2SV_StartBug> struct completion * vfork_done = tsk -> vfork_done ; <S2SV_EndBug> deactivate_mm ( tsk , mm ) ; if ( vfork_done ) { tsk -> vfork_done = NULL ; complete ( vfork_done ) ; } if ( tsk -> clear_child_tid && ! ( tsk -> flags & PF_SIGNALED ) && atomic_read ( & mm -> mm_users ) > 1 ) { u32 __user * tidptr = tsk -> clear_child_tid ; tsk -> clear_child_tid = NULL ; put_user ( 0 , tidptr ) ; sys_futex ( tidptr , FUTEX_WAKE , 1 , NULL , NULL , 0 ) ; } }
","<S2SV_ModStart> -> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
",torvalds@linux/8141c7f3e7aee618312fa1c15109e1219de784a7,CVE-2012-0028,https://github.com/torvalds/linux/commit/8141c7f3e7aee618312fa1c15109e1219de784a7,2012-06-21T23:55Z
CWE-134,"CWE-134 rrd_info_t * rrd_graph_v ( int argc , char * * argv ) { image_desc_t im ; rrd_info_t * grinfo ; rrd_graph_init ( & im ) ; rrd_graph_options ( argc , argv , & im ) ; if ( rrd_test_error ( ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( optind >= argc ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; rrd_set_error ( ""missing<S2SV_blank>filename"" ) ; return NULL ; } if ( strlen ( argv [ optind ] ) >= MAXPATH ) { rrd_set_error ( ""filename<S2SV_blank>(including<S2SV_blank>path)<S2SV_blank>too<S2SV_blank>long"" ) ; rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } strncpy ( im . graphfile , argv [ optind ] , MAXPATH - 1 ) ; im . graphfile [ MAXPATH - 1 ] = '\\0' ; if ( strcmp ( im . graphfile , ""-"" ) == 0 ) { im . graphfile [ 0 ] = '\\0' ; } rrd_graph_script ( argc , argv , & im , 1 ) ; if ( rrd_test_error ( ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( graph_paint ( & im ) == - 1 ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; return NULL ; } if ( im . imginfo && * im . imginfo ) { rrd_infoval_t info ; char * path ; char * filename ; if ( bad_format_imginfo ( im . imginfo ) ) { rrd_info_free ( im . grinfo ) ; im_free ( & im ) ; <S2SV_StartBug> rrd_set_error ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>imginfo"" ) ; <S2SV_EndBug> return NULL ; } path = strdup ( im . graphfile ) ; filename = basename ( path ) ; info . u_str = sprintf_alloc ( im . imginfo , filename , ( long ) ( im . zoom * im . ximg ) , ( long ) ( im . zoom * im . yimg ) ) ; grinfo_push ( & im , sprintf_alloc ( ""image_info"" ) , RD_I_STR , info ) ; free ( info . u_str ) ; free ( path ) ; } if ( im . rendered_image ) { rrd_infoval_t img ; img . u_blo . size = im . rendered_image_size ; img . u_blo . ptr = im . rendered_image ; grinfo_push ( & im , sprintf_alloc ( ""image"" ) , RD_I_BLO , img ) ; } grinfo = im . grinfo ; im_free ( & im ) ; return grinfo ; }
","<S2SV_ModStart> im ) ; <S2SV_ModEnd> return NULL ;
",oetiker@rrdtool-1.x/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,CVE-2014-6262,https://github.com/oetiker/rrdtool-1.x/commit/64ed5314af1255ab6dded45f70b39cdeab5ae2ec,2020-02-12T02:15Z
CWE-190,"CWE-190 <S2SV_StartBug> void * zmalloc ( size_t size ) { <S2SV_EndBug> void * ptr = malloc ( size + PREFIX_SIZE ) ; if ( ! ptr ) zmalloc_oom_handler ( size ) ; # ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc ( zmalloc_size ( ptr ) ) ; return ptr ; # else * ( ( size_t * ) ptr ) = size ; update_zmalloc_stat_alloc ( size + PREFIX_SIZE ) ; return ( char * ) ptr + PREFIX_SIZE ; # endif }
","<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
",redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z
CWE-000,"CWE-000 long join_session_keyring ( const char * name ) { const struct cred * old ; struct cred * new ; struct key * keyring ; long ret , serial ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; old = current_cred ( ) ; if ( ! name ) { ret = install_session_keyring_to_cred ( new , NULL ) ; if ( ret < 0 ) goto error ; serial = new -> session_keyring -> serial ; ret = commit_creds ( new ) ; if ( ret == 0 ) ret = serial ; goto okay ; } mutex_lock ( & key_session_mutex ) ; keyring = find_keyring_by_name ( name , false ) ; if ( PTR_ERR ( keyring ) == - ENOKEY ) { keyring = keyring_alloc ( name , old -> uid , old -> gid , old , KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } } else if ( IS_ERR ( keyring ) ) { ret = PTR_ERR ( keyring ) ; goto error2 ; } else if ( keyring == new -> session_keyring ) { <S2SV_StartBug> ret = 0 ; <S2SV_EndBug> goto error2 ; } ret = install_session_keyring_to_cred ( new , keyring ) ; if ( ret < 0 ) goto error2 ; commit_creds ( new ) ; mutex_unlock ( & key_session_mutex ) ; ret = keyring -> serial ; key_put ( keyring ) ; okay : return ret ; error2 : mutex_unlock ( & key_session_mutex ) ; error : abort_creds ( new ) ; return ret ; }
","<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
",torvalds@linux/23567fd052a9abb6d67fe8e7a9ccdd9800a540f2,CVE-2016-0728,https://github.com/torvalds/linux/commit/23567fd052a9abb6d67fe8e7a9ccdd9800a540f2,2016-02-08T03:59Z
CWE-119,"CWE-119 EAS_BOOL WT_CheckSampleEnd ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame , EAS_BOOL update ) { EAS_U32 endPhaseAccum ; EAS_U32 endPhaseFrac ; EAS_I32 numSamples ; EAS_BOOL done = EAS_FALSE ; endPhaseFrac = pWTVoice -> phaseFrac + ( pWTIntFrame -> frame . phaseIncrement << SYNTH_UPDATE_PERIOD_IN_BITS ) ; endPhaseAccum = pWTVoice -> phaseAccum + GET_PHASE_INT_PART ( endPhaseFrac ) ; if ( endPhaseAccum >= pWTVoice -> loopEnd ) { numSamples = ( EAS_I32 ) ( pWTVoice -> loopEnd - pWTVoice -> phaseAccum ) ; numSamples = ( EAS_I32 ) ( ( numSamples << NUM_PHASE_FRAC_BITS ) - pWTVoice -> phaseFrac ) ; if ( pWTIntFrame -> frame . phaseIncrement ) { pWTIntFrame -> numSamples = 1 + ( numSamples / pWTIntFrame -> frame . phaseIncrement ) ; } else { pWTIntFrame -> numSamples = numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( ""b/26366256"" ) ; <S2SV_StartBug> pWTIntFrame -> numSamples = 0 ; <S2SV_EndBug> } done = EAS_TRUE ; } if ( update ) { pWTVoice -> phaseFrac = endPhaseFrac ; pWTVoice -> phaseAccum = endPhaseAccum ; } return done ; }
","<S2SV_ModStart> ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256"" ) ;
",external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf,2016-04-18T00:59Z
CWE-125,"CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>[|pgm]"" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , tcpport_string ( ndo , sport ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } else { if ( ip -> ip_p == IPPROTO_PGM ) { ND_PRINT ( ( ndo , ""%s.%s<S2SV_blank>><S2SV_blank>%s.%s:<S2SV_blank>"" , ipaddr_string ( ndo , & ip -> ip_src ) , tcpport_string ( ndo , sport ) , ipaddr_string ( ndo , & ip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ) ; } else { ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s:<S2SV_blank>"" , tcpport_string ( ndo , sport ) , tcpport_string ( ndo , dport ) ) ) ; } } ND_TCHECK ( * pgm ) ; ND_PRINT ( ( ndo , ""PGM,<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_PRINT ( ( ndo , ""<S2SV_blank>0x%02x%02x%02x%02x%02x%02x<S2SV_blank>"" , pgm -> pgm_gsid [ 0 ] , pgm -> pgm_gsid [ 1 ] , pgm -> pgm_gsid [ 2 ] , pgm -> pgm_gsid [ 3 ] , pgm -> pgm_gsid [ 4 ] , pgm -> pgm_gsid [ 5 ] ) ) ; switch ( pgm -> pgm_type ) { case PGM_SPM : { const struct pgm_spm * spm ; spm = ( const struct pgm_spm * ) ( pgm + 1 ) ; ND_TCHECK ( * spm ) ; bp = ( const u_char * ) ( spm + 1 ) ; switch ( EXTRACT_16BITS ( & spm -> pgms_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""SPM<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>lead<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s"" , EXTRACT_32BITS ( & spm -> pgms_seq ) , EXTRACT_32BITS ( & spm -> pgms_trailseq ) , EXTRACT_32BITS ( & spm -> pgms_leadseq ) , nla_buf ) ) ; break ; } case PGM_POLL : { const struct pgm_poll * poll_msg ; poll_msg = ( const struct pgm_poll * ) ( pgm + 1 ) ; ND_TCHECK ( * poll_msg ) ; ND_PRINT ( ( ndo , ""POLL<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u"" , EXTRACT_32BITS ( & poll_msg -> pgmp_seq ) , EXTRACT_16BITS ( & poll_msg -> pgmp_round ) ) ) ; bp = ( const u_char * ) ( poll_msg + 1 ) ; break ; } case PGM_POLR : { const struct pgm_polr * polr ; uint32_t ivl , rnd , mask ; polr = ( const struct pgm_polr * ) ( pgm + 1 ) ; ND_TCHECK ( * polr ) ; bp = ( const u_char * ) ( polr + 1 ) ; switch ( EXTRACT_16BITS ( & polr -> pgmp_nla_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; ivl = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; rnd = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_TCHECK2 ( * bp , sizeof ( uint32_t ) ) ; mask = EXTRACT_32BITS ( bp ) ; bp += sizeof ( uint32_t ) ; ND_PRINT ( ( ndo , ""POLR<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>round<S2SV_blank>%u<S2SV_blank>nla<S2SV_blank>%s<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>rnd<S2SV_blank>0x%08x<S2SV_blank>"" ""mask<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & polr -> pgmp_seq ) , EXTRACT_16BITS ( & polr -> pgmp_round ) , nla_buf , ivl , rnd , mask ) ) ; break ; } case PGM_ODATA : { const struct pgm_data * odata ; odata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * odata ) ; ND_PRINT ( ( ndo , ""ODATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & odata -> pgmd_trailseq ) , EXTRACT_32BITS ( & odata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( odata + 1 ) ; break ; } case PGM_RDATA : { const struct pgm_data * rdata ; rdata = ( const struct pgm_data * ) ( pgm + 1 ) ; ND_TCHECK ( * rdata ) ; ND_PRINT ( ( ndo , ""RDATA<S2SV_blank>trail<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & rdata -> pgmd_trailseq ) , EXTRACT_32BITS ( & rdata -> pgmd_seq ) ) ) ; bp = ( const u_char * ) ( rdata + 1 ) ; break ; } case PGM_NAK : case PGM_NULLNAK : case PGM_NCF : { const struct pgm_nak * nak ; char source_buf [ INET6_ADDRSTRLEN ] , group_buf [ INET6_ADDRSTRLEN ] ; nak = ( const struct pgm_nak * ) ( pgm + 1 ) ; ND_TCHECK ( * nak ) ; bp = ( const u_char * ) ( nak + 1 ) ; switch ( EXTRACT_16BITS ( & nak -> pgmn_source_afi ) ) { case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , source_buf , sizeof ( source_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } bp += ( 2 * sizeof ( uint16_t ) ) ; <S2SV_StartBug> switch ( EXTRACT_16BITS ( bp ) ) { <S2SV_EndBug> case AFNUM_INET : ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , group_buf , sizeof ( group_buf ) ) ; bp += sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } switch ( pgm -> pgm_type ) { case PGM_NAK : ND_PRINT ( ( ndo , ""NAK<S2SV_blank>"" ) ) ; break ; case PGM_NULLNAK : ND_PRINT ( ( ndo , ""NNAK<S2SV_blank>"" ) ) ; break ; case PGM_NCF : ND_PRINT ( ( ndo , ""NCF<S2SV_blank>"" ) ) ; break ; default : break ; } ND_PRINT ( ( ndo , ""(%s<S2SV_blank>-><S2SV_blank>%s),<S2SV_blank>seq<S2SV_blank>%u"" , source_buf , group_buf , EXTRACT_32BITS ( & nak -> pgmn_seq ) ) ) ; break ; } case PGM_ACK : { const struct pgm_ack * ack ; ack = ( const struct pgm_ack * ) ( pgm + 1 ) ; ND_TCHECK ( * ack ) ; ND_PRINT ( ( ndo , ""ACK<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( & ack -> pgma_rx_max_seq ) ) ) ; bp = ( const u_char * ) ( ack + 1 ) ; break ; } case PGM_SPMR : ND_PRINT ( ( ndo , ""SPMR"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""UNKNOWN<S2SV_blank>type<S2SV_blank>0x%02x"" , pgm -> pgm_type ) ) ; break ; } if ( pgm -> pgm_options & PGM_OPT_BIT_PRESENT ) { if ( ! ND_TTEST2 ( * bp , PGM_MIN_OPT_LEN ) ) { ND_PRINT ( ( ndo , ""[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; if ( ( opt_type & PGM_OPT_MASK ) != PGM_OPT_LENGTH ) { ND_PRINT ( ( ndo , ""[First<S2SV_blank>option<S2SV_blank>bad,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>PGM_OPT_LENGTH,<S2SV_blank>is<S2SV_blank>%u]"" , opt_type & PGM_OPT_MASK ) ) ; return ; } opt_len = * bp ++ ; if ( opt_len != 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>4]"" , opt_len ) ) ; return ; } opts_len = EXTRACT_16BITS ( bp ) ; if ( opts_len < 4 ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>4]"" , opts_len ) ) ; return ; } bp += sizeof ( uint16_t ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>%d"" , opts_len ) ) ; opts_len -= 4 ; while ( opts_len ) { if ( opts_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } opt_type = * bp ++ ; opt_len = * bp ++ ; if ( opt_len < PGM_MIN_OPT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_MIN_OPT_LEN ) ) ; break ; } if ( opts_len < opt_len ) { ND_PRINT ( ( ndo , ""[Total<S2SV_blank>option<S2SV_blank>length<S2SV_blank>leaves<S2SV_blank>no<S2SV_blank>room<S2SV_blank>for<S2SV_blank>final<S2SV_blank>option]"" ) ) ; return ; } if ( ! ND_TTEST2 ( * bp , opt_len - 2 ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[|OPT]"" ) ) ; return ; } switch ( opt_type & PGM_OPT_MASK ) { case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , ""<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FRAGMENT_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u"" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NAK<S2SV_blank>LIST"" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , ""[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]"" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 ; opts_len -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_JOIN_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>JOIN<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_IVL_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) if ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NAK_BO_RNG_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u"" , offset , seq ) ) ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , PGM_OPT_REDIRECT_FIXED_LEN , opt_len ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>REDIRECT<S2SV_blank>%s"" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u"" , seq ) ) ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u"" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>NBR_UNREACH"" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , ""<S2SV_blank>PATH_NLA<S2SV_blank>[%d]"" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>SYN"" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>FIN"" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>RST"" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , ""<S2SV_blank>CR"" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]"" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , ""<S2SV_blank>CRQST"" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]"" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>PGMCC<S2SV_blank>FEEDBACK<S2SV_blank>%u<S2SV_blank>%s"" , offset , nla_buf ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>OPT_%02X<S2SV_blank>[%d]<S2SV_blank>"" , opt_type , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; } if ( opt_type & PGM_OPT_END ) break ; } } ND_PRINT ( ( ndo , ""<S2SV_blank>[%u]"" , length ) ) ; if ( ndo -> ndo_packettype == PT_PGM_ZMTP1 && ( pgm -> pgm_type == PGM_ODATA || pgm -> pgm_type == PGM_RDATA ) ) zmtp1_print_datagram ( ndo , bp , EXTRACT_16BITS ( & pgm -> pgm_length ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|pgm]"" ) ) ; if ( ch != '\\0' ) ND_PRINT ( ( ndo , "">"" ) ) ; }
","<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> ) ) ; } return ; <S2SV_ModEnd> } sport = <S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( bp ) ;
",the-tcpdump-group@tcpdump/da6f1a677bfa4476abaeaf9b1afe1c4390f51b41,CVE-2017-13034,https://github.com/the-tcpdump-group/tcpdump/commit/da6f1a677bfa4476abaeaf9b1afe1c4390f51b41,2017-09-14T06:29Z
CWE-119,"CWE-119 <S2SV_StartBug> int fourcc_is_ivf ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , ""DKIF"" , 4 ) == 0 ) { return 1 ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 * p_data_written , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <S2SV_StartBug> OPJ_UNUSED ( p_manager ) ; <S2SV_EndBug> if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , ""Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n"" ) ; return OPJ_FALSE ; } opj_write_bytes ( p_data , J2K_MS_SOT , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && ""TODO"" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }
","<S2SV_ModStart> p_stream ) ; <S2SV_ModEnd> if ( p_total_data_size
",uclouvain@openjpeg/c535531f03369623b9b833ef41952c62257b507e,CVE-2017-14039,https://github.com/uclouvain/openjpeg/commit/c535531f03369623b9b833ef41952c62257b507e,2017-08-30T22:29Z
CWE-264,"CWE-264 int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; <S2SV_StartBug> int ret ; <S2SV_EndBug> if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }
","<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
",torvalds@linux/3151527ee007b73a0ebd296010f1c0454a919c7d,CVE-2013-1956,https://github.com/torvalds/linux/commit/3151527ee007b73a0ebd296010f1c0454a919c7d,2013-04-24T19:55Z
CWE-119,"CWE-119 static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( ""Save"" ) , NULL , ""*.{txt,py}"" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , ""w"" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file"" ) , _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s"" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
",fontforge@fontforge/626f751752875a0ddd74b9e217b6f4828713573c,CVE-2019-15785,https://github.com/fontforge/fontforge/commit/626f751752875a0ddd74b9e217b6f4828713573c,2019-08-29T13:15Z
CWE-125,"CWE-125 static char * get_icu_value_internal ( const char * loc_name , char * tag_name , int * result , int fromParseLocale ) { char * tag_value = NULL ; int32_t tag_value_len = 512 ; int singletonPos = 0 ; char * mod_loc_name = NULL ; int grOffset = 0 ; int32_t buflen = 512 ; UErrorCode status = U_ZERO_ERROR ; if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) != 0 ) { grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ; if ( grOffset >= 0 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { return estrdup ( loc_name ) ; } else { return NULL ; } } if ( fromParseLocale == 1 ) { if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { if ( strlen ( loc_name ) > 1 && ( isIDPrefix ( loc_name ) == 1 ) ) { return estrdup ( loc_name ) ; } } singletonPos = getSingletonPos ( loc_name ) ; if ( singletonPos == 0 ) { return NULL ; } else if ( singletonPos > 0 ) { mod_loc_name = estrndup ( loc_name , singletonPos - 1 ) ; } } } if ( mod_loc_name == NULL ) { mod_loc_name = estrdup ( loc_name ) ; } do { tag_value = erealloc ( tag_value , buflen ) ; tag_value_len = buflen ; if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) { buflen = uloc_getScript ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) { buflen = uloc_getLanguage ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) { buflen = uloc_getCountry ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) { buflen = uloc_getVariant ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) == 0 ) { buflen = uloc_canonicalize ( mod_loc_name , tag_value , tag_value_len , & status ) ; } if ( U_FAILURE ( status ) ) { if ( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR ; <S2SV_StartBug> continue ; <S2SV_EndBug> } * result = 0 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } } while ( buflen > tag_value_len ) ; if ( buflen == 0 ) { * result = - 1 ; if ( tag_value ) { efree ( tag_value ) ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return NULL ; } else { * result = 1 ; } if ( mod_loc_name ) { efree ( mod_loc_name ) ; } return tag_value ; }
","<S2SV_ModStart> = U_ZERO_ERROR ; buflen ++ ;
",php@php-src/97eff7eb57fc2320c267a949cffd622c38712484,CVE-2016-5093,https://github.com/php/php-src/commit/97eff7eb57fc2320c267a949cffd622c38712484,2016-08-07T10:59Z
CWE-125,"CWE-125 static ssize_t parse8BIM ( Image * ifile , Image * ofile ) { char brkused , quoted , * line , * token , * newstr , * name ; int state , next ; unsigned char dataset ; unsigned int recnum ; int inputlen = MagickPathExtent ; MagickOffsetType savedpos , currentpos ; ssize_t savedolen = 0L , outputlen = 0L ; TokenInfo * token_info ; dataset = 0 ; recnum = 0 ; line = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * line ) ) ; if ( line == ( char * ) NULL ) return ( - 1 ) ; newstr = name = token = ( char * ) NULL ; savedpos = 0 ; token_info = AcquireTokenInfo ( ) ; while ( super_fgets ( & line , & inputlen , ifile ) != NULL ) { state = 0 ; next = 0 ; token = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * token ) ) ; if ( token == ( char * ) NULL ) break ; newstr = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * newstr ) ) ; if ( newstr == ( char * ) NULL ) break ; while ( Tokenizer ( token_info , 0 , token , ( size_t ) inputlen , line , """" , ""="" , ""\\"""" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( state == 0 ) { int state , next ; char brkused , quoted ; state = 0 ; next = 0 ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""#"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { switch ( state ) { case 0 : if ( strcmp ( newstr , ""8BIM"" ) == 0 ) dataset = 255 ; else dataset = ( unsigned char ) StringToLong ( newstr ) ; break ; case 1 : recnum = ( unsigned int ) StringToUnsignedLong ( newstr ) ; break ; case 2 : name = ( char * ) AcquireQuantumMemory ( strlen ( newstr ) + MagickPathExtent , sizeof ( * name ) ) ; if ( name ) ( void ) strcpy ( name , newstr ) ; break ; } state ++ ; } } else if ( state == 1 ) { int next ; ssize_t len ; char brkused , quoted ; next = 0 ; len = ( ssize_t ) strlen ( token ) ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""&"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( brkused && next > 0 ) { char * s = & token [ next - 1 ] ; len -= ( ssize_t ) convertHTMLcodes ( s , ( int ) strlen ( s ) ) ; } } if ( dataset == 255 ) { unsigned char nlen = 0 ; int i ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } ( void ) WriteBlobString ( ofile , ""8BIM"" ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) recnum ) ; outputlen += 6 ; if ( name ) nlen = ( unsigned char ) strlen ( name ) ; ( void ) WriteBlobByte ( ofile , nlen ) ; outputlen ++ ; for ( i = 0 ; i < nlen ; i ++ ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) name [ i ] ) ; outputlen += nlen ; if ( ( nlen & 0x01 ) == 0 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } if ( recnum != IPTC_ID ) { ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) len ) ; outputlen += 4 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } } else { savedpos = TellBlob ( ofile ) ; if ( savedpos < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , 0xFFFFFFFFU ) ; outputlen += 4 ; savedolen = outputlen ; } } else { if ( len <= 0x7FFF ) { ( void ) WriteBlobByte ( ofile , 0x1c ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) dataset ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) ( recnum & 0xff ) ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) len ) ; outputlen += 5 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; } } } state ++ ; } if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; } token_info = DestroyTokenInfo ( token_info ) ; if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; line = DestroyString ( line ) ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } return outputlen ; }
","<S2SV_ModStart> ( len -- > 0 <S2SV_ModStart> ( len -- > 0
",ImageMagick@ImageMagick/f8c318d462270b03e77f082e2a3a32867cacd3c6,CVE-2016-7524,https://github.com/ImageMagick/ImageMagick/commit/f8c318d462270b03e77f082e2a3a32867cacd3c6,2020-02-06T14:15Z
CWE-125,"CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , ""(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>"" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
","<S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> p + offset <S2SV_ModEnd> , tim .
",the-tcpdump-group@tcpdump/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,CVE-2017-13008,https://github.com/the-tcpdump-group/tcpdump/commit/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562,2017-09-14T06:29Z
CWE-125,"CWE-125 void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)<S2SV_blank>v%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : <S2SV_StartBug> type = * ( tptr ) ; <S2SV_EndBug> len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>len<S2SV_blank>%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { <S2SV_StartBug> subtype = * ( tptr + 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>Type<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_StartBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + 4 ) ) , <S2SV_EndBug> * ( tptr + 4 ) ) ) ; switch ( subtype ) { case EAP_TYPE_IDENTITY : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Identity:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NOTIFICATION : if ( len - 5 > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Notification:<S2SV_blank>"" ) ) ; safeputs ( ndo , tptr + 5 , len - 5 ) ; } break ; case EAP_TYPE_NAK : count = 5 ; while ( count < len ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>(%u),"" , <S2SV_EndBug> tok2str ( eap_type_values , ""unknown"" , * ( tptr + count ) ) , * ( tptr + count ) ) ) ; count ++ ; } break ; case EAP_TYPE_TTLS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>TTLSv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; <S2SV_StartBug> case EAP_TYPE_TLS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_FAST : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>FASTv%u"" , <S2SV_EndBug> EAP_TTLS_VERSION ( * ( tptr + 5 ) ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , bittok2str ( eap_tls_flags_values , ""none"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; if ( EAP_TLS_EXTRACT_BIT_L ( * ( tptr + 5 ) ) ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr + 6 ) ) ) ; <S2SV_EndBug> } break ; case EAP_TYPE_AKA : case EAP_TYPE_SIM : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>subtype<S2SV_blank>[%s]<S2SV_blank>0x%02x,"" , <S2SV_EndBug> tok2str ( eap_aka_subtype_values , ""unknown"" , * ( tptr + 5 ) ) , * ( tptr + 5 ) ) ) ; break ; case EAP_TYPE_MD5_CHALLENGE : case EAP_TYPE_OTP : case EAP_TYPE_GTC : case EAP_TYPE_EXPANDED_TYPES : case EAP_TYPE_EXPERIMENTAL : default : break ; } } break ; case EAP_FRAME_TYPE_LOGOFF : case EAP_FRAME_TYPE_ENCAP_ASF_ALERT : default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|EAP]"" ) ) ; }
","<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , ""unknown"" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
",the-tcpdump-group@tcpdump/985122081165753c7442bd7824c473eb9ff56308,CVE-2017-13015,https://github.com/the-tcpdump-group/tcpdump/commit/985122081165753c7442bd7824c473eb9ff56308,2017-09-14T06:29Z
CWE-264,"CWE-264 <S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> int ret = 0 ; const char * name ; char * command = NULL ; name = lsm_name ( ) ; if ( strcmp ( name , ""nop"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""none"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ; <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ; } else { labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ; } if ( labelfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } if ( strcmp ( name , ""AppArmor"" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( ""changeprofile<S2SV_blank>"" ) + 1 ) ; if ( ! command ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } size = sprintf ( command , ""changeprofile<S2SV_blank>%s"" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } } else { ERROR ( ""Unable<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>label<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>LSM:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } out : free ( command ) ; <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec <S2SV_ModStart> * lsm_label ) { int fret <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; const char <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ( write ( lsm_labelfd <S2SV_ModEnd> , command , <S2SV_ModStart> { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> { ERROR ( <S2SV_ModStart> name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free <S2SV_ModStart> ; if ( lsm_labelfd <S2SV_ModEnd> != - 1 <S2SV_ModStart> ) close ( lsm_labelfd <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
",lxc@lxc/81f466d05f2a89cb4f122ef7f593ff3f279b165c,CVE-2016-8649,https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c,2017-05-01T06:59Z
CWE-125,"CWE-125 <S2SV_StartBug> void ntlm_write_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> MaxLen < 1 ) fields -> MaxLen = fields -> Len ; Stream_Write_UINT16 ( s , fields -> Len ) ; Stream_Write_UINT16 ( s , fields -> MaxLen ) ; Stream_Write_UINT32 ( s , fields -> BufferOffset ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
CWE-189,"CWE-189 static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; ASSERT ( apic != NULL ) ; <S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) ; return tmcct ; }
","<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
",torvalds@linux/b963a22e6d1a266a67e9eecc88134713fd54775c,CVE-2013-6367,https://github.com/torvalds/linux/commit/b963a22e6d1a266a67e9eecc88134713fd54775c,2013-12-14T18:08Z
CWE-787,"CWE-787 static int input_default_setkeycode ( struct input_dev * dev , const struct input_keymap_entry * ke , unsigned int * old_keycode ) { unsigned int index ; int error ; int i ; if ( ! dev -> keycodesize ) return - EINVAL ; if ( ke -> flags & INPUT_KEYMAP_BY_INDEX ) { index = ke -> index ; } else { error = input_scancode_to_scalar ( ke , & index ) ; if ( error ) return error ; } if ( index >= dev -> keycodemax ) return - EINVAL ; if ( dev -> keycodesize < sizeof ( ke -> keycode ) && ( ke -> keycode >> ( dev -> keycodesize * 8 ) ) ) return - EINVAL ; switch ( dev -> keycodesize ) { case 1 : { u8 * k = ( u8 * ) dev -> keycode ; * old_keycode = k [ index ] ; k [ index ] = ke -> keycode ; break ; } case 2 : { u16 * k = ( u16 * ) dev -> keycode ; * old_keycode = k [ index ] ; k [ index ] = ke -> keycode ; break ; } default : { u32 * k = ( u32 * ) dev -> keycode ; * old_keycode = k [ index ] ; k [ index ] = ke -> keycode ; break ; } } <S2SV_StartBug> __clear_bit ( * old_keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> __set_bit ( ke -> keycode , dev -> keybit ) ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { <S2SV_EndBug> if ( input_fetch_keycode ( dev , i ) == * old_keycode ) { __set_bit ( * old_keycode , dev -> keybit ) ; break ; } } return 0 ; }
","<S2SV_ModStart> ; } } if ( * old_keycode <= KEY_MAX ) { <S2SV_ModStart> keybit ) ; for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { if ( input_fetch_keycode ( dev , i ) == * old_keycode ) { __set_bit ( * old_keycode <S2SV_ModEnd> , dev -> <S2SV_ModStart> keybit ) ; break ; } } } __set_bit ( ke -> keycode , dev -> keybit ) ; return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/cb222aed03d798fc074be55e59d9a112338ee784,CVE-2019-20636,https://github.com/torvalds/linux/commit/cb222aed03d798fc074be55e59d9a112338ee784,2020-04-08T14:15Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_accm_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""send=%08x<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""recv=%08x<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-20,"CWE-20 int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( handle && ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; <S2SV_StartBug> if ( sbi -> s_journal && ! handle ) <S2SV_EndBug> goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
","<S2SV_ModStart> ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> ! handle )
",torvalds@linux/c9b92530a723ac5ef8e352885a1862b18f31b2f5,CVE-2015-7509,https://github.com/torvalds/linux/commit/c9b92530a723ac5ef8e352885a1862b18f31b2f5,2015-12-28T11:59Z
CWE-787,"CWE-787 static inline int l2cap_config_rsp ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u8 * data ) { struct l2cap_conf_rsp * rsp = ( struct l2cap_conf_rsp * ) data ; u16 scid , flags , result ; struct sock * sk ; scid = __le16_to_cpu ( rsp -> scid ) ; flags = __le16_to_cpu ( rsp -> flags ) ; result = __le16_to_cpu ( rsp -> result ) ; BT_DBG ( ""scid<S2SV_blank>0x%4.4x<S2SV_blank>flags<S2SV_blank>0x%2.2x<S2SV_blank>result<S2SV_blank>0x%2.2x"" , scid , flags , result ) ; sk = l2cap_get_chan_by_scid ( & conn -> chan_list , scid ) ; if ( ! sk ) return 0 ; switch ( result ) { case L2CAP_CONF_SUCCESS : break ; case L2CAP_CONF_UNACCEPT : <S2SV_StartBug> if ( ++ l2cap_pi ( sk ) -> conf_retry < L2CAP_CONF_MAX_RETRIES ) { <S2SV_EndBug> char req [ 128 ] ; <S2SV_StartBug> l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , <S2SV_EndBug> l2cap_build_conf_req ( sk , req ) , req ) ; <S2SV_StartBug> goto done ; <S2SV_EndBug> } default : sk -> sk_state = BT_DISCONN ; sk -> sk_err = ECONNRESET ; l2cap_sock_set_timer ( sk , HZ * 5 ) ; { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } goto done ; } if ( flags & 0x01 ) goto done ; l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_INPUT_DONE ; if ( l2cap_pi ( sk ) -> conf_state & L2CAP_CONF_OUTPUT_DONE ) { sk -> sk_state = BT_CONNECTED ; l2cap_chan_ready ( sk ) ; } done : bh_unlock_sock ( sk ) ; return 0 ; }
","<S2SV_ModStart> : if ( l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) { int len = cmd -> len - sizeof ( * rsp ) ; char req [ 64 ] ; result = L2CAP_CONF_SUCCESS ; len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ; if ( len < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) <S2SV_ModEnd> ; l2cap_send_cmd ( <S2SV_ModStart> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & <S2SV_ModEnd> req ) ; <S2SV_ModStart> ; goto done ; } l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ; if ( result != L2CAP_CONF_SUCCESS ) goto done ; break
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z
CWE-476,"CWE-476 static gint dissect_ac_if_hdr_body ( tvbuff_t * tvb , gint offset , packet_info * pinfo _U_ , proto_tree * tree , usb_conv_info_t * usb_conv_info ) { gint offset_start ; guint16 bcdADC ; guint8 ver_major ; double ver ; guint8 if_in_collection , i ; audio_conv_info_t * audio_conv_info ; offset_start = offset ; bcdADC = tvb_get_letohs ( tvb , offset ) ; ver_major = USB_AUDIO_BCD44_TO_DEC ( bcdADC >> 8 ) ; ver = ver_major + USB_AUDIO_BCD44_TO_DEC ( bcdADC & 0xFF ) / 100.0 ; proto_tree_add_double_format_value ( tree , hf_ac_if_hdr_ver , tvb , offset , 2 , ver , ""%2.2f"" , ver ) ; audio_conv_info = ( audio_conv_info_t * ) usb_conv_info -> class_data ; if ( ! audio_conv_info ) { audio_conv_info = wmem_new ( wmem_file_scope ( ) , audio_conv_info_t ) ; usb_conv_info -> class_data = audio_conv_info ; <S2SV_StartBug> } <S2SV_EndBug> audio_conv_info -> ver_major = ver_major ; offset += 2 ; if ( ver_major == 1 ) { proto_tree_add_item ( tree , hf_ac_if_hdr_total_len , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; if_in_collection = tvb_get_guint8 ( tvb , offset ) ; proto_tree_add_item ( tree , hf_ac_if_hdr_bInCollection , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; for ( i = 0 ; i < if_in_collection ; i ++ ) { proto_tree_add_item ( tree , hf_ac_if_hdr_if_num , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; offset ++ ; } } return offset - offset_start ; }
","<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z
CWE-125,"CWE-125 SECURITY_STATUS ntlm_read_NegotiateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) { wStream * s ; size_t length ; NTLM_NEGOTIATE_MESSAGE * message ; message = & context -> NEGOTIATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_NEGOTIATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_NEGOTIATE ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } <S2SV_StartBug> Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; <S2SV_EndBug> if ( ! ( ( message -> NegotiateFlags & NTLMSSP_REQUEST_TARGET ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) && ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) ) ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } context -> NegotiateFlags = message -> NegotiateFlags ; if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } length = Stream_GetPosition ( s ) ; buffer -> cbBuffer = length ; if ( ! sspi_SecBufferAlloc ( & context -> NegotiateMessage , length ) ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> NegotiateMessage . pvBuffer , buffer -> pvBuffer , buffer -> cbBuffer ) ; context -> NegotiateMessage . BufferType = buffer -> BufferType ; # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""NEGOTIATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> NegotiateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> NegotiateMessage . pvBuffer , context -> NegotiateMessage . cbBuffer ) ; ntlm_print_negotiate_flags ( message -> NegotiateFlags ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; # endif context -> state = NTLM_STATE_CHALLENGE ; Stream_Free ( s , FALSE ) ; return SEC_I_CONTINUE_NEEDED ; }
","<S2SV_ModStart> SEC_E_INVALID_TOKEN ; } if ( Stream_GetRemainingLength ( s ) < 4 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; }
",FreeRDP@FreeRDP/8fa38359634a9910b91719818ab02f23c320dbae,CVE-2020-11088,https://github.com/FreeRDP/FreeRDP/commit/8fa38359634a9910b91719818ab02f23c320dbae,2020-05-29T20:15Z
CWE-704,"CWE-704 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
","<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
",torvalds@linux/966031f340185eddd05affcf72b740549f056348,CVE-2018-18386,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,2018-10-17T20:29Z
CWE-59,"CWE-59 static gchar * read_file ( gchar * filepath ) { FILE * f ; size_t length ; gchar * ret = NULL ; <S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ; fseek ( f , 0 , SEEK_SET ) ; ret = MALLOC ( length + 1 ) ; if ( ret ) { if ( fread ( ret , length , 1 , f ) != 1 ) { log_message ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>of<S2SV_blank>%s"" , filepath ) ; } ret [ length ] = '\\0' ; } else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>Dbus<S2SV_blank>file<S2SV_blank>%s"" , filepath ) ; fclose ( f ) ; } return ret ; }
","<S2SV_ModStart> ( filepath , ""r"" <S2SV_ModEnd> ) ; if
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
CWE-125,"CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } if ( ( ps = Ta3Parser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; Ta3Tokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; int col_offset ; type = Ta3Tokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; <S2SV_StartBug> len = b - a ; <S2SV_EndBug> str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""!="" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , ""<>"" ) ) { PyObject_FREE ( str ) ; <S2SV_StartBug> err_ret -> text = ""with<S2SV_blank>Barry<S2SV_blank>as<S2SV_blank>BDFL,<S2SV_blank>use<S2SV_blank>\'<>\'<S2SV_blank>"" <S2SV_EndBug> ""instead<S2SV_blank>of<S2SV_blank>\'!=\'"" ; err_ret -> error = E_SYNTAX ; break ; } } # endif <S2SV_StartBug> if ( a >= tok -> line_start ) <S2SV_EndBug> col_offset = Py_SAFE_DOWNCAST ( a - tok -> line_start , intptr_t , int ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> col_offset = - 1 ; <S2SV_EndBug> if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( ( err_ret -> error = Ta3Parser_AddToken ( ps , ( int ) type , str , tok -> lineno , col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; ps -> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { Ta3Node_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores ) ; # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; Ta3Node_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif Ta3Parser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = ( int ) ( tok -> cur - tok -> buf ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = Ta3Node_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : Ta3Tokenizer_Free ( tok ) ; return n ; }
","<S2SV_ModStart> ; len = ( a != NULL && b != NULL ) ? <S2SV_ModStart> b - a : 0 <S2SV_ModStart> ; err_ret -> expected = NOTEQUAL <S2SV_ModEnd> ; err_ret -> <S2SV_ModStart> if ( a != NULL && a <S2SV_ModStart> -> line_start ) { <S2SV_ModStart> int ) ; } else { <S2SV_ModEnd> col_offset = - <S2SV_ModStart> - 1 ; }
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-399,"CWE-399 int cib_connect ( gboolean full ) { int rc = pcmk_ok ; static gboolean need_pass = TRUE ; CRM_CHECK ( cib != NULL , return - EINVAL ) ; if ( getenv ( ""CIB_passwd"" ) != NULL ) { need_pass = FALSE ; } if ( watch_fencing && st == NULL ) { st = stonith_api_new ( ) ; } if ( watch_fencing && st -> state == stonith_disconnected ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>stonith"" ) ; rc = st -> cmds -> connect ( st , crm_system_name , NULL ) ; if ( rc == pcmk_ok ) { crm_trace ( ""Setting<S2SV_blank>up<S2SV_blank>stonith<S2SV_blank>callbacks"" ) ; st -> cmds -> register_notification ( st , T_STONITH_NOTIFY_FENCE , mon_st_callback ) ; } } if ( cib -> state != cib_connected_query && cib -> state != cib_connected_command ) { crm_trace ( ""Connecting<S2SV_blank>to<S2SV_blank>the<S2SV_blank>CIB"" ) ; if ( as_console && need_pass && cib -> variant == cib_remote ) { need_pass = FALSE ; print_as ( ""Password:"" ) ; } rc = cib -> cmds -> signon ( cib , crm_system_name , cib_query ) ; if ( rc != pcmk_ok ) { return rc ; } current_cib = get_cib_copy ( cib ) ; mon_refresh_display ( NULL ) ; if ( full ) { if ( rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) { <S2SV_StartBug> print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" ) ; <S2SV_EndBug> if ( as_console ) { sleep ( 2 ) ; } rc = pcmk_ok ; } } if ( rc == pcmk_ok ) { cib -> cmds -> del_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; rc = cib -> cmds -> add_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update ) ; } if ( rc != pcmk_ok ) { print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>failed,<S2SV_blank>could<S2SV_blank>not<S2SV_blank>monitor<S2SV_blank>CIB<S2SV_blank>actions"" ) ; if ( as_console ) { sleep ( 2 ) ; } clean_up ( - rc ) ; } } } return rc ; }
","<S2SV_ModStart> { print_as ( ""Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure"" <S2SV_ModEnd> ) ; if
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
CWE-125,"CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo<S2SV_blank>%s,<S2SV_blank>id<S2SV_blank>%u,<S2SV_blank>seq<S2SV_blank>%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , dp -> icmp_ip . ip_p ) ; break ; case ICMP_UNREACH_PORT : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; oip = & dp -> icmp_ip ; hlen = IP_HL ( oip ) * 4 ; ouh = ( const struct udphdr * ) ( ( ( const u_char * ) oip ) + hlen ) ; ND_TCHECK ( ouh -> uh_dport ) ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( oip -> ip_p ) { case IPPROTO_TCP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , tcpport_string ( ndo , dport ) ) ; break ; case IPPROTO_UDP : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , udpport_string ( ndo , dport ) ) ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ipaddr_string ( ndo , & oip -> ip_dst ) , oip -> ip_p , dport ) ; break ; } break ; case ICMP_UNREACH_NEEDFRAG : { register const struct mtu_discovery * mp ; mp = ( const struct mtu_discovery * ) ( const u_char * ) & dp -> icmp_void ; mtu = EXTRACT_16BITS ( & mp -> nexthopmtu ) ; if ( mtu ) { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag<S2SV_blank>(mtu<S2SV_blank>%d)"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , mtu ) ; } else { ( void ) snprintf ( buf , sizeof ( buf ) , ""%s<S2SV_blank>unreachable<S2SV_blank>-<S2SV_blank>need<S2SV_blank>to<S2SV_blank>frag"" , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; } } break ; default : fmt = tok2str ( unreach2str , ""#%d<S2SV_blank>%%s<S2SV_blank>unreachable"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) ) ; break ; } break ; case ICMP_REDIRECT : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; fmt = tok2str ( type2str , ""redirect-#%d<S2SV_blank>%%s<S2SV_blank>to<S2SV_blank>net<S2SV_blank>%%s"" , dp -> icmp_code ) ; ( void ) snprintf ( buf , sizeof ( buf ) , fmt , ipaddr_string ( ndo , & dp -> icmp_ip . ip_dst ) , ipaddr_string ( ndo , & dp -> icmp_gwaddr ) ) ; break ; case ICMP_ROUTERADVERT : { register const struct ih_rdiscovery * ihp ; register const struct id_rdiscovery * idp ; u_int lifetime , num , size ; ( void ) snprintf ( buf , sizeof ( buf ) , ""router<S2SV_blank>advertisement"" ) ; cp = buf + strlen ( buf ) ; ihp = ( const struct ih_rdiscovery * ) & dp -> icmp_void ; ND_TCHECK ( * ihp ) ; ( void ) strncpy ( cp , ""<S2SV_blank>lifetime<S2SV_blank>"" , sizeof ( buf ) - ( cp - buf ) ) ; cp = buf + strlen ( buf ) ; lifetime = EXTRACT_16BITS ( & ihp -> ird_lifetime ) ; if ( lifetime < 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u"" , lifetime ) ; } else if ( lifetime < 60 * 60 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u"" , lifetime / 60 , lifetime % 60 ) ; } else { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""%u:%02u:%02u"" , lifetime / 3600 , ( lifetime % 3600 ) / 60 , lifetime % 60 ) ; } cp = buf + strlen ( buf ) ; num = ihp -> ird_addrnum ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>%d:"" , num ) ; cp = buf + strlen ( buf ) ; size = ihp -> ird_addrsiz ; if ( size != 2 ) { ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>[size<S2SV_blank>%d]"" , size ) ; break ; } idp = ( const struct id_rdiscovery * ) & dp -> icmp_data ; while ( num -- > 0 ) { ND_TCHECK ( * idp ) ; ( void ) snprintf ( cp , sizeof ( buf ) - ( cp - buf ) , ""<S2SV_blank>{%s<S2SV_blank>%u}"" , ipaddr_string ( ndo , & idp -> ird_addr ) , EXTRACT_32BITS ( & idp -> ird_pref ) ) ; cp = buf + strlen ( buf ) ; ++ idp ; } } break ; case ICMP_TIMXCEED : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_TIMXCEED_INTRANS : str = ""time<S2SV_blank>exceeded<S2SV_blank>in-transit"" ; break ; case ICMP_TIMXCEED_REASS : str = ""ip<S2SV_blank>reassembly<S2SV_blank>time<S2SV_blank>exceeded"" ; break ; default : ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>exceeded-#%d"" , dp -> icmp_code ) ; break ; } break ; case ICMP_PARAMPROB : if ( dp -> icmp_code ) ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>code<S2SV_blank>%d"" , dp -> icmp_code ) ; else { ND_TCHECK ( dp -> icmp_pptr ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""parameter<S2SV_blank>problem<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%d"" , dp -> icmp_pptr ) ; } break ; case ICMP_MASKREPLY : ND_TCHECK ( dp -> icmp_mask ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""address<S2SV_blank>mask<S2SV_blank>is<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( & dp -> icmp_mask ) ) ; break ; case ICMP_TSTAMP : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>query<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_TSTAMPREPLY : ND_TCHECK ( dp -> icmp_ttime ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""time<S2SV_blank>stamp<S2SV_blank>reply<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>seq<S2SV_blank>%u:<S2SV_blank>org<S2SV_blank>%s"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_otime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>recv<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_rtime ) ) ) ; ( void ) snprintf ( buf + strlen ( buf ) , sizeof ( buf ) - strlen ( buf ) , "",<S2SV_blank>xmit<S2SV_blank>%s"" , icmp_tstamp_print ( EXTRACT_32BITS ( & dp -> icmp_ttime ) ) ) ; break ; default : str = tok2str ( icmp2str , ""type-#%d"" , dp -> icmp_type ) ; break ; } ND_PRINT ( ( ndo , ""ICMP<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , str , plen ) ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , icmp_sum ; if ( ND_TTEST2 ( * bp , plen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) dp ; vec [ 0 ] . len = plen ; sum = in_cksum ( vec , 1 ) ; if ( sum != 0 ) { icmp_sum = EXTRACT_16BITS ( & dp -> icmp_cksum ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(wrong<S2SV_blank>icmp<S2SV_blank>cksum<S2SV_blank>%x<S2SV_blank>(->%x)!)"" , icmp_sum , in_cksum_shouldbe ( icmp_sum , sum ) ) ) ; } } } if ( ndo -> ndo_vflag >= 1 && ICMP_ERRTYPE ( dp -> icmp_type ) ) { bp += 8 ; ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; ip = ( const struct ip * ) bp ; <S2SV_StartBug> snapend_save = ndo -> ndo_snapend ; <S2SV_EndBug> ip_print ( ndo , bp , EXTRACT_16BITS ( & ip -> ip_len ) ) ; ndo -> ndo_snapend = snapend_save ; } if ( ndo -> ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE ( dp -> icmp_type ) ) { ND_TCHECK ( * ext_dp ) ; if ( ! ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = plen - ICMP_EXTD_MINLEN ; if ( in_cksum ( vec , 1 ) ) { return ; } } ND_PRINT ( ( ndo , ""\\n\\tMPLS<S2SV_blank>extension<S2SV_blank>v%u"" , ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) ) ) ; if ( ICMP_MPLS_EXT_EXTRACT_VERSION ( * ( ext_dp -> icmp_ext_version_res ) ) != ICMP_MPLS_EXT_VERSION ) { ND_PRINT ( ( ndo , ""<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" ) ) ; return ; } hlen = plen - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { vec [ 0 ] . ptr = ( const uint8_t * ) ( const void * ) & ext_dp -> icmp_ext_version_res ; vec [ 0 ] . len = hlen ; ND_PRINT ( ( ndo , "",<S2SV_blank>checksum<S2SV_blank>0x%04x<S2SV_blank>(%scorrect),<S2SV_blank>length<S2SV_blank>%u"" , EXTRACT_16BITS ( ext_dp -> icmp_ext_checksum ) , in_cksum ( vec , 1 ) ? ""in"" : """" , hlen ) ) ; } hlen -= 4 ; obj_tptr = ( const uint8_t * ) ext_dp -> icmp_ext_data ; while ( hlen > sizeof ( struct icmp_mpls_ext_object_header_t ) ) { icmp_mpls_ext_object_header = ( const struct icmp_mpls_ext_object_header_t * ) obj_tptr ; ND_TCHECK ( * icmp_mpls_ext_object_header ) ; obj_tlen = EXTRACT_16BITS ( icmp_mpls_ext_object_header -> length ) ; obj_class_num = icmp_mpls_ext_object_header -> class_num ; obj_ctype = icmp_mpls_ext_object_header -> ctype ; obj_tptr += sizeof ( struct icmp_mpls_ext_object_header_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( icmp_mpls_ext_obj_values , ""unknown"" , obj_class_num ) , obj_class_num , obj_ctype , obj_tlen ) ) ; hlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; if ( ( obj_class_num == 0 ) || ( obj_tlen < sizeof ( struct icmp_mpls_ext_object_header_t ) ) ) { return ; } obj_tlen -= sizeof ( struct icmp_mpls_ext_object_header_t ) ; switch ( obj_class_num ) { case 1 : switch ( obj_ctype ) { case 1 : ND_TCHECK2 ( * obj_tptr , 4 ) ; raw_label = EXTRACT_32BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>label<S2SV_blank>%u,<S2SV_blank>exp<S2SV_blank>%u"" , MPLS_LABEL ( raw_label ) , MPLS_EXP ( raw_label ) ) ) ; if ( MPLS_STACK ( raw_label ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>[S]"" ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>ttl<S2SV_blank>%u"" , MPLS_TTL ( raw_label ) ) ) ; break ; default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; } break ; case 2 : default : print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( hlen < obj_tlen ) break ; hlen -= obj_tlen ; obj_tptr += obj_tlen ; } } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp]"" ) ) ; }
","<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
",the-tcpdump-group@tcpdump/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,CVE-2017-13012,https://github.com/the-tcpdump-group/tcpdump/commit/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b,2017-09-14T06:29Z
CWE-362,"CWE-362 fm_mgr_config_errno_t fm_mgr_config_mgr_connect ( fm_config_conx_hdl * hdl , fm_mgr_type_t mgr ) { char s_path [ 256 ] ; char c_path [ 256 ] ; char * mgr_prefix ; p_hsm_com_client_hdl_t * mgr_hdl ; <S2SV_StartBug> pid_t pid ; <S2SV_EndBug> memset ( s_path , 0 , sizeof ( s_path ) ) ; <S2SV_StartBug> memset ( c_path , 0 , sizeof ( c_path ) ) ; <S2SV_EndBug> pid = getpid ( ) ; switch ( mgr ) { case FM_MGR_SM : mgr_prefix = HSM_FM_SCK_SM ; mgr_hdl = & hdl -> sm_hdl ; break ; case FM_MGR_PM : mgr_prefix = HSM_FM_SCK_PM ; mgr_hdl = & hdl -> pm_hdl ; break ; case FM_MGR_FE : mgr_prefix = HSM_FM_SCK_FE ; mgr_hdl = & hdl -> fe_hdl ; break ; default : return FM_CONF_INIT_ERR ; } sprintf ( s_path , ""%s%s%d"" , HSM_FM_SCK_PREFIX , mgr_prefix , hdl -> instance ) ; <S2SV_StartBug> sprintf ( c_path , ""%s%s%d_C_%lu"" , HSM_FM_SCK_PREFIX , mgr_prefix , <S2SV_EndBug> <S2SV_StartBug> hdl -> instance , ( long unsigned ) pid ) ; <S2SV_EndBug> if ( * mgr_hdl == NULL ) { if ( hcom_client_init ( mgr_hdl , s_path , c_path , 32768 ) != HSM_COM_OK ) { return FM_CONF_INIT_ERR ; } } if ( hcom_client_connect ( * mgr_hdl ) == HSM_COM_OK ) { hdl -> conx_mask |= mgr ; return FM_CONF_OK ; } return FM_CONF_CONX_ERR ; }
","<S2SV_ModStart> * mgr_hdl ; <S2SV_ModEnd> memset ( s_path <S2SV_ModStart> ( c_path ) <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c_path , ""%s%s%d_C_XXXXXX"" <S2SV_ModEnd> , HSM_FM_SCK_PREFIX , <S2SV_ModStart> hdl -> instance <S2SV_ModEnd> ) ; if
",01org@opa-fm/c5759e7b76f5bf844be6c6641cc1b356bbc83869,CVE-2015-5232,https://github.com/01org/opa-fm/commit/c5759e7b76f5bf844be6c6641cc1b356bbc83869,2017-06-07T20:29Z
CWE-125,"CWE-125 static const u_char * ikev1_attrmap_print ( netdissect_options * ndo , <S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> const struct attrmap * map , size_t nmap ) { int totlen ; uint32_t t , v ; <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> totlen = 4 ; <S2SV_StartBug> else <S2SV_EndBug> totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|attr]"" ) ) ; <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""("" ) ) ; t = EXTRACT_16BITS ( & p [ 0 ] ) & 0x7fff ; if ( map && t < nmap && map [ t ] . type ) ND_PRINT ( ( ndo , ""type=%s<S2SV_blank>"" , map [ t ] . type ) ) ; else ND_PRINT ( ( ndo , ""type=#%d<S2SV_blank>"" , t ) ) ; if ( p [ 0 ] & 0x80 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""value="" ) ) ; <S2SV_EndBug> v = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( map && t < nmap && v < map [ t ] . nvalue && map [ t ] . value [ v ] ) ND_PRINT ( ( ndo , ""%s"" , map [ t ] . value [ v ] ) ) ; else <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> ND_PRINT ( ( ndo , ""len=%d<S2SV_blank>value="" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> const u_char * ep2 <S2SV_ModEnd> , const struct <S2SV_ModStart> , v ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ] ) ; } if ( ep2 <S2SV_ModEnd> < p + <S2SV_ModStart> ) ; return ep2 <S2SV_ModEnd> + 1 ; <S2SV_ModStart> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> , ""value="" ) ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> ) ; else { if ( ! <S2SV_ModStart> , 2 ) ) { ND_PRINT ( ( ndo , "")"" ) ) ; goto trunc ; } } <S2SV_ModEnd> } else { <S2SV_ModStart> , ""len=%d<S2SV_blank>value="" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo <S2SV_ModStart> 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> + totlen ; trunc : return NULL ;
",the-tcpdump-group@tcpdump/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,CVE-2017-13039,https://github.com/the-tcpdump-group/tcpdump/commit/e0a5a02b0fc1900a69d6c37ed0aab36fb8494e6d,2017-09-14T06:29Z
CWE-000,"CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n"" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n"" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n"" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( ""Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n"" ) ; return - ENOENT ; } return 0 ; }
","<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( ""FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n"" , ret ) ; return - EINVAL ; } } if (
",u-boot@u-boot/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,CVE-2021-27097,https://github.com/u-boot/u-boot/commit/6f3c2d8aa5e6cbd80b5e869bbbddecb66c329d01,2021-02-17T23:15Z
CWE-476,"CWE-476 static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }
","<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
",FFmpeg@FFmpeg/0a709e2a10b8288a0cc383547924ecfe285cef89,CVE-2017-9608,https://github.com/FFmpeg/FFmpeg/commit/0a709e2a10b8288a0cc383547924ecfe285cef89,2017-12-27T19:29Z
CWE-59,"CWE-59 int mount_proc_if_needed ( const char * rootfs ) { char path [ MAXPATHLEN ] ; char link [ 20 ] ; int linklen , ret ; int mypid ; ret = snprintf ( path , MAXPATHLEN , ""%s/proc/self"" , rootfs ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { SYSERROR ( ""proc<S2SV_blank>path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } memset ( link , 0 , 20 ) ; linklen = readlink ( path , link , 20 ) ; mypid = ( int ) getpid ( ) ; INFO ( ""I<S2SV_blank>am<S2SV_blank>%d,<S2SV_blank>/proc/self<S2SV_blank>points<S2SV_blank>to<S2SV_blank>\'%s\'"" , mypid , link ) ; ret = snprintf ( path , MAXPATHLEN , ""%s/proc"" , rootfs ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { SYSERROR ( ""proc<S2SV_blank>path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } if ( linklen < 0 ) goto domount ; if ( atoi ( link ) != mypid ) { umount2 ( path , MNT_DETACH ) ; goto domount ; } return 0 ; domount : <S2SV_StartBug> if ( mount ( ""proc"" , path , ""proc"" , 0 , NULL ) ) <S2SV_EndBug> return - 1 ; INFO ( ""Mounted<S2SV_blank>/proc<S2SV_blank>in<S2SV_blank>container<S2SV_blank>for<S2SV_blank>security<S2SV_blank>transition"" ) ; return 1 ; }
","<S2SV_ModStart> : if ( safe_mount <S2SV_ModEnd> ( ""proc"" , <S2SV_ModStart> 0 , NULL , rootfs ) < 0 <S2SV_ModEnd> ) return -
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-269,"CWE-269 static void process_open ( u_int32_t id ) { u_int32_t pflags ; Attrib a ; char * name ; int r , handle , fd , flags , mode , status = SSH2_FX_FAILURE ; if ( ( r = sshbuf_get_cstring ( iqueue , & name , NULL ) ) != 0 || ( r = sshbuf_get_u32 ( iqueue , & pflags ) ) != 0 || ( r = decode_attrib ( iqueue , & a ) ) != 0 ) fatal ( ""%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; debug3 ( ""request<S2SV_blank>%u:<S2SV_blank>open<S2SV_blank>flags<S2SV_blank>%d"" , id , pflags ) ; flags = flags_from_portable ( pflags ) ; mode = ( a . flags & SSH2_FILEXFER_ATTR_PERMISSIONS ) ? a . perm : 0666 ; logit ( ""open<S2SV_blank>\\""%s\\""<S2SV_blank>flags<S2SV_blank>%s<S2SV_blank>mode<S2SV_blank>0%o"" , name , string_from_portable ( pflags ) , mode ) ; if ( readonly && <S2SV_StartBug> ( ( flags & O_ACCMODE ) == O_WRONLY || <S2SV_EndBug> <S2SV_StartBug> ( flags & O_ACCMODE ) == O_RDWR ) ) { <S2SV_EndBug> verbose ( ""Refusing<S2SV_blank>open<S2SV_blank>request<S2SV_blank>in<S2SV_blank>read-only<S2SV_blank>mode"" ) ; status = SSH2_FX_PERMISSION_DENIED ; } else { fd = open ( name , flags , mode ) ; if ( fd < 0 ) { status = errno_to_portable ( errno ) ; } else { handle = handle_new ( HANDLE_FILE , name , fd , flags , NULL ) ; if ( handle < 0 ) { close ( fd ) ; } else { send_handle ( id , handle ) ; status = SSH2_FX_OK ; } } } if ( status != SSH2_FX_OK ) send_status ( id , status ) ; free ( name ) ; }
","<S2SV_ModStart> & O_ACCMODE ) != O_RDONLY <S2SV_ModEnd> || ( flags <S2SV_ModStart> ( flags & ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> ) ) {
",openbsd@src/a6981567e8e215acc1ef690c8dbb30f2d9b00a19,CVE-2017-15906,https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19,2017-10-26T03:29Z
CWE-125,"CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; <S2SV_StartBug> if ( cmd & 0x01 ) off = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x08 ) off |= ( ( unsigned ) * delta ++ << 24UL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x10 ) len = * delta ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; <S2SV_EndBug> <S2SV_StartBug> if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; <S2SV_EndBug> <S2SV_StartBug> if ( ! len ) len = 0x10000 ; <S2SV_EndBug> if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta"" ) ; return - 1 ; }
","<S2SV_ModStart> = 0 ; # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) <S2SV_ModEnd> * delta ++ <S2SV_ModStart> delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x04 ) ADD_DELTA ( off , 16UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x08 ) ADD_DELTA ( off , <S2SV_ModEnd> 24UL ) ; <S2SV_ModStart> & 0x10 ) ADD_DELTA ( len , 0UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x20 ) ADD_DELTA ( len , 8UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x40 ) ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0x10000 ; # undef ADD_DELTA
",libgit2@libgit2/9844d38bed10e9ff17174434b3421b227ae710f3,CVE-2018-10888,https://github.com/libgit2/libgit2/commit/9844d38bed10e9ff17174434b3421b227ae710f3,2018-07-10T14:29Z
CWE-125,"CWE-125 static void l2tp_result_code_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_EndBug> <S2SV_StartBug> if ( length > 2 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""/%u"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> if ( length > 4 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; <S2SV_StartBug> print_string ( ndo , ( const u_char * ) ptr , length - 4 ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ; ptr ++ ; length -= 2 <S2SV_ModStart> if ( length == 0 ) return ; if ( length < <S2SV_ModEnd> 2 ) { <S2SV_ModStart> 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModStart> ptr ++ ; length -= 2 ; <S2SV_ModEnd> if ( length <S2SV_ModStart> if ( length == 0 ) return ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-189,"CWE-189 static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
","<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,
",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
CWE-000,"CWE-000 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ; if ( user -> uid_keyring && user -> session_keyring ) { kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }
","<S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
",torvalds@linux/237bbd29f7a049d310d907f4b2716a7feef9abf3,CVE-2017-18270,https://github.com/torvalds/linux/commit/237bbd29f7a049d310d907f4b2716a7feef9abf3,2018-05-18T16:29Z
CWE-20,"CWE-20 error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHSR ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( status & RXFHSR_RXFV ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) <S2SV_EndBug> { <S2SV_StartBug> n = ksz8851ReadReg ( interface , KSZ8851_REG_RXFHBCR ) & RXFHBCR_RXBC_MASK ; <S2SV_EndBug> if ( n > 0 && n <= ETH_MAX_FRAME_SIZE ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_RXFDPR , RXFDPR_RXFPAI ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ; <S2SV_StartBug> ksz8851ClearBit ( interface , KSZ8851_REG_RXQCR , RXQCR_SDA ) ; <S2SV_EndBug> ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_RXQCR , RXQCR_RRXEF ) ; <S2SV_EndBug> return ERROR_INVALID_PACKET ; }
","<S2SV_ModStart> ( interface , KSZ8851_RXFHSR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> ) != 0 <S2SV_ModStart> status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> ) ) == <S2SV_ModStart> ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ancillary <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ) ; return
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-264,"CWE-264 static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
",torvalds@linux/ec8013beddd717d1740cfefb1a9b900deef85462,CVE-2011-4127,https://github.com/torvalds/linux/commit/ec8013beddd717d1740cfefb1a9b900deef85462,2012-07-03T16:40Z
CWE-20,"CWE-20 void SetGray ( double grayscale , int par ) { if ( par == STROKING ) { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , grayscale ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , grayscale ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>G"" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , ""<S2SV_blank>%12.3f<S2SV_blank>g"" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-20,"CWE-20 void SetBackgroundColor ( int par ) { <S2SV_StartBug> if ( par == STROKING ) { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ; } <S2SV_EndBug> <S2SV_StartBug> else { outpos += sprintf ( outpos , ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>k"" ) ; } <S2SV_EndBug> }
","<S2SV_ModStart> STROKING ) { send ( <S2SV_ModEnd> ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K"" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> ""<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>k"" ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-362,"CWE-362 static int inet_sk_reselect_saddr ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __be32 old_saddr = inet -> inet_saddr ; __be32 daddr = inet -> inet_daddr ; struct flowi4 fl4 ; struct rtable * rt ; __be32 new_saddr ; <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> daddr = inet -> opt -> faddr ; rt = ip_route_connect ( & fl4 , daddr , 0 , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , sk -> sk_protocol , inet -> inet_sport , inet -> inet_dport , sk , false ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; sk_setup_caps ( sk , & rt -> dst ) ; new_saddr = rt -> rt_src ; if ( new_saddr == old_saddr ) return 0 ; if ( sysctl_ip_dynaddr > 1 ) { printk ( KERN_INFO ""%s():<S2SV_blank>shifting<S2SV_blank>inet->saddr<S2SV_blank>from<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , & old_saddr , & new_saddr ) ; } inet -> inet_saddr = inet -> inet_rcv_saddr = new_saddr ; __sk_prot_rehash ( sk ) ; return 0 ; }
","<S2SV_ModStart> __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_funcdef_impl ( struct compiling * c , const node * n , <S2SV_EndBug> <S2SV_StartBug> asdl_seq * decorator_seq , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>functions<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , <S2SV_StartBug> type_comment , LINENO ( n ) , <S2SV_EndBug> n -> n_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 <S2SV_ModEnd> , asdl_seq * <S2SV_ModStart> * decorator_seq , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 static int dalvik_disassemble ( RAsm * a , RAsmOp * op , const ut8 * buf , int len ) { int vA , vB , vC , payload = 0 , i = ( int ) buf [ 0 ] ; int size = dalvik_opcodes [ i ] . len ; char str [ 1024 ] , * strasm ; ut64 offset ; const char * flag_str ; op -> buf_asm [ 0 ] = 0 ; if ( buf [ 0 ] == 0x00 ) { switch ( buf [ 1 ] ) { case 0x01 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> size = 8 ; payload = 2 * ( array_size * 2 ) ; len = 0 ; } break ; case 0x02 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> size = 4 ; payload = 2 * ( array_size * 4 ) ; len = 0 ; } break ; case 0x03 : if ( len > 7 ) { unsigned short elem_width = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; unsigned int array_size = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""fill-array-data-payload<S2SV_blank>%d,<S2SV_blank>%d"" , elem_width , array_size ) ; payload = 2 * ( ( array_size * elem_width + 1 ) / 2 ) ; } size = 8 ; len = 0 ; break ; default : break ; } } strasm = NULL ; if ( size <= len ) { strncpy ( op -> buf_asm , dalvik_opcodes [ i ] . name , sizeof ( op -> buf_asm ) - 1 ) ; strasm = strdup ( op -> buf_asm ) ; size = dalvik_opcodes [ i ] . len ; switch ( dalvik_opcodes [ i ] . fmt ) { case fmtop : break ; case fmtopvAvB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAAAvBBBB : vA = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vB = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAA : vA = ( int ) buf [ 1 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAcB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB : vA = ( int ) buf [ 1 ] ; { short sB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; } break ; case fmtopvAAcBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ; if ( buf [ 0 ] == 0x17 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB0000 : vA = ( int ) buf [ 1 ] ; vB = 0 | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; if ( buf [ 0 ] == 0x19 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBBBBBBBBBBBBBB : vA = ( int ) buf [ 1 ] ; # define llint long long int llint lB = ( llint ) buf [ 2 ] | ( ( llint ) buf [ 3 ] << 8 ) | ( ( llint ) buf [ 4 ] << 16 ) | ( ( llint ) buf [ 5 ] << 24 ) | ( ( llint ) buf [ 6 ] << 32 ) | ( ( llint ) buf [ 7 ] << 40 ) | ( ( llint ) buf [ 8 ] << 48 ) | ( ( llint ) buf [ 9 ] << 56 ) ; # undef llint <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBvCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBcCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBcCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAA : vA = ( char ) buf [ 1 ] ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAA : vA = ( short ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + ( vB * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAAAAAA : vA = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBpCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + vB ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineI : vA = ( int ) ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; * str = 0 ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineIR : case fmtoptinvokeVSR : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> break ; } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x1a ) { offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } } else if ( buf [ 0 ] == 0x1c || buf [ 0 ] == 0x1f || buf [ 0 ] == 0x22 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptopvAvBoCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 'o' , vC ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 't' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBtCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x20 || buf [ 0 ] == 0x23 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 5 ] | ( buf [ 4 ] << 8 ) | ( buf [ 3 ] << 16 ) | ( buf [ 2 ] << 24 ) ) ; offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvCCCCmBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; if ( buf [ 0 ] == 0x25 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvXtBBBB : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; case 5 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; if ( buf [ 0 ] == 0x24 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeI : case fmtoptinvokeIR : case fmt00 : default : strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; free ( strasm ) ; strasm = NULL ; size = 2 ; } if ( strasm ) { strncpy ( op -> buf_asm , strasm , sizeof ( op -> buf_asm ) - 1 ) ; op -> buf_asm [ sizeof ( op -> buf_asm ) - 1 ] = 0 ; } else { strcpy ( op -> buf_asm , ""invalid"" ) ; } } else if ( len > 0 ) { strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; op -> size = len ; size = len ; } op -> payload = payload ; size += payload ; op -> size = size ; free ( strasm ) ; return size ; }
","<S2SV_ModStart> 24 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> 8 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i"" , <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , <S2SV_ModStart> # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>method+%i"" ,
",radare@radare2/f41e941341e44aa86edd4483c4487ec09a074257,CVE-2017-6448,https://github.com/radare/radare2/commit/f41e941341e44aa86edd4483c4487ec09a074257,2017-04-03T05:59Z
CWE-264,"CWE-264 static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; <S2SV_StartBug> pgd = pgd_offset ( mm , 0xA0000 ) ; <S2SV_EndBug> if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : <S2SV_StartBug> flush_tlb ( ) ; <S2SV_EndBug> }
","<S2SV_ModStart> int i ; down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> ; out : up_write ( & mm -> mmap_sem ) ;
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-125,"CWE-125 int sock_queue_err_skb ( struct sock * sk , struct sk_buff * skb ) { if ( atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize >= ( unsigned int ) sk -> sk_rcvbuf ) return - ENOMEM ; skb_orphan ( skb ) ; skb -> sk = sk ; skb -> destructor = sock_rmem_free ; atomic_add ( skb -> truesize , & sk -> sk_rmem_alloc ) ; <S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> skb_queue_tail ( & sk -> sk_error_queue , skb ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk ) ; return 0 ; }
","<S2SV_ModStart> sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
",torvalds@linux/8605330aac5a5785630aec8f64378a54891937cc,CVE-2017-7277,https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc,2017-03-28T06:59Z
CWE-119,"CWE-119 static INLINE void load_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( x -> pred_mv , ctx -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( x ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }
","<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-285,"CWE-285 int jffs2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int rc , xprefix ; switch ( type ) { case ACL_TYPE_ACCESS : xprefix = JFFS2_XPREFIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> rc = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( rc < 0 ) return rc ; if ( inode -> i_mode != mode ) { struct iattr attr ; attr . ia_valid = ATTR_MODE | ATTR_CTIME ; attr . ia_mode = mode ; attr . ia_ctime = CURRENT_TIME_SEC ; rc = jffs2_do_setattr ( inode , & attr ) ; if ( rc < 0 ) return rc ; } <S2SV_StartBug> if ( rc == 0 ) <S2SV_EndBug> acl = NULL ; } break ; case ACL_TYPE_DEFAULT : xprefix = JFFS2_XPREFIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } rc = __jffs2_set_acl ( inode , xprefix , acl ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
","<S2SV_ModStart> { umode_t mode ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc <S2SV_ModStart> rc ; } <S2SV_ModEnd> } break ;
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-20,"CWE-20 void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> u32 data ; <S2SV_EndBug> void * vapic ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; <S2SV_StartBug> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <S2SV_EndBug> data = * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) ; kunmap_atomic ( vapic ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
","<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z
CWE-264,"CWE-264 int perf_pmu_register ( struct pmu * pmu , const char * name , int type ) { int cpu , ret ; mutex_lock ( & pmus_lock ) ; ret = - ENOMEM ; pmu -> pmu_disable_count = alloc_percpu ( int ) ; if ( ! pmu -> pmu_disable_count ) goto unlock ; pmu -> type = - 1 ; if ( ! name ) goto skip_type ; pmu -> name = name ; if ( type < 0 ) { type = idr_alloc ( & pmu_idr , pmu , PERF_TYPE_MAX , 0 , GFP_KERNEL ) ; if ( type < 0 ) { ret = type ; goto free_pdc ; } } pmu -> type = type ; if ( pmu_bus_running ) { ret = pmu_dev_alloc ( pmu ) ; if ( ret ) goto free_idr ; } skip_type : pmu -> pmu_cpu_context = find_pmu_context ( pmu -> task_ctx_nr ) ; if ( pmu -> pmu_cpu_context ) goto got_cpu_context ; ret = - ENOMEM ; pmu -> pmu_cpu_context = alloc_percpu ( struct perf_cpu_context ) ; if ( ! pmu -> pmu_cpu_context ) goto free_dev ; for_each_possible_cpu ( cpu ) { struct perf_cpu_context * cpuctx ; cpuctx = per_cpu_ptr ( pmu -> pmu_cpu_context , cpu ) ; __perf_event_init_context ( & cpuctx -> ctx ) ; lockdep_set_class ( & cpuctx -> ctx . mutex , & cpuctx_mutex ) ; lockdep_set_class ( & cpuctx -> ctx . lock , & cpuctx_lock ) ; <S2SV_StartBug> cpuctx -> ctx . type = cpu_context ; <S2SV_EndBug> cpuctx -> ctx . pmu = pmu ; __perf_cpu_hrtimer_init ( cpuctx , cpu ) ; INIT_LIST_HEAD ( & cpuctx -> rotation_list ) ; cpuctx -> unique_pmu = pmu ; } got_cpu_context : if ( ! pmu -> start_txn ) { if ( pmu -> pmu_enable ) { pmu -> start_txn = perf_pmu_start_txn ; pmu -> commit_txn = perf_pmu_commit_txn ; pmu -> cancel_txn = perf_pmu_cancel_txn ; } else { pmu -> start_txn = perf_pmu_nop_void ; pmu -> commit_txn = perf_pmu_nop_int ; pmu -> cancel_txn = perf_pmu_nop_void ; } } if ( ! pmu -> pmu_enable ) { pmu -> pmu_enable = perf_pmu_nop_void ; pmu -> pmu_disable = perf_pmu_nop_void ; } if ( ! pmu -> event_idx ) pmu -> event_idx = perf_event_idx_default ; list_add_rcu ( & pmu -> entry , & pmus ) ; ret = 0 ; unlock : mutex_unlock ( & pmus_lock ) ; return ret ; free_dev : device_del ( pmu -> dev ) ; put_device ( pmu -> dev ) ; free_idr : if ( pmu -> type >= PERF_TYPE_MAX ) idr_remove ( & pmu_idr , pmu -> type ) ; free_pdc : free_percpu ( pmu -> pmu_disable_count ) ; goto unlock ; }
","<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
",torvalds@linux/c3c87e770458aa004bd7ed3f29945ff436fd6511,CVE-2015-9004,https://github.com/torvalds/linux/commit/c3c87e770458aa004bd7ed3f29945ff436fd6511,2017-05-02T21:59Z
CWE-404,"CWE-404 int nfs3svc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-401,"CWE-401 static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>token<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>token!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; } while ( message_left && ( * * packet_data_pptr != 0xff ) ) { uint16_t option_len = ( * * packet_data_pptr & 0x0F ) ; uint16_t option_number = ( * * packet_data_pptr >> COAP_OPTIONS_OPTION_NUMBER_SHIFT ) ; message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; int8_t option_parse_result ; option_parse_result = parse_ext_option ( & option_number , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } <S2SV_StartBug> option_number += previous_option_number ; <S2SV_EndBug> option_parse_result = parse_ext_option ( & option_len , packet_data_pptr , packet_data_start_ptr , packet_len , & message_left ) ; if ( option_parse_result != 0 ) { return - 1 ; } previous_option_number = option_number ; switch ( option_number ) { case COAP_OPTION_MAX_AGE : case COAP_OPTION_PROXY_URI : case COAP_OPTION_ETAG : case COAP_OPTION_URI_HOST : case COAP_OPTION_LOCATION_PATH : case COAP_OPTION_URI_PORT : case COAP_OPTION_LOCATION_QUERY : case COAP_OPTION_OBSERVE : case COAP_OPTION_URI_QUERY : case COAP_OPTION_BLOCK2 : case COAP_OPTION_BLOCK1 : case COAP_OPTION_ACCEPT : case COAP_OPTION_SIZE1 : case COAP_OPTION_SIZE2 : if ( sn_coap_parser_alloc_options ( handle , dst_coap_msg_ptr ) == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>options!"" ) ; return - 1 ; } break ; } if ( message_left < option_len ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>would<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>parsing<S2SV_blank>options!"" ) ; return - 1 ; } switch ( option_number ) { case COAP_OPTION_CONTENT_FORMAT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> content_format != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_CONTENT_FORMAT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> content_format = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_MAX_AGE : if ( option_len > 4 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_MAX_AGE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> max_age = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_PROXY_URI : if ( ( option_len > 1034 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> proxy_uri_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_PROXY_URI<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_ETAG : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , <S2SV_EndBug> message_left , & dst_coap_msg_ptr -> options_list_ptr -> etag_ptr , ( uint16_t * ) & dst_coap_msg_ptr -> options_list_ptr -> etag_len , COAP_OPTION_ETAG , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_HOST : if ( ( option_len > 255 ) || ( option_len < 1 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_host_len = option_len ; dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , option_len ) ; if ( dst_coap_msg_ptr -> options_list_ptr -> uri_host_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_HOST<S2SV_blank>allocation<S2SV_blank>failed!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , option_len ) ; break ; case COAP_OPTION_LOCATION_PATH : if ( dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>exists!"" ) ; return - 1 ; } ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> location_path_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_path_len , COAP_OPTION_LOCATION_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PORT : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> uri_port != COAP_OPTION_URI_PORT_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PORT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> uri_port = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_LOCATION_QUERY : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> location_query_len , COAP_OPTION_LOCATION_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_URI_PATH : <S2SV_StartBug> ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , <S2SV_EndBug> & dst_coap_msg_ptr -> uri_path_ptr , & dst_coap_msg_ptr -> uri_path_len , COAP_OPTION_URI_PATH , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_OBSERVE : if ( ( option_len > 2 ) || dst_coap_msg_ptr -> options_list_ptr -> observe != COAP_OBSERVE_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_OBSERVE<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> observe = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_URI_QUERY : ret_status = sn_coap_parser_options_parse_multiple_options ( handle , packet_data_pptr , message_left , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_ptr , & dst_coap_msg_ptr -> options_list_ptr -> uri_query_len , COAP_OPTION_URI_QUERY , option_len ) ; if ( ret_status < 0 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_QUERY<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } break ; case COAP_OPTION_BLOCK2 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block2 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_BLOCK1 : if ( ( option_len > 3 ) || dst_coap_msg_ptr -> options_list_ptr -> block1 != COAP_OPTION_BLOCK_NONE ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_BLOCK1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> block1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_ACCEPT : if ( ( option_len > 2 ) || ( dst_coap_msg_ptr -> options_list_ptr -> accept != COAP_CT_NONE ) ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ACCEPT<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> accept = ( sn_coap_content_format_e ) sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE1 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size1 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE1<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size1 = true ; dst_coap_msg_ptr -> options_list_ptr -> size1 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; case COAP_OPTION_SIZE2 : if ( ( option_len > 4 ) || dst_coap_msg_ptr -> options_list_ptr -> use_size2 ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_SIZE2<S2SV_blank>not<S2SV_blank>valid!"" ) ; return - 1 ; } dst_coap_msg_ptr -> options_list_ptr -> use_size2 = true ; dst_coap_msg_ptr -> options_list_ptr -> size2 = sn_coap_parser_options_parse_uint ( packet_data_pptr , option_len ) ; break ; default : tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>option!"" ) ; return - 1 ; } if ( ( * packet_data_pptr - packet_data_start_ptr ) > packet_len ) { return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; } return 0 ; }
","<S2SV_ModStart> 1 ; } if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> option_parse_result = parse_ext_option <S2SV_ModStart> case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!"" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( ""sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!"" ) ; return - 1 ; }
",mjurczak@mbed-coap/4647a68e364401e81dbd370728127d844f221d93,CVE-2020-12887,https://github.com/mjurczak/mbed-coap/commit/4647a68e364401e81dbd370728127d844f221d93,2020-06-18T19:15Z
CWE-476,"CWE-476 static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n"" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( ""RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n"" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n"" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( ""RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n"" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
","<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
",torvalds@linux/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,CVE-2018-7492,https://github.com/torvalds/linux/commit/f3069c6d33f6ae63a1668737bc78aaaa51bff7ca,2018-02-26T20:29Z
CWE-476,"CWE-476 int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""out<S2SV_blank>of<S2SV_blank>memory\\n"" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , ""Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n"" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
",torvalds@linux/bcf3b67d16a4c8ffae0aa79de5853435e683945c,CVE-2019-11810,https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c,2019-05-07T14:29Z
CWE-125,"CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , pixels_length , quantum ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth != 1 ) && ( sun_info . depth != 8 ) && ( sun_info . depth != 24 ) && ( sun_info . depth != 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : break ; } image -> matte = sun_info . depth == 32 ? MagickTrue : MagickFalse ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( sun_info . length == 0 ) ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; number_pixels = ( MagickSizeType ) ( image -> columns * image -> rows ) ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8UL * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( HeapOverflowSanityCheck ( sun_info . width , sun_info . depth ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( sun_info . length , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; } quantum = sun_info . depth == 1 ? 15 : 7 ; bytes_per_line += quantum ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + quantum ) ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; } bytes_per_line >>= 4 ; if ( HeapOverflowSanityCheck ( height , bytes_per_line ) != MagickFalse ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; } pixels_length = height * bytes_per_line ; <S2SV_StartBug> sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( pixels_length , <S2SV_EndBug> sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } ResetMagickMemory ( sun_pixels , 0 , pixels_length * sizeof ( * sun_pixels ) ) ; if ( sun_info . type == RT_ENCODED ) { status = DecodeImage ( sun_data , sun_info . length , sun_pixels , pixels_length ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } else { if ( sun_info . length > pixels_length ) { sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; ThrowReaderException ( ResourceLimitError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; } sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) SetPixelIndex ( indexes + x + 7 - bit , ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) ) ; p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) SetPixelIndex ( indexes + x + 7 - bit , ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) ; p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( indexes + x , ConstrainColormapIndex ( image , * p ) ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> matte != MagickFalse ) bytes_per_pixel ++ ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; } else { SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; } if ( image -> colors != 0 ) { SetPixelRed ( q , image -> colormap [ ( ssize_t ) GetPixelRed ( q ) ] . red ) ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) GetPixelGreen ( q ) ] . green ) ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) GetPixelBlue ( q ) ] . blue ) ; } q ++ ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> AcquireQuantumMemory ( pixels_length + image -> rows
",ImageMagick@ImageMagick/3007531bfd326c5c1e29cd41d2cd80c166de8528,CVE-2017-6500,https://github.com/ImageMagick/ImageMagick/commit/3007531bfd326c5c1e29cd41d2cd80c166de8528,2017-03-06T02:59Z
CWE-20,"CWE-20 void dm9000EventHandler ( NetInterface * interface ) { error_t error ; uint8_t status ; <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> if ( ( status & ISR_LNKCHG ) != 0 ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_LNKCHG ) ; <S2SV_EndBug> <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NSR ) ; <S2SV_EndBug> if ( ( status & NSR_LINKST ) != 0 ) { if ( ( status & NSR_SPEED ) != 0 ) { interface -> linkSpeed = NIC_LINK_SPEED_10MBPS ; } else { interface -> linkSpeed = NIC_LINK_SPEED_100MBPS ; } <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_NCR ) ; <S2SV_EndBug> if ( ( status & NCR_FDX ) != 0 ) { interface -> duplexMode = NIC_FULL_DUPLEX_MODE ; } else { interface -> duplexMode = NIC_HALF_DUPLEX_MODE ; } interface -> linkState = TRUE ; } else { interface -> linkState = FALSE ; } nicNotifyLinkChange ( interface ) ; } <S2SV_StartBug> if ( ( status & ISR_PR ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PR ) ; <S2SV_EndBug> do { error = dm9000ReceivePacket ( interface ) ; } while ( error != ERROR_BUFFER_EMPTY ) ; } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , IMR_PAR | IMR_LNKCHGI | IMR_PTI | IMR_PRI ) ; <S2SV_EndBug> }
","<S2SV_ModStart> = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG <S2SV_ModEnd> ) != 0 <S2SV_ModStart> { dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG <S2SV_ModEnd> ) ; status <S2SV_ModStart> = dm9000ReadReg ( DM9000_NSR ) ; if ( ( status & DM9000_NSR_LINKST ) != 0 ) { if ( ( status & DM9000_NSR_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> = dm9000ReadReg ( DM9000_NCR ) ; if ( ( status & DM9000_NCR_FDX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & DM9000_ISR_PR <S2SV_ModEnd> ) != 0 <S2SV_ModStart> { dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PR <S2SV_ModEnd> ) ; do <S2SV_ModStart> } dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_size -- ; xmi_tmpdata -= 13 ; xmi_data += xmi_tmpdata ; xmi_size -= xmi_tmpdata ; if ( memcmp ( xmi_data , ""CAT<S2SV_blank>"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_catlen = * xmi_data ++ << 24 ; xmi_catlen |= * xmi_data ++ << 16 ; xmi_catlen |= * xmi_data ++ << 8 ; xmi_catlen |= * xmi_data ++ ; xmi_size -= 4 ; UNUSED ( xmi_catlen ) ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_mdi = _WM_initMDI ( ) ; _WM_midi_setup_divisions ( xmi_mdi , xmi_divisions ) ; _WM_midi_setup_tempo ( xmi_mdi , xmi_tempo ) ; xmi_samples_per_delta_f = _WM_GetSamplesPerTick ( xmi_divisions , xmi_tempo ) ; xmi_notelen = malloc ( sizeof ( uint32_t ) * 16 * 128 ) ; memset ( xmi_notelen , 0 , ( sizeof ( uint32_t ) * 16 * 128 ) ) ; for ( i = 0 ; i < xmi_formcnt ; i ++ ) { if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen = * xmi_data ++ << 24 ; xmi_subformlen |= * xmi_data ++ << 16 ; xmi_subformlen |= * xmi_data ++ << 8 ; xmi_subformlen |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XMID"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_subformlen -= 4 ; do { if ( ! memcmp ( xmi_data , ""TIMB"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""RBRN"" , 4 ) ) { xmi_data += 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_data += xmi_tmpdata ; xmi_size -= ( 8 + xmi_tmpdata ) ; xmi_subformlen -= ( 8 + xmi_tmpdata ) ; } else if ( ! memcmp ( xmi_data , ""EVNT"" , 4 ) ) { xmi_data += 4 ; xmi_evnt_cnt ++ ; xmi_evntlen = * xmi_data ++ << 24 ; xmi_evntlen |= * xmi_data ++ << 16 ; xmi_evntlen |= * xmi_data ++ << 8 ; xmi_evntlen |= * xmi_data ++ ; xmi_size -= 8 ; xmi_subformlen -= 8 ; do { if ( * xmi_data < 0x80 ) { xmi_delta = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_delta = ( xmi_delta << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; do { if ( ( xmi_lowestdelta != 0 ) && ( xmi_lowestdelta <= xmi_delta ) ) { xmi_tmpdata = xmi_lowestdelta ; } else { xmi_tmpdata = xmi_delta ; } xmi_sample_count_f = ( ( ( float ) xmi_tmpdata * xmi_samples_per_delta_f ) + xmi_sample_remainder ) ; xmi_sample_count = ( uint32_t ) xmi_sample_count_f ; xmi_sample_remainder = xmi_sample_count_f - ( float ) xmi_sample_count ; xmi_mdi -> events [ xmi_mdi -> event_count - 1 ] . samples_to_next += xmi_sample_count ; xmi_mdi -> extra_info . approx_total_samples += xmi_sample_count ; xmi_lowestdelta = 0 ; for ( j = 0 ; j < ( 16 * 128 ) ; j ++ ) { if ( xmi_notelen [ j ] == 0 ) continue ; xmi_notelen [ j ] -= xmi_tmpdata ; if ( xmi_notelen [ j ] == 0 ) { xmi_ch = j / 128 ; xmi_note = j - ( xmi_ch * 128 ) ; _WM_midi_setup_noteoff ( xmi_mdi , xmi_ch , xmi_note , 0 ) ; } else { if ( ( xmi_lowestdelta == 0 ) || ( xmi_lowestdelta > xmi_notelen [ j ] ) ) { xmi_lowestdelta = xmi_notelen [ j ] ; } } } xmi_delta -= xmi_tmpdata ; } while ( xmi_delta ) ; } else { if ( ( xmi_data [ 0 ] == 0xff ) && ( xmi_data [ 1 ] == 0x51 ) && ( xmi_data [ 2 ] == 0x03 ) ) { setup_ret = 6 ; goto _XMI_Next_Event ; } <S2SV_StartBug> if ( ( setup_ret = _WM_SetupMidiEvent ( xmi_mdi , xmi_data , 0 ) ) == 0 ) { <S2SV_EndBug> goto _xmi_end ; } if ( ( * xmi_data & 0xf0 ) == 0x90 ) { xmi_ch = * xmi_data & 0x0f ; xmi_note = xmi_data [ 1 ] ; xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; xmi_tmpdata = 0 ; if ( * xmi_data > 0x7f ) { while ( * xmi_data > 0x7f ) { xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; } } xmi_tmpdata = ( xmi_tmpdata << 7 ) | ( * xmi_data ++ & 0x7f ) ; xmi_size -- ; xmi_evntlen -- ; xmi_subformlen -- ; xmi_notelen [ 128 * xmi_ch + xmi_note ] = xmi_tmpdata ; if ( ( xmi_tmpdata > 0 ) && ( ( xmi_lowestdelta == 0 ) || ( xmi_tmpdata < xmi_lowestdelta ) ) ) { xmi_lowestdelta = xmi_tmpdata ; } } else { _XMI_Next_Event : xmi_data += setup_ret ; xmi_size -= setup_ret ; xmi_evntlen -= setup_ret ; xmi_subformlen -= setup_ret ; } } } while ( xmi_evntlen ) ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; goto _xmi_end ; } } while ( xmi_subformlen ) ; } if ( ( xmi_mdi -> reverb = _WM_init_reverb ( _WM_SampleRate , _WM_reverb_room_width , _WM_reverb_room_length , _WM_reverb_listen_posx , _WM_reverb_listen_posy ) ) == NULL ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_MEM , ""to<S2SV_blank>init<S2SV_blank>reverb"" , 0 ) ; goto _xmi_end ; } xmi_mdi -> extra_info . current_sample = 0 ; xmi_mdi -> current_event = & xmi_mdi -> events [ 0 ] ; xmi_mdi -> samples_to_mix = 0 ; xmi_mdi -> note = NULL ; if ( xmi_evnt_cnt > 1 ) { xmi_mdi -> is_type2 = 1 ; } _WM_ResetToStart ( xmi_mdi ) ; _xmi_end : if ( xmi_notelen != NULL ) free ( xmi_notelen ) ; if ( xmi_mdi -> reverb ) return ( xmi_mdi ) ; _WM_freeMDI ( xmi_mdi ) ; return NULL ; }
","<S2SV_ModStart> , xmi_data , xmi_size ,
",Mindwerks@wildmidi/ad6d7cf88d6673167ca1f517248af9409a9f1be1,CVE-2017-11664,https://github.com/Mindwerks/wildmidi/commit/ad6d7cf88d6673167ca1f517248af9409a9f1be1,2017-08-17T16:29Z
CWE-119,"CWE-119 static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , ""%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n"" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? ""Modified"" : ""Added"" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
","<S2SV_ModStart> ""REPLY_ADD_STA<S2SV_blank>PASSED\\n"" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
",torvalds@linux/2da424b0773cea3db47e1e81db71eeebde8269d4,CVE-2012-6712,https://github.com/torvalds/linux/commit/2da424b0773cea3db47e1e81db71eeebde8269d4,2019-07-27T22:15Z
CWE-200,"CWE-200 static void ipv6_select_ident ( struct frag_hdr * fhdr , struct rt6_info * rt ) { static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_EndBug> hash = __ipv6_addr_jhash ( & rt -> rt6i_dst . addr , ip6_idents_hashrnd ) ; hash = __ipv6_addr_jhash ( & rt -> rt6i_src . addr , hash ) ; <S2SV_StartBug> id = ip_idents_reserve ( hash , 1 ) ; <S2SV_EndBug> fhdr -> identification = htonl ( id ) ; }
","<S2SV_ModStart> ip6_idents_hashrnd __read_mostly ; static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip6_idents_hashrnd ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash ) ; hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;
",torvalds@linux/55f0fc7a02de8f12757f4937143d8d5091b2e40b,CVE-2019-10638,https://github.com/torvalds/linux/commit/55f0fc7a02de8f12757f4937143d8d5091b2e40b,2019-07-05T23:15Z
CWE-20,"CWE-20 int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; <S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }
","<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (
",systemd@systemd/a924f43f30f9c4acaf70618dd2a055f8b0f166be,CVE-2017-9217,https://github.com/systemd/systemd/commit/a924f43f30f9c4acaf70618dd2a055f8b0f166be,2017-05-24T05:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void encode_b_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> if ( bsize < BLOCK_8X8 ) { <S2SV_EndBug> if ( x -> ab_index > 0 ) return ; } <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_state_rt ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> update_stats ( cpi ) ; <S2SV_EndBug> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> mb ; <S2SV_ModEnd> set_offsets ( cpi <S2SV_ModStart> cpi , tile , x <S2SV_ModStart> ( cpi , td , ctx <S2SV_ModEnd> , mi_row , <S2SV_ModStart> bsize ) ; # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) { vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ; } # endif <S2SV_ModStart> encode_superblock ( cpi , td <S2SV_ModStart> mi_col , bsize , ctx <S2SV_ModStart> ; update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ; (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:<S2SV_blank>bad<S2SV_blank>"" ""negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Back<S2SV_blank>unset<S2SV_blank>"" ""on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>"" ""rule<S2SV_blank>%u\\n"" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( ""mark_source_chains:<S2SV_blank>"" ""bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n"" , newpos ) ; return 0 ; } duprintf ( ""Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n"" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( ""Finished<S2SV_blank>chain<S2SV_blank>%u\\n"" , hook ) ; } return 1 ; }
","<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
",torvalds@linux/54d83fc74aa9ec72794373cb47432c5f7fb1a309,CVE-2016-3134,https://github.com/torvalds/linux/commit/54d83fc74aa9ec72794373cb47432c5f7fb1a309,2016-04-27T17:59Z
CWE-264,"CWE-264 static void rd_release_device_space ( struct rd_dev * rd_dev ) { <S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( ! rd_dev -> sg_table_array || ! rd_dev -> sg_table_count ) return ; <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> sg = sg_table [ i ] . sg_table ; sg_per_table = sg_table [ i ] . rd_sg_count ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = sg_page ( & sg [ j ] ) ; if ( pg ) { __free_page ( pg ) ; page_count ++ ; } } kfree ( sg ) ; } pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" ""<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u,<S2SV_blank>pages<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables<S2SV_blank>total<S2SV_blank>bytes<S2SV_blank>%lu\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , page_count , rd_dev -> sg_table_count , ( unsigned long ) page_count * PAGE_SIZE ) ; <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> rd_dev -> sg_table_array = NULL ; rd_dev -> sg_table_count = 0 ; }
","<S2SV_ModStart> ) { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array
",torvalds@linux/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,CVE-2014-4027,https://github.com/torvalds/linux/commit/4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc,2014-06-23T11:21Z
CWE-000,"CWE-000 static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) { int i = 0 ; krb5_error_code st = 0 ; char * arg = NULL , * arg_val = NULL ; char * * dptr = NULL ; unsigned int arg_val_len = 0 ; if ( db_args ) { for ( i = 0 ; db_args [ i ] ; ++ i ) { arg = strtok_r ( db_args [ i ] , ""="" , & arg_val ) ; <S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> dptr = & xargs -> tktpolicydn ; } else { if ( strcmp ( arg , USERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> dn ; } else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> containerdn ; } else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) { if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> linkdn ; } else { st = EINVAL ; k5_setmsg ( context , st , _ ( ""unknown<S2SV_blank>option:<S2SV_blank>%s"" ) , arg ) ; goto cleanup ; } xargs -> dn_from_kbd = TRUE ; if ( arg_val == NULL || strlen ( arg_val ) == 0 ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } } if ( arg_val == NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } arg_val_len = strlen ( arg_val ) + 1 ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ; } else { * dptr = k5memdup ( arg_val , arg_val_len , & st ) ; if ( * dptr == NULL ) goto cleanup ; } } } cleanup : return st ; }
","<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : """" ;
",krb5@krb5/08c642c09c38a9c6454ab43a9b53b2a89b9eef99,CVE-2016-3119,https://github.com/krb5/krb5/commit/08c642c09c38a9c6454ab43a9b53b2a89b9eef99,2016-03-26T01:59Z
CWE-20,"CWE-20 sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; <S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
","<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
",torvalds@linux/ec0223ec48a90cb605244b45f7c62de856403729,CVE-2014-0101,https://github.com/torvalds/linux/commit/ec0223ec48a90cb605244b45f7c62de856403729,2014-03-11T13:01Z
CWE-787,"CWE-787 static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const IndexPacket * magick_restrict indexes ; register const PixelPacket * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , & image -> exception ) ; if ( p == ( const PixelPacket * ) NULL ) break ; indexes = GetVirtualIndexQueue ( image ) ; if ( y == 0 ) { waiting_code = ( short ) ( * indexes ) ; p ++ ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( IndexPacket ) ( ( size_t ) GetPixelIndex ( indexes + x ) & 0xff ) ; <S2SV_EndBug> p ++ ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
",ImageMagick@ImageMagick/19651f3db63fa1511ed83a348c4c82fa553f8d01,CVE-2019-13308,https://github.com/ImageMagick/ImageMagick/commit/19651f3db63fa1511ed83a348c4c82fa553f8d01,2019-07-05T01:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib , <S2SV_EndBug> MB_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int64_t * bestdistortion , BLOCK_SIZE bsize , int64_t rd_thresh ) { <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; int64_t best_rd = rd_thresh ; struct macroblock_plane * p = & x -> plane [ 0 ] ; struct macroblockd_plane * pd = & xd -> plane [ 0 ] ; const int src_stride = p -> src . stride ; const int dst_stride = pd -> dst . stride ; <S2SV_StartBug> const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> src_stride ) ] ; <S2SV_StartBug> uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib , <S2SV_EndBug> dst_stride ) ] ; ENTROPY_CONTEXT ta [ 2 ] , tempa [ 2 ] ; ENTROPY_CONTEXT tl [ 2 ] , templ [ 2 ] ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; uint8_t best_dst [ 8 * 8 ] ; <S2SV_StartBug> assert ( ib < 4 ) ; <S2SV_EndBug> vpx_memcpy ( ta , a , sizeof ( ta ) ) ; <S2SV_StartBug> vpx_memcpy ( tl , l , sizeof ( tl ) ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; <S2SV_EndBug> for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } <S2SV_StartBug> vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( templ , tl , sizeof ( tl ) ) ; <S2SV_EndBug> for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { <S2SV_StartBug> const int block = ib + idy * 2 + idx ; <S2SV_EndBug> const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; <S2SV_StartBug> int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block , <S2SV_EndBug> p -> src_diff ) ; <S2SV_StartBug> int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; <S2SV_EndBug> xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; <S2SV_StartBug> vp9_predict_intra_block ( xd , block , 1 , <S2SV_EndBug> TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , <S2SV_StartBug> dst , dst_stride , idx , idy , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; <S2SV_EndBug> if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; <S2SV_StartBug> vp9_fwht4x4 ( src_diff , coeff , 8 ) ; <S2SV_EndBug> vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) <S2SV_StartBug> goto next ; <S2SV_EndBug> vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , <S2SV_StartBug> p -> eobs [ block ] ) ; <S2SV_EndBug> } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; <S2SV_StartBug> vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; <S2SV_EndBug> vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; <S2SV_StartBug> distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , <S2SV_EndBug> <S2SV_StartBug> 16 , & unused ) >> 2 ; <S2SV_EndBug> if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) <S2SV_StartBug> goto next ; <S2SV_EndBug> vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , <S2SV_StartBug> dst , dst_stride , p -> eobs [ block ] ) ; <S2SV_EndBug> } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; <S2SV_StartBug> vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( l , templ , sizeof ( templ ) ) ; <S2SV_EndBug> for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) <S2SV_StartBug> vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> } <S2SV_StartBug> next : <S2SV_EndBug> { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) <S2SV_StartBug> vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , <S2SV_EndBug> <S2SV_StartBug> num_4x4_blocks_wide * 4 ) ; <S2SV_EndBug> return best_rd ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> x , int row , int col , PREDICTION_MODE <S2SV_ModEnd> * best_mode , <S2SV_ModStart> rd_thresh ) { PREDICTION_MODE <S2SV_ModEnd> mode ; MACROBLOCKD <S2SV_ModStart> . buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; uint8_t <S2SV_ModStart> . buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; ENTROPY_CONTEXT <S2SV_ModStart> 8 ] ; # if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ; # endif memcpy <S2SV_ModEnd> ( ta , <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( tl , <S2SV_ModStart> = TX_4X4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> continue ; } memcpy <S2SV_ModEnd> ( tempa , <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( templ , <S2SV_ModStart> int block = ( row + idy ) <S2SV_ModEnd> * 2 + <S2SV_ModStart> * 2 + ( col + idx ) <S2SV_ModEnd> ; const uint8_t <S2SV_ModStart> const src_diff = vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> src_diff ) ; tran_low_t <S2SV_ModEnd> * const coeff <S2SV_ModStart> ( xd , <S2SV_ModEnd> 1 , TX_4X4 <S2SV_ModStart> , dst_stride , col + idx , row + idy , 0 ) ; vpx_highbd_subtract_block <S2SV_ModEnd> ( 4 , <S2SV_ModStart> dst , dst_stride , xd -> bd <S2SV_ModStart> TX_4X4 ] ; vp9_highbd_fwht4x4 <S2SV_ModEnd> ( src_diff , <S2SV_ModStart> best_rd ) goto next_highbd ; vp9_highbd_iwht4x4_add <S2SV_ModEnd> ( BLOCK_OFFSET ( <S2SV_ModStart> [ block ] , xd -> bd <S2SV_ModStart> tx_type ] ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ; else vp9_highbd_fht4x4 <S2SV_ModEnd> ( src_diff , <S2SV_ModStart> ; distortion += vp9_highbd_block_error ( <S2SV_ModEnd> coeff , BLOCK_OFFSET <S2SV_ModStart> , & unused , xd -> bd <S2SV_ModStart> best_rd ) goto next_highbd ; vp9_highbd_iht4x4_add <S2SV_ModEnd> ( tx_type , <S2SV_ModStart> [ block ] , xd -> bd <S2SV_ModStart> = mode ; memcpy <S2SV_ModEnd> ( a , <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( l , <S2SV_ModStart> ++ idy ) { memcpy ( best_dst16 <S2SV_ModEnd> + idy * <S2SV_ModStart> * 8 , CONVERT_TO_SHORTPTR ( <S2SV_ModStart> idy * dst_stride ) <S2SV_ModStart> num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) <S2SV_ModStart> ) ; } } next_highbd <S2SV_ModEnd> : { } <S2SV_ModStart> ++ idy ) { memcpy ( CONVERT_TO_SHORTPTR <S2SV_ModEnd> ( dst_init + <S2SV_ModStart> idy * dst_stride ) , best_dst16 <S2SV_ModEnd> + idy * <S2SV_ModStart> num_4x4_blocks_wide * 4 * sizeof ( uint16_t ) ) ; } <S2SV_ModEnd> return best_rd ; <S2SV_ModStart> best_rd ; } # endif for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } memcpy ( tempa , ta , sizeof ( ta ) ) ; memcpy ( templ , tl , sizeof ( tl ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) ; const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_fwht4x4 ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; memcpy ( a , tempa , sizeof ( tempa ) ) ; memcpy ( l , templ , sizeof ( templ ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ; } next : { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ; return best_rd ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp9_remove_common ( VP9_COMMON * cm ) { <S2SV_StartBug> vp9_free_frame_buffers ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_free_internal_frame_buffers ( & cm -> int_frame_buffers ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cm ) { vp9_free_context_buffers <S2SV_ModEnd> ( cm ) <S2SV_ModStart> cm ) ; vpx_free ( cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-362,"CWE-362 static int packet_do_bind ( struct sock * sk , const char * name , int ifindex , __be16 proto ) { struct packet_sock * po = pkt_sk ( sk ) ; struct net_device * dev_curr ; __be16 proto_curr ; bool need_rehook ; struct net_device * dev = NULL ; int ret = 0 ; bool unlisted = false ; <S2SV_StartBug> if ( po -> fanout ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; if ( name ) { dev = dev_get_by_name_rcu ( sock_net ( sk ) , name ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } else if ( ifindex ) { dev = dev_get_by_index_rcu ( sock_net ( sk ) , ifindex ) ; if ( ! dev ) { ret = - ENODEV ; goto out_unlock ; } } if ( dev ) dev_hold ( dev ) ; proto_curr = po -> prot_hook . type ; dev_curr = po -> prot_hook . dev ; need_rehook = proto_curr != proto || dev_curr != dev ; if ( need_rehook ) { if ( po -> running ) { rcu_read_unlock ( ) ; __unregister_prot_hook ( sk , true ) ; rcu_read_lock ( ) ; dev_curr = po -> prot_hook . dev ; if ( dev ) unlisted = ! dev_get_by_index_rcu ( sock_net ( sk ) , dev -> ifindex ) ; } po -> num = proto ; po -> prot_hook . type = proto ; if ( unlikely ( unlisted ) ) { dev_put ( dev ) ; po -> prot_hook . dev = NULL ; po -> ifindex = - 1 ; packet_cached_dev_reset ( po ) ; } else { po -> prot_hook . dev = dev ; po -> ifindex = dev ? dev -> ifindex : 0 ; packet_cached_dev_assign ( po , dev ) ; } } if ( dev_curr ) dev_put ( dev_curr ) ; if ( proto == 0 || ! need_rehook ) goto out_unlock ; if ( ! unlisted && ( ! dev || ( dev -> flags & IFF_UP ) ) ) { register_prot_hook ( sk ) ; } else { sk -> sk_err = ENETDOWN ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_error_report ( sk ) ; } out_unlock : rcu_read_unlock ( ) ; spin_unlock ( & po -> bind_lock ) ; release_sock ( sk ) ; return ret ; }
","<S2SV_ModStart> = false ; lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> fanout ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out_unlock ; } <S2SV_ModEnd> if ( name
",torvalds@linux/4971613c1639d8e5f102c4e797c3bf8f83a5a69e,CVE-2017-15649,https://github.com/torvalds/linux/commit/4971613c1639d8e5f102c4e797c3bf8f83a5a69e,2017-10-19T22:29Z
CWE-125,"CWE-125 void icmp6_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 , int fragmented ) { const struct icmp6_hdr * dp ; const struct ip6_hdr * ip ; const struct ip6_hdr * oip ; const struct udphdr * ouh ; int dport ; const u_char * ep ; u_int prot ; dp = ( const struct icmp6_hdr * ) bp ; ip = ( const struct ip6_hdr * ) bp2 ; oip = ( const struct ip6_hdr * ) ( dp + 1 ) ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> icmp6_cksum ) ; if ( ndo -> ndo_vflag && ! fragmented ) { uint16_t sum , udp_sum ; if ( ND_TTEST2 ( bp [ 0 ] , length ) ) { udp_sum = EXTRACT_16BITS ( & dp -> icmp6_cksum ) ; sum = icmp6_cksum ( ndo , ip , dp , length ) ; if ( sum != 0 ) ND_PRINT ( ( ndo , ""[bad<S2SV_blank>icmp6<S2SV_blank>cksum<S2SV_blank>0x%04x<S2SV_blank>-><S2SV_blank>0x%04x!]<S2SV_blank>"" , udp_sum , in_cksum_shouldbe ( udp_sum , sum ) ) ) ; else ND_PRINT ( ( ndo , ""[icmp6<S2SV_blank>sum<S2SV_blank>ok]<S2SV_blank>"" ) ) ; } } ND_PRINT ( ( ndo , ""ICMP6,<S2SV_blank>%s"" , tok2str ( icmp6_type_values , ""unknown<S2SV_blank>icmp6<S2SV_blank>type<S2SV_blank>(%u)"" , dp -> icmp6_type ) ) ) ; if ( ndo -> ndo_vflag && ( dp -> icmp6_type == ND_ROUTER_SOLICIT || dp -> icmp6_type == ND_ROUTER_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_ADVERT || dp -> icmp6_type == ND_NEIGHBOR_SOLICIT || dp -> icmp6_type == ND_REDIRECT || dp -> icmp6_type == ICMP6_HADISCOV_REPLY || dp -> icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; switch ( dp -> icmp6_type ) { case ICMP6_DST_UNREACH : ND_TCHECK ( oip -> ip6_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( icmp6_dst_unreach_code_values , ""unknown<S2SV_blank>unreach<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ) ; switch ( dp -> icmp6_code ) { case ICMP6_DST_UNREACH_NOROUTE : case ICMP6_DST_UNREACH_ADMIN : case ICMP6_DST_UNREACH_ADDR : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_DST_UNREACH_BEYONDSCOPE : ND_PRINT ( ( ndo , ""<S2SV_blank>%s,<S2SV_blank>source<S2SV_blank>address<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , ip6addr_string ( ndo , & oip -> ip6_src ) ) ) ; break ; case ICMP6_DST_UNREACH_NOPORT : if ( ( ouh = get_upperlayer ( ndo , ( const u_char * ) oip , & prot ) ) == NULL ) goto trunc ; dport = EXTRACT_16BITS ( & ouh -> uh_dport ) ; switch ( prot ) { case IPPROTO_TCP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>tcp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , tcpport_string ( ndo , dport ) ) ) ; break ; case IPPROTO_UDP : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>udp<S2SV_blank>port<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , udpport_string ( ndo , dport ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>protocol<S2SV_blank>%d<S2SV_blank>port<S2SV_blank>%d<S2SV_blank>unreachable"" , ip6addr_string ( ndo , & oip -> ip6_dst ) , oip -> ip6_nxt , dport ) ) ; break ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } break ; } break ; case ICMP6_PACKET_TOO_BIG : ND_TCHECK ( dp -> icmp6_mtu ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>mtu<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_mtu ) ) ) ; break ; case ICMP6_TIME_EXCEEDED : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_TIME_EXCEED_TRANSIT : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>%s"" , ip6addr_string ( ndo , & oip -> ip6_dst ) ) ) ; break ; case ICMP6_TIME_EXCEED_REASSEMBLY : ND_PRINT ( ( ndo , ""<S2SV_blank>(reassembly)"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>code<S2SV_blank>(%u)"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_PARAM_PROB : ND_TCHECK ( oip -> ip6_dst ) ; switch ( dp -> icmp6_code ) { case ICMP6_PARAMPROB_HEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>erroneous<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_NEXTHEADER : ND_PRINT ( ( ndo , "",<S2SV_blank>next<S2SV_blank>header<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; case ICMP6_PARAMPROB_OPTION : ND_PRINT ( ( ndo , "",<S2SV_blank>option<S2SV_blank>-<S2SV_blank>octet<S2SV_blank>%u"" , EXTRACT_32BITS ( & dp -> icmp6_pptr ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>code-#%d"" , dp -> icmp6_code ) ) ; break ; } break ; case ICMP6_ECHO_REQUEST : case ICMP6_ECHO_REPLY : ND_TCHECK ( dp -> icmp6_seq ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_16BITS ( & dp -> icmp6_seq ) ) ) ; break ; case ICMP6_MEMBERSHIP_QUERY : if ( length == MLD_MINLEN ) { mld6_print ( ndo , ( const u_char * ) dp ) ; } else if ( length >= MLDV2_MINLEN ) { ND_PRINT ( ( ndo , ""<S2SV_blank>v2"" ) ) ; mldv2_query_print ( ndo , ( const u_char * ) dp , length ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>unknown-version<S2SV_blank>(len<S2SV_blank>%u)<S2SV_blank>"" , length ) ) ; } break ; case ICMP6_MEMBERSHIP_REPORT : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ICMP6_MEMBERSHIP_REDUCTION : mld6_print ( ndo , ( const u_char * ) dp ) ; break ; case ND_ROUTER_SOLICIT : # define RTSOLLEN 8 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + RTSOLLEN , length - RTSOLLEN ) ; } break ; case ND_ROUTER_ADVERT : # define RTADVLEN 16 if ( ndo -> ndo_vflag ) { const struct nd_router_advert * p ; p = ( const struct nd_router_advert * ) dp ; ND_TCHECK ( p -> nd_ra_retransmit ) ; ND_PRINT ( ( ndo , ""\\n\\thop<S2SV_blank>limit<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s]"" "",<S2SV_blank>pref<S2SV_blank>%s,<S2SV_blank>router<S2SV_blank>lifetime<S2SV_blank>%us,<S2SV_blank>reachable<S2SV_blank>time<S2SV_blank>%ums,<S2SV_blank>retrans<S2SV_blank>timer<S2SV_blank>%ums"" , ( u_int ) p -> nd_ra_curhoplimit , bittok2str ( icmp6_opt_ra_flag_values , ""none"" , ( p -> nd_ra_flags_reserved ) ) , get_rtpref ( p -> nd_ra_flags_reserved ) , EXTRACT_16BITS ( & p -> nd_ra_router_lifetime ) , EXTRACT_32BITS ( & p -> nd_ra_reachable ) , EXTRACT_32BITS ( & p -> nd_ra_retransmit ) ) ) ; icmp6_opt_print ( ndo , ( const u_char * ) dp + RTADVLEN , length - RTADVLEN ) ; } break ; case ND_NEIGHBOR_SOLICIT : { const struct nd_neighbor_solicit * p ; p = ( const struct nd_neighbor_solicit * ) dp ; ND_TCHECK ( p -> nd_ns_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>who<S2SV_blank>has<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_ns_target ) ) ) ; if ( ndo -> ndo_vflag ) { # define NDSOLLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDSOLLEN , length - NDSOLLEN ) ; } } break ; case ND_NEIGHBOR_ADVERT : { const struct nd_neighbor_advert * p ; p = ( const struct nd_neighbor_advert * ) dp ; ND_TCHECK ( p -> nd_na_target ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>tgt<S2SV_blank>is<S2SV_blank>%s"" , ip6addr_string ( ndo , & p -> nd_na_target ) ) ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( icmp6_nd_na_flag_values , ""none"" , EXTRACT_32BITS ( & p -> nd_na_flags_reserved ) ) ) ) ; # define NDADVLEN 24 icmp6_opt_print ( ndo , ( const u_char * ) dp + NDADVLEN , length - NDADVLEN ) ; # undef NDADVLEN } } break ; case ND_REDIRECT : # define RDR ( i ) ( ( const struct nd_redirect * ) ( i ) ) ND_TCHECK ( RDR ( dp ) -> nd_rd_dst ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_dst ) ) ) ; ND_TCHECK ( RDR ( dp ) -> nd_rd_target ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>to<S2SV_blank>%s"" , ip6addr_string ( ndo , & RDR ( dp ) -> nd_rd_target ) ) ) ; # define REDIRECTLEN 40 if ( ndo -> ndo_vflag ) { icmp6_opt_print ( ndo , ( const u_char * ) dp + REDIRECTLEN , length - REDIRECTLEN ) ; } break ; # undef REDIRECTLEN # undef RDR case ICMP6_ROUTER_RENUMBERING : icmp6_rrenum_print ( ndo , bp , ep ) ; break ; case ICMP6_NI_QUERY : case ICMP6_NI_REPLY : icmp6_nodeinfo_print ( ndo , length , bp , ep ) ; break ; case IND_SOLICIT : case IND_ADVERT : break ; case ICMP6_V2_MEMBERSHIP_REPORT : mldv2_report_print ( ndo , ( const u_char * ) dp , length ) ; break ; case ICMP6_MOBILEPREFIX_SOLICIT : case ICMP6_HADISCOV_REQUEST : ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; break ; case ICMP6_HADISCOV_REPLY : if ( ndo -> ndo_vflag ) { const struct in6_addr * in6 ; const u_char * cp ; ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; cp = ( const u_char * ) dp + length ; in6 = ( const struct in6_addr * ) ( dp + 1 ) ; for ( ; ( const u_char * ) in6 < cp ; in6 ++ ) { ND_TCHECK ( * in6 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ip6addr_string ( ndo , in6 ) ) ) ; } } break ; case ICMP6_MOBILEPREFIX_ADVERT : if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp -> icmp6_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>id<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( & dp -> icmp6_data16 [ 0 ] ) ) ) ; ND_TCHECK ( dp -> icmp6_data16 [ 1 ] ) ; if ( dp -> icmp6_data16 [ 1 ] & 0xc0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , ""M"" ) ) ; if ( dp -> icmp6_data16 [ 1 ] & 0x40 ) ND_PRINT ( ( ndo , ""O"" ) ) ; # define MPADVLEN 8 icmp6_opt_print ( ndo , ( const u_char * ) dp + MPADVLEN , length - MPADVLEN ) ; } break ; case ND_RPL_MESSAGE : rpl_print ( ndo , dp , & dp -> icmp6_data8 [ 0 ] , length - sizeof ( struct icmp6_hdr ) + 4 ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , bp , ""\\n\\t"" , length ) ; return ; } if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
CWE-119,"CWE-119 <S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> FILE * f = input_ctx -> file ; y4m_input * y4m = & input_ctx -> y4m ; int shortread = 0 ; if ( input_ctx -> file_type == FILE_TYPE_Y4M ) { if ( y4m_input_fetch_frame ( y4m , f , img ) < 1 ) return 0 ; } else { shortread = read_yuv_frame ( input_ctx , img ) ; } return ! shortread ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static void ext4_free_io_end ( ext4_io_end_t * io ) { <S2SV_StartBug> BUG_ON ( ! io ) ; <S2SV_EndBug> iput ( io -> inode ) ; kfree ( io ) ; }
","<S2SV_ModStart> ( ! io ) ; if ( io -> page ) put_page ( io -> page
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-399,"CWE-399 static int kvm_guest_time_update ( struct kvm_vcpu * v ) { unsigned long flags , this_tsc_khz ; struct kvm_vcpu_arch * vcpu = & v -> arch ; struct kvm_arch * ka = & v -> kvm -> arch ; <S2SV_StartBug> void * shared_kaddr ; <S2SV_EndBug> s64 kernel_ns , max_kernel_ns ; u64 tsc_timestamp , host_tsc ; <S2SV_StartBug> struct pvclock_vcpu_time_info * guest_hv_clock ; <S2SV_EndBug> u8 pvclock_flags ; bool use_master_clock ; kernel_ns = 0 ; host_tsc = 0 ; spin_lock ( & ka -> pvclock_gtod_sync_lock ) ; use_master_clock = ka -> use_master_clock ; if ( use_master_clock ) { host_tsc = ka -> master_cycle_now ; kernel_ns = ka -> master_kernel_ns ; } spin_unlock ( & ka -> pvclock_gtod_sync_lock ) ; local_irq_save ( flags ) ; this_tsc_khz = __get_cpu_var ( cpu_tsc_khz ) ; if ( unlikely ( this_tsc_khz == 0 ) ) { local_irq_restore ( flags ) ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , v ) ; return 1 ; } if ( ! use_master_clock ) { host_tsc = native_read_tsc ( ) ; kernel_ns = get_kernel_ns ( ) ; } tsc_timestamp = kvm_x86_ops -> read_l1_tsc ( v , host_tsc ) ; if ( vcpu -> tsc_catchup ) { u64 tsc = compute_guest_tsc ( v , kernel_ns ) ; if ( tsc > tsc_timestamp ) { adjust_tsc_offset_guest ( v , tsc - tsc_timestamp ) ; tsc_timestamp = tsc ; } } local_irq_restore ( flags ) ; <S2SV_StartBug> if ( ! vcpu -> time_page ) <S2SV_EndBug> return 0 ; max_kernel_ns = 0 ; if ( vcpu -> hv_clock . tsc_timestamp ) { max_kernel_ns = vcpu -> last_guest_tsc - vcpu -> hv_clock . tsc_timestamp ; max_kernel_ns = pvclock_scale_delta ( max_kernel_ns , vcpu -> hv_clock . tsc_to_system_mul , vcpu -> hv_clock . tsc_shift ) ; max_kernel_ns += vcpu -> last_kernel_ns ; } if ( unlikely ( vcpu -> hw_tsc_khz != this_tsc_khz ) ) { kvm_get_time_scale ( NSEC_PER_SEC / 1000 , this_tsc_khz , & vcpu -> hv_clock . tsc_shift , & vcpu -> hv_clock . tsc_to_system_mul ) ; vcpu -> hw_tsc_khz = this_tsc_khz ; } if ( ! use_master_clock ) { if ( max_kernel_ns > kernel_ns ) kernel_ns = max_kernel_ns ; } vcpu -> hv_clock . tsc_timestamp = tsc_timestamp ; vcpu -> hv_clock . system_time = kernel_ns + v -> kvm -> arch . kvmclock_offset ; vcpu -> last_kernel_ns = kernel_ns ; vcpu -> last_guest_tsc = tsc_timestamp ; vcpu -> hv_clock . version += 2 ; <S2SV_StartBug> shared_kaddr = kmap_atomic ( vcpu -> time_page ) ; <S2SV_EndBug> guest_hv_clock = shared_kaddr + vcpu -> time_offset ; <S2SV_StartBug> pvclock_flags = ( guest_hv_clock -> flags & PVCLOCK_GUEST_STOPPED ) ; <S2SV_EndBug> if ( vcpu -> pvclock_set_guest_stopped_request ) { pvclock_flags |= PVCLOCK_GUEST_STOPPED ; vcpu -> pvclock_set_guest_stopped_request = false ; } if ( use_master_clock ) pvclock_flags |= PVCLOCK_TSC_STABLE_BIT ; vcpu -> hv_clock . flags = pvclock_flags ; <S2SV_StartBug> memcpy ( shared_kaddr + vcpu -> time_offset , & vcpu -> hv_clock , <S2SV_EndBug> sizeof ( vcpu -> hv_clock ) ) ; <S2SV_StartBug> kunmap_atomic ( shared_kaddr ) ; <S2SV_EndBug> mark_page_dirty ( v -> kvm , vcpu -> time >> PAGE_SHIFT ) ; return 0 ; }
","<S2SV_ModStart> -> arch ; <S2SV_ModEnd> s64 kernel_ns , <S2SV_ModStart> ; struct pvclock_vcpu_time_info <S2SV_ModEnd> guest_hv_clock ; u8 <S2SV_ModStart> ! vcpu -> pv_time_enabled <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 2 ; if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> ; pvclock_flags = <S2SV_ModStart> = ( guest_hv_clock . <S2SV_ModEnd> flags & PVCLOCK_GUEST_STOPPED <S2SV_ModStart> = pvclock_flags ; kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> & vcpu -> <S2SV_ModStart> ) ) ; <S2SV_ModEnd> return 0 ;
",torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z
CWE-674,"CWE-674 int yyparse ( void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 : <S2SV_StartBug> # line 105 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1340 ""re_grammar.c"" <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> # line 114 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1348 ""re_grammar.c"" <S2SV_EndBug> break ; case 5 : <S2SV_StartBug> # line 118 ""re_grammar.y"" <S2SV_EndBug> { mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1363 ""re_grammar.c"" <S2SV_EndBug> break ; case 6 : <S2SV_StartBug> # line 129 ""re_grammar.y"" <S2SV_EndBug> { RE_NODE * node ; mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> node = yr_re_node_create ( RE_NODE_EMPTY , NULL , NULL ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; ERROR_IF ( node == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 1 ] . re_node ) , node ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1382 ""re_grammar.c"" <S2SV_EndBug> break ; case 7 : <S2SV_StartBug> # line 147 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1390 ""re_grammar.c"" <S2SV_EndBug> break ; case 8 : <S2SV_StartBug> # line 151 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1402 ""re_grammar.c"" <S2SV_EndBug> break ; case 9 : <S2SV_StartBug> # line 162 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast ; mark_as_not_fast_regexp ( ) ; re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_GREEDY ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_STAR , ( yyvsp [ - 1 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1420 ""re_grammar.c"" <S2SV_EndBug> break ; case 10 : <S2SV_StartBug> # line 176 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast ; mark_as_not_fast_regexp ( ) ; re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_UNGREEDY ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_STAR , ( yyvsp [ - 2 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1440 ""re_grammar.c"" <S2SV_EndBug> break ; case 11 : <S2SV_StartBug> # line 192 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast ; mark_as_not_fast_regexp ( ) ; re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_GREEDY ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_PLUS , ( yyvsp [ - 1 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1458 ""re_grammar.c"" <S2SV_EndBug> break ; case 12 : <S2SV_StartBug> # line 206 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast ; mark_as_not_fast_regexp ( ) ; re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_UNGREEDY ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_PLUS , ( yyvsp [ - 2 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1478 ""re_grammar.c"" <S2SV_EndBug> break ; case 13 : <S2SV_StartBug> # line 222 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_GREEDY ; if ( ( yyvsp [ - 1 ] . re_node ) -> type == RE_NODE_ANY ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; DESTROY_NODE_IF ( TRUE , ( yyvsp [ - 1 ] . re_node ) ) ; } else { mark_as_not_fast_regexp ( ) ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE , ( yyvsp [ - 1 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = 1 ; } <S2SV_StartBug> # line 1505 ""re_grammar.c"" <S2SV_EndBug> break ; case 14 : <S2SV_StartBug> # line 245 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_UNGREEDY ; if ( ( yyvsp [ - 2 ] . re_node ) -> type == RE_NODE_ANY ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; DESTROY_NODE_IF ( TRUE , ( yyvsp [ - 2 ] . re_node ) ) ; } else { mark_as_not_fast_regexp ( ) ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE , ( yyvsp [ - 2 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = 1 ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1533 ""re_grammar.c"" <S2SV_EndBug> break ; case 15 : <S2SV_StartBug> # line 269 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_GREEDY ; if ( ( yyvsp [ - 1 ] . re_node ) -> type == RE_NODE_ANY ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; DESTROY_NODE_IF ( TRUE , ( yyvsp [ - 1 ] . re_node ) ) ; } else { mark_as_not_fast_regexp ( ) ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE , ( yyvsp [ - 1 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; } ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( yyvsp [ 0 ] . range ) & 0xFFFF ; ; ( yyval . re_node ) -> end = ( yyvsp [ 0 ] . range ) >> 16 ; ; } <S2SV_StartBug> # line 1559 ""re_grammar.c"" <S2SV_EndBug> break ; case 16 : <S2SV_StartBug> # line 291 ""re_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> flags |= RE_FLAGS_UNGREEDY ; if ( ( yyvsp [ - 2 ] . re_node ) -> type == RE_NODE_ANY ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; DESTROY_NODE_IF ( TRUE , ( yyvsp [ - 2 ] . re_node ) ) ; } else { mark_as_not_fast_regexp ( ) ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE , ( yyvsp [ - 2 ] . re_node ) , NULL ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; } ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( yyvsp [ - 1 ] . range ) & 0xFFFF ; ; ( yyval . re_node ) -> end = ( yyvsp [ - 1 ] . range ) >> 16 ; ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1586 ""re_grammar.c"" <S2SV_EndBug> break ; case 17 : <S2SV_StartBug> # line 314 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1594 ""re_grammar.c"" <S2SV_EndBug> break ; case 18 : <S2SV_StartBug> # line 318 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_WORD_BOUNDARY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1604 ""re_grammar.c"" <S2SV_EndBug> break ; case 19 : <S2SV_StartBug> # line 324 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_NON_WORD_BOUNDARY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1614 ""re_grammar.c"" <S2SV_EndBug> break ; case 20 : <S2SV_StartBug> # line 330 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANCHOR_START , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1624 ""re_grammar.c"" <S2SV_EndBug> break ; case 21 : <S2SV_StartBug> # line 336 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANCHOR_END , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1634 ""re_grammar.c"" <S2SV_EndBug> break ; case 22 : <S2SV_StartBug> # line 345 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; } <S2SV_StartBug> # line 1642 ""re_grammar.c"" <S2SV_EndBug> break ; case 23 : <S2SV_StartBug> # line 349 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1652 ""re_grammar.c"" <S2SV_EndBug> break ; case 24 : <S2SV_StartBug> # line 355 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 1664 ""re_grammar.c"" <S2SV_EndBug> break ; case 25 : <S2SV_StartBug> # line 363 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_WORD_CHAR , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1674 ""re_grammar.c"" <S2SV_EndBug> break ; case 26 : <S2SV_StartBug> # line 369 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_NON_WORD_CHAR , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1684 ""re_grammar.c"" <S2SV_EndBug> break ; case 27 : <S2SV_StartBug> # line 375 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_SPACE , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1694 ""re_grammar.c"" <S2SV_EndBug> break ; case 28 : <S2SV_StartBug> # line 381 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_NON_SPACE , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1704 ""re_grammar.c"" <S2SV_EndBug> break ; case 29 : <S2SV_StartBug> # line 387 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_DIGIT , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1714 ""re_grammar.c"" <S2SV_EndBug> break ; case 30 : <S2SV_StartBug> # line 393 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_NON_DIGIT , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1724 ""re_grammar.c"" <S2SV_EndBug> break ; case 31 : <S2SV_StartBug> # line 399 ""re_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CLASS , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> class_vector = ( yyvsp [ 0 ] . class_vector ) ; } <S2SV_StartBug> # line 1736 ""re_grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 1740 ""re_grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }
","<S2SV_ModStart> : # line 113 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1348 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1356 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> ""re_grammar.y"" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1372 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 138 <S2SV_ModEnd> ""re_grammar.y"" { RE_NODE <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1392 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 157 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1400 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 161 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1414 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 174 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 188 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1452 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 204 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1470 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 218 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1490 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 234 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1517 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 257 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1545 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 281 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1571 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 303 <S2SV_ModEnd> ""re_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1598 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 326 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1606 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 330 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1616 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1626 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 342 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1636 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 348 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1646 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 357 ""re_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1656 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 363 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1666 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 369 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1678 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 377 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1688 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1698 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 389 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1708 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 395 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1718 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 401 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1728 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 407 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1738 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> : # line 413 <S2SV_ModEnd> ""re_grammar.y"" { ( <S2SV_ModStart> } # line 1750 <S2SV_ModEnd> ""re_grammar.c"" break ; <S2SV_ModStart> ; # line 1754 <S2SV_ModEnd> ""re_grammar.c"" default :
",VirusTotal@yara/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,CVE-2017-9304,https://github.com/VirusTotal/yara/commit/925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699,2017-05-31T04:29Z
CWE-200,"CWE-200 static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) { static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; <S2SV_StartBug> u32 now ; <S2SV_EndBug> if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ; now = jiffies / HZ ; if ( now != challenge_timestamp ) { <S2SV_StartBug> challenge_timestamp = now ; <S2SV_EndBug> <S2SV_StartBug> challenge_count = 0 ; <S2SV_EndBug> } if ( ++ challenge_count <= sysctl_tcp_challenge_ack_limit ) { NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; tcp_send_ack ( sk ) ; } }
","<S2SV_ModStart> ) ; u32 count , <S2SV_ModStart> challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net
",torvalds@linux/75ff39ccc1bd5d3c455b6822ab09e533c551f758,CVE-2016-5696,https://github.com/torvalds/linux/commit/75ff39ccc1bd5d3c455b6822ab09e533c551f758,2016-08-06T20:59Z
CWE-476,"CWE-476 int crypto_rng_reset ( struct crypto_rng * tfm , const u8 * seed , unsigned int slen ) { u8 * buf = NULL ; int err ; if ( ! seed && slen ) { buf = kmalloc ( slen , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; get_random_bytes ( buf , slen ) ; seed = buf ; } <S2SV_StartBug> err = tfm -> seed ( tfm , seed , slen ) ; <S2SV_EndBug> kfree ( buf ) ; return err ; }
","<S2SV_ModStart> } err = crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> seed (
",torvalds@linux/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,CVE-2017-15116,https://github.com/torvalds/linux/commit/94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6,2017-11-30T18:29Z
CWE-399,"CWE-399 static int db_interception ( struct vcpu_svm * svm ) { struct kvm_run * kvm_run = svm -> vcpu . run ; if ( ! ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) && ! svm -> nmi_singlestep ) { kvm_queue_exception ( & svm -> vcpu , DB_VECTOR ) ; return 1 ; } if ( svm -> nmi_singlestep ) { svm -> nmi_singlestep = false ; if ( ! ( svm -> vcpu . guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) svm -> vmcb -> save . rflags &= ~ ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( & svm -> vcpu ) ; <S2SV_EndBug> } if ( svm -> vcpu . guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) { kvm_run -> exit_reason = KVM_EXIT_DEBUG ; kvm_run -> debug . arch . pc = svm -> vmcb -> save . cs . base + svm -> vmcb -> save . rip ; kvm_run -> debug . arch . exception = DB_VECTOR ; return 0 ; } return 1 ; }
","<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if (
",torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z
CWE-401,"CWE-401 struct resource_pool * dce120_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z
CWE-125,"CWE-125 static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> int tstype ) <S2SV_EndBug> { struct sock_exterr_skb * serr ; <S2SV_StartBug> int err ; <S2SV_EndBug> serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; <S2SV_StartBug> serr -> ee . ee_info = tstype ; <S2SV_EndBug> if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
","<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
",torvalds@linux/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,CVE-2017-7277,https://github.com/torvalds/linux/commit/4ef1b2869447411ad3ef91ad7d4891a83c1a509a,2017-03-28T06:59Z
CWE-119,"CWE-119 int disrsi_ ( int stream , int * negate , unsigned * value , unsigned count ) { int c ; unsigned locval ; unsigned ndigs ; char * cp ; char scratch [ DIS_BUFSIZ + 1 ] ; assert ( negate != NULL ) ; assert ( value != NULL ) ; assert ( count ) ; assert ( stream >= 0 ) ; assert ( dis_getc != NULL ) ; assert ( dis_gets != NULL ) ; memset ( scratch , 0 , DIS_BUFSIZ + 1 ) ; if ( dis_umaxd == 0 ) disiui_ ( ) ; <S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> { case '-' : case '+' : * negate = c == '-' ; if ( ( * dis_gets ) ( stream , scratch , count ) != ( int ) count ) { return ( DIS_EOD ) ; } if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } cp = scratch ; locval = 0 ; do { if ( ( ( c = * cp ++ ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } locval = 10 * locval + c - '0' ; } while ( -- count ) ; * value = locval ; return ( DIS_SUCCESS ) ; break ; case '0' : return ( DIS_LEADZRO ) ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : ndigs = c - '0' ; if ( count > 1 ) { if ( ( * dis_gets ) ( stream , scratch + 1 , count - 1 ) != ( int ) count - 1 ) { return ( DIS_EOD ) ; } cp = scratch ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) break ; * cp = c ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) break ; } while ( -- count ) { if ( ( ( c = * ++ cp ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } ndigs = 10 * ndigs + c - '0' ; } } return ( disrsi_ ( stream , negate , value , ndigs ) ) ; break ; case - 1 : return ( DIS_EOD ) ; break ; case - 2 : return ( DIS_EOF ) ; break ; default : return ( DIS_NONDIGIT ) ; break ; } * negate = FALSE ; overflow : * value = UINT_MAX ; return ( DIS_OVERFLOW ) ; }
","<S2SV_ModStart> ( ) ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; }
",adaptivecomputing@torque/3ed749263abe3d69fa3626d142a5789dcb5a5684,CVE-2014-0749,https://github.com/adaptivecomputing/torque/commit/3ed749263abe3d69fa3626d142a5789dcb5a5684,2014-05-16T14:55Z
CWE-119,"CWE-119 static void stellaris_enet_class_init ( ObjectClass * klass , void * data ) { DeviceClass * dc = DEVICE_CLASS ( klass ) ; SysBusDeviceClass * k = SYS_BUS_DEVICE_CLASS ( klass ) ; k -> init = stellaris_enet_init ; dc -> unrealize = stellaris_enet_unrealize ; dc -> props = stellaris_enet_properties ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = stellaris_enet_properties ; dc -> vmsd = & vmstate_stellaris_enet ;
",qemu@qemu/2e1198672759eda6e122ff38fcf6df06f27e0fe2,CVE-2013-4532,https://github.com/qemu/qemu/commit/2e1198672759eda6e122ff38fcf6df06f27e0fe2,2020-01-02T16:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_first_pass ( VP9_COMP * cpi ) { <S2SV_EndBug> int mb_row , mb_col ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; TileInfo tile ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; <S2SV_StartBug> const PICK_MODE_CONTEXT * ctx = & x -> sb64_context ; <S2SV_EndBug> int i ; int recon_yoffset , recon_uvoffset ; <S2SV_StartBug> YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; int recon_y_stride = lst_yv12 -> y_stride ; int recon_uv_stride = lst_yv12 -> uv_stride ; int uv_mb_height = 16 >> ( lst_yv12 -> y_height > lst_yv12 -> uv_height ) ; int64_t intra_error = 0 ; int64_t coded_error = 0 ; int64_t sr_coded_error = 0 ; int sum_mvr = 0 , sum_mvc = 0 ; int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; int64_t sum_mvrs = 0 , sum_mvcs = 0 ; int mvcount = 0 ; int intercount = 0 ; int second_ref_count = 0 ; <S2SV_StartBug> int intrapenalty = 256 ; <S2SV_EndBug> int neutral_count = 0 ; int new_mv_count = 0 ; int sum_in_vectors = 0 ; <S2SV_StartBug> uint32_t lastmv_as_int = 0 ; <S2SV_EndBug> struct twopass_rc * twopass = & cpi -> twopass ; const MV zero_mv = { 0 , 0 } ; <S2SV_StartBug> const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; <S2SV_EndBug> <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> MV_REFERENCE_FRAME ref_frame = LAST_FRAME ; const YV12_BUFFER_CONFIG * scaled_ref_buf = NULL ; twopass = & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . twopass ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) { scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; ref_frame = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP9_ALT_FLAG ) { scaled_ref_buf = vp9_get_scaled_ref_frame ( cpi , ALTREF_FRAME ) ; ref_frame = ALTREF_FRAME ; } <S2SV_StartBug> if ( scaled_ref_buf != NULL ) { <S2SV_EndBug> <S2SV_StartBug> first_ref_buf = scaled_ref_buf ; <S2SV_EndBug> recon_y_stride = first_ref_buf -> y_stride ; recon_uv_stride = first_ref_buf -> uv_stride ; uv_mb_height = 16 >> ( first_ref_buf -> y_height > first_ref_buf -> uv_height ) ; } gld_yv12 = NULL ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; } vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; vp9_setup_dst_planes ( xd , new_yv12 , 0 , 0 ) ; xd -> mi = cm -> mi_grid_visible ; xd -> mi [ 0 ] = cm -> mi ; vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_frame_init_quantizer ( cpi ) ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; } x -> skip_recode = 0 ; vp9_init_mv_probs ( cm ) ; vp9_initialize_rd_consts ( cpi ) ; vp9_tile_init ( & tile , cm , 0 , 0 ) ; <S2SV_StartBug> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; ++ mb_row ) { <S2SV_EndBug> <S2SV_StartBug> int_mv best_ref_mv ; <S2SV_EndBug> best_ref_mv . as_int = 0 ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * uv_mb_height ) ; x -> mv_row_min = - ( ( mb_row * 16 ) + BORDER_MV_PIXELS_B16 ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + BORDER_MV_PIXELS_B16 ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; ++ mb_col ) { int this_error ; const int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; <S2SV_StartBug> double error_weight = 1.0 ; <S2SV_EndBug> const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ; xd -> plane [ 1 ] . dst . buf = new_yv12 -> u_buffer + recon_uvoffset ; xd -> plane [ 2 ] . dst . buf = new_yv12 -> v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; set_mi_row_col ( xd , & tile , mb_row << 1 , num_8x8_blocks_high_lookup [ bsize ] , mb_col << 1 , num_8x8_blocks_wide_lookup [ bsize ] , cm -> mi_rows , cm -> mi_cols ) ; <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> const int energy = vp9_block_energy ( cpi , x , bsize ) ; error_weight = vp9_vaq_inv_q_ratio ( energy ) ; } this_error = vp9_encode_intra ( x , use_dc_pred ) ; if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { vp9_clear_system_state ( ) ; this_error = ( int ) ( this_error * error_weight ) ; } this_error += intrapenalty ; <S2SV_StartBug> intra_error += ( int64_t ) this_error ; <S2SV_EndBug> x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + BORDER_MV_PIXELS_B16 ; <S2SV_StartBug> if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> <S2SV_StartBug> int tmp_err , motion_error ; <S2SV_EndBug> int_mv mv , tmp_mv ; xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; <S2SV_StartBug> motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> mv . as_int = tmp_mv . as_int = 0 ; first_pass_motion_search ( cpi , x , & best_ref_mv . as_mv , & mv . as_mv , & motion_error ) ; if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { vp9_clear_system_state ( ) ; motion_error = ( int ) ( motion_error * error_weight ) ; } if ( best_ref_mv . as_int ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , & tmp_err ) ; if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { vp9_clear_system_state ( ) ; tmp_err = ( int ) ( tmp_err * error_weight ) ; } if ( tmp_err < motion_error ) { motion_error = tmp_err ; <S2SV_StartBug> mv . as_int = tmp_mv . as_int ; <S2SV_EndBug> } } <S2SV_StartBug> if ( cm -> current_video_frame > 1 && gld_yv12 != NULL ) { <S2SV_EndBug> int gf_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = gld_yv12 -> y_buffer + recon_yoffset ; <S2SV_StartBug> gf_motion_error = zz_motion_search ( x ) ; <S2SV_EndBug> <S2SV_StartBug> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv . as_mv , <S2SV_EndBug> & gf_motion_error ) ; <S2SV_StartBug> if ( cpi -> oxcf . aq_mode == VARIANCE_AQ ) { <S2SV_EndBug> vp9_clear_system_state ( ) ; gf_motion_error = ( int ) ( gf_motion_error * error_weight ) ; } if ( gf_motion_error < motion_error && gf_motion_error < this_error ) ++ second_ref_count ; xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; xd -> plane [ 1 ] . pre [ 0 ] . buf = first_ref_buf -> u_buffer + recon_uvoffset ; xd -> plane [ 2 ] . pre [ 0 ] . buf = first_ref_buf -> v_buffer + recon_uvoffset ; if ( gf_motion_error < this_error ) sr_coded_error += gf_motion_error ; else sr_coded_error += this_error ; } else { sr_coded_error += motion_error ; } <S2SV_StartBug> best_ref_mv . as_int = 0 ; <S2SV_EndBug> if ( motion_error <= this_error ) { <S2SV_StartBug> if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && <S2SV_EndBug> <S2SV_StartBug> this_error < 2 * intrapenalty ) <S2SV_EndBug> <S2SV_StartBug> ++ neutral_count ; <S2SV_EndBug> mv . as_mv . row *= 8 ; <S2SV_StartBug> mv . as_mv . col *= 8 ; <S2SV_EndBug> this_error = motion_error ; xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = mv ; <S2SV_EndBug> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; vp9_build_inter_predictors_sby ( xd , mb_row << 1 , mb_col << 1 , bsize ) ; vp9_encode_sby_pass1 ( x , bsize ) ; <S2SV_StartBug> sum_mvr += mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvr_abs += abs ( mv . as_mv . row ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc += mv . as_mv . col ; <S2SV_EndBug> <S2SV_StartBug> sum_mvc_abs += abs ( mv . as_mv . col ) ; <S2SV_EndBug> <S2SV_StartBug> sum_mvrs += mv . as_mv . row * mv . as_mv . row ; <S2SV_EndBug> <S2SV_StartBug> sum_mvcs += mv . as_mv . col * mv . as_mv . col ; <S2SV_EndBug> ++ intercount ; <S2SV_StartBug> best_ref_mv . as_int = mv . as_int ; <S2SV_EndBug> if ( mv . as_int ) { ++ mvcount ; <S2SV_StartBug> if ( mv . as_int != lastmv_as_int ) <S2SV_EndBug> ++ new_mv_count ; <S2SV_StartBug> lastmv_as_int = mv . as_int ; <S2SV_EndBug> if ( mb_row < cm -> mb_rows / 2 ) { <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> -- sum_in_vectors ; <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> ++ sum_in_vectors ; } else if ( mb_row > cm -> mb_rows / 2 ) { <S2SV_StartBug> if ( mv . as_mv . row > 0 ) <S2SV_EndBug> ++ sum_in_vectors ; <S2SV_StartBug> else if ( mv . as_mv . row < 0 ) <S2SV_EndBug> -- sum_in_vectors ; } if ( mb_col < cm -> mb_cols / 2 ) { <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> -- sum_in_vectors ; <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> ++ sum_in_vectors ; } else if ( mb_col > cm -> mb_cols / 2 ) { <S2SV_StartBug> if ( mv . as_mv . col > 0 ) <S2SV_EndBug> ++ sum_in_vectors ; <S2SV_StartBug> else if ( mv . as_mv . col < 0 ) <S2SV_EndBug> -- sum_in_vectors ; } } } } else { sr_coded_error += ( int64_t ) this_error ; } coded_error += ( int64_t ) this_error ; x -> plane [ 0 ] . src . buf += 16 ; x -> plane [ 1 ] . src . buf += uv_mb_height ; x -> plane [ 2 ] . src . buf += uv_mb_height ; recon_yoffset += 16 ; recon_uvoffset += uv_mb_height ; } x -> plane [ 0 ] . src . buf += 16 * x -> plane [ 0 ] . src . stride - 16 * cm -> mb_cols ; x -> plane [ 1 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ; x -> plane [ 2 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - uv_mb_height * cm -> mb_cols ; <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> } vp9_clear_system_state ( ) ; { FIRSTPASS_STATS fps ; <S2SV_StartBug> fps . frame = cm -> current_video_frame ; <S2SV_EndBug> <S2SV_StartBug> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; <S2SV_EndBug> <S2SV_StartBug> fps . intra_error = ( double ) ( intra_error >> 8 ) ; <S2SV_EndBug> fps . coded_error = ( double ) ( coded_error >> 8 ) ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) ; fps . ssim_weighted_pred_err = fps . coded_error * simple_weight ( cpi -> Source ) ; fps . count = 1.0 ; <S2SV_StartBug> fps . pcnt_inter = ( double ) intercount / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_second_ref = ( double ) second_ref_count / cm -> MBs ; <S2SV_EndBug> <S2SV_StartBug> fps . pcnt_neutral = ( double ) neutral_count / cm -> MBs ; <S2SV_EndBug> if ( mvcount > 0 ) { fps . MVr = ( double ) sum_mvr / mvcount ; fps . mvr_abs = ( double ) sum_mvr_abs / mvcount ; fps . MVc = ( double ) sum_mvc / mvcount ; fps . mvc_abs = ( double ) sum_mvc_abs / mvcount ; <S2SV_StartBug> fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / mvcount ) ) / mvcount ; <S2SV_EndBug> <S2SV_StartBug> fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / mvcount ) ) / mvcount ; <S2SV_EndBug> fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ; fps . new_mv_count = new_mv_count ; <S2SV_StartBug> fps . pcnt_motion = ( double ) mvcount / cm -> MBs ; <S2SV_EndBug> } else { fps . MVr = 0.0 ; fps . mvr_abs = 0.0 ; fps . MVc = 0.0 ; fps . mvc_abs = 0.0 ; fps . MVrv = 0.0 ; fps . MVcv = 0.0 ; fps . mv_in_out_count = 0.0 ; fps . new_mv_count = 0.0 ; fps . pcnt_motion = 0.0 ; } <S2SV_StartBug> fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; <S2SV_EndBug> twopass -> this_frame_stats = fps ; output_stats ( & twopass -> this_frame_stats , cpi -> output_pkt_list ) ; <S2SV_StartBug> accumulate_stats ( & twopass -> total_stats , & fps ) ; <S2SV_EndBug> } if ( ( twopass -> sr_update_lag > 3 ) || ( ( cm -> current_video_frame > 0 ) && ( twopass -> this_frame_stats . pcnt_inter > 0.20 ) && ( ( twopass -> this_frame_stats . intra_error / DOUBLE_DIVIDE_CHECK ( twopass -> this_frame_stats . coded_error ) ) > 2.0 ) ) ) { if ( gld_yv12 != NULL ) { <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> } twopass -> sr_update_lag = 1 ; } else { ++ twopass -> sr_update_lag ; } <S2SV_StartBug> if ( cpi -> use_svc && cpi -> svc . number_temporal_layers == 1 ) { <S2SV_EndBug> vp9_update_reference_frames ( cpi ) ; } else { <S2SV_StartBug> swap_yv12 ( lst_yv12 , new_yv12 ) ; <S2SV_EndBug> } vp9_extend_frame_borders ( lst_yv12 ) ; <S2SV_StartBug> if ( cm -> current_video_frame == 0 && gld_yv12 != NULL ) { <S2SV_EndBug> <S2SV_StartBug> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; <S2SV_EndBug> } if ( 0 ) { char filename [ 512 ] ; FILE * recon_file ; snprintf ( filename , sizeof ( filename ) , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; if ( cm -> current_video_frame == 0 ) recon_file = fopen ( filename , ""wb"" ) ; else recon_file = fopen ( filename , ""ab"" ) ; ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } ++ cm -> current_video_frame ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> VP9_COMP * cpi , const struct lookahead_entry * source <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> ctx = & cpi -> td . pc_root -> none <S2SV_ModEnd> ; int i <S2SV_ModStart> , recon_uvoffset ; <S2SV_ModEnd> int64_t intra_error = <S2SV_ModStart> = 0 ; const <S2SV_ModStart> int intrapenalty = INTRA_MODE_PENALTY ; double neutral_count ; int intra_skip_count = 0 ; int image_data_start_row = INVALID_ROW <S2SV_ModEnd> ; int new_mv_count <S2SV_ModStart> = 0 ; MV lastmv = { 0 , 0 } ; TWO_PASS <S2SV_ModEnd> * twopass = <S2SV_ModStart> 0 } ; int recon_y_stride , recon_uv_stride , uv_mb_height ; YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; <S2SV_ModStart> = lst_yv12 ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & <S2SV_ModEnd> cpi -> svc <S2SV_ModStart> -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; double intra_factor ; double brightness_factor ; BufferPool * const pool = cm -> buffer_pool ; assert ( new_yv12 <S2SV_ModEnd> != NULL ) <S2SV_ModStart> != NULL ) ; assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; } # endif vpx_clear_system_state ( ) ; intra_factor = 0.0 ; brightness_factor = 0.0 ; neutral_count = 0.0 ; set_first_pass_params ( cpi ) ; vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; if ( lc != NULL ) { twopass = & lc -> twopass ; cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags = VP9_LAST_FLAG ; if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) { cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; } else { cpi -> refresh_golden_frame = 0 ; } if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) <S2SV_ModStart> { first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; } if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; if ( gld_yv12 == NULL ) { gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } } else { gld_yv12 = NULL ; } set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ; } vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; } xd -> mi = cm -> mi_grid_visible ; xd -> mi [ 0 ] = cm -> mi <S2SV_ModEnd> ; vp9_frame_init_quantizer ( <S2SV_ModStart> 0 ) ; recon_y_stride = new_yv12 -> y_stride ; recon_uv_stride = new_yv12 -> uv_stride ; uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; <S2SV_ModStart> mb_row ) { MV best_ref_mv = { 0 , 0 } <S2SV_ModEnd> ; xd -> <S2SV_ModStart> mb_row ) ; <S2SV_ModEnd> const BLOCK_SIZE bsize <S2SV_ModStart> mb_col ) ; double log_intra ; int level_sample ; # if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) ; <S2SV_ModStart> mi_cols ) ; x -> skip_encode = 0 ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; vp9_encode_intra_block_plane ( x , bsize , 0 ) ; this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; if ( this_error < UL_INTRA_THRESH ) { ++ intra_skip_count ; } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = mb_row ; } # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { switch ( cm -> bit_depth ) { case VPX_BITS_8 : break ; case VPX_BITS_10 : this_error >>= 4 ; break ; case VPX_BITS_12 : this_error >>= 8 ; break ; default : assert ( 0 && ""cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>"" ""VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return ; } } # endif vpx_clear_system_state ( ) ; log_intra = log ( this_error + 1.0 ) ; if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; else intra_factor += 1.0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; else brightness_factor += 1.0 ; <S2SV_ModEnd> this_error += intrapenalty <S2SV_ModStart> ) this_error ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; } # endif <S2SV_ModStart> ; if ( ( lc == NULL && <S2SV_ModStart> > 0 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) <S2SV_ModStart> tmp_err , motion_error , raw_motion_error ; MV mv = { 0 , 0 } , tmp_mv = { 0 , 0 } ; struct buf_2d unscaled_last_source_buf_2d <S2SV_ModEnd> ; xd -> <S2SV_ModStart> + recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; } else { raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; } # else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; # endif if ( raw_motion_error > 25 || lc != NULL ) { first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; if ( ! is_zero_mv ( & best_ref_mv ) ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; <S2SV_ModEnd> if ( tmp_err <S2SV_ModStart> tmp_err ; mv = tmp_mv ; } } if ( ( ( lc == NULL && <S2SV_ModEnd> cm -> current_video_frame <S2SV_ModStart> current_video_frame > 1 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) <S2SV_ModStart> + recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif <S2SV_ModEnd> first_pass_motion_search ( cpi <S2SV_ModStart> , & tmp_mv <S2SV_ModEnd> , & gf_motion_error <S2SV_ModStart> gf_motion_error ) ; <S2SV_ModEnd> if ( gf_motion_error <S2SV_ModStart> motion_error ; } } else { sr_coded_error += motion_error ; } best_ref_mv . row = 0 ; best_ref_mv . col = 0 ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif <S2SV_ModEnd> if ( motion_error <S2SV_ModStart> this_error ) { vpx_clear_system_state ( ) ; <S2SV_ModStart> 10 ) && ( this_error < ( <S2SV_ModEnd> 2 * intrapenalty <S2SV_ModStart> * intrapenalty ) ) ) { neutral_count += 1.0 ; } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; } mv <S2SV_ModEnd> . row *= <S2SV_ModStart> ; mv . <S2SV_ModEnd> col *= 8 <S2SV_ModStart> [ 0 ] . as_mv <S2SV_ModStart> += mv . <S2SV_ModEnd> row ; sum_mvr_abs <S2SV_ModStart> ( mv . <S2SV_ModEnd> row ) ; <S2SV_ModStart> += mv . <S2SV_ModEnd> col ; sum_mvc_abs <S2SV_ModStart> ( mv . <S2SV_ModEnd> col ) ; <S2SV_ModStart> += mv . <S2SV_ModEnd> row * mv <S2SV_ModStart> row * mv <S2SV_ModEnd> . row ; <S2SV_ModStart> += mv . <S2SV_ModEnd> col * mv <S2SV_ModStart> col * mv <S2SV_ModEnd> . col ; <S2SV_ModStart> intercount ; best_ref_mv = mv ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( ! is_zero_mv ( & mv ) <S2SV_ModEnd> ) { ++ <S2SV_ModStart> ++ mvcount ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_MOTION_ZERO_MASK ; <S2SV_ModStart> ( mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ; } else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ; } else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ; } else { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ; } } # endif if ( ! is_equal_mv ( & mv , & lastmv ) <S2SV_ModEnd> ) ++ new_mv_count <S2SV_ModStart> ++ new_mv_count ; lastmv = mv <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( mv . <S2SV_ModEnd> row > 0 <S2SV_ModStart> if ( mv <S2SV_ModEnd> . row < <S2SV_ModStart> ( mv . <S2SV_ModEnd> row > 0 <S2SV_ModStart> if ( mv <S2SV_ModEnd> . row < <S2SV_ModStart> ( mv . <S2SV_ModEnd> col > 0 <S2SV_ModStart> if ( mv <S2SV_ModEnd> . col < <S2SV_ModStart> ( mv . <S2SV_ModEnd> col > 0 <S2SV_ModStart> if ( mv <S2SV_ModEnd> . col < <S2SV_ModStart> -> mb_cols ; vpx_clear_system_state ( ) ; } if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = cm -> mb_rows / 2 ; } if ( image_data_start_row > 0 ) { intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; } <S2SV_ModEnd> { FIRSTPASS_STATS fps <S2SV_ModStart> FIRSTPASS_STATS fps ; const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; const double min_err = 200 * sqrt ( num_mbs ) ; intra_factor = intra_factor / ( double ) num_mbs ; brightness_factor = brightness_factor / ( double ) num_mbs ; fps . weight = intra_factor * brightness_factor ; fps . <S2SV_ModEnd> frame = cm <S2SV_ModStart> svc . spatial_layer_id ; fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err <S2SV_ModStart> >> 8 ) + min_err <S2SV_ModEnd> ; fps . <S2SV_ModStart> ) intercount / num_mbs <S2SV_ModEnd> ; fps . <S2SV_ModStart> ) second_ref_count / num_mbs <S2SV_ModEnd> ; fps . <S2SV_ModStart> ) neutral_count / num_mbs ; fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; fps . inactive_zone_rows = ( double ) image_data_start_row ; fps . inactive_zone_cols = ( double ) 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) sum_mvrs - ( ( double ) sum_mvr * sum_mvr <S2SV_ModEnd> / mvcount ) <S2SV_ModStart> ) sum_mvcs - ( ( double ) sum_mvc * sum_mvc <S2SV_ModEnd> / mvcount ) <S2SV_ModStart> ) mvcount / num_mbs <S2SV_ModEnd> ; } else <S2SV_ModStart> double ) ( <S2SV_ModEnd> source -> ts_end <S2SV_ModStart> -> ts_end - <S2SV_ModEnd> source -> ts_start <S2SV_ModStart> fps ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; } # endif <S2SV_ModStart> NULL ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> sr_update_lag ; } vpx_extend_frame_borders ( new_yv12 ) ; if ( lc != NULL <S2SV_ModEnd> ) { vp9_update_reference_frames <S2SV_ModStart> } else { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ; } <S2SV_ModEnd> if ( cm <S2SV_ModStart> == 0 && cpi -> gld_fb_idx != INVALID_IDX && lc == <S2SV_ModEnd> NULL ) { <S2SV_ModStart> NULL ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> current_video_frame ; if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void down2_symeven ( const uint8_t * const input , int length , uint8_t * output ) { <S2SV_StartBug> static const int16_t * filter = vp9_down2_symeven_half_filter ; <S2SV_EndBug> const int filter_len_half = sizeof ( vp9_down2_symeven_half_filter ) / 2 ; int i , j ; uint8_t * optr = output ; int l1 = filter_len_half ; int l2 = ( length - filter_len_half ) ; l1 += ( l1 & 1 ) ; l2 += ( l2 & 1 ) ; if ( l1 > l2 ) { for ( i = 0 ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } else { for ( i = 0 ; i < l1 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ ( i - j < 0 ? 0 : i - j ) ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < l2 ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ i + 1 + j ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } for ( ; i < length ; i += 2 ) { int sum = ( 1 << ( FILTER_BITS - 1 ) ) ; for ( j = 0 ; j < filter_len_half ; ++ j ) { sum += ( input [ i - j ] + input [ ( i + 1 + j >= length ? length - 1 : i + 1 + j ) ] ) * filter [ j ] ; } sum >>= FILTER_BITS ; * optr ++ = clip_pixel ( sum ) ; } } }
","<S2SV_ModStart> output ) { <S2SV_ModEnd> const int16_t *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static inline int l2cap_connect_rsp ( struct l2cap_conn * conn , struct l2cap_cmd_hdr * cmd , u8 * data ) { struct l2cap_conn_rsp * rsp = ( struct l2cap_conn_rsp * ) data ; u16 scid , dcid , result , status ; struct sock * sk ; u8 req [ 128 ] ; scid = __le16_to_cpu ( rsp -> scid ) ; dcid = __le16_to_cpu ( rsp -> dcid ) ; result = __le16_to_cpu ( rsp -> result ) ; status = __le16_to_cpu ( rsp -> status ) ; BT_DBG ( ""dcid<S2SV_blank>0x%4.4x<S2SV_blank>scid<S2SV_blank>0x%4.4x<S2SV_blank>result<S2SV_blank>0x%2.2x<S2SV_blank>status<S2SV_blank>0x%2.2x"" , dcid , scid , result , status ) ; if ( scid ) { sk = l2cap_get_chan_by_scid ( & conn -> chan_list , scid ) ; if ( ! sk ) return 0 ; } else { sk = l2cap_get_chan_by_ident ( & conn -> chan_list , cmd -> ident ) ; if ( ! sk ) return 0 ; } switch ( result ) { case L2CAP_CR_SUCCESS : sk -> sk_state = BT_CONFIG ; l2cap_pi ( sk ) -> ident = 0 ; l2cap_pi ( sk ) -> dcid = dcid ; l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_REQ_SENT ; l2cap_pi ( sk ) -> conf_state &= ~ L2CAP_CONF_CONNECT_PEND ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , l2cap_build_conf_req ( sk , req ) , req ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case L2CAP_CR_PEND : l2cap_pi ( sk ) -> conf_state |= L2CAP_CONF_CONNECT_PEND ; break ; default : l2cap_chan_del ( sk , ECONNREFUSED ) ; break ; } bh_unlock_sock ( sk ) ; return 0 ; }
","<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
",torvalds@linux/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,2017-09-12T17:29Z
CWE-362,"CWE-362 int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ; <S2SV_StartBug> if ( user -> uid_keyring ) { <S2SV_EndBug> kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , KEY_ALLOC_IN_QUOTA , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }
","<S2SV_ModStart> user -> uid_keyring && user -> session_keyring
",torvalds@linux/0da9dfdd2cd9889201bc6f6f43580c99165cd087,CVE-2013-1792,https://github.com/torvalds/linux/commit/0da9dfdd2cd9889201bc6f6f43580c99165cd087,2013-03-22T11:59Z
CWE-190,"CWE-190 int bson_check_string ( bson * b , const char * string , <S2SV_StartBug> const int length ) { <S2SV_EndBug> return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 0 , 0 ) ; }
","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-20,"CWE-20 int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>test<S2SV_blank>name.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:<S2SV_blank>invalid<S2SV_blank>arguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run<S2SV_blank>\'adb<S2SV_blank>shell<S2SV_blank>stop\'<S2SV_blank>before<S2SV_blank>running<S2SV_blank>%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stack<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>paired<S2SV_blank>device<S2SV_blank>in<S2SV_blank>config<S2SV_blank>file.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>Bluetooth<S2SV_blank>HAL.\\n"" ) ; return 1 ; } if ( ! btsocket_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>Bluetooth<S2SV_blank>sockets.\\n"" ) ; return 2 ; } if ( ! pan_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>PAN.\\n"" ) ; return 3 ; } if ( ! gatt_init ( ) ) { printf ( ""Unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>GATT.\\n"" ) ; return 4 ; } watchdog_running = true ; pthread_create ( & watchdog_thread , NULL , watchdog_fn , NULL ) ; static const char * DEFAULT = ""\\x1b[0m"" ; static const char * GREEN = ""\\x1b[0;32m"" ; static const char * RED = ""\\x1b[0;31m"" ; if ( ! isatty ( fileno ( stdout ) ) ) { DEFAULT = GREEN = RED = """" ; } int pass = 0 ; int fail = 0 ; int case_num = 0 ; if ( ! skip_sanity_suite ) { for ( size_t i = 0 ; i < sanity_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , sanity_suite [ i ] . function_name ) ) { callbacks_init ( ) ; if ( sanity_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , sanity_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } callbacks_cleanup ( ) ; ++ watchdog_id ; } } } if ( fail ) { printf ( ""\\n%sSanity<S2SV_blank>suite<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>errors.%s\\n"" , RED , fail , DEFAULT ) ; hal_close ( ) ; return 4 ; } for ( size_t i = 0 ; i < test_suite_size ; ++ i ) { if ( ! test_name || ! strcmp ( test_name , test_suite [ i ] . function_name ) ) { callbacks_init ( ) ; <S2SV_StartBug> CALL_AND_WAIT ( bt_interface -> enable ( ) , adapter_state_changed ) ; <S2SV_EndBug> if ( test_suite [ i ] . function ( ) ) { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sPASS%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , GREEN , DEFAULT ) ; ++ pass ; } else { printf ( ""[%4d]<S2SV_blank>%-64s<S2SV_blank>[%sFAIL%s]\\n"" , ++ case_num , test_suite [ i ] . function_name , RED , DEFAULT ) ; ++ fail ; } CALL_AND_WAIT ( bt_interface -> disable ( ) , adapter_state_changed ) ; callbacks_cleanup ( ) ; ++ watchdog_id ; } } printf ( ""\\n"" ) ; if ( fail ) { printf ( ""%d/%d<S2SV_blank>tests<S2SV_blank>failed.<S2SV_blank>See<S2SV_blank>above<S2SV_blank>for<S2SV_blank>failed<S2SV_blank>test<S2SV_blank>cases.\\n"" , fail , sanity_suite_size + test_suite_size ) ; } else { printf ( ""All<S2SV_blank>tests<S2SV_blank>passed!\\n"" ) ; } watchdog_running = false ; pthread_join ( watchdog_thread , NULL ) ; hal_close ( ) ; return 0 ; }
","<S2SV_ModStart> -> enable ( false
",system@bt/37c88107679d36c419572732b4af6e18bb2f7dce,CVE-2016-3760,https://android.googlesource.com/platform/system/bt/+/37c88107679d36c419572732b4af6e18bb2f7dce,2016-07-11T02:00Z
CWE-189,"CWE-189 static int efx_register_netdev ( struct efx_nic * efx ) { struct net_device * net_dev = efx -> net_dev ; struct efx_channel * channel ; int rc ; net_dev -> watchdog_timeo = 5 * HZ ; net_dev -> irq = efx -> pci_dev -> irq ; net_dev -> netdev_ops = & efx_netdev_ops ; SET_ETHTOOL_OPS ( net_dev , & efx_ethtool_ops ) ; <S2SV_StartBug> efx -> mac_op -> update_stats ( efx ) ; <S2SV_EndBug> memset ( & efx -> mac_stats , 0 , sizeof ( efx -> mac_stats ) ) ; rtnl_lock ( ) ; rc = dev_alloc_name ( net_dev , net_dev -> name ) ; if ( rc < 0 ) goto fail_locked ; efx_update_name ( efx ) ; rc = register_netdevice ( net_dev ) ; if ( rc ) goto fail_locked ; efx_for_each_channel ( channel , efx ) { struct efx_tx_queue * tx_queue ; efx_for_each_channel_tx_queue ( tx_queue , channel ) efx_init_tx_queue_core_txq ( tx_queue ) ; } netif_carrier_off ( efx -> net_dev ) ; rtnl_unlock ( ) ; rc = device_create_file ( & efx -> pci_dev -> dev , & dev_attr_phy_type ) ; if ( rc ) { netif_err ( efx , drv , efx -> net_dev , ""failed<S2SV_blank>to<S2SV_blank>init<S2SV_blank>net<S2SV_blank>dev<S2SV_blank>attributes\\n"" ) ; goto fail_registered ; } return 0 ; fail_locked : rtnl_unlock ( ) ; netif_err ( efx , drv , efx -> net_dev , ""could<S2SV_blank>not<S2SV_blank>register<S2SV_blank>net<S2SV_blank>dev\\n"" ) ; return rc ; fail_registered : unregister_netdev ( net_dev ) ; return rc ; }
","<S2SV_ModStart> efx_ethtool_ops ) ; net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;
",torvalds@linux/68cb695ccecf949d48949e72f8ce591fdaaa325c,CVE-2012-3412,https://github.com/torvalds/linux/commit/68cb695ccecf949d48949e72f8ce591fdaaa325c,2012-10-03T11:02Z
CWE-476,"CWE-476 void gf_isom_cenc_get_default_info_internal ( GF_TrackBox * trak , u32 sampleDescriptionIndex , u32 * container_type , Bool * default_IsEncrypted , u8 * crypt_byte_block , u8 * skip_byte_block , const u8 * * key_info , u32 * key_info_size ) { GF_ProtectionSchemeInfoBox * sinf ; if ( default_IsEncrypted ) * default_IsEncrypted = GF_FALSE ; if ( crypt_byte_block ) * crypt_byte_block = 0 ; if ( skip_byte_block ) * skip_byte_block = 0 ; if ( container_type ) * container_type = 0 ; if ( key_info ) * key_info = NULL ; if ( key_info_size ) * key_info_size = 0 ; sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBC_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CENS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_CBCS_SCHEME , NULL ) ; if ( ! sinf ) sinf = isom_get_sinf_entry ( trak , sampleDescriptionIndex , GF_ISOM_PIFF_SCHEME , NULL ) ; if ( ! sinf ) { u32 i , nb_stsd = gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ; for ( i = 0 ; i < nb_stsd ; i ++ ) { GF_ProtectionSchemeInfoBox * a_sinf ; GF_SampleEntryBox * sentry = NULL ; if ( i + 1 == sampleDescriptionIndex ) continue ; sentry = gf_list_get ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes , i ) ; a_sinf = ( GF_ProtectionSchemeInfoBox * ) gf_isom_box_find_child ( sentry -> child_boxes , GF_ISOM_BOX_TYPE_SINF ) ; if ( ! a_sinf ) continue ; return ; } } if ( sinf && sinf -> info && sinf -> info -> tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = sinf -> info -> tenc -> isProtected ; if ( crypt_byte_block ) * crypt_byte_block = sinf -> info -> tenc -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = sinf -> info -> tenc -> skip_byte_block ; if ( key_info ) * key_info = sinf -> info -> tenc -> key_info ; if ( key_info_size ) { * key_info_size = 20 ; if ( ! sinf -> info -> tenc -> key_info [ 3 ] ) * key_info_size += 1 + sinf -> info -> tenc -> key_info [ 20 ] ; } if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else if ( sinf && sinf -> info && sinf -> info -> piff_tenc ) { if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( key_info ) * key_info = sinf -> info -> piff_tenc -> key_info ; if ( key_info_size ) * key_info_size = 19 ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } else { u32 i , count = 0 ; GF_CENCSampleEncryptionGroupEntry * seig_entry = NULL ; if ( ! trak -> moov -> mov -> is_smooth ) count = gf_list_count ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) ; for ( i = 0 ; i < count ; i ++ ) { GF_SampleGroupDescriptionBox * sgdesc = ( GF_SampleGroupDescriptionBox * ) gf_list_get ( trak -> Media -> information -> sampleTable -> sampleGroupsDescription , i ) ; if ( sgdesc -> grouping_type != GF_ISOM_SAMPLE_GROUP_SEIG ) continue ; if ( sgdesc -> default_description_index ) seig_entry = gf_list_get ( sgdesc -> group_descriptions , sgdesc -> default_description_index - 1 ) ; else seig_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; <S2SV_StartBug> if ( ! seig_entry -> key_info [ 0 ] ) <S2SV_EndBug> seig_entry = NULL ; break ; } if ( seig_entry ) { if ( default_IsEncrypted ) * default_IsEncrypted = seig_entry -> IsProtected ; if ( crypt_byte_block ) * crypt_byte_block = seig_entry -> crypt_byte_block ; if ( skip_byte_block ) * skip_byte_block = seig_entry -> skip_byte_block ; if ( key_info ) * key_info = seig_entry -> key_info ; if ( key_info_size ) * key_info_size = seig_entry -> key_info_size ; if ( container_type ) * container_type = GF_ISOM_BOX_TYPE_SENC ; } else { if ( ! trak -> moov -> mov -> is_smooth ) { trak -> moov -> mov -> is_smooth = GF_TRUE ; GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>senc<S2SV_blank>box<S2SV_blank>without<S2SV_blank>tenc,<S2SV_blank>assuming<S2SV_blank>MS<S2SV_blank>smooth+piff\\n"" ) ) ; } if ( default_IsEncrypted ) * default_IsEncrypted = GF_TRUE ; if ( container_type ) * container_type = GF_ISOM_BOX_UUID_PSEC ; } } if ( container_type && trak -> sample_encryption ) { if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_SENC ) * container_type = GF_ISOM_BOX_TYPE_SENC ; else if ( trak -> sample_encryption -> type == GF_ISOM_BOX_TYPE_UUID ) * container_type = ( ( GF_UUIDBox * ) trak -> sample_encryption ) -> internal_4cc ; } }
","<S2SV_ModStart> ; if ( seig_entry &&
",gpac@gpac/3b84ffcbacf144ce35650df958432f472b6483f8,CVE-2021-31259,https://github.com/gpac/gpac/commit/3b84ffcbacf144ce35650df958432f472b6483f8,2021-04-19T19:15Z
CWE-20,"CWE-20 static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied ; struct sk_buff * skb , * data_skb ; int err , ret ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; copied = 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( skb == NULL ) goto out ; data_skb = skb ; # ifdef CONFIG_COMPAT_NETLINK_MESSAGES if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { if ( flags & MSG_CMSG_COMPAT ) data_skb = skb_shinfo ( skb ) -> frag_list ; } # endif <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = data_skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( data_skb ) ; err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; if ( msg -> msg_name ) { struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; addr -> nl_family = AF_NETLINK ; addr -> nl_pad = 0 ; addr -> nl_pid = NETLINK_CB ( skb ) . portid ; addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; msg -> msg_namelen = sizeof ( * addr ) ; } if ( nlk -> flags & NETLINK_RECV_PKTINFO ) netlink_cmsg_recv_pktinfo ( msg , skb ) ; if ( NULL == siocb -> scm ) { memset ( & scm , 0 , sizeof ( scm ) ) ; siocb -> scm = & scm ; } siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; if ( flags & MSG_TRUNC ) copied = data_skb -> len ; skb_free_datagram ( sk , skb ) ; if ( nlk -> cb_running && atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { ret = netlink_dump ( sk ) ; if ( ret ) { sk -> sk_err = ret ; sk -> sk_error_report ( sk ) ; } } scm_recv ( sock , msg , siocb -> scm , flags ) ; out : netlink_rcv_wake ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; }
",radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4,CVE-2017-15385,https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4,2017-10-16T22:29Z
CWE-287,"CWE-287 ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || <S2SV_StartBug> cherokee_buffer_is_empty ( & conn -> validator -> user ) ) <S2SV_EndBug> return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtree<S2SV_blank>search<S2SV_blank>(%s):<S2SV_blank>done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error ; } ldap_msgfree ( message ) ; ret = validate_dn ( props , dn , conn -> validator -> passwd . buf ) ; if ( ret != ret_ok ) return ret ; re = ldap_unbind_s ( ldap -> conn ) ; if ( re != LDAP_SUCCESS ) return ret_error ; TRACE ( ENTRIES , ""Access<S2SV_blank>to<S2SV_blank>use<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>been<S2SV_blank>granted\\n"" , conn -> validator -> user . buf ) ; return ret_ok ; }
","<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
",cherokee@webserver/fbda667221c51f0aa476a02366e0cf66cb012f88,CVE-2014-4668,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,2014-07-02T04:14Z
CWE-189,"CWE-189 Datum path_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; PATH * path ; int isopen ; char * s ; int npts ; <S2SV_StartBug> int size ; <S2SV_EndBug> int depth = 0 ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; s = str ; while ( isspace ( ( unsigned char ) * s ) ) s ++ ; if ( ( * s == LDELIM ) && ( strrchr ( s , LDELIM ) == s ) ) { s ++ ; depth ++ ; } <S2SV_StartBug> size = offsetof ( PATH , p [ 0 ] ) + sizeof ( path -> p [ 0 ] ) * npts ; <S2SV_EndBug> path = ( PATH * ) palloc ( size ) ; SET_VARSIZE ( path , size ) ; path -> npts = npts ; if ( ( ! path_decode ( TRUE , npts , s , & isopen , & s , & ( path -> p [ 0 ] ) ) ) && ( ! ( ( depth == 0 ) && ( * s == '\\0' ) ) ) && ! ( ( depth >= 1 ) && ( * s == RDELIM ) ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>path:<S2SV_blank>\\""%s\\"""" , str ) ) ) ; path -> closed = ( ! isopen ) ; path -> dummy = 0 ; PG_RETURN_PATH_P ( path ) ; }
","<S2SV_ModStart> ; int size ; int base_size <S2SV_ModStart> ++ ; } base_size = sizeof ( path -> <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) * npts ; size = offsetof ( PATH , <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested"" ) ) ) <S2SV_ModEnd> ; path =
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-264,"CWE-264 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) <S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; iov . iov_len = size ; iov . iov_base = ubuf ; iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; msg . msg_namelen = 0 ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
",torvalds@linux/4de930efc23b92ddf88ce91c405ee645fe6e27ea,CVE-2015-2686,https://github.com/torvalds/linux/commit/4de930efc23b92ddf88ce91c405ee645fe6e27ea,2016-05-02T10:59Z
CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_gettargetinfo ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_targetinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_targetinfo karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> VirtDevice * vdevice ; char * pmem ; <S2SV_StartBug> int * pdata ; <S2SV_EndBug> int iocnum ; int numDevices = 0 ; int lun ; int maxWordsLeft ; int numBytes ; u8 port ; struct scsi_device * sdev ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_gettargetinfo()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_gettargetinfo<S2SV_blank>called.\\n"" , ioc -> name ) ) ; numBytes = karg . hdr . maxDataSize - sizeof ( mpt_ioctl_header ) ; maxWordsLeft = numBytes / sizeof ( int ) ; port = karg . hdr . port ; if ( maxWordsLeft <= 0 ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo()<S2SV_blank>-<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>available!\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pmem = kzalloc ( numBytes , GFP_KERNEL ) ; if ( ! pmem ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo()<S2SV_blank>-<S2SV_blank>no<S2SV_blank>memory<S2SV_blank>available!\\n"" , ioc -> name , __FILE__ , __LINE__ ) ; return - ENOMEM ; } pdata = ( int * ) pmem ; if ( ioc -> sh ) { shost_for_each_device ( sdev , ioc -> sh ) { if ( ! maxWordsLeft ) continue ; vdevice = sdev -> hostdata ; if ( vdevice == NULL || vdevice -> vtarget == NULL ) continue ; if ( vdevice -> vtarget -> tflags & MPT_TARGET_FLAGS_RAID_COMPONENT ) continue ; lun = ( vdevice -> vtarget -> raidVolume ) ? 0x80 : vdevice -> lun ; * pdata = ( ( ( u8 ) lun << 16 ) + ( vdevice -> vtarget -> channel << 8 ) + ( vdevice -> vtarget -> id ) ) ; pdata ++ ; numDevices ++ ; -- maxWordsLeft ; } } karg . numDevices = numDevices ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_targetinfo ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; kfree ( pmem ) ; return - EFAULT ; } if ( copy_to_user ( uarg -> targetInfo , pmem , numBytes ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_gettargetinfo<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_targetinfo<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , pdata ) ; kfree ( pmem ) ; return - EFAULT ; } kfree ( pmem ) ; return 0 ; }
","<S2SV_ModStart> int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_targetinfo karg ; <S2SV_ModEnd> VirtDevice * vdevice <S2SV_ModStart> int * pdata <S2SV_ModEnd> ; int numDevices <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-119,"CWE-119 void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ; <S2SV_StartBug> for ( row = 0 ; row < height ; row ++ ) <S2SV_EndBug> { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ; <S2SV_StartBug> if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) <S2SV_EndBug> derror ( ) ; } } }
","<S2SV_ModStart> ; row < raw_height <S2SV_ModEnd> ; row ++ <S2SV_ModStart> col < width && row < height
",LibRaw@LibRaw/f1394822a0152ceed77815eafa5cac4e8baab10a,CVE-2017-16909,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,2018-12-07T22:29Z
CWE-787,"CWE-787 static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; <S2SV_StartBug> if ( len < needed ) { <S2SV_EndBug> param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
","<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
",torvalds@linux/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,CVE-2021-31916,https://github.com/torvalds/linux/commit/4edbe1d7bcffcd6269f3b5eb63f710393ff2ec7a,2021-05-06T17:15Z
CWE-119,"CWE-119 static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }
","<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
",torvalds@linux/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,CVE-2011-2517,https://github.com/torvalds/linux/commit/208c72f4fe44fe09577e7975ba0e7fa0278f3d03,2012-05-24T23:55Z
CWE-476,"CWE-476 static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }
",LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,CVE-2020-14397,https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,2020-06-17T16:15Z
CWE-119,"CWE-119 char * _single_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( len + 1 ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24,2018-02-26T14:29Z
CWE-732,"CWE-732 void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( ""Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n"" , RUN_MNT_DIR ) ; if ( mount ( ""tmpfs"" , RUN_MNT_DIR , ""tmpfs"" , MS_NOSUID | MS_STRICTATIME , ""mode=755,gid=0"" ) < 0 ) errExit ( ""mounting<S2SV_blank>/run/firejail/mnt"" ) ; tmpfs_mounted = 1 ; fs_logger2 ( ""tmpfs"" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; # endif } }
","<S2SV_ModStart> # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
",netblue30@firejail/eecf35c2f8249489a1d3e512bb07f0d427183134,CVE-2019-12589,https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134,2019-06-03T03:29Z
CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
",ImageMagick@ImageMagick/b173a352397877775c51c9a0e9d59eb6ce24c455,CVE-2016-10070,https://github.com/ImageMagick/ImageMagick/commit/b173a352397877775c51c9a0e9d59eb6ce24c455,2017-03-03T18:59Z
CWE-20,"CWE-20 static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; <S2SV_StartBug> int idx , ret = - EINVAL ; <S2SV_EndBug> if ( ! kvm_arch_has_assigned_device ( kvm ) || ! irq_remapping_cap ( IRQ_POSTING_CAP ) || ! kvm_vcpu_apicv_active ( kvm -> vcpus [ 0 ] ) ) return 0 ; idx = srcu_read_lock ( & kvm -> irq_srcu ) ; irq_rt = srcu_dereference ( kvm -> irq_routing , & kvm -> irq_srcu ) ; <S2SV_StartBug> BUG_ON ( guest_irq >= irq_rt -> nr_rt_entries ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { <S2SV_EndBug> if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failed<S2SV_blank>to<S2SV_blank>back<S2SV_blank>to<S2SV_blank>remapped<S2SV_blank>mode,<S2SV_blank>irq:<S2SV_blank>%u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update ( vcpu -> vcpu_id , host_irq , e -> gsi , vcpu_info . vector , vcpu_info . pi_desc_addr , set ) ; if ( set ) ret = irq_set_vcpu_affinity ( host_irq , & vcpu_info ) ; else { pi_set_sn ( vcpu_to_pi_desc ( vcpu ) ) ; ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; pi_clear_sn ( vcpu_to_pi_desc ( vcpu ) ) ; } if ( ret < 0 ) { printk ( KERN_INFO ""%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>update<S2SV_blank>PI<S2SV_blank>IRTE\\n"" , __func__ ) ; goto out ; } } ret = 0 ; out : srcu_read_unlock ( & kvm -> irq_srcu , idx ) ; return ret ; }
","<S2SV_ModStart> , ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> irq_srcu ) ; if <S2SV_ModEnd> ( guest_irq >= <S2SV_ModStart> irq_rt -> nr_rt_entries || hlist_empty ( <S2SV_ModEnd> & irq_rt -> <S2SV_ModStart> [ guest_irq ] ) ) { pr_warn_once ( ""no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ]
",torvalds@linux/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,CVE-2017-1000252,https://github.com/torvalds/linux/commit/3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb,2017-09-26T05:29Z
CWE-310,"CWE-310 static void prefetch_dec ( void ) <S2SV_StartBug> { <S2SV_EndBug> prefetch_table ( ( const void * ) & dec_tables , sizeof ( dec_tables ) ) ; }
","<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
CWE-264,"CWE-264 int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) { struct super_block * sb = src_dir -> i_sb ; struct hfs_find_data src_fd , dst_fd ; hfsplus_cat_entry entry ; int entry_size , type ; int err ; dprint ( DBG_CAT_MOD , ""rename_cat:<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>%lu,%s<S2SV_blank>-<S2SV_blank>%lu,%s\\n"" , cnid , src_dir -> i_ino , src_name -> name , dst_dir -> i_ino , dst_name -> name ) ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & src_fd ) ; if ( err ) return err ; dst_fd = src_fd ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; <S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> src_fd . entrylength ) ; hfsplus_cat_build_key ( sb , dst_fd . search_key , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , src_fd . entrylength ) ; if ( err ) goto out ; dst_dir -> i_size ++ ; dst_dir -> i_mtime = dst_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; src_dir -> i_size -- ; src_dir -> i_mtime = src_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , cnid , NULL ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; type = hfs_bnode_read_u16 ( src_fd . bnode , src_fd . entryoffset ) ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; hfsplus_cat_build_key ( sb , dst_fd . search_key , cnid , NULL ) ; entry_size = hfsplus_fill_cat_thread ( sb , & entry , type , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , entry_size ) ; hfsplus_mark_inode_dirty ( dst_dir , HFSPLUS_I_CAT_DIRTY ) ; hfsplus_mark_inode_dirty ( src_dir , HFSPLUS_I_CAT_DIRTY ) ; out : hfs_bnode_put ( dst_fd . bnode ) ; hfs_find_exit ( & src_fd ) ; return err ; }
","<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
",torvalds@linux/6f24f892871acc47b40dd594c63606a17c714f77,CVE-2012-2319,https://github.com/torvalds/linux/commit/6f24f892871acc47b40dd594c63606a17c714f77,2012-05-17T11:00Z
CWE-125,"CWE-125 int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\n"" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\n"" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n"" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n"" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n"" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }
","<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , ""Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%"" PRId64 ""<S2SV_blank>is<S2SV_blank>invalid)\\n"" , chunksize ) ; return AVERROR_INVALIDDATA ; }
",FFmpeg@FFmpeg/cced03dd667a5df6df8fd40d8de0bff477ee02e8,CVE-2018-1999010,https://github.com/FFmpeg/FFmpeg/commit/cced03dd667a5df6df8fd40d8de0bff477ee02e8,2018-07-23T15:29Z
CWE-416,"CWE-416 static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfqq ) <S2SV_StartBug> bfq_idle_slice_timer_body ( bfqq ) ; <S2SV_EndBug> return HRTIMER_NORESTART ; }
","<S2SV_ModStart> ) bfq_idle_slice_timer_body ( bfqd ,
",torvalds@linux/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,CVE-2020-12657,https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9,2020-05-05T07:15Z
CWE-362,"CWE-362 struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , ""Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n"" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
","<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
",torvalds@linux/1d147bfa64293b2723c4fec50922168658e613ba,CVE-2014-2706,https://github.com/torvalds/linux/commit/1d147bfa64293b2723c4fec50922168658e613ba,2014-04-14T23:55Z
CWE-362,"CWE-362 static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>packet<S2SV_blank>parsing:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; debug ( ""%s:<S2SV_blank>cuser<S2SV_blank>%s<S2SV_blank>chost<S2SV_blank>%s<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>slen<S2SV_blank>%zu"" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( ""signature:"" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>key_from_blob:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { error ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>peer<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>format"" ) ; goto done ; } if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>HostbasedAcceptedKeyTypes"" , __func__ , sshkey_type ( key ) ) ; goto done ; } <S2SV_StartBug> if ( ( b = sshbuf_new ( ) ) == NULL ) <S2SV_EndBug> fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""hostbased"" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( ""%s:<S2SV_blank>buffer<S2SV_blank>error:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif auth2_record_info ( authctxt , ""client<S2SV_blank>user<S2SV_blank>\\""%.100s\\"",<S2SV_blank>client<S2SV_blank>host<S2SV_blank>\\""%.100s\\"""" , cuser , chost ) ; authenticated = 0 ; if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ; auth2_record_key ( authctxt , authenticated , key ) ; sshbuf_free ( b ) ; done : debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d"" , __func__ , authenticated ) ; sshkey_free ( key ) ; free ( pkalg ) ; free ( pkblob ) ; free ( cuser ) ; free ( chost ) ; free ( sig ) ; return authenticated ; }
","<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } if (
",openbsd@src/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,CVE-2018-15473,https://github.com/openbsd/src/commit/779974d35b4859c07bc3cb8a12c74b43b0a7d1e0,2018-08-17T19:29Z
CWE-189,"CWE-189 PHP_FUNCTION ( imageconvolution ) { zval * SIM , * hash_matrix ; zval * * var = NULL , * * var2 = NULL ; gdImagePtr im_src = NULL ; double div , offset ; int nelem , i , j , res ; float matrix [ 3 ] [ 3 ] = { { 0 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 0 } } ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""radd"" , & SIM , & hash_matrix , & div , & offset ) == FAILURE ) { RETURN_FALSE ; } ZEND_FETCH_RESOURCE ( im_src , gdImagePtr , & SIM , - 1 , ""Image"" , le_gd ) ; nelem = zend_hash_num_elements ( Z_ARRVAL_P ( hash_matrix ) ) ; if ( nelem != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>3x3<S2SV_blank>array"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( hash_matrix ) , ( i ) , ( void * * ) & var ) == SUCCESS && Z_TYPE_PP ( var ) == IS_ARRAY ) { if ( Z_TYPE_PP ( var ) != IS_ARRAY || zend_hash_num_elements ( Z_ARRVAL_PP ( var ) ) != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>3x3<S2SV_blank>array"" ) ; RETURN_FALSE ; } for ( j = 0 ; j < 3 ; j ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_PP ( var ) , ( j ) , ( void * * ) & var2 ) == SUCCESS ) { <S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; <S2SV_EndBug> RETURN_FALSE ; } } <S2SV_StartBug> } <S2SV_EndBug> } res = gdImageConvolution ( im_src , matrix , ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE ; } else { RETURN_FALSE ; } }
","<S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP <S2SV_ModEnd> ( var2 ) <S2SV_ModStart> ( var2 ) != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> ; convert_to_double ( & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> var2 ) ; <S2SV_ModStart> var2 ) ; } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix"" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> ( float ) <S2SV_ModStart> ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { <S2SV_ModEnd> RETURN_FALSE ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",php@php-src/2938329ce19cb8c4197dec146c3ec887c6f61d01,CVE-2014-2020,https://github.com/php/php-src/commit/2938329ce19cb8c4197dec146c3ec887c6f61d01,2014-02-18T11:55Z
CWE-476,"CWE-476 <S2SV_StartBug> static inline void mcryptd_check_internal ( struct rtattr * * tb , u32 * type , <S2SV_EndBug> u32 * mask ) { struct crypto_attr_type * algt ; algt = crypto_get_attr_type ( tb ) ; if ( IS_ERR ( algt ) ) <S2SV_StartBug> return ; <S2SV_EndBug> <S2SV_StartBug> if ( ( algt -> type & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> * type |= CRYPTO_ALG_INTERNAL ; <S2SV_StartBug> if ( ( algt -> mask & CRYPTO_ALG_INTERNAL ) ) <S2SV_EndBug> * mask |= CRYPTO_ALG_INTERNAL ; }
","<S2SV_ModStart> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct <S2SV_ModStart> ) ) return false ; * type |= <S2SV_ModEnd> algt -> type <S2SV_ModStart> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & <S2SV_ModEnd> CRYPTO_ALG_INTERNAL ; if <S2SV_ModStart> ; if ( * type & * <S2SV_ModEnd> mask & CRYPTO_ALG_INTERNAL <S2SV_ModStart> & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/48a992727d82cb7db076fa15d372178743b1f4cd,CVE-2016-10147,https://github.com/torvalds/linux/commit/48a992727d82cb7db076fa15d372178743b1f4cd,2017-01-18T21:59Z
CWE-119,"CWE-119 static void encode_frame_internal ( VP9_COMP * cpi ) { SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> xd -> mi = cm -> mi_grid_visible ; <S2SV_EndBug> xd -> mi [ 0 ] = cm -> mi ; <S2SV_StartBug> vp9_zero ( cm -> counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> coef_counts ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> tx_stepdown_count ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_zero ( cpi -> rd_comp_pred_diff ) ; <S2SV_EndBug> vp9_zero ( cpi -> rd_filter_diff ) ; vp9_zero ( cpi -> rd_tx_select_diff ) ; vp9_zero ( cpi -> rd_tx_select_threshes ) ; cm -> tx_mode = select_tx_mode ( cpi ) ; cpi -> mb . e_mbd . lossless = cm -> base_qindex == 0 && cm -> y_dc_delta_q == 0 && cm -> uv_dc_delta_q == 0 && cm -> uv_ac_delta_q == 0 ; <S2SV_StartBug> switch_lossless_mode ( cpi , cpi -> mb . e_mbd . lossless ) ; <S2SV_EndBug> vp9_frame_init_quantizer ( cpi ) ; vp9_initialize_rd_consts ( cpi ) ; <S2SV_StartBug> vp9_initialize_me_consts ( cpi , cm -> base_qindex ) ; <S2SV_EndBug> init_encode_frame_mb_context ( cpi ) ; <S2SV_StartBug> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) <S2SV_EndBug> build_activity_map ( cpi ) ; <S2SV_StartBug> cm -> prev_mi = get_prev_mi ( cm ) ; <S2SV_EndBug> if ( sf -> use_nonrd_pick_mode ) { int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; <S2SV_StartBug> PICK_MODE_CONTEXT * ctx = & cpi -> mb . sb64_context ; <S2SV_EndBug> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; } vp9_zero ( x -> zcoeff_blk ) ; <S2SV_StartBug> if ( cpi -> sf . partition_search_type == SOURCE_VAR_BASED_PARTITION && <S2SV_EndBug> cm -> current_video_frame > 0 ) { int check_freq = cpi -> sf . search_type_check_frequency ; if ( ( cm -> current_video_frame - 1 ) % check_freq == 0 ) { cpi -> use_large_partition_rate = 0 ; } if ( ( cm -> current_video_frame - 1 ) % check_freq == 1 ) { const int mbs_in_b32x32 = 1 << ( ( b_width_log2_lookup [ BLOCK_32X32 ] - b_width_log2_lookup [ BLOCK_16X16 ] ) + ( b_height_log2_lookup [ BLOCK_32X32 ] - b_height_log2_lookup [ BLOCK_16X16 ] ) ) ; cpi -> use_large_partition_rate = cpi -> use_large_partition_rate * 100 * mbs_in_b32x32 / cm -> MBs ; } if ( ( cm -> current_video_frame - 1 ) % check_freq >= 1 ) { if ( cpi -> use_large_partition_rate < 15 ) cpi -> sf . partition_search_type = FIXED_PARTITION ; } } } { struct vpx_usec_timer emr_timer ; vpx_usec_timer_start ( & emr_timer ) ; <S2SV_StartBug> { <S2SV_EndBug> int tile_col , tile_row ; TOKENEXTRA * tp = cpi -> tok ; <S2SV_StartBug> const int tile_cols = 1 << cm -> log2_tile_cols ; <S2SV_EndBug> const int tile_rows = 1 << cm -> log2_tile_rows ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { TileInfo tile ; TOKENEXTRA * tp_old = tp ; int mi_row ; vp9_tile_init ( & tile , cm , tile_row , tile_col ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { if ( sf -> use_nonrd_pick_mode && cm -> frame_type != KEY_FRAME ) encode_nonrd_sb_row ( cpi , & tile , mi_row , & tp ) ; else <S2SV_StartBug> encode_rd_sb_row ( cpi , & tile , mi_row , & tp ) ; <S2SV_EndBug> } cpi -> tok_count [ tile_row ] [ tile_col ] = ( unsigned int ) ( tp - tp_old ) ; assert ( tp - cpi -> tok <= get_token_alloc ( cm -> mb_rows , cm -> mb_cols ) ) ; } } } vpx_usec_timer_mark ( & emr_timer ) ; cpi -> time_encode_sb_row += vpx_usec_timer_elapsed ( & emr_timer ) ; } <S2SV_StartBug> if ( sf -> skip_encode_sb ) { <S2SV_EndBug> int j ; unsigned int intra_count = 0 , inter_count = 0 ; for ( j = 0 ; j < INTRA_INTER_CONTEXTS ; ++ j ) { intra_count += cm -> counts . intra_inter [ j ] [ 0 ] ; inter_count += cm -> counts . intra_inter [ j ] [ 1 ] ; } sf -> skip_encode_frame = ( intra_count << 2 ) < inter_count && cm -> frame_type != KEY_FRAME && cm -> show_frame ; } else { sf -> skip_encode_frame = 0 ; } # if 0 cpi -> last_frame_distortion = cpi -> frame_distortion ; # endif }
","<S2SV_ModStart> -> sf ; ThreadData * const td = & cpi -> td ; <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> -> e_mbd ; RD_COUNTS * const rdc = & cpi -> td . rd_counts ; <S2SV_ModStart> ; vp9_zero ( * td <S2SV_ModEnd> -> counts ) <S2SV_ModStart> ; vp9_zero ( rdc <S2SV_ModEnd> -> coef_counts ) <S2SV_ModStart> ; vp9_zero ( rdc -> comp_pred_diff <S2SV_ModEnd> ) ; vp9_zero <S2SV_ModStart> ; vp9_zero ( rdc -> filter_diff ) ; xd -> <S2SV_ModEnd> lossless = cm <S2SV_ModStart> == 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add ; # else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; # endif x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; if ( xd -> lossless ) x -> optimize = 0 ; cm -> tx_mode = select_tx_mode <S2SV_ModEnd> ( cpi , <S2SV_ModStart> ( cpi , xd <S2SV_ModEnd> ) ; vp9_frame_init_quantizer <S2SV_ModStart> ( cpi , x , <S2SV_ModStart> cpi ) ; cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame <S2SV_ModEnd> ; cm -> <S2SV_ModStart> -> prev_mi = cm -> use_prev_frame_mvs ? cm -> prev_mip + cm -> mi_stride + 1 : NULL ; x -> quant_fp = cpi -> sf . use_quant_fp ; vp9_zero ( x -> skip_txfm <S2SV_ModEnd> ) ; if <S2SV_ModStart> & cpi -> td . pc_root -> none <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; if ( cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; if ( sf -> <S2SV_ModEnd> partition_search_type == SOURCE_VAR_BASED_PARTITION <S2SV_ModStart> partition_search_type == SOURCE_VAR_BASED_PARTITION ) source_var_based_partition_search_method ( cpi ) ; <S2SV_ModEnd> } { struct <S2SV_ModStart> emr_timer ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , & cpi -> twopass . this_frame_mb_stats ) ; } # endif if ( MIN ( cpi -> oxcf . max_threads , <S2SV_ModEnd> 1 << cm <S2SV_ModStart> cm -> log2_tile_cols ) > 1 ) vp9_encode_tiles_mt ( cpi <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else encode_tiles ( cpi ) ; <S2SV_ModEnd> vpx_usec_timer_mark ( & <S2SV_ModStart> ) ; } sf -> skip_encode_frame = sf -> skip_encode_sb ? get_skip_encode_frame ( cm , td ) : 0 ; <S2SV_ModEnd> # if 0
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , <S2SV_StartBug> size_t input_size , <S2SV_EndBug> int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { uint8_t * ip ; uint8_t * input ; uint8_t mask ; uint8_t value ; RE_FIBER_LIST fibers ; RE_THREAD_STORAGE * storage ; RE_FIBER * fiber ; RE_FIBER * next_fiber ; int error ; int bytes_matched ; int max_bytes_matched ; int match ; int character_size ; int input_incr ; int kill ; int action ; int result = - 1 ; # define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 <S2SV_StartBug> # define prolog if ( bytes_matched >= max_bytes_matched ) { action = ACTION_KILL ; break ; } <S2SV_EndBug> <S2SV_StartBug> # define fail_if_error ( e ) switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } <S2SV_EndBug> if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ; if ( flags & RE_FLAGS_WIDE ) character_size = 2 ; else character_size = 1 ; input = input_data ; input_incr = character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { <S2SV_StartBug> input -= character_size ; <S2SV_EndBug> input_incr = - input_incr ; } <S2SV_StartBug> max_bytes_matched = ( int ) yr_min ( input_size , RE_SCAN_LIMIT ) ; <S2SV_EndBug> max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched = 0 ; error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; fibers . head = fiber ; fibers . tail = fiber ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; while ( fibers . head != NULL ) { fiber = fibers . head ; while ( fiber != NULL ) { ip = fiber -> ip ; action = ACTION_NONE ; switch ( * ip ) { case RE_OPCODE_ANY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_GREEDY : case RE_OPCODE_REPEAT_ANY_UNGREEDY : prolog ; match = ( flags & RE_FLAGS_DOT_ALL ) || ( * input != 0x0A ) ; action = match ? ACTION_NONE : ACTION_KILL ; break ; case RE_OPCODE_LITERAL : prolog ; if ( flags & RE_FLAGS_NO_CASE ) match = yr_lowercase [ * input ] == yr_lowercase [ * ( ip + 1 ) ] ; else match = ( * input == * ( ip + 1 ) ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 2 ; break ; case RE_OPCODE_MASKED_LITERAL : prolog ; value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; match = ( ( * input & mask ) == value ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 3 ; break ; case RE_OPCODE_CLASS : prolog ; match = CHAR_IN_CLASS ( * input , ip + 1 ) ; if ( ! match && ( flags & RE_FLAGS_NO_CASE ) ) match = CHAR_IN_CLASS ( yr_altercase [ * input ] , ip + 1 ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 33 ; break ; case RE_OPCODE_WORD_CHAR : prolog ; <S2SV_StartBug> match = IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_WORD_CHAR : prolog ; <S2SV_StartBug> match = ! IS_WORD_CHAR ( * input ) ; <S2SV_EndBug> action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_SPACE : case RE_OPCODE_NON_SPACE : prolog ; switch ( * input ) { case '<S2SV_blank>' : case '\\t' : case '\\r' : case '\\n' : case '\\v' : case '\\f' : match = TRUE ; break ; default : match = FALSE ; } if ( * ip == RE_OPCODE_NON_SPACE ) match = ! match ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_DIGIT : prolog ; match = isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_NON_DIGIT : prolog ; match = ! isdigit ( * input ) ; action = match ? ACTION_NONE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_WORD_BOUNDARY : case RE_OPCODE_NON_WORD_BOUNDARY : if ( bytes_matched == 0 && <S2SV_StartBug> ! ( flags & RE_FLAGS_NOT_AT_START ) && <S2SV_EndBug> ! ( flags & RE_FLAGS_BACKWARDS ) ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> else if ( bytes_matched >= max_bytes_matched ) <S2SV_StartBug> match = TRUE ; <S2SV_EndBug> <S2SV_StartBug> else if ( IS_WORD_CHAR ( * ( input - input_incr ) ) != IS_WORD_CHAR ( * input ) ) <S2SV_EndBug> match = TRUE ; else match = FALSE ; if ( * ip == RE_OPCODE_NON_WORD_BOUNDARY ) match = ! match ; action = match ? ACTION_CONTINUE : ACTION_KILL ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_START : if ( flags & RE_FLAGS_BACKWARDS ) <S2SV_StartBug> kill = input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> else <S2SV_StartBug> kill = ( flags & RE_FLAGS_NOT_AT_START ) || ( bytes_matched != 0 ) ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH_AT_END : kill = flags & RE_FLAGS_BACKWARDS || <S2SV_StartBug> input_size > ( size_t ) bytes_matched ; <S2SV_EndBug> action = kill ? ACTION_KILL : ACTION_CONTINUE ; fiber -> ip += 1 ; break ; case RE_OPCODE_MATCH : result = bytes_matched ; if ( flags & RE_FLAGS_EXHAUSTIVE ) { if ( callback != NULL ) { int cb_result ; if ( flags & RE_FLAGS_BACKWARDS ) cb_result = callback ( input + character_size , bytes_matched , flags , callback_args ) ; else cb_result = callback ( input_data , bytes_matched , flags , callback_args ) ; switch ( cb_result ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_MATCHES : return - 3 ; default : if ( cb_result != ERROR_SUCCESS ) return - 4 ; } } action = ACTION_KILL ; } else { action = ACTION_KILL_TAIL ; } break ; default : assert ( FALSE ) ; } switch ( action ) { case ACTION_KILL : fiber = _yr_re_fiber_kill ( & fibers , & storage -> fiber_pool , fiber ) ; break ; case ACTION_KILL_TAIL : _yr_re_fiber_kill_tail ( & fibers , & storage -> fiber_pool , fiber ) ; fiber = NULL ; break ; case ACTION_CONTINUE : error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; break ; default : next_fiber = fiber -> next ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; fiber = next_fiber ; } <S2SV_StartBug> } <S2SV_EndBug> if ( flags & RE_FLAGS_WIDE && bytes_matched < max_bytes_matched && * ( input + 1 ) != 0 ) { _yr_re_fiber_kill_all ( & fibers , & storage -> fiber_pool ) ; } input += input_incr ; bytes_matched += character_size ; if ( flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched ) { error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; _yr_re_fiber_append ( & fibers , fiber ) ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool , fiber ) ; fail_if_error ( error ) ; } } return result ; }
","<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
",VirusTotal@yara/83d799804648c2a0895d40a19835d9b757c6fa4e,CVE-2017-8294,https://github.com/VirusTotal/yara/commit/83d799804648c2a0895d40a19835d9b757c6fa4e,2017-04-27T14:59Z
CWE-119,"CWE-119 void WT_Interpolate ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 phaseFrac ; EAS_I32 acc0 ; const EAS_SAMPLE * pSamples ; const EAS_SAMPLE * loopEnd ; EAS_I32 samp1 ; EAS_I32 samp2 ; EAS_I32 numSamples ; numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <S2SV_StartBug> ALOGE ( ""b/26366256"" ) ; <S2SV_EndBug> return ; } pOutputBuffer = pWTIntFrame -> pAudioBuffer ; loopEnd = ( const EAS_SAMPLE * ) pWTVoice -> loopEnd + 1 ; pSamples = ( const EAS_SAMPLE * ) pWTVoice -> phaseAccum ; phaseFrac = pWTVoice -> phaseFrac ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif while ( numSamples -- ) { acc0 = samp2 - samp1 ; acc0 = acc0 * phaseFrac ; acc0 = samp1 + ( acc0 >> NUM_PHASE_FRAC_BITS ) ; * pOutputBuffer ++ = ( EAS_I16 ) ( acc0 >> 2 ) ; phaseFrac += phaseInc ; acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS ; if ( acc0 > 0 ) { pSamples += acc0 ; phaseFrac = ( EAS_I32 ) ( ( EAS_U32 ) phaseFrac & PHASE_FRAC_MASK ) ; acc0 = ( EAS_I32 ) ( pSamples - loopEnd ) ; if ( acc0 >= 0 ) pSamples = ( const EAS_SAMPLE * ) pWTVoice -> loopStart + acc0 ; # if defined ( _8_BIT_SAMPLES ) samp1 = pSamples [ 0 ] << 8 ; samp2 = pSamples [ 1 ] << 8 ; # else samp1 = pSamples [ 0 ] ; samp2 = pSamples [ 1 ] ; # endif } } pWTVoice -> phaseAccum = ( EAS_U32 ) pSamples ; pWTVoice -> phaseFrac = ( EAS_U32 ) phaseFrac ; }
","<S2SV_ModStart> ALOGE ( ""b/26366256"" ) ; android_errorWriteLog ( 0x534e4554 , ""26366256""
",external@sonivox/24d7c408c52143bce7b49de82f3913fd8d1219cf,CVE-2016-0838,https://android.googlesource.com/platform/external/sonivox/+/24d7c408c52143bce7b49de82f3913fd8d1219cf,2016-04-18T00:59Z
CWE-20,"CWE-20 long kvm_arch_vcpu_ioctl ( struct file * filp , unsigned int ioctl , unsigned long arg ) { struct kvm_vcpu * vcpu = filp -> private_data ; void __user * argp = ( void __user * ) arg ; int r ; union { struct kvm_lapic_state * lapic ; struct kvm_xsave * xsave ; struct kvm_xcrs * xcrs ; void * buffer ; } u ; u . buffer = NULL ; switch ( ioctl ) { case KVM_GET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = kzalloc ( sizeof ( struct kvm_lapic_state ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . lapic ) goto out ; r = kvm_vcpu_ioctl_get_lapic ( vcpu , u . lapic ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , u . lapic , sizeof ( struct kvm_lapic_state ) ) ) goto out ; r = 0 ; break ; } case KVM_SET_LAPIC : { r = - EINVAL ; if ( ! vcpu -> arch . apic ) goto out ; u . lapic = memdup_user ( argp , sizeof ( * u . lapic ) ) ; if ( IS_ERR ( u . lapic ) ) return PTR_ERR ( u . lapic ) ; r = kvm_vcpu_ioctl_set_lapic ( vcpu , u . lapic ) ; break ; } case KVM_INTERRUPT : { struct kvm_interrupt irq ; r = - EFAULT ; if ( copy_from_user ( & irq , argp , sizeof irq ) ) goto out ; r = kvm_vcpu_ioctl_interrupt ( vcpu , & irq ) ; break ; } case KVM_NMI : { r = kvm_vcpu_ioctl_nmi ( vcpu ) ; break ; } case KVM_SET_CPUID : { struct kvm_cpuid __user * cpuid_arg = argp ; struct kvm_cpuid cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_SET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_set_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; break ; } case KVM_GET_CPUID2 : { struct kvm_cpuid2 __user * cpuid_arg = argp ; struct kvm_cpuid2 cpuid ; r = - EFAULT ; if ( copy_from_user ( & cpuid , cpuid_arg , sizeof cpuid ) ) goto out ; r = kvm_vcpu_ioctl_get_cpuid2 ( vcpu , & cpuid , cpuid_arg -> entries ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( cpuid_arg , & cpuid , sizeof cpuid ) ) goto out ; r = 0 ; break ; } case KVM_GET_MSRS : r = msr_io ( vcpu , argp , kvm_get_msr , 1 ) ; break ; case KVM_SET_MSRS : r = msr_io ( vcpu , argp , do_set_msr , 0 ) ; break ; case KVM_TPR_ACCESS_REPORTING : { struct kvm_tpr_access_ctl tac ; r = - EFAULT ; if ( copy_from_user ( & tac , argp , sizeof tac ) ) goto out ; r = vcpu_ioctl_tpr_access_reporting ( vcpu , & tac ) ; if ( r ) goto out ; r = - EFAULT ; if ( copy_to_user ( argp , & tac , sizeof tac ) ) goto out ; r = 0 ; break ; } ; case KVM_SET_VAPIC_ADDR : { struct kvm_vapic_addr va ; r = - EINVAL ; if ( ! irqchip_in_kernel ( vcpu -> kvm ) ) goto out ; r = - EFAULT ; if ( copy_from_user ( & va , argp , sizeof va ) ) goto out ; <S2SV_StartBug> r = 0 ; <S2SV_EndBug> kvm_lapic_set_vapic_addr ( vcpu , va . vapic_addr ) ; break ; } case KVM_X86_SETUP_MCE : { u64 mcg_cap ; r = - EFAULT ; if ( copy_from_user ( & mcg_cap , argp , sizeof mcg_cap ) ) goto out ; r = kvm_vcpu_ioctl_x86_setup_mce ( vcpu , mcg_cap ) ; break ; } case KVM_X86_SET_MCE : { struct kvm_x86_mce mce ; r = - EFAULT ; if ( copy_from_user ( & mce , argp , sizeof mce ) ) goto out ; r = kvm_vcpu_ioctl_x86_set_mce ( vcpu , & mce ) ; break ; } case KVM_GET_VCPU_EVENTS : { struct kvm_vcpu_events events ; kvm_vcpu_ioctl_x86_get_vcpu_events ( vcpu , & events ) ; r = - EFAULT ; if ( copy_to_user ( argp , & events , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = 0 ; break ; } case KVM_SET_VCPU_EVENTS : { struct kvm_vcpu_events events ; r = - EFAULT ; if ( copy_from_user ( & events , argp , sizeof ( struct kvm_vcpu_events ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_vcpu_events ( vcpu , & events ) ; break ; } case KVM_GET_DEBUGREGS : { struct kvm_debugregs dbgregs ; kvm_vcpu_ioctl_x86_get_debugregs ( vcpu , & dbgregs ) ; r = - EFAULT ; if ( copy_to_user ( argp , & dbgregs , sizeof ( struct kvm_debugregs ) ) ) break ; r = 0 ; break ; } case KVM_SET_DEBUGREGS : { struct kvm_debugregs dbgregs ; r = - EFAULT ; if ( copy_from_user ( & dbgregs , argp , sizeof ( struct kvm_debugregs ) ) ) break ; r = kvm_vcpu_ioctl_x86_set_debugregs ( vcpu , & dbgregs ) ; break ; } case KVM_GET_XSAVE : { u . xsave = kzalloc ( sizeof ( struct kvm_xsave ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xsave ) break ; kvm_vcpu_ioctl_x86_get_xsave ( vcpu , u . xsave ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xsave , sizeof ( struct kvm_xsave ) ) ) break ; r = 0 ; break ; } case KVM_SET_XSAVE : { u . xsave = memdup_user ( argp , sizeof ( * u . xsave ) ) ; if ( IS_ERR ( u . xsave ) ) return PTR_ERR ( u . xsave ) ; r = kvm_vcpu_ioctl_x86_set_xsave ( vcpu , u . xsave ) ; break ; } case KVM_GET_XCRS : { u . xcrs = kzalloc ( sizeof ( struct kvm_xcrs ) , GFP_KERNEL ) ; r = - ENOMEM ; if ( ! u . xcrs ) break ; kvm_vcpu_ioctl_x86_get_xcrs ( vcpu , u . xcrs ) ; r = - EFAULT ; if ( copy_to_user ( argp , u . xcrs , sizeof ( struct kvm_xcrs ) ) ) break ; r = 0 ; break ; } case KVM_SET_XCRS : { u . xcrs = memdup_user ( argp , sizeof ( * u . xcrs ) ) ; if ( IS_ERR ( u . xcrs ) ) return PTR_ERR ( u . xcrs ) ; r = kvm_vcpu_ioctl_x86_set_xcrs ( vcpu , u . xcrs ) ; break ; } case KVM_SET_TSC_KHZ : { u32 user_tsc_khz ; r = - EINVAL ; user_tsc_khz = ( u32 ) arg ; if ( user_tsc_khz >= kvm_max_guest_tsc_khz ) goto out ; if ( user_tsc_khz == 0 ) user_tsc_khz = tsc_khz ; kvm_set_tsc_khz ( vcpu , user_tsc_khz ) ; r = 0 ; goto out ; } case KVM_GET_TSC_KHZ : { r = vcpu -> arch . virtual_tsc_khz ; goto out ; } case KVM_KVMCLOCK_CTRL : { r = kvm_set_guest_paused ( vcpu ) ; goto out ; } default : r = - EINVAL ; } out : kfree ( u . buffer ) ; return r ; }
","<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
",torvalds@linux/fda4e2e85589191b123d31cdc21fd33ee70f50fd,CVE-2013-6368,https://github.com/torvalds/linux/commit/fda4e2e85589191b123d31cdc21fd33ee70f50fd,2013-12-14T18:08Z
CWE-362,"CWE-362 int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> __be32 saddr , __be32 daddr , struct ip_options * opt ) <S2SV_EndBug> { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = skb_rtable ( skb ) ; struct iphdr * iph ; <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> skb_reset_network_header ( skb ) ; iph = ip_hdr ( skb ) ; iph -> version = 4 ; iph -> ihl = 5 ; iph -> tos = inet -> tos ; if ( ip_dont_fragment ( sk , & rt -> dst ) ) iph -> frag_off = htons ( IP_DF ) ; else iph -> frag_off = 0 ; iph -> ttl = ip_select_ttl ( inet , & rt -> dst ) ; iph -> daddr = rt -> rt_dst ; iph -> saddr = rt -> rt_src ; iph -> protocol = sk -> sk_protocol ; ip_select_ident ( iph , & rt -> dst , sk ) ; <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , daddr , rt , 0 ) ; <S2SV_EndBug> } skb -> priority = sk -> sk_priority ; skb -> mark = sk -> sk_mark ; return ip_local_out ( skb ) ; }
","<S2SV_ModStart> daddr , struct ip_options_rcu <S2SV_ModEnd> * opt ) <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ( skb , & opt ->
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-200,"CWE-200 void iov_iter_pipe ( struct iov_iter * i , int direction , struct pipe_inode_info * pipe , size_t count ) { <S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> i -> type = direction ; i -> pipe = pipe ; i -> idx = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; i -> iov_offset = 0 ; i -> count = count ; }
","<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
",torvalds@linux/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,CVE-2017-5550,https://github.com/torvalds/linux/commit/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb,2017-02-06T06:59Z
CWE-200,"CWE-200 static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> sa -> rc_family = AF_BLUETOOTH ; sa -> rc_channel = rfcomm_pi ( sk ) -> channel ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
","<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
",torvalds@linux/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,CVE-2012-6545,https://github.com/torvalds/linux/commit/9344a972961d1a6d2c04d9008b13617bcb6ec2ef,2013-03-15T20:55Z
CWE-20,"CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ;
",ImageMagick@ImageMagick/afa878a689870c28b6994ecf3bb8dbfb2b76d135,CVE-2018-16644,https://github.com/ImageMagick/ImageMagick/commit/afa878a689870c28b6994ecf3bb8dbfb2b76d135,2018-09-06T22:29Z
CWE-17,"CWE-17 static void destroy_super ( struct super_block * s ) { int i ; list_lru_destroy ( & s -> s_dentry_lru ) ; list_lru_destroy ( & s -> s_inode_lru ) ; <S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> free_percpu ( s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) percpu_counter_destroy ( & s -> s_writers . counter [ i ] ) ; security_sb_free ( s ) ; WARN_ON ( ! list_empty ( & s -> s_mounts ) ) ; kfree ( s -> s_subtype ) ; kfree ( s -> s_options ) ; kfree_rcu ( s , rcu ) ; }
","<S2SV_ModStart> s_inode_lru ) ; <S2SV_ModEnd> for ( i
",torvalds@linux/eee5cc2702929fd41cce28058dc6d6717f723f87,CVE-2014-8172,https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87,2015-03-16T10:59Z
CWE-416,"CWE-416 static int get_gate_page ( struct mm_struct * mm , unsigned long address , unsigned int gup_flags , struct vm_area_struct * * vma , struct page * * page ) { pgd_t * pgd ; p4d_t * p4d ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; int ret = - EFAULT ; if ( gup_flags & FOLL_WRITE ) return - EFAULT ; if ( address > TASK_SIZE ) pgd = pgd_offset_k ( address ) ; else pgd = pgd_offset_gate ( mm , address ) ; BUG_ON ( pgd_none ( * pgd ) ) ; p4d = p4d_offset ( pgd , address ) ; BUG_ON ( p4d_none ( * p4d ) ) ; pud = pud_offset ( p4d , address ) ; BUG_ON ( pud_none ( * pud ) ) ; pmd = pmd_offset ( pud , address ) ; if ( ! pmd_present ( * pmd ) ) return - EFAULT ; VM_BUG_ON ( pmd_trans_huge ( * pmd ) ) ; pte = pte_offset_map ( pmd , address ) ; if ( pte_none ( * pte ) ) goto unmap ; * vma = get_gate_vma ( mm ) ; if ( ! page ) goto out ; * page = vm_normal_page ( * vma , address , * pte ) ; if ( ! * page ) { if ( ( gup_flags & FOLL_DUMP ) || ! is_zero_pfn ( pte_pfn ( * pte ) ) ) goto unmap ; * page = pte_page ( * pte ) ; if ( is_device_public_page ( * page ) ) goto unmap ; } <S2SV_StartBug> get_page ( * page ) ; <S2SV_EndBug> out : ret = 0 ; unmap : pte_unmap ( pte ) ; return ret ; }
","<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
",torvalds@linux/8fde12ca79aff9b5ba951fce1a2641901b8d8e64,CVE-2019-11487,https://github.com/torvalds/linux/commit/8fde12ca79aff9b5ba951fce1a2641901b8d8e64,2019-04-23T22:29Z
CWE-674,"CWE-674 static krb5_error_code decode_sequence ( const uint8_t * asn1 , size_t len , const struct seq_info * seq , void * val ) { krb5_error_code ret ; const uint8_t * contents ; size_t i , j , clen ; taginfo t ; assert ( seq -> n_fields > 0 ) ; for ( i = 0 ; i < seq -> n_fields ; i ++ ) { if ( len == 0 ) break ; <S2SV_StartBug> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <S2SV_EndBug> if ( ret ) goto error ; for ( ; i < seq -> n_fields ; i ++ ) { if ( check_atype_tag ( seq -> fields [ i ] , & t ) ) break ; ret = omit_atype ( seq -> fields [ i ] , val ) ; if ( ret ) goto error ; } if ( i == seq -> n_fields ) break ; ret = decode_atype ( & t , contents , clen , seq -> fields [ i ] , val ) ; if ( ret ) goto error ; } for ( ; i < seq -> n_fields ; i ++ ) { ret = omit_atype ( seq -> fields [ i ] , val ) ; if ( ret ) goto error ; } return 0 ; error : for ( j = 0 ; j < i ; j ++ ) free_atype ( seq -> fields [ j ] , val ) ; for ( j = 0 ; j < i ; j ++ ) free_atype_ptr ( seq -> fields [ j ] , val ) ; return ret ; }
","<S2SV_ModStart> , & len , 0
",krb5@krb5/57415dda6cf04e73ffc3723be518eddfae599bfd,CVE-2020-28196,https://github.com/krb5/krb5/commit/57415dda6cf04e73ffc3723be518eddfae599bfd,2020-11-06T08:15Z
CWE-362,"CWE-362 static ssize_t n_tty_write ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) { const unsigned char * b = buf ; DECLARE_WAITQUEUE ( wait , current ) ; int c ; ssize_t retval = 0 ; if ( L_TOSTOP ( tty ) && file -> f_op -> write != redirected_tty_write ) { retval = tty_check_change ( tty ) ; if ( retval ) return retval ; } down_read ( & tty -> termios_rwsem ) ; process_echoes ( tty ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( signal_pending ( current ) ) { retval = - ERESTARTSYS ; break ; } if ( tty_hung_up_p ( file ) || ( tty -> link && ! tty -> link -> count ) ) { retval = - EIO ; break ; } if ( O_OPOST ( tty ) ) { while ( nr > 0 ) { ssize_t num = process_output_block ( tty , b , nr ) ; if ( num < 0 ) { if ( num == - EAGAIN ) break ; retval = num ; goto break_out ; } b += num ; nr -= num ; if ( nr == 0 ) break ; c = * b ; if ( process_output ( c , tty ) < 0 ) break ; b ++ ; nr -- ; } if ( tty -> ops -> flush_chars ) tty -> ops -> flush_chars ( tty ) ; } else { <S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> if ( c < 0 ) { retval = c ; goto break_out ; } if ( ! c ) break ; b += c ; nr -= c ; } } if ( ! nr ) break ; if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; break ; } up_read ( & tty -> termios_rwsem ) ; schedule ( ) ; down_read ( & tty -> termios_rwsem ) ; } break_out : __set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( b - buf != nr && tty -> fasync ) set_bit ( TTY_DO_WRITE_WAKEUP , & tty -> flags ) ; up_read ( & tty -> termios_rwsem ) ; return ( b - buf ) ? b - buf : retval ; }
","<S2SV_ModStart> } else { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> 0 ) { mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> b , nr ) ; mutex_unlock ( & ldata -> output_lock
",torvalds@linux/4291086b1f081b869c6d79e5b7441633dc3ace00,CVE-2014-0196,https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00,2014-05-07T10:55Z
CWE-400,"CWE-400 int do_mathemu ( struct pt_regs * regs , struct task_struct * fpt ) { int i ; int retcode = 0 ; unsigned long insn ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> # ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\n"" , regs -> pc ) ; printk ( ""fpqdepth<S2SV_blank>is<S2SV_blank>%ld\\n"" , fpt -> thread . fpqdepth ) ; for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) printk ( ""%d:<S2SV_blank>%08lx<S2SV_blank>at<S2SV_blank>%08lx\\n"" , i , fpt -> thread . fpqueue [ i ] . insn , ( unsigned long ) fpt -> thread . fpqueue [ i ] . insn_addr ) ; # endif if ( fpt -> thread . fpqdepth == 0 ) { # ifdef DEBUG_MATHEMU printk ( ""precise<S2SV_blank>trap<S2SV_blank>at<S2SV_blank>%08lx\\n"" , regs -> pc ) ; # endif if ( ! get_user ( insn , ( u32 __user * ) regs -> pc ) ) { retcode = do_one_mathemu ( insn , & fpt -> thread . fsr , fpt -> thread . float_regs ) ; if ( retcode ) { regs -> pc = regs -> npc ; regs -> npc += 4 ; } } return retcode ; } for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) { retcode = do_one_mathemu ( fpt -> thread . fpqueue [ i ] . insn , & ( fpt -> thread . fsr ) , fpt -> thread . float_regs ) ; if ( ! retcode ) break ; } if ( retcode ) fpt -> thread . fsr &= ~ ( 0x3000 | FSR_CEXC_MASK ) ; else fpt -> thread . fsr &= ~ 0x3000 ; fpt -> thread . fpqdepth = 0 ; return retcode ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-125,"CWE-125 static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += 1 ; <S2SV_StartBug> length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; <S2SV_EndBug> length += update_prepare_bounds ( context , orderInfo ) ; return length ; }
","<S2SV_ModStart> ; length += get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ; length +=
",FreeRDP@FreeRDP/733ee3208306b1ea32697b356c0215180fc3f049,CVE-2020-11095,https://github.com/FreeRDP/FreeRDP/commit/733ee3208306b1ea32697b356c0215180fc3f049,2020-06-22T22:15Z
CWE-787,"CWE-787 int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( ""[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer"" ) ; return - 1 ; } memset ( & strm , '\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }
","<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf =
",fluent@fluent-bit/cadff53c093210404aed01c4cf586adb8caa07af,CVE-2020-35963,https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af,2021-01-03T19:15Z
CWE-310,"CWE-310 static void prefetch_enc ( void ) { <S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
CWE-119,"CWE-119 int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { UINT8 * ptr ; int framesize ; int c , chunks ; int l , lines ; int i , j , x = 0 , y , ymax ; if ( bytes < 4 ) return 0 ; ptr = buf ; framesize = I32 ( ptr ) ; if ( framesize < I32 ( ptr ) ) return 0 ; if ( I16 ( ptr + 4 ) != 0xF1FA ) { state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } chunks = I16 ( ptr + 6 ) ; ptr += 16 ; for ( c = 0 ; c < chunks ; c ++ ) { UINT8 * data = ptr + 6 ; switch ( I16 ( ptr + 4 ) ) { case 4 : case 11 : break ; case 7 : lines = I16 ( data ) ; data += 2 ; for ( l = y = 0 ; l < lines && y < state -> ysize ; l ++ , y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; int p , packets ; packets = I16 ( data ) ; data += 2 ; while ( packets & 0x8000 ) { if ( packets & 0x4000 ) { y += 65536 - packets ; if ( y >= state -> ysize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } buf = ( UINT8 * ) im -> image [ y ] ; } else { buf [ state -> xsize - 1 ] = ( UINT8 ) packets ; } packets = I16 ( data ) ; data += 2 ; } for ( p = x = 0 ; p < packets ; p ++ ) { x += data [ 0 ] ; if ( data [ 1 ] >= 128 ) { i = 256 - data [ 1 ] ; if ( x + i + i > state -> xsize ) break ; for ( j = 0 ; j < i ; j ++ ) { buf [ x ++ ] = data [ 2 ] ; buf [ x ++ ] = data [ 3 ] ; } data += 2 + 2 ; } else { i = 2 * ( int ) data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( buf + x , data + 2 , i ) ; data += 2 + i ; x += i ; } } if ( p < packets ) break ; } if ( l < lines ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 12 : y = I16 ( data ) ; ymax = y + I16 ( data + 2 ) ; data += 4 ; for ( ; y < ymax && y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; int p , packets = * data ++ ; for ( p = x = 0 ; p < packets ; p ++ , x += i ) { x += data [ 0 ] ; if ( data [ 1 ] & 0x80 ) { i = 256 - data [ 1 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 2 ] , i ) ; data += 3 ; } else { i = data [ 1 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 2 , i ) ; data += i + 2 ; } } if ( p < packets ) break ; } if ( y < ymax ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } break ; case 13 : for ( y = 0 ; y < state -> ysize ; y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ; break ; case 15 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * out = ( UINT8 * ) im -> image [ y ] ; data += 1 ; for ( x = 0 ; x < state -> xsize ; x += i ) { if ( data [ 0 ] & 0x80 ) { i = 256 - data [ 0 ] ; if ( x + i > state -> xsize ) break ; memcpy ( out + x , data + 1 , i ) ; data += i + 1 ; } else { i = data [ 0 ] ; if ( x + i > state -> xsize ) break ; memset ( out + x , data [ 1 ] , i ) ; data += 2 ; } } if ( x != state -> xsize ) { state -> errcode = IMAGING_CODEC_OVERRUN ; return - 1 ; } } break ; case 16 : for ( y = 0 ; y < state -> ysize ; y ++ ) { UINT8 * buf = ( UINT8 * ) im -> image [ y ] ; <S2SV_StartBug> memcpy ( buf + x , data , state -> xsize ) ; <S2SV_EndBug> data += state -> xsize ; } break ; case 18 : break ; default : state -> errcode = IMAGING_CODEC_UNKNOWN ; return - 1 ; } ptr += I32 ( ptr ) ; } return - 1 ; }
","<S2SV_ModStart> memcpy ( buf <S2SV_ModEnd> , data ,
",python-pillow@Pillow/893a40850c2d5da41537958e40569c029a6e127b,CVE-2016-0775,https://github.com/python-pillow/Pillow/commit/893a40850c2d5da41537958e40569c029a6e127b,2016-04-13T16:59Z
CWE-20,"CWE-20 struct sk_buff * sock_alloc_send_pskb ( struct sock * sk , unsigned long header_len , unsigned long data_len , int noblock , int * errcode ) { struct sk_buff * skb ; gfp_t gfp_mask ; long timeo ; int err ; <S2SV_StartBug> gfp_mask = sk -> sk_allocation ; <S2SV_EndBug> if ( gfp_mask & __GFP_WAIT ) gfp_mask |= __GFP_REPEAT ; timeo = sock_sndtimeo ( sk , noblock ) ; while ( 1 ) { err = sock_error ( sk ) ; if ( err != 0 ) goto failure ; err = - EPIPE ; if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto failure ; if ( atomic_read ( & sk -> sk_wmem_alloc ) < sk -> sk_sndbuf ) { skb = alloc_skb ( header_len , gfp_mask ) ; if ( skb ) { <S2SV_StartBug> int npages ; <S2SV_EndBug> int i ; if ( ! data_len ) <S2SV_StartBug> break ; <S2SV_EndBug> npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; skb -> truesize += data_len ; skb_shinfo ( skb ) -> nr_frags = npages ; for ( i = 0 ; i < npages ; i ++ ) { struct page * page ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( ! page ) { err = - ENOBUFS ; skb_shinfo ( skb ) -> nr_frags = i ; kfree_skb ( skb ) ; goto failure ; } __skb_fill_page_desc ( skb , i , page , 0 , ( data_len >= PAGE_SIZE ? PAGE_SIZE : data_len ) ) ; data_len -= PAGE_SIZE ; } break ; } err = - ENOBUFS ; goto failure ; } set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; set_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ; err = - EAGAIN ; if ( ! timeo ) goto failure ; if ( signal_pending ( current ) ) goto interrupted ; timeo = sock_wait_for_wmem ( sk , timeo ) ; } skb_set_owner_w ( skb , sk ) ; return skb ; interrupted : err = sock_intr_errno ( timeo ) ; failure : * errcode = err ; return NULL ; }
","<S2SV_ModStart> int err ; int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart> ) { int <S2SV_ModEnd> i ; if <S2SV_ModStart> data_len ) break <S2SV_ModEnd> ; skb ->
",torvalds@linux/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc,CVE-2012-2136,https://github.com/torvalds/linux/commit/cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc,2012-08-09T10:29Z
CWE-20,"CWE-20 int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB_CHUNK_MAX , TRACK_SIZES , NO_INLINE_ASCII_RESP , MODERN , NO_MODERN , NO_CHUNKED_ITEMS , NO_SLAB_REASSIGN , NO_SLAB_AUTOMOVE , NO_MAXCONNS_FAST , INLINE_ASCII_RESP , NO_LRU_CRAWLER , NO_LRU_MAINTAINER , NO_DROP_PRIVILEGES , # ifdef MEMCACHED_DEBUG RELAXED_PRIVILEGES , # endif # ifdef EXTSTORE EXT_PAGE_SIZE , EXT_PAGE_COUNT , EXT_WBUF_SIZE , EXT_THREADS , EXT_IO_DEPTH , EXT_PATH , EXT_ITEM_SIZE , EXT_ITEM_AGE , EXT_LOW_TTL , EXT_RECACHE_RATE , EXT_COMPACT_UNDER , EXT_DROP_UNDER , EXT_MAX_FRAG , EXT_DROP_UNREAD , SLAB_AUTOMOVE_FREERATIO , # endif } ; char * const subopts_tokens [ ] = { [ MAXCONNS_FAST ] = ""maxconns_fast"" , [ HASHPOWER_INIT ] = ""hashpower"" , [ NO_HASHEXPAND ] = ""no_hashexpand"" , [ SLAB_REASSIGN ] = ""slab_reassign"" , [ SLAB_AUTOMOVE ] = ""slab_automove"" , [ SLAB_AUTOMOVE_RATIO ] = ""slab_automove_ratio"" , [ SLAB_AUTOMOVE_WINDOW ] = ""slab_automove_window"" , [ TAIL_REPAIR_TIME ] = ""tail_repair_time"" , [ HASH_ALGORITHM ] = ""hash_algorithm"" , [ LRU_CRAWLER ] = ""lru_crawler"" , [ LRU_CRAWLER_SLEEP ] = ""lru_crawler_sleep"" , [ LRU_CRAWLER_TOCRAWL ] = ""lru_crawler_tocrawl"" , [ LRU_MAINTAINER ] = ""lru_maintainer"" , [ HOT_LRU_PCT ] = ""hot_lru_pct"" , [ WARM_LRU_PCT ] = ""warm_lru_pct"" , [ HOT_MAX_FACTOR ] = ""hot_max_factor"" , [ WARM_MAX_FACTOR ] = ""warm_max_factor"" , [ TEMPORARY_TTL ] = ""temporary_ttl"" , [ IDLE_TIMEOUT ] = ""idle_timeout"" , [ WATCHER_LOGBUF_SIZE ] = ""watcher_logbuf_size"" , [ WORKER_LOGBUF_SIZE ] = ""worker_logbuf_size"" , [ SLAB_SIZES ] = ""slab_sizes"" , [ SLAB_CHUNK_MAX ] = ""slab_chunk_max"" , [ TRACK_SIZES ] = ""track_sizes"" , [ NO_INLINE_ASCII_RESP ] = ""no_inline_ascii_resp"" , [ MODERN ] = ""modern"" , [ NO_MODERN ] = ""no_modern"" , [ NO_CHUNKED_ITEMS ] = ""no_chunked_items"" , [ NO_SLAB_REASSIGN ] = ""no_slab_reassign"" , [ NO_SLAB_AUTOMOVE ] = ""no_slab_automove"" , [ NO_MAXCONNS_FAST ] = ""no_maxconns_fast"" , [ INLINE_ASCII_RESP ] = ""inline_ascii_resp"" , [ NO_LRU_CRAWLER ] = ""no_lru_crawler"" , [ NO_LRU_MAINTAINER ] = ""no_lru_maintainer"" , [ NO_DROP_PRIVILEGES ] = ""no_drop_privileges"" , # ifdef MEMCACHED_DEBUG [ RELAXED_PRIVILEGES ] = ""relaxed_privileges"" , # endif # ifdef EXTSTORE [ EXT_PAGE_SIZE ] = ""ext_page_size"" , [ EXT_PAGE_COUNT ] = ""ext_page_count"" , [ EXT_WBUF_SIZE ] = ""ext_wbuf_size"" , [ EXT_THREADS ] = ""ext_threads"" , [ EXT_IO_DEPTH ] = ""ext_io_depth"" , [ EXT_PATH ] = ""ext_path"" , [ EXT_ITEM_SIZE ] = ""ext_item_size"" , [ EXT_ITEM_AGE ] = ""ext_item_age"" , [ EXT_LOW_TTL ] = ""ext_low_ttl"" , [ EXT_RECACHE_RATE ] = ""ext_recache_rate"" , [ EXT_COMPACT_UNDER ] = ""ext_compact_under"" , [ EXT_DROP_UNDER ] = ""ext_drop_under"" , [ EXT_MAX_FRAG ] = ""ext_max_frag"" , [ EXT_DROP_UNREAD ] = ""ext_drop_unread"" , [ SLAB_AUTOMOVE_FREERATIO ] = ""slab_automove_freeratio"" , # endif NULL } ; if ( ! sanitycheck ( ) ) { return EX_OSERR ; } signal ( SIGINT , sig_handler ) ; signal ( SIGTERM , sig_handler ) ; settings_init ( ) ; # ifdef EXTSTORE settings . ext_item_size = 512 ; settings . ext_item_age = UINT_MAX ; settings . ext_low_ttl = 0 ; settings . ext_recache_rate = 2000 ; settings . ext_max_frag = 0.8 ; settings . ext_drop_unread = false ; settings . ext_wbuf_size = 1024 * 1024 * 4 ; settings . ext_compact_under = 0 ; settings . ext_drop_under = 0 ; settings . slab_automove_freeratio = 0.01 ; ext_cf . page_size = 1024 * 1024 * 64 ; ext_cf . page_count = 64 ; ext_cf . wbuf_size = settings . ext_wbuf_size ; ext_cf . io_threadcount = 1 ; ext_cf . io_depth = 1 ; ext_cf . page_buckets = 4 ; ext_cf . wbuf_count = ext_cf . page_buckets ; # endif init_lru_maintainer ( ) ; setbuf ( stderr , NULL ) ; char * shortopts = ""a:"" ""A"" ""p:"" ""s:"" ""U:"" ""m:"" ""M"" ""c:"" ""k"" ""hiV"" ""r"" ""v"" ""d"" ""l:"" ""u:"" ""P:"" ""f:"" ""n:"" ""t:"" ""D:"" ""L"" ""R:"" ""C"" ""b:"" ""B:"" ""I:"" ""S"" ""F"" ""X"" ""o:"" ; # ifdef HAVE_GETOPT_LONG const struct option longopts [ ] = { { ""unix-mask"" , required_argument , 0 , 'a' } , { ""enable-shutdown"" , no_argument , 0 , 'A' } , { ""port"" , required_argument , 0 , 'p' } , { ""unix-socket"" , required_argument , 0 , 's' } , { ""udp-port"" , required_argument , 0 , 'U' } , { ""memory-limit"" , required_argument , 0 , 'm' } , { ""disable-evictions"" , no_argument , 0 , 'M' } , { ""conn-limit"" , required_argument , 0 , 'c' } , { ""lock-memory"" , no_argument , 0 , 'k' } , { ""help"" , no_argument , 0 , 'h' } , { ""license"" , no_argument , 0 , 'i' } , { ""version"" , no_argument , 0 , 'V' } , { ""enable-coredumps"" , no_argument , 0 , 'r' } , { ""verbose"" , optional_argument , 0 , 'v' } , { ""daemon"" , no_argument , 0 , 'd' } , { ""listen"" , required_argument , 0 , 'l' } , { ""user"" , required_argument , 0 , 'u' } , { ""pidfile"" , required_argument , 0 , 'P' } , { ""slab-growth-factor"" , required_argument , 0 , 'f' } , { ""slab-min-size"" , required_argument , 0 , 'n' } , { ""threads"" , required_argument , 0 , 't' } , { ""enable-largepages"" , no_argument , 0 , 'L' } , { ""max-reqs-per-event"" , required_argument , 0 , 'R' } , { ""disable-cas"" , no_argument , 0 , 'C' } , { ""listen-backlog"" , required_argument , 0 , 'b' } , { ""protocol"" , required_argument , 0 , 'B' } , { ""max-item-size"" , required_argument , 0 , 'I' } , { ""enable-sasl"" , no_argument , 0 , 'S' } , { ""disable-flush-all"" , no_argument , 0 , 'F' } , { ""disable-dumping"" , no_argument , 0 , 'X' } , { ""extended"" , required_argument , 0 , 'o' } , { 0 , 0 , 0 , 0 } } ; int optindex ; while ( - 1 != ( c = getopt_long ( argc , argv , shortopts , longopts , & optindex ) ) ) { # else while ( - 1 != ( c = getopt ( argc , argv , shortopts ) ) ) { # endif switch ( c ) { case 'A' : settings . shutdown_command = true ; break ; case 'a' : settings . access = strtol ( optarg , NULL , 8 ) ; break ; case 'U' : settings . udpport = atoi ( optarg ) ; udp_specified = true ; break ; case 'p' : settings . port = atoi ( optarg ) ; tcp_specified = true ; break ; case 's' : settings . socketpath = optarg ; break ; case 'm' : settings . maxbytes = ( ( size_t ) atoi ( optarg ) ) * 1024 * 1024 ; break ; case 'M' : settings . evict_to_free = 0 ; break ; case 'c' : settings . maxconns = atoi ( optarg ) ; if ( settings . maxconns <= 0 ) { fprintf ( stderr , ""Maximum<S2SV_blank>connections<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'h' : usage ( ) ; exit ( EXIT_SUCCESS ) ; case 'i' : usage_license ( ) ; exit ( EXIT_SUCCESS ) ; case 'V' : printf ( PACKAGE ""<S2SV_blank>"" VERSION ""\\n"" ) ; exit ( EXIT_SUCCESS ) ; case 'k' : lock_memory = true ; break ; case 'v' : settings . verbose ++ ; break ; case 'l' : if ( settings . inter != NULL ) { if ( strstr ( settings . inter , optarg ) != NULL ) { break ; } size_t len = strlen ( settings . inter ) + strlen ( optarg ) + 2 ; char * p = malloc ( len ) ; if ( p == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory\\n"" ) ; return 1 ; } snprintf ( p , len , ""%s,%s"" , settings . inter , optarg ) ; free ( settings . inter ) ; settings . inter = p ; } else { settings . inter = strdup ( optarg ) ; } break ; case 'd' : do_daemonize = true ; break ; case 'r' : maxcore = 1 ; break ; case 'R' : settings . reqs_per_event = atoi ( optarg ) ; if ( settings . reqs_per_event == 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>requests<S2SV_blank>per<S2SV_blank>event<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 'u' : username = optarg ; break ; case 'P' : pid_file = optarg ; break ; case 'f' : settings . factor = atof ( optarg ) ; if ( settings . factor <= 1.0 ) { fprintf ( stderr , ""Factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case 'n' : settings . chunk_size = atoi ( optarg ) ; if ( settings . chunk_size == 0 ) { fprintf ( stderr , ""Chunk<S2SV_blank>size<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } break ; case 't' : settings . num_threads = atoi ( optarg ) ; if ( settings . num_threads <= 0 ) { fprintf ( stderr , ""Number<S2SV_blank>of<S2SV_blank>threads<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0\\n"" ) ; return 1 ; } if ( settings . num_threads > 64 ) { fprintf ( stderr , ""WARNING:<S2SV_blank>Setting<S2SV_blank>a<S2SV_blank>high<S2SV_blank>number<S2SV_blank>of<S2SV_blank>worker"" ""threads<S2SV_blank>is<S2SV_blank>not<S2SV_blank>recommended.\\n"" ""<S2SV_blank>Set<S2SV_blank>this<S2SV_blank>value<S2SV_blank>to<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cores<S2SV_blank>in"" ""<S2SV_blank>your<S2SV_blank>machine<S2SV_blank>or<S2SV_blank>less.\\n"" ) ; } break ; case 'D' : if ( ! optarg || ! optarg [ 0 ] ) { fprintf ( stderr , ""No<S2SV_blank>delimiter<S2SV_blank>specified\\n"" ) ; return 1 ; } settings . prefix_delimiter = optarg [ 0 ] ; settings . detail_enabled = 1 ; break ; case 'L' : if ( enable_large_pages ( ) == 0 ) { preallocate = true ; } else { fprintf ( stderr , ""Cannot<S2SV_blank>enable<S2SV_blank>large<S2SV_blank>pages<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system\\n"" ""(There<S2SV_blank>is<S2SV_blank>no<S2SV_blank>Linux<S2SV_blank>support<S2SV_blank>as<S2SV_blank>of<S2SV_blank>this<S2SV_blank>version)\\n"" ) ; return 1 ; } break ; case 'C' : settings . use_cas = false ; break ; case 'b' : settings . backlog = atoi ( optarg ) ; break ; case 'B' : protocol_specified = true ; if ( strcmp ( optarg , ""auto"" ) == 0 ) { settings . binding_protocol = negotiating_prot ; } else if ( strcmp ( optarg , ""binary"" ) == 0 ) { settings . binding_protocol = binary_prot ; } else if ( strcmp ( optarg , ""ascii"" ) == 0 ) { settings . binding_protocol = ascii_prot ; } else { fprintf ( stderr , ""Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>binding<S2SV_blank>protocol:<S2SV_blank>%s\\n"" ""<S2SV_blank>--<S2SV_blank>should<S2SV_blank>be<S2SV_blank>one<S2SV_blank>of<S2SV_blank>auto,<S2SV_blank>binary,<S2SV_blank>or<S2SV_blank>ascii\\n"" , optarg ) ; exit ( EX_USAGE ) ; } break ; case 'I' : buf = strdup ( optarg ) ; unit = buf [ strlen ( buf ) - 1 ] ; if ( unit == 'k' || unit == 'm' || unit == 'K' || unit == 'M' ) { buf [ strlen ( buf ) - 1 ] = '\\0' ; size_max = atoi ( buf ) ; if ( unit == 'k' || unit == 'K' ) size_max *= 1024 ; if ( unit == 'm' || unit == 'M' ) size_max *= 1024 * 1024 ; settings . item_size_max = size_max ; } else { settings . item_size_max = atoi ( buf ) ; } free ( buf ) ; break ; case 'S' : # ifndef ENABLE_SASL fprintf ( stderr , ""This<S2SV_blank>server<S2SV_blank>is<S2SV_blank>not<S2SV_blank>built<S2SV_blank>with<S2SV_blank>SASL<S2SV_blank>support.\\n"" ) ; exit ( EX_USAGE ) ; # endif settings . sasl = true ; break ; case 'F' : settings . flush_enabled = false ; break ; case 'X' : settings . dump_enabled = false ; break ; case 'o' : subopts_orig = subopts = strdup ( optarg ) ; while ( * subopts != '\\0' ) { switch ( getsubopt ( & subopts , subopts_tokens , & subopts_value ) ) { case MAXCONNS_FAST : settings . maxconns_fast = true ; break ; case HASHPOWER_INIT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>hashpower\\n"" ) ; return 1 ; } settings . hashpower_init = atoi ( subopts_value ) ; if ( settings . hashpower_init < 12 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low\\n"" , settings . hashpower_init ) ; return 1 ; } else if ( settings . hashpower_init > 32 ) { fprintf ( stderr , ""Initial<S2SV_blank>hashtable<S2SV_blank>multiplier<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>high\\n"" ""Choose<S2SV_blank>a<S2SV_blank>value<S2SV_blank>based<S2SV_blank>on<S2SV_blank>\\""STAT<S2SV_blank>hash_power_level\\""<S2SV_blank>from<S2SV_blank>a<S2SV_blank>running<S2SV_blank>instance\\n"" , settings . hashpower_init ) ; return 1 ; } break ; case NO_HASHEXPAND : start_assoc_maint = false ; break ; case SLAB_REASSIGN : settings . slab_reassign = true ; break ; case SLAB_AUTOMOVE : if ( subopts_value == NULL ) { settings . slab_automove = 1 ; break ; } settings . slab_automove = atoi ( subopts_value ) ; if ( settings . slab_automove < 0 || settings . slab_automove > 2 ) { fprintf ( stderr , ""slab_automove<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>2\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_RATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_ratio<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_ratio = atof ( subopts_value ) ; if ( settings . slab_automove_ratio <= 0 || settings . slab_automove_ratio > 1 ) { fprintf ( stderr , ""slab_automove_ratio<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0<S2SV_blank>and<S2SV_blank><<S2SV_blank>1\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_WINDOW : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_window<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . slab_automove_window = atoi ( subopts_value ) ; if ( settings . slab_automove_window < 3 ) { fprintf ( stderr , ""slab_automove_window<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>2\\n"" ) ; return 1 ; } break ; case TAIL_REPAIR_TIME : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>tail_repair_time\\n"" ) ; return 1 ; } settings . tail_repair_time = atoi ( subopts_value ) ; if ( settings . tail_repair_time < 10 ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>tail_repair_time<S2SV_blank>to<S2SV_blank>less<S2SV_blank>than<S2SV_blank>10<S2SV_blank>seconds\\n"" ) ; return 1 ; } break ; case HASH_ALGORITHM : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hash_algorithm<S2SV_blank>argument\\n"" ) ; return 1 ; } ; if ( strcmp ( subopts_value , ""jenkins"" ) == 0 ) { hash_type = JENKINS_HASH ; } else if ( strcmp ( subopts_value , ""murmur3"" ) == 0 ) { hash_type = MURMUR3_HASH ; } else { fprintf ( stderr , ""Unknown<S2SV_blank>hash_algorithm<S2SV_blank>option<S2SV_blank>(jenkins,<S2SV_blank>murmur3)\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER : start_lru_crawler = true ; break ; case LRU_CRAWLER_SLEEP : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_sleep<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_sleep = atoi ( subopts_value ) ; if ( settings . lru_crawler_sleep > 1000000 || settings . lru_crawler_sleep < 0 ) { fprintf ( stderr , ""LRU<S2SV_blank>crawler<S2SV_blank>sleep<S2SV_blank>must<S2SV_blank>be<S2SV_blank>between<S2SV_blank>0<S2SV_blank>and<S2SV_blank>1<S2SV_blank>second\\n"" ) ; return 1 ; } break ; case LRU_CRAWLER_TOCRAWL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>lru_crawler_tocrawl<S2SV_blank>value\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & tocrawl ) ) { fprintf ( stderr , ""lru_crawler_tocrawl<S2SV_blank>takes<S2SV_blank>a<S2SV_blank>numeric<S2SV_blank>32bit<S2SV_blank>value\\n"" ) ; return 1 ; } settings . lru_crawler_tocrawl = tocrawl ; break ; case LRU_MAINTAINER : start_lru_maintainer = true ; settings . lru_segmented = true ; break ; case HOT_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_lru_pct = atoi ( subopts_value ) ; if ( settings . hot_lru_pct < 1 || settings . hot_lru_pct >= 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case WARM_LRU_PCT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_lru_pct<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_lru_pct = atoi ( subopts_value ) ; if ( settings . warm_lru_pct < 1 || settings . warm_lru_pct >= 80 ) { fprintf ( stderr , ""warm_lru_pct<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>1<S2SV_blank>and<S2SV_blank><<S2SV_blank>80\\n"" ) ; return 1 ; } break ; case HOT_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>hot_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . hot_max_factor = atof ( subopts_value ) ; if ( settings . hot_max_factor <= 0 ) { fprintf ( stderr , ""hot_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case WARM_MAX_FACTOR : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>warm_max_factor<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . warm_max_factor = atof ( subopts_value ) ; if ( settings . warm_max_factor <= 0 ) { fprintf ( stderr , ""warm_max_factor<S2SV_blank>must<S2SV_blank>be<S2SV_blank>><S2SV_blank>0\\n"" ) ; return 1 ; } break ; case TEMPORARY_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>temporary_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } settings . temp_lru = true ; settings . temporary_ttl = atoi ( subopts_value ) ; break ; case IDLE_TIMEOUT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>numeric<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>idle_timeout\\n"" ) ; return 1 ; } settings . idle_timeout = atoi ( subopts_value ) ; break ; case WATCHER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>watcher_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_watcher_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>watcher_logbuf_size\\n"" ) ; return 1 ; } settings . logger_watcher_buf_size *= 1024 ; break ; case WORKER_LOGBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>worker_logbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . logger_buf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>worker_logbuf_size\\n"" ) ; return 1 ; } settings . logger_buf_size *= 1024 ; case SLAB_SIZES : slab_sizes_unparsed = subopts_value ; break ; case SLAB_CHUNK_MAX : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_chunk_max<S2SV_blank>argument\\n"" ) ; } if ( ! safe_strtol ( subopts_value , & settings . slab_chunk_size_max ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_chunk_max\\n"" ) ; } slab_chunk_size_changed = true ; break ; case TRACK_SIZES : item_stats_sizes_init ( ) ; break ; case NO_INLINE_ASCII_RESP : settings . inline_ascii_response = false ; break ; case INLINE_ASCII_RESP : settings . inline_ascii_response = true ; break ; case NO_CHUNKED_ITEMS : settings . slab_chunk_size_max = settings . slab_page_size ; break ; case NO_SLAB_REASSIGN : settings . slab_reassign = false ; break ; case NO_SLAB_AUTOMOVE : settings . slab_automove = 0 ; break ; case NO_MAXCONNS_FAST : settings . maxconns_fast = false ; break ; case NO_LRU_CRAWLER : settings . lru_crawler = false ; start_lru_crawler = false ; break ; case NO_LRU_MAINTAINER : start_lru_maintainer = false ; settings . lru_segmented = false ; break ; # ifdef EXTSTORE case EXT_PAGE_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_size\\n"" ) ; return 1 ; } ext_cf . page_size *= 1024 * 1024 ; break ; case EXT_PAGE_COUNT : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_page_count<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . page_count ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_page_count\\n"" ) ; return 1 ; } break ; case EXT_WBUF_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_wbuf_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . wbuf_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_wbuf_size\\n"" ) ; return 1 ; } ext_cf . wbuf_size *= 1024 * 1024 ; settings . ext_wbuf_size = ext_cf . wbuf_size ; break ; case EXT_THREADS : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_threads<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_threadcount ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_threads\\n"" ) ; return 1 ; } break ; case EXT_IO_DEPTH : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_io_depth<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & ext_cf . io_depth ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_io_depth\\n"" ) ; return 1 ; } break ; case EXT_ITEM_SIZE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_size<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_size ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_size\\n"" ) ; return 1 ; } break ; case EXT_ITEM_AGE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_item_age<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_item_age ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_item_age\\n"" ) ; return 1 ; } break ; case EXT_LOW_TTL : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_low_ttl<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_low_ttl ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_low_ttl\\n"" ) ; return 1 ; } break ; case EXT_RECACHE_RATE : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_recache_rate<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_recache_rate ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_recache_rate\\n"" ) ; return 1 ; } break ; case EXT_COMPACT_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_compact_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_compact_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_compact_under\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNDER : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_drop_under<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtoul ( subopts_value , & settings . ext_drop_under ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_drop_under\\n"" ) ; return 1 ; } break ; case EXT_MAX_FRAG : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>ext_max_frag<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . ext_max_frag ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>ext_max_frag\\n"" ) ; return 1 ; } break ; case SLAB_AUTOMOVE_FREERATIO : if ( subopts_value == NULL ) { fprintf ( stderr , ""Missing<S2SV_blank>slab_automove_freeratio<S2SV_blank>argument\\n"" ) ; return 1 ; } if ( ! safe_strtod ( subopts_value , & settings . slab_automove_freeratio ) ) { fprintf ( stderr , ""could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>slab_automove_freeratio\\n"" ) ; return 1 ; } break ; case EXT_DROP_UNREAD : settings . ext_drop_unread = true ; break ; case EXT_PATH : storage_file = strdup ( subopts_value ) ; break ; # endif case MODERN : break ; case NO_MODERN : if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size ; } settings . slab_reassign = false ; settings . slab_automove = 0 ; settings . maxconns_fast = false ; settings . inline_ascii_response = true ; settings . lru_segmented = false ; hash_type = JENKINS_HASH ; start_lru_crawler = false ; start_lru_maintainer = false ; break ; case NO_DROP_PRIVILEGES : settings . drop_privileges = false ; break ; # ifdef MEMCACHED_DEBUG case RELAXED_PRIVILEGES : settings . relaxed_privileges = true ; break ; # endif default : printf ( ""Illegal<S2SV_blank>suboption<S2SV_blank>\\""%s\\""\\n"" , subopts_value ) ; return 1 ; } } free ( subopts_orig ) ; break ; default : fprintf ( stderr , ""Illegal<S2SV_blank>argument<S2SV_blank>\\""%c\\""\\n"" , c ) ; return 1 ; } } if ( settings . item_size_max < 1024 ) { fprintf ( stderr , ""Item<S2SV_blank>max<S2SV_blank>size<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>less<S2SV_blank>than<S2SV_blank>1024<S2SV_blank>bytes.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( settings . maxbytes / 2 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>1/2<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>max.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > ( 1024 * 1024 * 1024 ) ) { fprintf ( stderr , ""Cannot<S2SV_blank>set<S2SV_blank>item<S2SV_blank>size<S2SV_blank>limit<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>a<S2SV_blank>gigabyte.\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max > 1024 * 1024 ) { if ( ! slab_chunk_size_changed ) { settings . slab_chunk_size_max = settings . slab_page_size / 2 ; } } if ( settings . slab_chunk_size_max > settings . item_size_max ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>-I<S2SV_blank>(item_size_max<S2SV_blank>%d)\\n"" , settings . slab_chunk_size_max , settings . item_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . item_size_max % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>be<S2SV_blank>evenly<S2SV_blank>divisible<S2SV_blank>by<S2SV_blank>slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)\\n"" , settings . item_size_max , settings . slab_chunk_size_max ) ; exit ( EX_USAGE ) ; } if ( settings . slab_page_size % settings . slab_chunk_size_max != 0 ) { fprintf ( stderr , ""slab_chunk_max<S2SV_blank>(bytes:<S2SV_blank>%d)<S2SV_blank>must<S2SV_blank>divide<S2SV_blank>evenly<S2SV_blank>into<S2SV_blank>%d<S2SV_blank>(slab_page_size)\\n"" , settings . slab_chunk_size_max , settings . slab_page_size ) ; exit ( EX_USAGE ) ; } # ifdef EXTSTORE if ( storage_file ) { if ( settings . item_size_max > ext_cf . wbuf_size ) { fprintf ( stderr , ""-I<S2SV_blank>(item_size_max:<S2SV_blank>%d)<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>ext_wbuf_size:<S2SV_blank>%d\\n"" , settings . item_size_max , ext_cf . wbuf_size ) ; exit ( EX_USAGE ) ; } if ( settings . inline_ascii_response ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>inline_ascii_response<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . udpport ) { fprintf ( stderr , ""Cannot<S2SV_blank>use<S2SV_blank>UDP<S2SV_blank>with<S2SV_blank>extstore<S2SV_blank>enabled<S2SV_blank>(-U<S2SV_blank>0<S2SV_blank>to<S2SV_blank>disable)\\n"" ) ; exit ( EX_USAGE ) ; } } # endif if ( slab_sizes_unparsed != NULL ) { if ( _parse_slab_sizes ( slab_sizes_unparsed , slab_sizes ) ) { use_slab_sizes = true ; } else { exit ( EX_USAGE ) ; } } if ( settings . hot_lru_pct + settings . warm_lru_pct > 80 ) { fprintf ( stderr , ""hot_lru_pct<S2SV_blank>+<S2SV_blank>warm_lru_pct<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>more<S2SV_blank>than<S2SV_blank>80%%<S2SV_blank>combined\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . temp_lru && ! start_lru_maintainer ) { fprintf ( stderr , ""temporary_ttl<S2SV_blank>requires<S2SV_blank>lru_maintainer<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; exit ( EX_USAGE ) ; } if ( hash_init ( hash_type ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>hash_algorithm!\\n"" ) ; exit ( EX_USAGE ) ; } if ( settings . inter != NULL && strchr ( settings . inter , ',' ) ) { settings . num_threads_per_udp = 1 ; } else { settings . num_threads_per_udp = settings . num_threads ; } if ( settings . sasl ) { if ( ! protocol_specified ) { settings . binding_protocol = binary_prot ; } else { if ( settings . binding_protocol != binary_prot ) { fprintf ( stderr , ""ERROR:<S2SV_blank>You<S2SV_blank>cannot<S2SV_blank>allow<S2SV_blank>the<S2SV_blank>ASCII<S2SV_blank>protocol<S2SV_blank>while<S2SV_blank>using<S2SV_blank>SASL.\\n"" ) ; exit ( EX_USAGE ) ; } } } <S2SV_StartBug> if ( tcp_specified && settings . port != 0 && ! udp_specified ) { <S2SV_EndBug> settings . udpport = settings . port ; } else if ( udp_specified && settings . udpport != 0 && ! tcp_specified ) { settings . port = settings . udpport ; } if ( maxcore != 0 ) { struct rlimit rlim_new ; if ( getrlimit ( RLIMIT_CORE , & rlim ) == 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = RLIM_INFINITY ; if ( setrlimit ( RLIMIT_CORE , & rlim_new ) != 0 ) { rlim_new . rlim_cur = rlim_new . rlim_max = rlim . rlim_max ; ( void ) setrlimit ( RLIMIT_CORE , & rlim_new ) ; } } if ( ( getrlimit ( RLIMIT_CORE , & rlim ) != 0 ) || rlim . rlim_cur == 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>corefile<S2SV_blank>creation\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>getrlimit<S2SV_blank>number<S2SV_blank>of<S2SV_blank>files\\n"" ) ; exit ( EX_OSERR ) ; } else { rlim . rlim_cur = settings . maxconns ; rlim . rlim_max = settings . maxconns ; if ( setrlimit ( RLIMIT_NOFILE , & rlim ) != 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>rlimit<S2SV_blank>for<S2SV_blank>open<S2SV_blank>files.<S2SV_blank>Try<S2SV_blank>starting<S2SV_blank>as<S2SV_blank>root<S2SV_blank>or<S2SV_blank>requesting<S2SV_blank>smaller<S2SV_blank>maxconns<S2SV_blank>value.\\n"" ) ; exit ( EX_OSERR ) ; } } if ( getuid ( ) == 0 || geteuid ( ) == 0 ) { if ( username == 0 || * username == '\\0' ) { fprintf ( stderr , ""can\'t<S2SV_blank>run<S2SV_blank>as<S2SV_blank>root<S2SV_blank>without<S2SV_blank>the<S2SV_blank>-u<S2SV_blank>switch\\n"" ) ; exit ( EX_USAGE ) ; } if ( ( pw = getpwnam ( username ) ) == 0 ) { fprintf ( stderr , ""can\'t<S2SV_blank>find<S2SV_blank>the<S2SV_blank>user<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to\\n"" , username ) ; exit ( EX_NOUSER ) ; } if ( setgid ( pw -> pw_gid ) < 0 || setuid ( pw -> pw_uid ) < 0 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>assume<S2SV_blank>identity<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%s\\n"" , username ) ; exit ( EX_OSERR ) ; } } if ( settings . sasl ) { init_sasl ( ) ; } if ( do_daemonize ) { if ( sigignore ( SIGHUP ) == - 1 ) { perror ( ""Failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGHUP"" ) ; } if ( daemonize ( maxcore , settings . verbose ) == - 1 ) { fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>daemon()<S2SV_blank>in<S2SV_blank>order<S2SV_blank>to<S2SV_blank>daemonize\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( lock_memory ) { # ifdef HAVE_MLOCKALL int res = mlockall ( MCL_CURRENT | MCL_FUTURE ) ; if ( res != 0 ) { fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; } # else fprintf ( stderr , ""warning:<S2SV_blank>-k<S2SV_blank>invalid,<S2SV_blank>mlockall()<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>on<S2SV_blank>this<S2SV_blank>platform.<S2SV_blank><S2SV_blank>proceeding<S2SV_blank>without.\\n"" ) ; # endif } # if defined ( LIBEVENT_VERSION_NUMBER ) && LIBEVENT_VERSION_NUMBER >= 0x02000101 struct event_config * ev_config ; ev_config = event_config_new ( ) ; event_config_set_flag ( ev_config , EVENT_BASE_FLAG_NOLOCK ) ; main_base = event_base_new_with_config ( ev_config ) ; event_config_free ( ev_config ) ; # else main_base = event_init ( ) ; # endif logger_init ( ) ; stats_init ( ) ; assoc_init ( settings . hashpower_init ) ; conn_init ( ) ; slabs_init ( settings . maxbytes , settings . factor , preallocate , use_slab_sizes ? slab_sizes : NULL ) ; # ifdef EXTSTORE if ( storage_file ) { enum extstore_res eres ; if ( settings . ext_compact_under == 0 ) { settings . ext_compact_under = ext_cf . page_count / 4 ; settings . ext_drop_under = ext_cf . page_count / 4 ; } crc32c_init ( ) ; for ( int x = 0 ; x < MAX_NUMBER_OF_SLAB_CLASSES ; x ++ ) { settings . ext_free_memchunks [ x ] = 0 ; } storage = extstore_init ( storage_file , & ext_cf , & eres ) ; if ( storage == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>external<S2SV_blank>storage:<S2SV_blank>%s\\n"" , extstore_err ( eres ) ) ; if ( eres == EXTSTORE_INIT_OPEN_FAIL ) { perror ( ""extstore<S2SV_blank>open"" ) ; } exit ( EXIT_FAILURE ) ; } ext_storage = storage ; slabs_prefill_global ( ) ; } # endif if ( sigignore ( SIGPIPE ) == - 1 ) { perror ( ""failed<S2SV_blank>to<S2SV_blank>ignore<S2SV_blank>SIGPIPE;<S2SV_blank>sigaction"" ) ; exit ( EX_OSERR ) ; } # ifdef EXTSTORE slabs_set_storage ( storage ) ; memcached_thread_init ( settings . num_threads , storage ) ; init_lru_crawler ( storage ) ; # else memcached_thread_init ( settings . num_threads , NULL ) ; init_lru_crawler ( NULL ) ; # endif if ( start_assoc_maint && start_assoc_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( start_lru_crawler && start_item_crawler_thread ( ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>crawler<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } # ifdef EXTSTORE if ( storage && start_storage_compact_thread ( storage ) != 0 ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>storage<S2SV_blank>compaction<S2SV_blank>thread\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( start_lru_maintainer && start_lru_maintainer_thread ( storage ) != 0 ) { # else if ( start_lru_maintainer && start_lru_maintainer_thread ( NULL ) != 0 ) { # endif fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>LRU<S2SV_blank>maintainer<S2SV_blank>thread\\n"" ) ; return 1 ; } if ( settings . slab_reassign && start_slab_maintenance_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } if ( settings . idle_timeout && start_conn_timeout_thread ( ) == - 1 ) { exit ( EXIT_FAILURE ) ; } clock_handler ( 0 , 0 , 0 ) ; if ( settings . socketpath != NULL ) { errno = 0 ; if ( server_socket_unix ( settings . socketpath , settings . access ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UNIX<S2SV_blank>socket:<S2SV_blank>%s"" , settings . socketpath ) ; exit ( EX_OSERR ) ; } } if ( settings . socketpath == NULL ) { const char * portnumber_filename = getenv ( ""MEMCACHED_PORT_FILENAME"" ) ; char * temp_portnumber_filename = NULL ; size_t len ; FILE * portnumber_file = NULL ; if ( portnumber_filename != NULL ) { len = strlen ( portnumber_filename ) + 4 + 1 ; temp_portnumber_filename = malloc ( len ) ; snprintf ( temp_portnumber_filename , len , ""%s.lck"" , portnumber_filename ) ; portnumber_file = fopen ( temp_portnumber_filename , ""a"" ) ; if ( portnumber_file == NULL ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , temp_portnumber_filename , strerror ( errno ) ) ; } } errno = 0 ; if ( settings . port && server_sockets ( settings . port , tcp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>TCP<S2SV_blank>port<S2SV_blank>%d"" , settings . port ) ; exit ( EX_OSERR ) ; } errno = 0 ; if ( settings . udpport && server_sockets ( settings . udpport , udp_transport , portnumber_file ) ) { vperror ( ""failed<S2SV_blank>to<S2SV_blank>listen<S2SV_blank>on<S2SV_blank>UDP<S2SV_blank>port<S2SV_blank>%d"" , settings . udpport ) ; exit ( EX_OSERR ) ; } if ( portnumber_file ) { fclose ( portnumber_file ) ; rename ( temp_portnumber_filename , portnumber_filename ) ; } if ( temp_portnumber_filename ) free ( temp_portnumber_filename ) ; } usleep ( 1000 ) ; if ( stats_state . curr_conns + stats_state . reserved_fds >= settings . maxconns - 1 ) { fprintf ( stderr , ""Maxconns<S2SV_blank>setting<S2SV_blank>is<S2SV_blank>too<S2SV_blank>low,<S2SV_blank>use<S2SV_blank>-c<S2SV_blank>to<S2SV_blank>increase.\\n"" ) ; exit ( EXIT_FAILURE ) ; } if ( pid_file != NULL ) { save_pid ( pid_file ) ; } if ( settings . drop_privileges ) { drop_privileges ( ) ; } uriencode_init ( ) ; if ( event_base_loop ( main_base , 0 ) != 0 ) { retval = EXIT_FAILURE ; } stop_assoc_maintenance_thread ( ) ; if ( do_daemonize ) remove_pidfile ( pid_file ) ; if ( settings . inter ) free ( settings . inter ) ; if ( l_socket ) free ( l_socket ) ; if ( u_socket ) free ( u_socket ) ; event_base_free ( main_base ) ; return retval ; }
","<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
",memcached@memcached/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,CVE-2018-1000115,https://github.com/memcached/memcached/commit/dbb7a8af90054bf4ef51f5814ef7ceb17d83d974,2018-03-05T14:29Z
CWE-119,"CWE-119 void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) <S2SV_EndBug> vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
","<S2SV_ModStart> < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-772,"CWE-772 generic_ret * rename_principal_2_svc ( rprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; <S2SV_StartBug> char * prime_arg1 , <S2SV_EndBug> * prime_arg2 ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; size_t tlen1 , tlen2 , clen , slen ; char * tdots1 , * tdots2 , * cdots , * sdots ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> src , & prime_arg1 ) || krb5_unparse_name ( handle -> context , arg -> dest , & prime_arg2 ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } tlen1 = strlen ( prime_arg1 ) ; trunc_name ( & tlen1 , & tdots1 ) ; tlen2 = strlen ( prime_arg2 ) ; trunc_name ( & tlen2 , & tdots2 ) ; clen = client_name . length ; trunc_name ( & clen , & cdots ) ; slen = service_name . length ; trunc_name ( & slen , & sdots ) ; ret . code = KADM5_OK ; if ( ! CHANGEPW_SERVICE ( rqstp ) ) { if ( ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> src , NULL ) ) ret . code = KADM5_AUTH_DELETE ; if ( ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> dest , & rp ) || rp ) { if ( ret . code == KADM5_AUTH_DELETE ) ret . code = KADM5_AUTH_INSUFFICIENT ; else ret . code = KADM5_AUTH_ADD ; } } else ret . code = KADM5_AUTH_INSUFFICIENT ; if ( ret . code != KADM5_OK ) { krb5_klog_syslog ( LOG_NOTICE , _ ( ""Unauthorized<S2SV_blank>request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ; } else { ret . code = kadm5_rename_principal ( ( void * ) handle , arg -> src , arg -> dest ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; krb5_klog_syslog ( LOG_NOTICE , _ ( ""Request:<S2SV_blank>kadm5_rename_principal,<S2SV_blank>"" ""%.*s%s<S2SV_blank>to<S2SV_blank>%.*s%s,<S2SV_blank>%s,<S2SV_blank>"" ""client=%.*s%s,<S2SV_blank>service=%.*s%s,<S2SV_blank>addr=%s"" ) , ( int ) tlen1 , prime_arg1 , tdots1 , ( int ) tlen2 , prime_arg2 , tdots2 , errmsg ? errmsg : _ ( ""success"" ) , ( int ) clen , ( char * ) client_name . value , cdots , ( int ) slen , ( char * ) service_name . value , sdots , client_addr ( rqstp -> rq_xprt ) ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> free ( prime_arg1 ) ; <S2SV_EndBug> free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> char * prime_arg1 = NULL , * prime_arg2 = NULL <S2SV_ModEnd> ; gss_buffer_desc client_name <S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-200,"CWE-200 int equalizer_get_parameter ( effect_context_t * context , effect_param_t * p , uint32_t * size ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t param2 ; char * name ; void * value = p -> data + voffset ; int i ; ALOGV ( ""%s"" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : case EQ_PARAM_CUR_PRESET : case EQ_PARAM_GET_NUM_OF_PRESETS : case EQ_PARAM_BAND_LEVEL : case EQ_PARAM_GET_BAND : if ( p -> vsize < sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int16_t ) ; break ; case EQ_PARAM_LEVEL_RANGE : if ( p -> vsize < 2 * sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int16_t ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : if ( p -> vsize < 2 * sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int32_t ) ; break ; case EQ_PARAM_CENTER_FREQ : if ( p -> vsize < sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int32_t ) ; break ; case EQ_PARAM_GET_PRESET_NAME : break ; case EQ_PARAM_PROPERTIES : if ( p -> vsize < ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ) p -> status = - EINVAL ; p -> vsize = ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ; break ; default : p -> status = - EINVAL ; } * size = sizeof ( effect_param_t ) + voffset + p -> vsize ; if ( p -> status != 0 ) return 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_NUM_BANDS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) NUM_EQ_BANDS ; break ; case EQ_PARAM_LEVEL_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_LEVEL_RANGE"" , __func__ ) ; * ( int16_t * ) value = - 1500 ; * ( ( int16_t * ) value + 1 ) = 1500 ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_LEVEL"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int16_t * ) value = ( int16_t ) equalizer_get_band_level ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CENTER_FREQ : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CENTER_FREQ"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> break ; } equalizer_get_band_freq_range ( eq_ctxt , param2 , ( uint32_t * ) value , ( ( uint32_t * ) value + 1 ) ) ; break ; case EQ_PARAM_GET_BAND : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_BAND"" , __func__ ) ; param2 = * param_tmp ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_band ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CUR_PRESET : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CUR_PRESET"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_preset ( eq_ctxt ) ; break ; case EQ_PARAM_GET_NUM_OF_PRESETS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_NUM_OF_PRESETS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_num_presets ( eq_ctxt ) ; break ; case EQ_PARAM_GET_PRESET_NAME : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_PRESET_NAME"" , __func__ ) ; param2 = * param_tmp ; ALOGV ( ""param2:<S2SV_blank>%d"" , param2 ) ; if ( param2 >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } name = ( char * ) value ; strlcpy ( name , equalizer_get_preset_name ( eq_ctxt , param2 ) , p -> vsize - 1 ) ; name [ p -> vsize - 1 ] = 0 ; p -> vsize = strlen ( name ) + 1 ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_PROPERTIES"" , __func__ ) ; int16_t * prop = ( int16_t * ) value ; prop [ 0 ] = ( int16_t ) equalizer_get_preset ( eq_ctxt ) ; prop [ 1 ] = ( int16_t ) NUM_EQ_BANDS ; for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { prop [ 2 + i ] = ( int16_t ) equalizer_get_band_level ( eq_ctxt , i ) ; } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
","<S2SV_ModStart> if ( param2 < 0 || param2 <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; }
",hardware@qcom@audio/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,CVE-2017-0402,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,2017-01-12T20:59Z
CWE-787,"CWE-787 static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n"" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , ""File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported."" ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
","<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
",uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z
CWE-119,"CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; <S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free
",ckolivas@cgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4501,https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
CWE-319,"CWE-319 static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
","<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
",torvalds@linux/574823bfab82d9d8fa47f422778043fbb4b4f50e,CVE-2019-5489,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,2019-01-07T17:29Z
CWE-834,"CWE-834 static int mxf_read_index_entry_array ( AVIOContext * pb , MXFIndexTableSegment * segment ) { int i , length ; segment -> nb_index_entries = avio_rb32 ( pb ) ; length = avio_rb32 ( pb ) ; <S2SV_StartBug> if ( ! ( segment -> temporal_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> temporal_offset_entries ) ) ) || <S2SV_EndBug> ! ( segment -> flag_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> flag_entries ) ) ) || ! ( segment -> stream_offset_entries = av_calloc ( segment -> nb_index_entries , sizeof ( * segment -> stream_offset_entries ) ) ) ) { av_freep ( & segment -> temporal_offset_entries ) ; av_freep ( & segment -> flag_entries ) ; return AVERROR ( ENOMEM ) ; } <S2SV_StartBug> for ( i = 0 ; i < segment -> nb_index_entries ; i ++ ) { <S2SV_EndBug> segment -> temporal_offset_entries [ i ] = avio_r8 ( pb ) ; avio_r8 ( pb ) ; segment -> flag_entries [ i ] = avio_r8 ( pb ) ; segment -> stream_offset_entries [ i ] = avio_rb64 ( pb ) ; avio_skip ( pb , length - 11 ) ; } return 0 ; }
","<S2SV_ModStart> ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
",FFmpeg@FFmpeg/900f39692ca0337a98a7cf047e4e2611071810c2,CVE-2017-14170,https://github.com/FFmpeg/FFmpeg/commit/900f39692ca0337a98a7cf047e4e2611071810c2,2017-09-07T06:29Z
CWE-190,"CWE-190 <S2SV_StartBug> void * zrealloc ( void * ptr , size_t size ) { <S2SV_EndBug> # ifndef HAVE_MALLOC_SIZE void * realptr ; # endif size_t oldsize ; void * newptr ; if ( size == 0 && ptr != NULL ) { zfree ( ptr ) ; return NULL ; } if ( ptr == NULL ) return zmalloc ( size ) ; # ifdef HAVE_MALLOC_SIZE oldsize = zmalloc_size ( ptr ) ; newptr = realloc ( ptr , size ) ; if ( ! newptr ) zmalloc_oom_handler ( size ) ; update_zmalloc_stat_free ( oldsize ) ; update_zmalloc_stat_alloc ( zmalloc_size ( newptr ) ) ; return newptr ; # else realptr = ( char * ) ptr - PREFIX_SIZE ; oldsize = * ( ( size_t * ) realptr ) ; newptr = realloc ( realptr , size + PREFIX_SIZE ) ; if ( ! newptr ) zmalloc_oom_handler ( size ) ; * ( ( size_t * ) newptr ) = size ; update_zmalloc_stat_free ( oldsize + PREFIX_SIZE ) ; update_zmalloc_stat_alloc ( size + PREFIX_SIZE ) ; return ( char * ) newptr + PREFIX_SIZE ; # endif }
","<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
",redis@redis/c992857618db99776917f10bf4f2345a5fdc78b0,CVE-2021-21309,https://github.com/redis/redis/commit/c992857618db99776917f10bf4f2345a5fdc78b0,2021-02-26T22:15Z
CWE-119,"CWE-119 static int read_compressed_header ( VP9Decoder * pbi , const uint8_t * data , size_t partition_size ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> vp9_reader r ; int k ; <S2SV_StartBug> if ( vp9_reader_init ( & r , data , partition_size ) ) <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>bool<S2SV_blank>decoder<S2SV_blank>0"" ) ; cm -> tx_mode = xd -> lossless ? ONLY_4X4 : read_tx_mode ( & r ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) read_tx_mode_probs ( & fc -> tx_probs , & r ) ; read_coef_probs ( fc , cm -> tx_mode , & r ) ; for ( k = 0 ; k < SKIP_CONTEXTS ; ++ k ) vp9_diff_update_prob ( & r , & fc -> skip_probs [ k ] ) ; if ( ! frame_is_intra_only ( cm ) ) { nmv_context * const nmvc = & fc -> nmvc ; int i , j ; read_inter_mode_probs ( fc , & r ) ; if ( cm -> interp_filter == SWITCHABLE ) read_switchable_interp_probs ( fc , & r ) ; for ( i = 0 ; i < INTRA_INTER_CONTEXTS ; i ++ ) vp9_diff_update_prob ( & r , & fc -> intra_inter_prob [ i ] ) ; cm -> reference_mode = read_frame_reference_mode ( cm , & r ) ; if ( cm -> reference_mode != SINGLE_REFERENCE ) setup_compound_reference_mode ( cm ) ; read_frame_reference_mode_probs ( cm , & r ) ; for ( j = 0 ; j < BLOCK_SIZE_GROUPS ; j ++ ) for ( i = 0 ; i < INTRA_MODES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> y_mode_prob [ j ] [ i ] ) ; for ( j = 0 ; j < PARTITION_CONTEXTS ; ++ j ) for ( i = 0 ; i < PARTITION_TYPES - 1 ; ++ i ) vp9_diff_update_prob ( & r , & fc -> partition_prob [ j ] [ i ] ) ; read_mv_probs ( nmvc , cm -> allow_high_precision_mv , & r ) ; } <S2SV_StartBug> return vp9_reader_has_error ( & r ) ; <S2SV_EndBug> }
","<S2SV_ModStart> const fc = cm -> fc ; vpx_reader <S2SV_ModEnd> r ; int <S2SV_ModStart> ; if ( vpx_reader_init <S2SV_ModEnd> ( & r <S2SV_ModStart> data , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> ; } return vpx_reader_has_error <S2SV_ModEnd> ( & r
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( numrows < 0 || numcols < 0 ) { <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_StartBug> return 0 ; <S2SV_EndBug> } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; <S2SV_StartBug> matrix -> datasize_ = numrows * numcols ; <S2SV_EndBug> if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { <S2SV_StartBug> jas_matrix_destroy ( matrix ) ; <S2SV_EndBug> return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> 0 ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } matrix <S2SV_ModStart> -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
",mdadams@jasper/988f8365f7d8ad8073b6786e433d34c553ecf568,CVE-2016-10249,https://github.com/mdadams/jasper/commit/988f8365f7d8ad8073b6786e433d34c553ecf568,2017-03-15T14:59Z
CWE-125,"CWE-125 matvar_t * Mat_VarReadNextInfo4 ( mat_t * mat ) { int M , O , data_type , class_type ; mat_int32_t tmp ; long nBytes ; size_t readresult ; matvar_t * matvar = NULL ; union { mat_uint32_t u ; mat_uint8_t c [ 4 ] ; } endian ; if ( mat == NULL || mat -> fp == NULL ) return NULL ; else if ( NULL == ( matvar = Mat_VarCalloc ( ) ) ) return NULL ; readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } endian . u = 0x01020304 ; if ( tmp < 0 || tmp > 4052 ) { if ( Mat_int32Swap ( & tmp ) > 4052 ) { Mat_VarFree ( matvar ) ; return NULL ; } } M = ( int ) floor ( tmp / 1000.0 ) ; switch ( M ) { case 0 : mat -> byteswap = endian . c [ 0 ] != 4 ; break ; case 1 : mat -> byteswap = endian . c [ 0 ] != 1 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= M * 1000 ; O = ( int ) floor ( tmp / 100.0 ) ; if ( 0 != O ) { Mat_VarFree ( matvar ) ; return NULL ; } tmp -= O * 100 ; data_type = ( int ) floor ( tmp / 10.0 ) ; switch ( data_type ) { case 0 : matvar -> data_type = MAT_T_DOUBLE ; break ; case 1 : matvar -> data_type = MAT_T_SINGLE ; break ; case 2 : matvar -> data_type = MAT_T_INT32 ; break ; case 3 : matvar -> data_type = MAT_T_INT16 ; break ; case 4 : matvar -> data_type = MAT_T_UINT16 ; break ; case 5 : matvar -> data_type = MAT_T_UINT8 ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } tmp -= data_type * 10 ; class_type = ( int ) floor ( tmp / 1.0 ) ; switch ( class_type ) { case 0 : matvar -> class_type = MAT_C_DOUBLE ; break ; case 1 : matvar -> class_type = MAT_C_CHAR ; break ; case 2 : matvar -> class_type = MAT_C_SPARSE ; break ; default : Mat_VarFree ( matvar ) ; return NULL ; } matvar -> rank = 2 ; matvar -> dims = ( size_t * ) calloc ( 2 , sizeof ( * matvar -> dims ) ) ; if ( NULL == matvar -> dims ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 0 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; matvar -> dims [ 1 ] = tmp ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & ( matvar -> isComplex ) , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( matvar -> isComplex && MAT_C_CHAR == matvar -> class_type ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( & tmp , sizeof ( int ) , 1 , ( FILE * ) mat -> fp ) ; if ( 1 != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; } if ( mat -> byteswap ) Mat_int32Swap ( & tmp ) ; if ( tmp < 1 ) { Mat_VarFree ( matvar ) ; return NULL ; } matvar -> name = ( char * ) malloc ( tmp ) ; if ( NULL == matvar -> name ) { Mat_VarFree ( matvar ) ; return NULL ; } readresult = fread ( matvar -> name , 1 , tmp , ( FILE * ) mat -> fp ) ; if ( tmp != readresult ) { Mat_VarFree ( matvar ) ; return NULL ; <S2SV_StartBug> } <S2SV_EndBug> matvar -> internal -> datapos = ftell ( ( FILE * ) mat -> fp ) ; if ( matvar -> internal -> datapos == - 1L ) { Mat_VarFree ( matvar ) ; Mat_Critical ( ""Couldn\'t<S2SV_blank>determine<S2SV_blank>file<S2SV_blank>position"" ) ; return NULL ; } { int err ; size_t tmp2 = Mat_SizeOf ( matvar -> data_type ) ; if ( matvar -> isComplex ) tmp2 *= 2 ; err = SafeMulDims ( matvar , & tmp2 ) ; if ( err ) { Mat_VarFree ( matvar ) ; Mat_Critical ( ""Integer<S2SV_blank>multiplication<S2SV_blank>overflow"" ) ; return NULL ; } nBytes = ( long ) tmp2 ; } ( void ) fseek ( ( FILE * ) mat -> fp , nBytes , SEEK_CUR ) ; return matvar ; }
","<S2SV_ModStart> NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
",tbeu@matio/651a8e28099edb5fbb9e4e1d4d3238848f446c9a,CVE-2019-17533,https://github.com/tbeu/matio/commit/651a8e28099edb5fbb9e4e1d4d3238848f446c9a,2019-10-13T02:15Z
CWE-20,"CWE-20 int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ; <S2SV_StartBug> * dst = * src ; <S2SV_EndBug> clear_task_ebb ( dst ) ; return 0 ; }
","<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
",torvalds@linux/621b5060e823301d0cba4cb52a7ee3491922d291,CVE-2014-2673,https://github.com/torvalds/linux/commit/621b5060e823301d0cba4cb52a7ee3491922d291,2014-04-01T06:35Z
CWE-125,"CWE-125 static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , ""label"" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->
",ImageMagick@ImageMagick/8f8959033e4e59418d6506b345829af1f7a71127,CVE-2016-7101,https://github.com/ImageMagick/ImageMagick/commit/8f8959033e4e59418d6506b345829af1f7a71127,2017-01-18T17:59Z
CWE-284,"CWE-284 bool semaphore_try_wait ( semaphore_t * semaphore ) { assert ( semaphore != NULL ) ; assert ( semaphore -> fd != INVALID_FD ) ; <S2SV_StartBug> int flags = fcntl ( semaphore -> fd , F_GETFL ) ; <S2SV_EndBug> if ( flags == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; return false ; } <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags | O_NONBLOCK ) == - 1 ) { <S2SV_EndBug> LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>O_NONBLOCK<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; return false ; } eventfd_t value ; if ( eventfd_read ( semaphore -> fd , & value ) == - 1 ) return false ; <S2SV_StartBug> if ( fcntl ( semaphore -> fd , F_SETFL , flags ) == - 1 ) <S2SV_EndBug> LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>resetore<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>semaphore<S2SV_blank>fd:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; return true ; }
","<S2SV_ModStart> int flags = TEMP_FAILURE_RETRY ( <S2SV_ModStart> fd , F_GETFL ) <S2SV_ModStart> } if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> flags | O_NONBLOCK ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> F_SETFL , flags )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-125,"CWE-125 void bootp_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register const struct bootp * bp ; static const u_char vm_cmu [ 4 ] = VM_CMU ; static const u_char vm_rfc1048 [ 4 ] = VM_RFC1048 ; bp = ( const struct bootp * ) cp ; ND_TCHECK ( bp -> bp_op ) ; ND_PRINT ( ( ndo , ""BOOTP/DHCP,<S2SV_blank>%s"" , tok2str ( bootp_op_values , ""unknown<S2SV_blank>(0x%02x)"" , bp -> bp_op ) ) ) ; ND_TCHECK ( bp -> bp_hlen ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 && bp -> bp_op == BOOTPREQUEST ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>from<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ! ndo -> ndo_vflag ) return ; ND_TCHECK ( bp -> bp_secs ) ; if ( bp -> bp_htype != 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>htype<S2SV_blank>%d"" , bp -> bp_htype ) ) ; if ( bp -> bp_htype != 1 || bp -> bp_hlen != 6 ) ND_PRINT ( ( ndo , "",<S2SV_blank>hlen<S2SV_blank>%d"" , bp -> bp_hlen ) ) ; if ( bp -> bp_hops ) ND_PRINT ( ( ndo , "",<S2SV_blank>hops<S2SV_blank>%d"" , bp -> bp_hops ) ) ; if ( EXTRACT_32BITS ( & bp -> bp_xid ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>xid<S2SV_blank>0x%x"" , EXTRACT_32BITS ( & bp -> bp_xid ) ) ) ; if ( EXTRACT_16BITS ( & bp -> bp_secs ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>secs<S2SV_blank>%d"" , EXTRACT_16BITS ( & bp -> bp_secs ) ) ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , <S2SV_EndBug> bittok2str ( bootp_flag_values , ""none"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ) ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( & bp -> bp_flags ) ) ) ; ND_TCHECK ( bp -> bp_ciaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_ciaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_ciaddr ) ) ) ; ND_TCHECK ( bp -> bp_yiaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_yiaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Your-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_yiaddr ) ) ) ; ND_TCHECK ( bp -> bp_siaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_siaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Server-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_siaddr ) ) ) ; ND_TCHECK ( bp -> bp_giaddr ) ; if ( EXTRACT_32BITS ( & bp -> bp_giaddr . s_addr ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Gateway-IP<S2SV_blank>%s"" , ipaddr_string ( ndo , & bp -> bp_giaddr ) ) ) ; if ( bp -> bp_htype == 1 && bp -> bp_hlen == 6 ) { ND_TCHECK2 ( bp -> bp_chaddr [ 0 ] , 6 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Client-Ethernet-Address<S2SV_blank>%s"" , etheraddr_string ( ndo , bp -> bp_chaddr ) ) ) ; } ND_TCHECK2 ( bp -> bp_sname [ 0 ] , 1 ) ; if ( * bp -> bp_sname ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>sname<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_sname , ( u_int ) sizeof bp -> bp_sname , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK2 ( bp -> bp_file [ 0 ] , 1 ) ; if ( * bp -> bp_file ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>file<S2SV_blank>\\"""" ) ) ; if ( fn_printztn ( ndo , bp -> bp_file , ( u_int ) sizeof bp -> bp_file , ndo -> ndo_snapend ) ) { ND_PRINT ( ( ndo , ""\\"""" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr + 1 ) ) ; return ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } ND_TCHECK ( bp -> bp_vend [ 0 ] ) ; if ( memcmp ( ( const char * ) bp -> bp_vend , vm_rfc1048 , sizeof ( uint32_t ) ) == 0 ) rfc1048_print ( ndo , bp -> bp_vend ) ; else if ( memcmp ( ( const char * ) bp -> bp_vend , vm_cmu , sizeof ( uint32_t ) ) == 0 ) cmu_print ( ndo , bp -> bp_vend ) ; else { uint32_t ul ; ul = EXTRACT_32BITS ( & bp -> bp_vend ) ; if ( ul != 0 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Vendor-#0x%x"" , ul ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
",the-tcpdump-group@tcpdump/29e5470e6ab84badbc31f4532bb7554a796d9d52,CVE-2017-13028,https://github.com/the-tcpdump-group/tcpdump/commit/29e5470e6ab84badbc31f4532bb7554a796d9d52,2017-09-14T06:29Z
CWE-400,"CWE-400 int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; <S2SV_StartBug> if ( retval ) <S2SV_EndBug> return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
","<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
",torvalds@linux/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,CVE-2016-9685,https://github.com/torvalds/linux/commit/2e83b79b2d6c78bf1b4aa227938a214dcbddc83f,2016-12-28T07:59Z
CWE-362,"CWE-362 void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
CWE-59,"CWE-59 static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long"" ) ; return - 1 ; } <S2SV_StartBug> return mount_entry_on_generic ( mntent , path ) ; <S2SV_EndBug> }
","<S2SV_ModStart> mntent , path , rootfs
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-254,"CWE-254 static int prepend_path ( const struct path * path , const struct path * root , char * * buffer , int * buflen ) { struct dentry * dentry ; struct vfsmount * vfsmnt ; struct mount * mnt ; int error = 0 ; unsigned seq , m_seq = 0 ; char * bptr ; int blen ; rcu_read_lock ( ) ; restart_mnt : read_seqbegin_or_lock ( & mount_lock , & m_seq ) ; seq = 0 ; rcu_read_lock ( ) ; restart : bptr = * buffer ; blen = * buflen ; error = 0 ; dentry = path -> dentry ; vfsmnt = path -> mnt ; mnt = real_mount ( vfsmnt ) ; read_seqbegin_or_lock ( & rename_lock , & seq ) ; while ( dentry != root -> dentry || vfsmnt != root -> mnt ) { struct dentry * parent ; if ( dentry == vfsmnt -> mnt_root || IS_ROOT ( dentry ) ) { <S2SV_StartBug> struct mount * parent = ACCESS_ONCE ( mnt -> mnt_parent ) ; <S2SV_EndBug> if ( mnt != parent ) { dentry = ACCESS_ONCE ( mnt -> mnt_mountpoint ) ; mnt = parent ; vfsmnt = & mnt -> mnt ; continue ; } if ( ! error ) error = is_mounted ( vfsmnt ) ? 1 : 2 ; break ; } parent = dentry -> d_parent ; prefetch ( parent ) ; error = prepend_name ( & bptr , & blen , & dentry -> d_name ) ; if ( error ) break ; dentry = parent ; } if ( ! ( seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & rename_lock , seq ) ) { seq = 1 ; goto restart ; } done_seqretry ( & rename_lock , seq ) ; if ( ! ( m_seq & 1 ) ) rcu_read_unlock ( ) ; if ( need_seqretry ( & mount_lock , m_seq ) ) { m_seq = 1 ; goto restart_mnt ; } done_seqretry ( & mount_lock , m_seq ) ; if ( error >= 0 && bptr == * buffer ) { if ( -- blen < 0 ) error = - ENAMETOOLONG ; else * -- bptr = '/' ; } * buffer = bptr ; * buflen = blen ; return error ; }
","<S2SV_ModStart> mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }
",torvalds@linux/cde93be45a8a90d8c264c776fab63487b5038a65,CVE-2015-2925,https://github.com/torvalds/linux/commit/cde93be45a8a90d8c264c776fab63487b5038a65,2015-11-16T11:59Z
CWE-862,"CWE-862 <S2SV_StartBug> static void construct_get_dest_keyring ( struct key * * _dest_keyring ) <S2SV_EndBug> { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; <S2SV_StartBug> kenter ( ""%p"" , dest_keyring ) ; <S2SV_EndBug> if ( dest_keyring ) { key_get ( dest_keyring ) ; <S2SV_StartBug> } else { <S2SV_EndBug> switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) <S2SV_StartBug> break ; <S2SV_EndBug> } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; } <S2SV_StartBug> } <S2SV_EndBug> * _dest_keyring = dest_keyring ; kleave ( ""<S2SV_blank>[dk<S2SV_blank>%d]"" , key_serial ( dest_keyring ) ) ; <S2SV_StartBug> return ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
",torvalds@linux/4dca6ea1d9432052afb06baf2e3ae78188a4410b,CVE-2017-17807,https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b,2017-12-20T23:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><frame>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void faad_resetbits ( bitfile * ld , int bits ) { uint32_t tmp ; int words = bits >> 5 ; int remainder = bits & 0x1F ; <S2SV_StartBug> ld -> bytes_left = ld -> buffer_size - words * 4 ; <S2SV_EndBug> if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufa = tmp ; if ( ld -> bytes_left >= 4 ) { tmp = getdword ( & ld -> start [ words + 1 ] ) ; ld -> bytes_left -= 4 ; } else { tmp = getdword_n ( & ld -> start [ words + 1 ] , ld -> bytes_left ) ; ld -> bytes_left = 0 ; } ld -> bufb = tmp ; ld -> bits_left = 32 - remainder ; ld -> tail = & ld -> start [ words + 2 ] ; ld -> error = 0 ; }
","<S2SV_ModStart> & 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
",knik0@faad2/942c3e0aee748ea6fe97cb2c1aa5893225316174,CVE-2019-15296,https://github.com/knik0/faad2/commit/942c3e0aee748ea6fe97cb2c1aa5893225316174,2019-08-21T07:15Z
CWE-119,"CWE-119 static Image * ReadARTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; QuantumInfo * quantum_info ; QuantumType quantum_type ; MagickBooleanType status ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 1 ; image -> endian = MSBEndian ; ( void ) ReadBlobLSBShort ( image ) ; image -> columns = ( size_t ) ReadBlobLSBShort ( image ) ; ( void ) ReadBlobLSBShort ( image ) ; image -> rows = ( size_t ) ReadBlobLSBShort ( image ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> quantum_type = IndexQuantum ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register PixelPacket * restrict q ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; count = ReadBlob ( image , ( size_t ) ( - ( ssize_t ) length ) & 0x01 , pixels ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-20,"CWE-20 error_t ipStringToAddr ( const char_t * str , IpAddr * ipAddr ) { error_t error ; # if ( IPV6_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , ':' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv6Addr ) ; error = ipv6StringToAddr ( str , & ipAddr -> ipv6Addr ) ; } else # endif # if ( IPV4_SUPPORT == ENABLED ) <S2SV_StartBug> if ( strchr ( str , '.' ) ) <S2SV_EndBug> { ipAddr -> length = sizeof ( Ipv4Addr ) ; error = ipv4StringToAddr ( str , & ipAddr -> ipv4Addr ) ; } else # endif { error = ERROR_FAILURE ; } return error ; }
","<S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , ':' ) != NULL <S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , '.' ) != NULL
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-189,"CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }
","<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
",torvalds@linux/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,CVE-2014-8369,https://github.com/torvalds/linux/commit/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,2014-11-10T11:55Z
CWE-20,"CWE-20 void enc28j60SelectBank ( NetInterface * interface , uint16_t address ) { uint16_t bank ; Enc28j60Context * context ; context = ( Enc28j60Context * ) interface -> nicContext ; bank = address & REG_BANK_MASK ; if ( bank != context -> currentBank ) { <S2SV_StartBug> switch ( bank ) <S2SV_EndBug> { case BANK_0 : <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> break ; case BANK_1 : <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> break ; case BANK_2 : <S2SV_StartBug> enc28j60ClearBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL0 ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 ) ; <S2SV_EndBug> break ; case BANK_3 : <S2SV_StartBug> enc28j60SetBit ( interface , ENC28J60_REG_ECON1 , ECON1_BSEL1 | ECON1_BSEL0 ) ; <S2SV_EndBug> break ; default : break ; } context -> currentBank = bank ; } }
","<S2SV_ModStart> currentBank ) { if ( bank == BANK_0 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> ; } context
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; <S2SV_EndBug> if ( ! frame_is_intra_only ( cm ) ) { <S2SV_StartBug> vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , <S2SV_EndBug> rate , dist , bsize ) ; } else { MB_PREDICTION_MODE intramode = DC_PRED ; set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ; } duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; }
","<S2SV_ModStart> * cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * const <S2SV_ModStart> TileInfo * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> -> e_mbd ; MB_MODE_INFO * mbmi ; <S2SV_ModStart> ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & <S2SV_ModEnd> xd -> mi <S2SV_ModStart> ] -> mbmi ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) <S2SV_ModEnd> vp9_pick_inter_mode ( cpi <S2SV_ModStart> , x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
",dbry@WavPack/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,CVE-2018-10540,https://github.com/dbry/WavPack/commit/6f8bb34c2993a48ab9afbe353e6d0cff7c8d821d,2018-04-29T15:29Z
CWE-125,"CWE-125 static int init_normalization ( struct compiling * c ) { PyObject * m = PyImport_ImportModuleNoBlock ( ""unicodedata"" ) ; if ( ! m ) return 0 ; c -> c_normalize = PyObject_GetAttrString ( m , ""normalize"" ) ; Py_DECREF ( m ) ; if ( ! c -> c_normalize ) return 0 ; <S2SV_StartBug> c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ; <S2SV_EndBug> if ( ! c -> c_normalize_args ) { Py_CLEAR ( c -> c_normalize ) ; return 0 ; } PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , NULL ) ; return 1 ; }
","<S2SV_ModStart> return 0 ; <S2SV_ModEnd> return 1 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-20,"CWE-20 long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; <S2SV_StartBug> if ( upid == - 1 ) <S2SV_EndBug> type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
","<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
",torvalds@linux/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,CVE-2018-10087,https://github.com/torvalds/linux/commit/dd83c161fbcc5d8be637ab159c0de015cbff5ba4,2018-04-13T13:29Z
CWE-119,"CWE-119 int dtls1_read_bytes ( SSL * s , int type , unsigned char * buf , int len , int peek ) { int al , i , j , ret ; unsigned int n ; SSL3_RECORD * rr ; void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ; if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_buffers ( s ) ) return ( - 1 ) ; if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ( ret = have_handshake_fragment ( s , type , buf , len , peek ) ) ) return ret ; # ifndef OPENSSL_NO_SCTP if ( ( ! s -> in_handshake && SSL_in_init ( s ) ) || ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) && s -> s3 -> in_read_app_data != 2 ) ) # else if ( ! s -> in_handshake && SSL_in_init ( s ) ) # endif { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } } start : s -> rwstate = SSL_NOTHING ; rr = & ( s -> s3 -> rrec ) ; if ( s -> state == SSL_ST_OK && rr -> length == 0 ) { pitem * item ; item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ; if ( item ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { DTLS1_RECORD_DATA * rdata = ( DTLS1_RECORD_DATA * ) item -> data ; BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_SET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif dtls1_copy_record ( s , item ) ; OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } } if ( dtls1_handle_timeout ( s ) > 0 ) goto start ; if ( ( rr -> length == 0 ) || ( s -> rstate == SSL_ST_READ_BODY ) ) { ret = dtls1_get_record ( s ) ; if ( ret <= 0 ) { ret = dtls1_read_failed ( s , ret ) ; if ( ret <= 0 ) return ( ret ) ; else goto start ; } } if ( s -> d1 -> listen && rr -> type != SSL3_RT_HANDSHAKE ) { rr -> length = 0 ; goto start ; } if ( s -> s3 -> change_cipher_spec && ( rr -> type != SSL3_RT_HANDSHAKE ) ) { <S2SV_StartBug> dtls1_buffer_record ( s , & ( s -> d1 -> buffered_app_data ) , rr -> seq_num ) ; <S2SV_EndBug> rr -> length = 0 ; goto start ; } if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) { rr -> length = 0 ; s -> rwstate = SSL_NOTHING ; return ( 0 ) ; } if ( type == rr -> type ) { if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ; goto f_err ; } if ( len <= 0 ) return ( len ) ; if ( ( unsigned int ) len > rr -> length ) n = rr -> length ; else n = ( unsigned int ) len ; memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ; if ( ! peek ) { rr -> length -= n ; rr -> off += n ; if ( rr -> length == 0 ) { s -> rstate = SSL_ST_READ_HEADER ; rr -> off = 0 ; } } # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && rr -> type == SSL3_RT_APPLICATION_DATA && ( s -> state == DTLS1_SCTP_ST_SR_READ_SOCK || s -> state == DTLS1_SCTP_ST_CR_READ_SOCK ) ) { s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; } if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && s -> d1 -> shutdown_received && ! BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # endif return ( n ) ; } { unsigned int k , dest_maxlen = 0 ; unsigned char * dest = NULL ; unsigned int * dest_len = NULL ; if ( rr -> type == SSL3_RT_HANDSHAKE ) { dest_maxlen = sizeof s -> d1 -> handshake_fragment ; dest = s -> d1 -> handshake_fragment ; dest_len = & s -> d1 -> handshake_fragment_len ; } else if ( rr -> type == SSL3_RT_ALERT ) { dest_maxlen = sizeof ( s -> d1 -> alert_fragment ) ; dest = s -> d1 -> alert_fragment ; dest_len = & s -> d1 -> alert_fragment_len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( rr -> type == TLS1_RT_HEARTBEAT ) { dtls1_process_heartbeat ( s ) ; rr -> length = 0 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return ( - 1 ) ; } # endif else if ( rr -> type != SSL3_RT_CHANGE_CIPHER_SPEC ) { if ( rr -> type == SSL3_RT_APPLICATION_DATA ) { BIO * bio ; s -> s3 -> in_read_app_data = 2 ; bio = SSL_get_rbio ( s ) ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } if ( dest_maxlen > 0 ) { if ( rr -> length < dest_maxlen ) { # ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE FIX ME # endif s -> rstate = SSL_ST_READ_HEADER ; rr -> length = 0 ; goto start ; } for ( k = 0 ; k < dest_maxlen ; k ++ ) { dest [ k ] = rr -> data [ rr -> off ++ ] ; rr -> length -- ; } * dest_len = dest_maxlen ; } } if ( ( ! s -> server ) && ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ( s -> d1 -> handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) { s -> d1 -> handshake_fragment_len = 0 ; if ( ( s -> d1 -> handshake_fragment [ 1 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 2 ] != 0 ) || ( s -> d1 -> handshake_fragment [ 3 ] != 0 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ; goto err ; } if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> d1 -> handshake_fragment , 4 , s , s -> msg_callback_arg ) ; if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) { s -> d1 -> handshake_read_seq ++ ; s -> new_session = 1 ; ssl3_renegotiate ( s ) ; if ( ssl3_renegotiate_check ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } } } goto start ; } if ( s -> d1 -> alert_fragment_len >= DTLS1_AL_HEADER_LENGTH ) { int alert_level = s -> d1 -> alert_fragment [ 0 ] ; int alert_descr = s -> d1 -> alert_fragment [ 1 ] ; s -> d1 -> alert_fragment_len = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> d1 -> alert_fragment , 2 , s , s -> msg_callback_arg ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; if ( cb != NULL ) { j = ( alert_level << 8 ) | alert_descr ; cb ( s , SSL_CB_READ_ALERT , j ) ; } if ( alert_level == 1 ) { s -> s3 -> warn_alert = alert_descr ; if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) { # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && BIO_dgram_sctp_msg_waiting ( SSL_get_rbio ( s ) ) ) { s -> d1 -> shutdown_received = 1 ; s -> rwstate = SSL_READING ; BIO_clear_retry_flags ( SSL_get_rbio ( s ) ) ; BIO_set_retry_read ( SSL_get_rbio ( s ) ) ; return - 1 ; } # endif s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; return ( 0 ) ; } # if 0 if ( alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) { unsigned short seq ; unsigned int frag_off ; unsigned char * p = & ( s -> d1 -> alert_fragment [ 2 ] ) ; n2s ( p , seq ) ; n2l3 ( p , frag_off ) ; dtls1_retransmit_message ( s , dtls1_get_queue_priority ( frag -> msg_header . seq , 0 ) , frag_off , & found ) ; if ( ! found && SSL_in_init ( s ) ) { ssl3_send_alert ( s , SSL3_AL_WARNING , DTLS1_AD_MISSING_HANDSHAKE_MESSAGE ) ; } } # endif } else if ( alert_level == 2 ) { char tmp [ 16 ] ; s -> rwstate = SSL_NOTHING ; s -> s3 -> fatal_alert = alert_descr ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ; BIO_snprintf ( tmp , sizeof tmp , ""%d"" , alert_descr ) ; ERR_add_error_data ( 2 , ""SSL<S2SV_blank>alert<S2SV_blank>number<S2SV_blank>"" , tmp ) ; s -> shutdown |= SSL_RECEIVED_SHUTDOWN ; SSL_CTX_remove_session ( s -> ctx , s -> session ) ; return ( 0 ) ; } else { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ; goto f_err ; } goto start ; } if ( s -> shutdown & SSL_SENT_SHUTDOWN ) { s -> rwstate = SSL_NOTHING ; rr -> length = 0 ; return ( 0 ) ; } if ( rr -> type == SSL3_RT_CHANGE_CIPHER_SPEC ) { struct ccs_header_st ccs_hdr ; unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH ; dtls1_get_ccs_header ( rr -> data , & ccs_hdr ) ; if ( s -> version == DTLS1_BAD_VER ) ccs_hdr_len = 3 ; if ( ( rr -> length != ccs_hdr_len ) || ( rr -> off != 0 ) || ( rr -> data [ 0 ] != SSL3_MT_CCS ) ) { i = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_BAD_CHANGE_CIPHER_SPEC ) ; goto err ; } rr -> length = 0 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , rr -> data , 1 , s , s -> msg_callback_arg ) ; if ( ! s -> d1 -> change_cipher_spec_ok ) { goto start ; } s -> d1 -> change_cipher_spec_ok = 0 ; s -> s3 -> change_cipher_spec = 1 ; if ( ! ssl3_do_change_cipher_spec ( s ) ) goto err ; dtls1_reset_seq_numbers ( s , SSL3_CC_READ ) ; if ( s -> version == DTLS1_BAD_VER ) s -> d1 -> handshake_read_seq ++ ; # ifndef OPENSSL_NO_SCTP BIO_ctrl ( SSL_get_wbio ( s ) , BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD , 1 , NULL ) ; # endif goto start ; } if ( ( s -> d1 -> handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH ) && ! s -> in_handshake ) { struct hm_header_st msg_hdr ; dtls1_get_message_header ( rr -> data , & msg_hdr ) ; if ( rr -> epoch != s -> d1 -> r_epoch ) { rr -> length = 0 ; goto start ; } if ( msg_hdr . type == SSL3_MT_FINISHED ) { if ( dtls1_check_timeout_num ( s ) < 0 ) return - 1 ; dtls1_retransmit_buffered_messages ( s ) ; rr -> length = 0 ; goto start ; } if ( ( ( s -> state & SSL_ST_MASK ) == SSL_ST_OK ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) { # if 0 s -> state = SSL_ST_BEFORE | ( s -> server ) ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # else s -> state = s -> server ? SSL_ST_ACCEPT : SSL_ST_CONNECT ; # endif s -> renegotiate = 1 ; s -> new_session = 1 ; } i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return ( - 1 ) ; } if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) { if ( s -> s3 -> rbuf . left == 0 ) { BIO * bio ; s -> rwstate = SSL_READING ; bio = SSL_get_rbio ( s ) ; BIO_clear_retry_flags ( bio ) ; BIO_set_retry_read ( bio ) ; return ( - 1 ) ; } } goto start ; } switch ( rr -> type ) { default : # ifndef OPENSSL_NO_TLS if ( s -> version == TLS1_VERSION ) { rr -> length = 0 ; goto start ; } # endif al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; goto f_err ; case SSL3_RT_APPLICATION_DATA : if ( s -> s3 -> in_read_app_data && ( s -> s3 -> total_renegotiations != 0 ) && ( ( ( s -> state & SSL_ST_CONNECT ) && ( s -> state >= SSL3_ST_CW_CLNT_HELLO_A ) && ( s -> state <= SSL3_ST_CR_SRVR_HELLO_A ) ) || ( ( s -> state & SSL_ST_ACCEPT ) && ( s -> state <= SSL3_ST_SW_HELLO_REQ_A ) && ( s -> state >= SSL3_ST_SR_CLNT_HELLO_A ) ) ) ) { s -> s3 -> in_read_app_data = 2 ; return ( - 1 ) ; } else { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ; goto f_err ; } } f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( - 1 ) ; }
","<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
CWE-119,"CWE-119 static int key_notify_sa_flush ( const struct km_event * c ) { struct sk_buff * skb ; struct sadb_msg * hdr ; skb = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = pfkey_proto2satype ( c -> data . proto ) ; hdr -> sadb_msg_type = SADB_FLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <S2SV_StartBug> pfkey_broadcast ( skb , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
",torvalds@linux/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887,CVE-2013-2234,https://github.com/torvalds/linux/commit/a5cc68f3d63306d0d288f31edfc2ae6ef8ecd887,2013-07-04T21:55Z
CWE-787,"CWE-787 MYSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannot<S2SV_blank>open<S2SV_blank>file<S2SV_blank>%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; <S2SV_StartBug> * err = superblockRead ( & reader , & reader . superblock ) ; <S2SV_EndBug> if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
","<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
",hoene@libmysofa/2e6fac6ab6156dae8e8c6f417741388084b70d6f,CVE-2019-20016,https://github.com/hoene/libmysofa/commit/2e6fac6ab6156dae8e8c6f417741388084b70d6f,2019-12-27T02:15Z
CWE-264,"CWE-264 int x86_emulate_insn ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; int rc = X86EMUL_CONTINUE ; int saved_dst_type = ctxt -> dst . type ; ctxt -> mem_read . pos = 0 ; if ( ctxt -> lock_prefix && ( ! ( ctxt -> d & Lock ) || ctxt -> dst . type != OP_MEM ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ctxt -> d & SrcMask ) == SrcMemFAddr && ctxt -> src . type != OP_MEM ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( unlikely ( ctxt -> d & ( No64 | Undefined | Sse | Mmx | Intercept | CheckPerm | Priv | Prot | String ) ) ) { if ( ( ctxt -> mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & No64 ) ) || ( ctxt -> d & Undefined ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_EM ) ) ) || ( ( ctxt -> d & Sse ) && ! ( ops -> get_cr ( ctxt , 4 ) & X86_CR4_OSFXSR ) ) ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ( ctxt -> d & ( Sse | Mmx ) ) && ( ops -> get_cr ( ctxt , 0 ) & X86_CR0_TS ) ) { rc = emulate_nm ( ctxt ) ; goto done ; } if ( ctxt -> d & Mmx ) { rc = flush_pending_x87_faults ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; fetch_possible_mmx_operand ( ctxt , & ctxt -> src ) ; fetch_possible_mmx_operand ( ctxt , & ctxt -> src2 ) ; if ( ! ( ctxt -> d & Mov ) ) fetch_possible_mmx_operand ( ctxt , & ctxt -> dst ) ; } if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_PRE_EXCEPT ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ( ctxt -> d & Priv ) && ops -> cpl ( ctxt ) ) { if ( ctxt -> d & PrivUD ) rc = emulate_ud ( ctxt ) ; else rc = emulate_gp ( ctxt , 0 ) ; goto done ; } if ( ( ctxt -> d & Prot ) && ctxt -> mode < X86EMUL_MODE_PROT16 ) { rc = emulate_ud ( ctxt ) ; goto done ; } if ( ctxt -> d & CheckPerm ) { rc = ctxt -> check_perm ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_POST_EXCEPT ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) { ctxt -> eip = ctxt -> _eip ; ctxt -> eflags &= ~ EFLG_RF ; goto done ; } } } if ( ( ctxt -> src . type == OP_MEM ) && ! ( ctxt -> d & NoAccess ) ) { rc = segmented_read ( ctxt , ctxt -> src . addr . mem , ctxt -> src . valptr , ctxt -> src . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; ctxt -> src . orig_val64 = ctxt -> src . val64 ; } if ( ctxt -> src2 . type == OP_MEM ) { rc = segmented_read ( ctxt , ctxt -> src2 . addr . mem , & ctxt -> src2 . val , ctxt -> src2 . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ( ctxt -> d & DstMask ) == ImplicitOps ) goto special_insn ; if ( ( ctxt -> dst . type == OP_MEM ) && ! ( ctxt -> d & Mov ) ) { rc = segmented_read ( ctxt , ctxt -> dst . addr . mem , & ctxt -> dst . val , ctxt -> dst . bytes ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } ctxt -> dst . orig_val = ctxt -> dst . val ; special_insn : if ( unlikely ( ctxt -> guest_mode ) && ( ctxt -> d & Intercept ) ) { rc = emulator_check_intercept ( ctxt , ctxt -> intercept , X86_ICPT_POST_MEMACCESS ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) ctxt -> eflags |= EFLG_RF ; else ctxt -> eflags &= ~ EFLG_RF ; if ( ctxt -> execute ) { if ( ctxt -> d & Fastop ) { void ( * fop ) ( struct fastop * ) = ( void * ) ctxt -> execute ; rc = fastop ( ctxt , fop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; } rc = ctxt -> execute ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; } if ( ctxt -> opcode_len == 2 ) goto twobyte_insn ; else if ( ctxt -> opcode_len == 3 ) goto threebyte_insn ; switch ( ctxt -> b ) { case 0x63 : if ( ctxt -> mode != X86EMUL_MODE_PROT64 ) goto cannot_emulate ; ctxt -> dst . val = ( s32 ) ctxt -> src . val ; break ; case 0x70 ... 0x7f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> break ; case 0x8d : ctxt -> dst . val = ctxt -> src . addr . mem . ea ; break ; case 0x90 ... 0x97 : if ( ctxt -> dst . addr . reg == reg_rmw ( ctxt , VCPU_REGS_RAX ) ) ctxt -> dst . type = OP_NONE ; else rc = em_xchg ( ctxt ) ; break ; case 0x98 : switch ( ctxt -> op_bytes ) { case 2 : ctxt -> dst . val = ( s8 ) ctxt -> dst . val ; break ; case 4 : ctxt -> dst . val = ( s16 ) ctxt -> dst . val ; break ; case 8 : ctxt -> dst . val = ( s32 ) ctxt -> dst . val ; break ; } break ; case 0xcc : rc = emulate_int ( ctxt , 3 ) ; break ; case 0xcd : rc = emulate_int ( ctxt , ctxt -> src . val ) ; break ; case 0xce : if ( ctxt -> eflags & EFLG_OF ) rc = emulate_int ( ctxt , 4 ) ; break ; case 0xe9 : case 0xeb : <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> ctxt -> dst . type = OP_NONE ; break ; case 0xf4 : ctxt -> ops -> halt ( ctxt ) ; break ; case 0xf5 : ctxt -> eflags ^= EFLG_CF ; break ; case 0xf8 : ctxt -> eflags &= ~ EFLG_CF ; break ; case 0xf9 : ctxt -> eflags |= EFLG_CF ; break ; case 0xfc : ctxt -> eflags &= ~ EFLG_DF ; break ; case 0xfd : ctxt -> eflags |= EFLG_DF ; break ; default : goto cannot_emulate ; } if ( rc != X86EMUL_CONTINUE ) goto done ; writeback : if ( ctxt -> d & SrcWrite ) { BUG_ON ( ctxt -> src . type == OP_MEM || ctxt -> src . type == OP_MEM_STR ) ; rc = writeback ( ctxt , & ctxt -> src ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } if ( ! ( ctxt -> d & NoWrite ) ) { rc = writeback ( ctxt , & ctxt -> dst ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; } ctxt -> dst . type = saved_dst_type ; if ( ( ctxt -> d & SrcMask ) == SrcSI ) string_addr_inc ( ctxt , VCPU_REGS_RSI , & ctxt -> src ) ; if ( ( ctxt -> d & DstMask ) == DstDI ) string_addr_inc ( ctxt , VCPU_REGS_RDI , & ctxt -> dst ) ; if ( ctxt -> rep_prefix && ( ctxt -> d & String ) ) { unsigned int count ; struct read_cache * r = & ctxt -> io_read ; if ( ( ctxt -> d & SrcMask ) == SrcSI ) count = ctxt -> src . count ; else count = ctxt -> dst . count ; register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - count ) ; if ( ! string_insn_completed ( ctxt ) ) { if ( ( r -> end != 0 || reg_read ( ctxt , VCPU_REGS_RCX ) & 0x3ff ) && ( r -> end == 0 || r -> end != r -> pos ) ) { ctxt -> mem_read . end = 0 ; writeback_registers ( ctxt ) ; return EMULATION_RESTART ; } goto done ; } ctxt -> eflags &= ~ EFLG_RF ; } ctxt -> eip = ctxt -> _eip ; done : if ( rc == X86EMUL_PROPAGATE_FAULT ) { WARN_ON ( ctxt -> exception . vector > 0x1f ) ; ctxt -> have_exception = true ; } if ( rc == X86EMUL_INTERCEPTED ) return EMULATION_INTERCEPTED ; if ( rc == X86EMUL_CONTINUE ) writeback_registers ( ctxt ) ; return ( rc == X86EMUL_UNHANDLEABLE ) ? EMULATION_FAILED : EMULATION_OK ; twobyte_insn : switch ( ctxt -> b ) { case 0x09 : ( ctxt -> ops -> wbinvd ) ( ctxt ) ; break ; case 0x08 : case 0x0d : case 0x18 : case 0x1f : break ; case 0x20 : ctxt -> dst . val = ops -> get_cr ( ctxt , ctxt -> modrm_reg ) ; break ; case 0x21 : ops -> get_dr ( ctxt , ctxt -> modrm_reg , & ctxt -> dst . val ) ; break ; case 0x40 ... 0x4f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) ctxt -> dst . val = ctxt -> src . val ; else if ( ctxt -> mode != X86EMUL_MODE_PROT64 || ctxt -> op_bytes != 4 ) ctxt -> dst . type = OP_NONE ; break ; case 0x80 ... 0x8f : if ( test_cc ( ctxt -> b , ctxt -> eflags ) ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> break ; case 0x90 ... 0x9f : ctxt -> dst . val = test_cc ( ctxt -> b , ctxt -> eflags ) ; break ; case 0xae : break ; case 0xb6 ... 0xb7 : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( u8 ) ctxt -> src . val : ( u16 ) ctxt -> src . val ; break ; case 0xbe ... 0xbf : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> src . bytes == 1 ) ? ( s8 ) ctxt -> src . val : ( s16 ) ctxt -> src . val ; break ; case 0xc3 : ctxt -> dst . bytes = ctxt -> op_bytes ; ctxt -> dst . val = ( ctxt -> op_bytes == 8 ) ? ( u64 ) ctxt -> src . val : ( u32 ) ctxt -> src . val ; break ; default : goto cannot_emulate ; } threebyte_insn : if ( rc != X86EMUL_CONTINUE ) goto done ; goto writeback ; cannot_emulate : return EMULATION_FAILED ; }
","<S2SV_ModStart> eflags ) ) rc = <S2SV_ModStart> case 0xeb : rc = <S2SV_ModStart> eflags ) ) rc =
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static int conditional_skipintra ( MB_PREDICTION_MODE mode , <S2SV_EndBug> MB_PREDICTION_MODE best_intra_mode ) { if ( mode == D117_PRED && best_intra_mode != V_PRED && best_intra_mode != D135_PRED ) return 1 ; if ( mode == D63_PRED && best_intra_mode != V_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D207_PRED && best_intra_mode != H_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D153_PRED && best_intra_mode != H_PRED && best_intra_mode != D135_PRED ) return 1 ; return 0 ; }
","<S2SV_ModStart> int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> best_intra_mode ) {
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void opl3_setup_voice ( int dev , int voice , int chn ) { <S2SV_StartBug> struct channel_info * info = <S2SV_EndBug> & synth_devs [ dev ] -> chn_info [ chn ] ; opl3_set_instr ( dev , voice , info -> pgm_num ) ; devc -> voc [ voice ] . bender = 0 ; devc -> voc [ voice ] . bender_range = info -> bender_range ; devc -> voc [ voice ] . volume = info -> controllers [ CTL_MAIN_VOLUME ] ; devc -> voc [ voice ] . panning = ( info -> controllers [ CTL_PAN ] * 2 ) - 128 ; }
","<S2SV_ModStart> channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
",torvalds@linux/4d00135a680727f6c3be78f8befaac009030e4df,CVE-2011-1477,https://github.com/torvalds/linux/commit/4d00135a680727f6c3be78f8befaac009030e4df,2012-06-21T23:55Z
CWE-119,"CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , ""__wakeup"" , sizeof ( ""__wakeup"" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , ""__wakeup"" , sizeof ( ""__wakeup"" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }
","<S2SV_ModStart> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
",php@php-src/6a7cc8ff85827fa9ac715b3a83c2d9147f33cd43,CVE-2016-7411,https://github.com/php/php-src/commit/6a7cc8ff85827fa9ac715b3a83c2d9147f33cd43,2016-09-17T21:59Z
CWE-119,"CWE-119 static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; <S2SV_StartBug> size_t copied , len , cur_len ; <S2SV_EndBug> ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len = cur_len ; for ( i = 0 ; i < nr_pages ; i ++ ) { <S2SV_StartBug> copied = min_t ( const size_t , cur_len , PAGE_SIZE ) ; <S2SV_EndBug> copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , <S2SV_StartBug> 0 , copied ) ; <S2SV_EndBug> cur_len -= copied ; iov_iter_advance ( & it , copied ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> cur_len = save_len - cur_len ; <S2SV_EndBug> wdata -> sync_mode = WB_SYNC_ALL ; wdata -> nr_pages = nr_pages ; wdata -> offset = ( __u64 ) offset ; wdata -> cfile = cifsFileInfo_get ( open_file ) ; wdata -> pid = pid ; wdata -> bytes = cur_len ; wdata -> pagesz = PAGE_SIZE ; wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE ) ; rc = cifs_uncached_retry_writev ( wdata ) ; if ( rc ) { kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; break ; } list_add_tail ( & wdata -> list , & wdata_list ) ; offset += cur_len ; len -= cur_len ; } while ( len > 0 ) ; if ( ! list_empty ( & wdata_list ) ) rc = 0 ; restart_loop : list_for_each_entry_safe ( wdata , tmp , & wdata_list , list ) { if ( ! rc ) { rc = wait_for_completion_killable ( & wdata -> done ) ; if ( rc ) rc = - EINTR ; else if ( wdata -> result ) rc = wdata -> result ; else total_written += wdata -> bytes ; if ( rc == - EAGAIN ) { rc = cifs_uncached_retry_writev ( wdata ) ; goto restart_loop ; } } list_del_init ( & wdata -> list ) ; kref_put ( & wdata -> refcount , cifs_uncached_writedata_release ) ; } if ( total_written > 0 ) * poffset += total_written ; cifs_stats_bytes_written ( tcon , total_written ) ; return total_written ? total_written : ( ssize_t ) rc ; }
","<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
",torvalds@linux/5d81de8e8667da7135d3a32a964087c0faf5483f,CVE-2014-0069,https://github.com/torvalds/linux/commit/5d81de8e8667da7135d3a32a964087c0faf5483f,2014-02-28T06:18Z
CWE-119,"CWE-119 static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }
","<S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
","<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
",torvalds@linux/fdf5af0daf8019cec2396cdef8fb042d80fe71fa,CVE-2012-6638,https://github.com/torvalds/linux/commit/fdf5af0daf8019cec2396cdef8fb042d80fe71fa,2014-02-15T14:57Z
CWE-119,"CWE-119 <S2SV_StartBug> static void write_inter_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> assert ( is_inter_mode ( mode ) ) ; vp9_write_token ( w , vp9_inter_mode_tree , probs , & inter_mode_encodings [ INTER_OFFSET ( mode ) ] ) ; }
","<S2SV_ModStart> void write_inter_mode ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * w , PREDICTION_MODE <S2SV_ModEnd> mode , const <S2SV_ModStart> mode , const vpx_prob <S2SV_ModEnd> * probs )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 void qedi_dbg_info ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , u32 level , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & level ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_info ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_info ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
","<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,
",torvalds@linux/c09581a52765a85f19fc35340127396d5e3379cc,CVE-2019-15090,https://github.com/torvalds/linux/commit/c09581a52765a85f19fc35340127396d5e3379cc,2019-08-16T00:15Z
CWE-190,"CWE-190 static int readSeparateStripsIntoBuffer ( TIFF * in , uint8 * obuf , uint32 length , uint32 width , uint16 spp , struct dump_opts * dump ) { <S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> int32 bytes_read = 0 ; <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> uint32 src_rowsize , dst_rowsize , rows_processed , rps ; uint32 rows_this_strip = 0 ; tsample_t s ; tstrip_t strip ; tsize_t scanlinesize = TIFFScanlineSize ( in ) ; tsize_t stripsize = TIFFStripSize ( in ) ; unsigned char * srcbuffs [ MAX_SAMPLES ] ; unsigned char * buff = NULL ; unsigned char * dst = NULL ; if ( obuf == NULL ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Invalid<S2SV_blank>buffer<S2SV_blank>argument"" ) ; return ( 0 ) ; } memset ( srcbuffs , '\\0' , sizeof ( srcbuffs ) ) ; TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; if ( rps > length ) rps = length ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; src_rowsize = ( ( bps * width ) + 7 ) / 8 ; dst_rowsize = ( ( bps * width * spp ) + 7 ) / 8 ; dst = obuf ; if ( ( dump -> infile != NULL ) && ( dump -> level == 3 ) ) { dump_info ( dump -> infile , dump -> format , """" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Scanline<S2SV_blank>size,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , scanlinesize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d,<S2SV_blank>Shift<S2SV_blank>width<S2SV_blank>%d"" , bps , spp , shift_width ) ; } nstrips = TIFFNumberOfStrips ( in ) ; strips_per_sample = nstrips / spp ; for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { srcbuffs [ s ] = NULL ; buff = _TIFFmalloc ( stripsize ) ; if ( ! buff ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>strip<S2SV_blank>read<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , s ) ; for ( i = 0 ; i < s ; i ++ ) _TIFFfree ( srcbuffs [ i ] ) ; return 0 ; } srcbuffs [ s ] = buff ; } rows_processed = 0 ; for ( j = 0 ; ( j < strips_per_sample ) && ( result == 1 ) ; j ++ ) { for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; strip = ( s * strips_per_sample ) + j ; bytes_read = TIFFReadEncodedStrip ( in , strip , buff , stripsize ) ; rows_this_strip = bytes_read / src_rowsize ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , ( unsigned long ) strip , s + 1 ) ; result = 0 ; break ; } # ifdef DEVELMODE TIFFError ( """" , ""Strip<S2SV_blank>%2d,<S2SV_blank>read<S2SV_blank>%5d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>%4d<S2SV_blank>scanlines,<S2SV_blank>shift<S2SV_blank>width<S2SV_blank>%d"" , strip , bytes_read , rows_this_strip , shift_width ) ; # endif } if ( rps > rows_this_strip ) rps = rows_this_strip ; dst = obuf + ( dst_rowsize * rows_processed ) ; if ( ( bps % 8 ) == 0 ) { if ( combineSeparateSamplesBytes ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } } else { switch ( shift_width ) { case 1 : if ( combineSeparateSamples8bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 2 : if ( combineSeparateSamples16bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 3 : if ( combineSeparateSamples24bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 4 : case 5 : case 6 : case 7 : case 8 : if ( combineSeparateSamples32bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; default : TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth:<S2SV_blank>%d"" , bps ) ; result = 0 ; break ; } } if ( ( rows_processed + rps ) > length ) { rows_processed = length ; rps = length - rows_processed ; } else rows_processed += rps ; } for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; if ( buff != NULL ) _TIFFfree ( buff ) ; } return ( result ) ; }
","<S2SV_ModStart> int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 bytes_read <S2SV_ModStart> uint16 bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ; uint32
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,2016-11-22T19:59Z
CWE-190,"CWE-190 jas_matrix_t * jas_matrix_copy ( jas_matrix_t * x ) { jas_matrix_t * y ; <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; y = jas_matrix_create ( x -> numrows_ , x -> numcols_ ) ; for ( i = 0 ; i < x -> numrows_ ; ++ i ) { for ( j = 0 ; j < x -> numcols_ ; ++ j ) { * jas_matrix_getref ( y , i , j ) = jas_matrix_get ( x , i , j ) ; } } return y ; }
","<S2SV_ModStart> * y ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; y
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-119,"CWE-119 private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { size_t i ; cdf_timestamp_t tp ; struct timespec ts ; char buf [ 64 ] ; const char * str = NULL ; const char * s ; int len ; <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; i ++ ) { cdf_print_property_name ( buf , sizeof ( buf ) , info [ i ] . pi_id ) ; switch ( info [ i ] . pi_type ) { case CDF_NULL : break ; case CDF_SIGNED16 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%hd"" , buf , info [ i ] . pi_s16 ) == - 1 ) return - 1 ; break ; case CDF_SIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%d"" , buf , info [ i ] . pi_s32 ) == - 1 ) return - 1 ; break ; case CDF_UNSIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%u"" , buf , info [ i ] . pi_u32 ) == - 1 ) return - 1 ; break ; case CDF_FLOAT : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_f ) == - 1 ) return - 1 ; break ; case CDF_DOUBLE : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_d ) == - 1 ) return - 1 ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : len = info [ i ] . pi_str . s_len ; if ( len > 1 ) { char vbuf [ 1024 ] ; size_t j , k = 1 ; if ( info [ i ] . pi_type == CDF_LENGTH32_WSTRING ) k ++ ; s = info [ i ] . pi_str . s_buf ; for ( j = 0 ; j < sizeof ( vbuf ) && len -- ; j ++ , s += k ) { if ( * s == '\\0' ) break ; if ( isprint ( ( unsigned char ) * s ) ) vbuf [ j ] = * s ; } if ( j == sizeof ( vbuf ) ) -- j ; vbuf [ j ] = '\\0' ; if ( NOTMIME ( ms ) ) { if ( vbuf [ 0 ] ) { if ( file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , vbuf ) == - 1 ) return - 1 ; } } else if ( str == NULL && info [ i ] . pi_id == CDF_PROPERTY_NAME_OF_APPLICATION ) { str = cdf_app_to_mime ( vbuf , app2mime ) ; } } break ; case CDF_FILETIME : tp = info [ i ] . pi_tp ; if ( tp != 0 ) { char tbuf [ 64 ] ; if ( tp < 1000000000000000LL ) { cdf_print_elapsed_time ( tbuf , sizeof ( tbuf ) , tp ) ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , tbuf ) == - 1 ) return - 1 ; } else { char * c , * ec ; cdf_timestamp_to_timespec ( & ts , tp ) ; c = cdf_ctime ( & ts . tv_sec , tbuf ) ; if ( c != NULL && ( ec = strchr ( c , '\\n' ) ) != NULL ) * ec = '\\0' ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , c ) == - 1 ) return - 1 ; } } break ; case CDF_CLIPBOARD : break ; default : return - 1 ; } } if ( ! NOTMIME ( ms ) ) { if ( str == NULL ) return 0 ; if ( file_printf ( ms , ""application/%s"" , str ) == - 1 ) return - 1 ; } return 1 ; }
","<S2SV_ModStart> count , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ( ms ) && root_storage <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime )
",file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z
CWE-908,"CWE-908 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 22 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; <S2SV_StartBug> if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) <S2SV_EndBug> { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
",ImageMagick@ImageMagick/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,CVE-2017-9098,https://github.com/ImageMagick/ImageMagick/commit/1c358ffe0049f768dd49a8a889c1cbf99ac9849b,2017-05-19T19:29Z
CWE-189,"CWE-189 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
","<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n"" , dst ) ; return ret ; }
",torvalds@linux/d3bd7413e0ca40b60cf60d4003246d067cafdeda,CVE-2019-7308,https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda,2019-02-01T22:29Z
CWE-772,"CWE-772 generic_ret * chpass_principal3_2_svc ( chpass3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal_3 ( ( void * ) handle , arg -> princ , arg -> keepold , arg -> n_ks_tuple , arg -> ks_tuple , arg -> pass ) ; } else { log_unauth ( ""kadm5_chpass_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_CHANGEPW ; } if ( ret . code != KADM5_AUTH_CHANGEPW ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_chpass_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-119,"CWE-119 static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ; <S2SV_StartBug> int tmp ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( buf , buffer , count ) ) <S2SV_EndBug> return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }
","<S2SV_ModStart> ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , buffer , size <S2SV_ModEnd> ) ) return
",torvalds@linux/201f99f170df14ba52ea4c52847779042b7a623b,CVE-2013-4512,https://github.com/torvalds/linux/commit/201f99f170df14ba52ea4c52847779042b7a623b,2013-11-12T14:35Z
CWE-476,"CWE-476 static apr_status_t modsecurity_request_body_store_memory ( modsec_rec * msr , const char * data , apr_size_t length , char * * error_msg ) { * error_msg = NULL ; <S2SV_StartBug> if ( ( msr -> msc_reqbody_spilltodisk ) <S2SV_EndBug> && ( msr -> msc_reqbody_length + length > ( apr_size_t ) msr -> txcfg -> reqbody_inmemory_limit ) ) { msc_data_chunk * * chunks ; unsigned int disklen = 0 ; int i ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Request<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>store<S2SV_blank>in<S2SV_blank>memory,<S2SV_blank>switching<S2SV_blank>to<S2SV_blank>disk."" ) ; msr -> msc_reqbody_storage = MSC_REQBODY_DISK ; if ( modsecurity_request_body_start_init ( msr , error_msg ) < 0 ) return - 1 ; chunks = ( msc_data_chunk * * ) msr -> msc_reqbody_chunks -> elts ; for ( i = 0 ; i < msr -> msc_reqbody_chunks -> nelts ; i ++ ) { disklen += chunks [ i ] -> length ; if ( modsecurity_request_body_store_disk ( msr , chunks [ i ] -> data , chunks [ i ] -> length , error_msg ) < 0 ) { return - 1 ; } free ( chunks [ i ] -> data ) ; chunks [ i ] -> data = NULL ; } msr -> msc_reqbody_chunks = NULL ; apr_pool_clear ( msr -> msc_reqbody_mp ) ; msr_log ( msr , 4 , ""Input<S2SV_blank>filter:<S2SV_blank>Wrote<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>memory<S2SV_blank>to<S2SV_blank>disk."" , disklen ) ; return modsecurity_request_body_store_disk ( msr , data , length , error_msg ) ; } { unsigned long int bucket_offset , bucket_left ; bucket_offset = 0 ; bucket_left = length ; while ( bucket_left > 0 ) { if ( msr -> msc_reqbody_chunk_current == NULL ) { msr -> msc_reqbody_chunk_current = ( msc_data_chunk * ) apr_pcalloc ( msr -> msc_reqbody_mp , sizeof ( msc_data_chunk ) ) ; if ( msr -> msc_reqbody_chunk_current == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk."" , ( unsigned long ) sizeof ( msc_data_chunk ) ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> data = malloc ( CHUNK_CAPACITY ) ; if ( msr -> msc_reqbody_chunk_current -> data == NULL ) { * error_msg = apr_psprintf ( msr -> mp , ""Input<S2SV_blank>filter:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>"" ""for<S2SV_blank>request<S2SV_blank>body<S2SV_blank>chunk<S2SV_blank>data."" , CHUNK_CAPACITY ) ; return - 1 ; } msr -> msc_reqbody_chunk_current -> length = 0 ; msr -> msc_reqbody_chunk_current -> is_permanent = 1 ; * ( const msc_data_chunk * * ) apr_array_push ( msr -> msc_reqbody_chunks ) = msr -> msc_reqbody_chunk_current ; } if ( bucket_left < ( CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ) ) { memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , bucket_left ) ; msr -> msc_reqbody_chunk_current -> length += bucket_left ; bucket_left = 0 ; } else { unsigned long int copy_length = CHUNK_CAPACITY - msr -> msc_reqbody_chunk_current -> length ; memcpy ( msr -> msc_reqbody_chunk_current -> data + msr -> msc_reqbody_chunk_current -> length , data + bucket_offset , copy_length ) ; bucket_offset += copy_length ; bucket_left -= copy_length ; msr -> msc_reqbody_chunk_current -> length += copy_length ; msr -> msc_reqbody_chunk_current = NULL ; } } msr -> msc_reqbody_length += length ; } return 1 ; }
","<S2SV_ModStart> msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON
",SpiderLabs@ModSecurity/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,CVE-2013-2765,https://github.com/SpiderLabs/ModSecurity/commit/0840b13612a0b7ef1ce7441cf811dcfc6b463fba,2013-07-15T15:55Z
CWE-295,"CWE-295 void options_defaults ( ) { SERVICE_OPTIONS * service ; memset ( & new_global_options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ; new_service_options . next = NULL ; <S2SV_StartBug> parse_global_option ( CMD_SET_DEFAULTS , NULL , NULL ) ; <S2SV_EndBug> service = & new_service_options ; parse_service_option ( CMD_SET_DEFAULTS , & service , NULL , NULL ) ; }
","<S2SV_ModStart> ( CMD_SET_DEFAULTS , & new_global_options ,
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-189,"CWE-189 static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( ""mmap(%d,<S2SV_blank>R,<S2SV_blank>PRIVATE,<S2SV_blank>%d,<S2SV_blank>%d)<S2SV_blank>failed:<S2SV_blank>%s\\n"" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ; <S2SV_StartBug> pMap -> ranges = malloc ( sizeof ( MappedRange ) ) ; <S2SV_EndBug> pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }
","<S2SV_ModStart> ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( ""malloc<S2SV_blank>failed:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z
CWE-476,"CWE-476 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return __this_address ; switch ( mode & S_IFMT ) { case S_IFIFO : case S_IFCHR : case S_IFBLK : case S_IFSOCK : if ( dip -> di_format != XFS_DINODE_FMT_DEV ) return __this_address ; break ; case S_IFREG : case S_IFLNK : case S_IFDIR : <S2SV_StartBug> switch ( dip -> di_format ) { <S2SV_EndBug> case XFS_DINODE_FMT_LOCAL : if ( S_ISREG ( mode ) ) return __this_address ; if ( di_size > XFS_DFORK_DSIZE ( dip , mp ) ) return __this_address ; if ( dip -> di_nextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { switch ( dip -> di_aformat ) { case XFS_DINODE_FMT_LOCAL : if ( dip -> di_anextents ) return __this_address ; case XFS_DINODE_FMT_EXTENTS : case XFS_DINODE_FMT_BTREE : break ; default : return __this_address ; } } else { switch ( dip -> di_aformat ) { case 0 : case XFS_DINODE_FMT_EXTENTS : break ; default : return __this_address ; } if ( dip -> di_anextents ) return __this_address ; } fa = xfs_inode_validate_extsize ( mp , be32_to_cpu ( dip -> di_extsize ) , mode , flags ) ; if ( fa ) return fa ; if ( dip -> di_version < 3 ) return NULL ; flags2 = be64_to_cpu ( dip -> di_flags2 ) ; if ( ( flags2 & ( XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE ) ) && ! xfs_sb_version_hasreflink ( & mp -> m_sb ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( mode & S_IFMT ) != S_IFREG ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags & XFS_DIFLAG_REALTIME ) ) return __this_address ; if ( ( flags2 & XFS_DIFLAG2_REFLINK ) && ( flags2 & XFS_DIFLAG2_DAX ) ) return __this_address ; fa = xfs_inode_validate_cowextsize ( mp , be32_to_cpu ( dip -> di_cowextsize ) , mode , flags , flags2 ) ; if ( fa ) return fa ; return NULL ; }
","<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
",torvalds@linux/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,CVE-2018-13095,https://github.com/torvalds/linux/commit/23fcb3340d033d9f081e21e6c12c2db7eaa541d3,2018-07-03T10:29Z
CWE-20,"CWE-20 int treeRead ( struct READER * reader , struct DATAOBJECT * data ) { int i , j , err , olen , elements , size , x , y , z , b , e , dy , dz , sx , sy , sz , dzy , szy ; char * input , * output ; uint8_t node_type , node_level ; uint16_t entries_used ; uint32_t size_of_chunk ; uint32_t filter_mask ; uint64_t address_of_left_sibling , address_of_right_sibling , start [ 4 ] , child_pointer , key , store ; char buf [ 4 ] ; UNUSED ( node_level ) ; UNUSED ( address_of_right_sibling ) ; UNUSED ( address_of_left_sibling ) ; UNUSED ( key ) ; if ( data -> ds . dimensionality > 3 ) { log ( ""TREE<S2SV_blank>dimensions<S2SV_blank>><S2SV_blank>3"" ) ; return MYSOFA_INVALID_FORMAT ; } if ( fread ( buf , 1 , 4 , reader -> fhd ) != 4 || strncmp ( buf , ""TREE"" , 4 ) ) { log ( ""cannot<S2SV_blank>read<S2SV_blank>signature<S2SV_blank>of<S2SV_blank>TREE\\n"" ) ; return MYSOFA_INVALID_FORMAT ; } log ( ""%08lX<S2SV_blank>%.4s\\n"" , ( uint64_t ) ftell ( reader -> fhd ) - 4 , buf ) ; node_type = ( uint8_t ) fgetc ( reader -> fhd ) ; node_level = ( uint8_t ) fgetc ( reader -> fhd ) ; entries_used = ( uint16_t ) readValue ( reader , 2 ) ; if ( entries_used > 0x1000 ) return MYSOFA_UNSUPPORTED_FORMAT ; address_of_left_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; address_of_right_sibling = readValue ( reader , reader -> superblock . size_of_offsets ) ; elements = 1 ; for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) elements *= data -> datalayout_chunk [ j ] ; dy = data -> datalayout_chunk [ 1 ] ; dz = data -> datalayout_chunk [ 2 ] ; sx = data -> ds . dimension_size [ 0 ] ; sy = data -> ds . dimension_size [ 1 ] ; sz = data -> ds . dimension_size [ 2 ] ; dzy = dz * dy ; szy = sz * sy ; size = data -> datalayout_chunk [ data -> ds . dimensionality ] ; log ( ""elements<S2SV_blank>%d<S2SV_blank>size<S2SV_blank>%d\\n"" , elements , size ) ; if ( ! ( output = malloc ( elements * size ) ) ) { return MYSOFA_NO_MEMORY ; } for ( e = 0 ; e < entries_used * 2 ; e ++ ) { if ( node_type == 0 ) { key = readValue ( reader , reader -> superblock . size_of_lengths ) ; } else { size_of_chunk = ( uint32_t ) readValue ( reader , 4 ) ; filter_mask = ( uint32_t ) readValue ( reader , 4 ) ; if ( filter_mask ) { log ( ""TREE<S2SV_blank>all<S2SV_blank>filters<S2SV_blank>must<S2SV_blank>be<S2SV_blank>enabled\\n"" ) ; free ( output ) ; return MYSOFA_INVALID_FORMAT ; } for ( j = 0 ; j < data -> ds . dimensionality ; j ++ ) { start [ j ] = readValue ( reader , 8 ) ; log ( ""start<S2SV_blank>%d<S2SV_blank>%lu\\n"" , j , start [ j ] ) ; } if ( readValue ( reader , 8 ) ) { break ; } child_pointer = readValue ( reader , reader -> superblock . size_of_offsets ) ; log ( ""<S2SV_blank>data<S2SV_blank>at<S2SV_blank>%lX<S2SV_blank>len<S2SV_blank>%u\\n"" , child_pointer , size_of_chunk ) ; store = ftell ( reader -> fhd ) ; if ( fseek ( reader -> fhd , child_pointer , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } if ( ! ( input = malloc ( size_of_chunk ) ) ) { free ( output ) ; return MYSOFA_NO_MEMORY ; } if ( fread ( input , 1 , size_of_chunk , reader -> fhd ) != size_of_chunk ) { free ( output ) ; free ( input ) ; return MYSOFA_INVALID_FORMAT ; } olen = elements * size ; err = gunzip ( size_of_chunk , input , & olen , output ) ; free ( input ) ; log ( ""<S2SV_blank><S2SV_blank><S2SV_blank>gunzip<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n"" , err , olen , elements * size ) ; if ( err || olen != elements * size ) { free ( output ) ; return MYSOFA_INVALID_FORMAT ; } switch ( data -> ds . dimensionality ) { case 1 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements + start [ 0 ] ; <S2SV_StartBug> if ( x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = x * size + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 2 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; y = x % dy + start [ 1 ] ; x = x / dy + start [ 0 ] ; <S2SV_StartBug> if ( y < sy && x < sx ) { <S2SV_EndBug> <S2SV_StartBug> j = ( ( x * sy + y ) * size ) + b ; <S2SV_EndBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; } } break ; case 3 : for ( i = 0 ; i < olen ; i ++ ) { b = i / elements ; x = i % elements ; z = x % dz + start [ 2 ] ; y = ( x / dz ) % dy + start [ 1 ] ; x = ( x / dzy ) + start [ 0 ] ; <S2SV_StartBug> if ( z < sz && y < sy && x < sx ) { <S2SV_EndBug> j = ( x * szy + y * sz + z ) * size + b ; <S2SV_StartBug> ( ( char * ) data -> data ) [ j ] = output [ i ] ; <S2SV_EndBug> } } break ; default : log ( ""invalid<S2SV_blank>dim\\n"" ) ; return MYSOFA_INTERNAL_ERROR ; } if ( fseek ( reader -> fhd , store , SEEK_SET ) < 0 ) { free ( output ) ; return errno ; } } } free ( output ) ; if ( fseek ( reader -> fhd , 4 , SEEK_CUR ) < 0 ) return errno ; return MYSOFA_OK ; }
","<S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = x <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) {
",hoene@libmysofa/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1,CVE-2019-10672,https://github.com/hoene/libmysofa/commit/d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1,2019-03-31T17:29Z
CWE-120,"CWE-120 int read_fru_area_section ( struct ipmi_intf * intf , struct fru_info * fru , uint8_t id , uint32_t offset , uint32_t length , uint8_t * frubuf ) { static uint32_t fru_data_rqst_size = 20 ; <S2SV_StartBug> uint32_t off = offset , tmp , finish ; <S2SV_EndBug> struct ipmi_rs * rsp ; struct ipmi_rq req ; uint8_t msg_data [ 4 ] ; if ( offset > fru -> size ) { lprintf ( LOG_ERR , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>offset<S2SV_blank>incorrect:<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d"" , offset , fru -> size ) ; return - 1 ; } finish = offset + length ; if ( finish > fru -> size ) { <S2SV_StartBug> finish = fru -> size ; <S2SV_EndBug> lprintf ( LOG_NOTICE , ""Read<S2SV_blank>FRU<S2SV_blank>Area<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large,<S2SV_blank>"" ""Adjusting<S2SV_blank>to<S2SV_blank>%d"" , <S2SV_StartBug> offset + length , finish - offset ) ; <S2SV_EndBug> } memset ( & req , 0 , sizeof ( req ) ) ; req . msg . netfn = IPMI_NETFN_STORAGE ; req . msg . cmd = GET_FRU_DATA ; req . msg . data = msg_data ; req . msg . data_len = 4 ; # ifdef LIMIT_ALL_REQUEST_SIZE if ( fru_data_rqst_size > 16 ) # else if ( fru -> access && fru_data_rqst_size > 16 ) # endif fru_data_rqst_size = 16 ; <S2SV_StartBug> do { <S2SV_EndBug> tmp = fru -> access ? off >> 1 : off ; msg_data [ 0 ] = id ; msg_data [ 1 ] = ( uint8_t ) ( tmp & 0xff ) ; msg_data [ 2 ] = ( uint8_t ) ( tmp >> 8 ) ; tmp = finish - off ; if ( tmp > fru_data_rqst_size ) msg_data [ 3 ] = ( uint8_t ) fru_data_rqst_size ; else msg_data [ 3 ] = ( uint8_t ) tmp ; rsp = intf -> sendrecv ( intf , & req ) ; if ( ! rsp ) { lprintf ( LOG_NOTICE , ""FRU<S2SV_blank>Read<S2SV_blank>failed"" ) ; break ; } if ( rsp -> ccode ) { if ( fru_cc_rq2big ( rsp -> ccode ) && ( -- fru_data_rqst_size > FRU_BLOCK_SZ ) ) { lprintf ( LOG_INFO , ""Retrying<S2SV_blank>FRU<S2SV_blank>read<S2SV_blank>with<S2SV_blank>request<S2SV_blank>size<S2SV_blank>%d"" , fru_data_rqst_size ) ; continue ; } lprintf ( LOG_NOTICE , ""FRU<S2SV_blank>Read<S2SV_blank>failed:<S2SV_blank>%s"" , val2str ( rsp -> ccode , completion_code_vals ) ) ; break ; } tmp = fru -> access ? rsp -> data [ 0 ] << 1 : rsp -> data [ 0 ] ; <S2SV_StartBug> memcpy ( ( frubuf + off ) - offset , rsp -> data + 1 , tmp ) ; <S2SV_EndBug> off += tmp ; <S2SV_StartBug> if ( tmp == 0 && off < finish ) <S2SV_EndBug> return 0 ; } while ( off < finish ) ; if ( off < finish ) return - 1 ; return 0 ; }
","<S2SV_ModStart> off = offset ; uint32_t tmp , finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> ; struct ipmi_rs <S2SV_ModStart> size ) { memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> - offset ) ; length = finish - offset <S2SV_ModStart> = 16 ; size_left_in_buffer = length ; <S2SV_ModStart> 0 ] ; if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( ""<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size"" ) ; return - 1 ; } <S2SV_ModStart> += tmp ; size_left_in_buffer -= tmp ;
",ipmitool@ipmitool/e824c23316ae50beb7f7488f2055ac65e8b341f2,CVE-2020-5208,https://github.com/ipmitool/ipmitool/commit/e824c23316ae50beb7f7488f2055ac65e8b341f2,2020-02-05T14:15Z
CWE-369,"CWE-369 static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || <S2SV_StartBug> g -> head <= 0 || <S2SV_EndBug> g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = ""user<S2SV_blank>format"" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM ) DRS -> keep_data = - 1 ; else DRS -> keep_data = 1 ; if ( DRS -> maxblock > user_params [ drive ] . sect || DRS -> maxtrack || ( ( user_params [ drive ] . sect ^ oldStretch ) & ( FD_SWAPSIDES | FD_SECTBASEMASK ) ) ) invalidate_drive ( bdev ) ; else process_fd_request ( ) ; } return 0 ; }
","<S2SV_ModStart> -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) ==
",torvalds@linux/f3554aeb991214cbfafd17d55e2bfddb50282e32,CVE-2019-14284,https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32,2019-07-26T13:15Z
CWE-119,"CWE-119 static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } <S2SV_StartBug> if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) <S2SV_EndBug> return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
","<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
",FFmpeg@FFmpeg/2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,https://github.com/FFmpeg/FFmpeg/commit/2171dfae8c065878a2e130390eb78cf2947a5b69,2017-06-28T06:29Z
CWE-264,"CWE-264 static int raw_cmd_copyin ( int cmd , void __user * param , struct floppy_raw_cmd * * rcmd ) { struct floppy_raw_cmd * ptr ; int ret ; int i ; * rcmd = NULL ; loop : ptr = kmalloc ( sizeof ( struct floppy_raw_cmd ) , GFP_USER ) ; if ( ! ptr ) return - ENOMEM ; * rcmd = ptr ; ret = copy_from_user ( ptr , param , sizeof ( * ptr ) ) ; <S2SV_StartBug> if ( ret ) <S2SV_EndBug> <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ptr -> next = NULL ; ptr -> buffer_length = 0 ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ptr -> cmd_count > 33 ) return - EINVAL ; for ( i = 0 ; i < 16 ; i ++ ) ptr -> reply [ i ] = 0 ; ptr -> resultcode = 0 ; <S2SV_StartBug> ptr -> kernel_data = NULL ; <S2SV_EndBug> if ( ptr -> flags & ( FD_RAW_READ | FD_RAW_WRITE ) ) { if ( ptr -> length <= 0 ) return - EINVAL ; ptr -> kernel_data = ( char * ) fd_dma_mem_alloc ( ptr -> length ) ; fallback_on_nodma_alloc ( & ptr -> kernel_data , ptr -> length ) ; if ( ! ptr -> kernel_data ) return - ENOMEM ; ptr -> buffer_length = ptr -> length ; } if ( ptr -> flags & FD_RAW_WRITE ) { ret = fd_copyin ( ptr -> data , ptr -> kernel_data , ptr -> length ) ; if ( ret ) return ret ; } if ( ptr -> flags & FD_RAW_MORE ) { rcmd = & ( ptr -> next ) ; ptr -> rate &= 0x43 ; goto loop ; } return 0 ; }
","<S2SV_ModStart> ) ) ; ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; param += <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr
",torvalds@linux/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,CVE-2014-1737,https://github.com/torvalds/linux/commit/ef87dbe7614341c2e7bfe8d32fcb7028cc97442c,2014-05-11T21:55Z
CWE-119,"CWE-119 static int http_buf_read ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int len ; len = s -> buf_end - s -> buf_ptr ; if ( len > 0 ) { if ( len > size ) len = size ; memcpy ( buf , s -> buf_ptr , len ) ; s -> buf_ptr += len ; } else { <S2SV_StartBug> int64_t target_end = s -> end_off ? s -> end_off : s -> filesize ; <S2SV_EndBug> <S2SV_StartBug> if ( ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off >= target_end ) return AVERROR_EOF ; len = ffurl_read ( s -> hd , buf , size ) ; <S2SV_StartBug> if ( ! len && ( ! s -> willclose || s -> chunksize < 0 ) && <S2SV_EndBug> target_end >= 0 && s -> off < target_end ) { av_log ( h , AV_LOG_ERROR , <S2SV_StartBug> ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRId64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRId64 ""\\n"" , <S2SV_EndBug> s -> off , target_end ) ; return AVERROR ( EIO ) ; } } if ( len > 0 ) { s -> off += len ; if ( s -> chunksize > 0 ) s -> chunksize -= len ; } return len ; }
","<S2SV_ModStart> } else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , ""Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%"" PRIu64 "",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> ""\\n"" , s
",FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
CWE-19,"CWE-19 int xfs_attr3_leaf_clearflag ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr ; xfs_attr_leaf_name_local_t * name_loc ; int namelen ; char * name ; # endif trace_xfs_attr_leaf_clearflag ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return ( error ) ; leaf = bp -> b_addr ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; ASSERT ( entry -> flags & XFS_ATTR_INCOMPLETE ) ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( args -> index < ichdr . count ) ; ASSERT ( args -> index >= 0 ) ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; namelen = name_loc -> namelen ; name = ( char * ) name_loc -> nameval ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; namelen = name_rmt -> namelen ; name = ( char * ) name_rmt -> name ; } ASSERT ( be32_to_cpu ( entry -> hashval ) == args -> hashval ) ; ASSERT ( namelen == args -> namelen ) ; ASSERT ( memcmp ( name , args -> name , namelen ) == 0 ) ; # endif entry -> flags &= ~ XFS_ATTR_INCOMPLETE ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , sizeof ( * entry ) ) ) ; if ( args -> rmtblkno ) { ASSERT ( ( entry -> flags & XFS_ATTR_LOCAL ) == 0 ) ; name_rmt = xfs_attr3_leaf_name_remote ( leaf , args -> index ) ; name_rmt -> valueblk = cpu_to_be32 ( args -> rmtblkno ) ; <S2SV_StartBug> name_rmt -> valuelen = cpu_to_be32 ( args -> valuelen ) ; <S2SV_EndBug> xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , name_rmt , sizeof ( * name_rmt ) ) ) ; } return xfs_trans_roll ( & args -> trans , args -> dp ) ; }
","<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
CWE-399,"CWE-399 static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE ""rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>"" ""extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n"" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n"" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }
","<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
",torvalds@linux/f54e18f1b831c92f6512d2eedb224cd63d607d3d,CVE-2014-9420,https://github.com/torvalds/linux/commit/f54e18f1b831c92f6512d2eedb224cd63d607d3d,2014-12-26T00:59Z
CWE-416,"CWE-416 static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if ( ! ( cmpt -> data = jas_strdup ( jas_tvparser_getval ( tvp ) ) ) ) { return - 1 ; } break ; } } <S2SV_StartBug> jas_tvparser_destroy ( tvp ) ; <S2SV_EndBug> if ( ! cmpt -> sampperx || ! cmpt -> samppery ) { goto error ; } if ( mif_hdr_addcmpt ( hdr , hdr -> numcmpts , cmpt ) ) { goto error ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> error : if ( cmpt ) { mif_cmpt_destroy ( cmpt ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return - 1 ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
",mdadams@jasper/df5d2867e8004e51e18b89865bc4aa69229227b3,CVE-2015-5221,https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3,2017-07-25T18:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( ""Attached<S2SV_blank>RS2000/TS2020!"" ) ; return 0 ; } info ( ""Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!"" ) ; return - EIO ; }
","<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ""command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed."" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
",torvalds@linux/606142af57dad981b78707234cfbd15f9f7b7125,CVE-2017-8062,https://github.com/torvalds/linux/commit/606142af57dad981b78707234cfbd15f9f7b7125,2017-04-23T05:59Z
CWE-119,"CWE-119 static uint64_t calc_plane_error ( unsigned char * orig , int orig_stride , unsigned char * recon , int recon_stride , unsigned int cols , unsigned int rows ) { unsigned int row , col ; uint64_t total_sse = 0 ; int diff ; for ( row = 0 ; row + 16 <= rows ; row += 16 ) { for ( col = 0 ; col + 16 <= cols ; col += 16 ) { unsigned int sse ; <S2SV_StartBug> vp8_mse16x16 ( orig + col , orig_stride , <S2SV_EndBug> recon + col , recon_stride , & sse ) ; total_sse += sse ; } if ( col < cols ) { unsigned int border_row , border_col ; unsigned char * border_orig = orig ; unsigned char * border_recon = recon ; for ( border_row = 0 ; border_row < 16 ; border_row ++ ) { for ( border_col = col ; border_col < cols ; border_col ++ ) { diff = border_orig [ border_col ] - border_recon [ border_col ] ; total_sse += diff * diff ; } border_orig += orig_stride ; border_recon += recon_stride ; } } orig += orig_stride * 16 ; recon += recon_stride * 16 ; } for ( ; row < rows ; row ++ ) { for ( col = 0 ; col < cols ; col ++ ) { diff = orig [ col ] - recon [ col ] ; total_sse += diff * diff ; } orig += orig_stride ; recon += recon_stride ; } vp8_clear_system_state ( ) ; return total_sse ; }
","<S2SV_ModStart> int sse ; vpx_mse16x16 <S2SV_ModEnd> ( orig +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static __u8 * kye_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { switch ( hdev -> product ) { case USB_DEVICE_ID_KYE_ERGO_525V : <S2SV_StartBug> if ( * rsize >= 74 && <S2SV_EndBug> <S2SV_StartBug> rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && <S2SV_EndBug> rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_I405X : if ( * rsize == EASYPEN_I405X_RDESC_ORIG_SIZE ) { rdesc = easypen_i405x_rdesc_fixed ; * rsize = sizeof ( easypen_i405x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_MOUSEPEN_I608X : if ( * rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE ) { rdesc = mousepen_i608x_rdesc_fixed ; * rsize = sizeof ( mousepen_i608x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_KYE_EASYPEN_M610X : if ( * rsize == EASYPEN_M610X_RDESC_ORIG_SIZE ) { rdesc = easypen_m610x_rdesc_fixed ; * rsize = sizeof ( easypen_m610x_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , ""Genius<S2SV_blank>Gila<S2SV_blank>Gaming<S2SV_blank>Mouse"" ) ; break ; case USB_DEVICE_ID_GENIUS_GX_IMPERATOR : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 83 , ""Genius<S2SV_blank>Gx<S2SV_blank>Imperator<S2SV_blank>Keyboard"" ) ; break ; case USB_DEVICE_ID_GENIUS_MANTICORE : rdesc = kye_consumer_control_fixup ( hdev , rdesc , rsize , 104 , ""Genius<S2SV_blank>Manticore<S2SV_blank>Keyboard"" ) ; break ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>"" ""report<S2SV_blank>descriptor\\n"" ) ; <S2SV_ModEnd> rdesc [ 62 <S2SV_ModStart> [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> ; } break
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
CWE-119,"CWE-119 TEE_Result syscall_cryp_obj_populate ( unsigned long obj , struct utee_attribute * usr_attrs , unsigned long attr_count ) { TEE_Result res ; struct tee_ta_session * sess ; struct tee_obj * o ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * attrs = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_PARAMETERS ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_IMPLEMENTED ; <S2SV_StartBug> attrs = malloc ( sizeof ( TEE_Attribute ) * attr_count ) ; <S2SV_EndBug> if ( ! attrs ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_attrs , attr_count , attrs ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_POPULATE , type_props , attrs , attr_count ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_obj_populate_type ( o , type_props , attrs , attr_count ) ; if ( res == TEE_SUCCESS ) o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; out : free ( attrs ) ; return res ; }
","<S2SV_ModStart> return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
",OP-TEE@optee_os/b60e1cee406a1ff521145ab9534370dfb85dd592,CVE-2019-1010296,https://github.com/OP-TEE/optee_os/commit/b60e1cee406a1ff521145ab9534370dfb85dd592,2019-07-15T18:15Z
CWE-000,"CWE-000 rfbBool SetFormatAndEncodings ( rfbClient * client ) { rfbSetPixelFormatMsg spf ; <S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> int len = 0 ; rfbBool requestCompressLevel = FALSE ; rfbBool requestQualityLevel = FALSE ; rfbBool requestLastRectEncoding = FALSE ; rfbClientProtocolExtension * e ; if ( ! SupportsClient2Server ( client , rfbSetPixelFormat ) ) return TRUE ; spf . type = rfbSetPixelFormat ; spf . pad1 = 0 ; spf . pad2 = 0 ; spf . format = client -> format ; spf . format . redMax = rfbClientSwap16IfLE ( spf . format . redMax ) ; spf . format . greenMax = rfbClientSwap16IfLE ( spf . format . greenMax ) ; spf . format . blueMax = rfbClientSwap16IfLE ( spf . format . blueMax ) ; if ( ! WriteToRFBServer ( client , ( char * ) & spf , sz_rfbSetPixelFormatMsg ) ) return FALSE ; if ( ! SupportsClient2Server ( client , rfbSetEncodings ) ) return TRUE ; se -> type = rfbSetEncodings ; se -> pad = 0 ; se -> nEncodings = 0 ; if ( client -> appData . encodingsString ) { const char * encStr = client -> appData . encodingsString ; int encStrLen ; do { const char * nextEncStr = strchr ( encStr , '<S2SV_blank>' ) ; if ( nextEncStr ) { encStrLen = nextEncStr - encStr ; nextEncStr ++ ; } else { encStrLen = strlen ( encStr ) ; } if ( strncasecmp ( encStr , ""raw"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } else if ( strncasecmp ( encStr , ""copyrect"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG } else if ( strncasecmp ( encStr , ""tight"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; if ( client -> appData . enableJPEG ) requestQualityLevel = TRUE ; # endif # endif } else if ( strncasecmp ( encStr , ""hextile"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ } else if ( strncasecmp ( encStr , ""zlib"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""zlibhex"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlibHex ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""trle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTRLE ) ; } else if ( strncasecmp ( encStr , ""zrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; } else if ( strncasecmp ( encStr , ""zywrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; requestQualityLevel = TRUE ; # endif } else if ( ( strncasecmp ( encStr , ""ultra"" , encStrLen ) == 0 ) || ( strncasecmp ( encStr , ""ultrazip"" , encStrLen ) == 0 ) ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; } else if ( strncasecmp ( encStr , ""corre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; } else if ( strncasecmp ( encStr , ""rre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; } else { rfbClientLog ( ""Unknown<S2SV_blank>encoding<S2SV_blank>\'%.*s\'\\n"" , encStrLen , encStr ) ; } encStr = nextEncStr ; } while ( encStr && se -> nEncodings < MAX_ENCODINGS ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestCompressLevel ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } if ( se -> nEncodings < MAX_ENCODINGS && requestQualityLevel ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } else { if ( SameMachine ( client -> sock ) ) { rfbClientLog ( ""Same<S2SV_blank>machine:<S2SV_blank>preferring<S2SV_blank>raw<S2SV_blank>encoding\\n"" ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; # endif # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } else { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCompressLevel1 ) ; } if ( client -> appData . enableJPEG ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } if ( client -> appData . useRemoteCursor ) { if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRichCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingPointerPos ) ; } if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingKeyboardLedState ) ; if ( se -> nEncodings < MAX_ENCODINGS && client -> canHandleNewFBSize ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingNewFBSize ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestLastRectEncoding ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingLastRect ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedMessages ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedEncodings ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingServerIdentity ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXvp ) ; for ( e = rfbClientExtensions ; e ; e = e -> next ) if ( e -> encodings ) { int * enc ; for ( enc = e -> encodings ; * enc ; enc ++ ) if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( * enc ) ; } len = sz_rfbSetEncodingsMsg + se -> nEncodings * 4 ; se -> nEncodings = rfbClientSwap16IfLE ( se -> nEncodings ) ; <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> return TRUE ; }
","<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes
",LibVNC@libvncserver/23e5cbe6b090d7f22982aee909a6a618174d3c2d,CVE-2020-14399,https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d,2020-06-17T16:15Z
CWE-787,"CWE-787 static int kwajd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mskwajd_header * hdr ) { unsigned char buf [ 16 ] ; int i ; if ( sys -> read ( fh , & buf [ 0 ] , kwajh_SIZEOF ) != kwajh_SIZEOF ) { return MSPACK_ERR_READ ; } if ( ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature1 ] ) != 0x4A41574B ) || ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature2 ] ) != 0xD127F088 ) ) { return MSPACK_ERR_SIGNATURE ; } hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ; hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ; hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ; hdr -> length = 0 ; hdr -> filename = NULL ; hdr -> extra = NULL ; hdr -> extra_length = 0 ; if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) { if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; hdr -> length = EndGetI32 ( & buf [ 0 ] ) ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; } if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { <S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } * fn = '\\0' ; } if ( hdr -> headers & MSKWAJ_HDR_HASEXTRATEXT ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; hdr -> extra = ( char * ) sys -> alloc ( sys , ( size_t ) i + 1 ) ; if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ; if ( sys -> read ( fh , hdr -> extra , i ) != i ) return MSPACK_ERR_READ ; hdr -> extra [ i ] = '\\0' ; hdr -> extra_length = i ; } return MSPACK_ERR_OK ; }
","<S2SV_ModStart> ) ) { int len <S2SV_ModEnd> ; char * <S2SV_ModStart> if ( ! ( hdr -> filename = fn ) ) <S2SV_ModEnd> return MSPACK_ERR_NOMEMORY ; <S2SV_ModStart> return MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( hdr <S2SV_ModStart> { if ( ( len = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> ; if ( ( len = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn --
",kyz@libmspack/0b0ef9344255ff5acfac6b7af09198ac9c9756c8,CVE-2018-14681,https://github.com/kyz/libmspack/commit/0b0ef9344255ff5acfac6b7af09198ac9c9756c8,2018-07-28T23:29Z
CWE-119,"CWE-119 char * cJSON_Print ( cJSON * item ) { <S2SV_StartBug> return print_value ( item , 0 , 1 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> 0 , 1 , 0
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-000,"CWE-000 int main ( int argc , char * * argv ) { char * oldshell ; int nullshell = 0 ; const uid_t uid = getuid ( ) ; struct sinfo info = { 0 } ; struct passwd * pw ; sanitize_env ( ) ; setlocale ( LC_ALL , """" ) ; bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; atexit ( close_stdout ) ; parse_argv ( argc , argv , & info ) ; if ( ! info . username ) { pw = getpwuid ( uid ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( ""you<S2SV_blank>(user<S2SV_blank>%d)<S2SV_blank>don\'t<S2SV_blank>exist."" ) , uid ) ; } else { pw = getpwnam ( info . username ) ; if ( ! pw ) errx ( EXIT_FAILURE , _ ( ""user<S2SV_blank>\\""%s\\""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist."" ) , info . username ) ; } # ifndef HAVE_LIBUSER if ( ! ( is_local ( pw -> pw_name ) ) ) errx ( EXIT_FAILURE , _ ( ""can<S2SV_blank>only<S2SV_blank>change<S2SV_blank>local<S2SV_blank>entries"" ) ) ; # endif # ifdef HAVE_LIBSELINUX if ( is_selinux_enabled ( ) > 0 ) { if ( uid == 0 ) { if ( checkAccess ( pw -> pw_name , PASSWD__CHSH ) != 0 ) { security_context_t user_context ; if ( getprevcon ( & user_context ) < 0 ) user_context = ( security_context_t ) NULL ; errx ( EXIT_FAILURE , _ ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>change<S2SV_blank>the<S2SV_blank>shell<S2SV_blank>of<S2SV_blank>%s"" ) , user_context ? : _ ( ""Unknown<S2SV_blank>user<S2SV_blank>context"" ) , pw -> pw_name ) ; } } if ( setupDefaultContext ( _PATH_PASSWD ) != 0 ) errx ( EXIT_FAILURE , _ ( ""can\'t<S2SV_blank>set<S2SV_blank>default<S2SV_blank>context<S2SV_blank>for<S2SV_blank>%s"" ) , _PATH_PASSWD ) ; } # endif oldshell = pw -> pw_shell ; if ( oldshell == NULL || * oldshell == '\\0' ) { oldshell = _PATH_BSHELL ; nullshell = 1 ; } # ifdef HAVE_LIBUSER if ( geteuid ( ) != getuid ( ) && uid != pw -> pw_uid ) { # else if ( uid != 0 && uid != pw -> pw_uid ) { # endif errno = EACCES ; err ( EXIT_FAILURE , _ ( ""running<S2SV_blank>UID<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>UID<S2SV_blank>of<S2SV_blank>user<S2SV_blank>we\'re<S2SV_blank>"" ""altering,<S2SV_blank>shell<S2SV_blank>change<S2SV_blank>denied"" ) ) ; } if ( uid != 0 && ! get_shell_list ( oldshell ) ) { errno = EACCES ; err ( EXIT_FAILURE , _ ( ""your<S2SV_blank>shell<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>%s,<S2SV_blank>"" ""shell<S2SV_blank>change<S2SV_blank>denied"" ) , _PATH_SHELLS ) ; } printf ( _ ( ""Changing<S2SV_blank>shell<S2SV_blank>for<S2SV_blank>%s.\\n"" ) , pw -> pw_name ) ; # if ! defined ( HAVE_LIBUSER ) && defined ( CHFN_CHSH_PASSWORD ) if ( ! auth_pam ( ""chsh"" , uid , pw -> pw_name ) ) { return EXIT_FAILURE ; } # endif if ( ! info . shell ) { info . shell = ask_new_shell ( _ ( ""New<S2SV_blank>shell"" ) , oldshell ) ; if ( ! info . shell ) return EXIT_SUCCESS ; } check_shell ( info . shell ) ; if ( ! nullshell && strcmp ( oldshell , info . shell ) == 0 ) errx ( EXIT_SUCCESS , _ ( ""Shell<S2SV_blank>not<S2SV_blank>changed."" ) ) ; # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chsh"" , pw -> pw_name , uid , LU_LOGINSHELL , info . shell ) < 0 ) errx ( EXIT_FAILURE , _ ( ""Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later."" ) ) ; # else pw -> pw_shell = info . shell ; <S2SV_StartBug> if ( setpwnam ( pw ) < 0 ) <S2SV_EndBug> err ( EXIT_FAILURE , _ ( ""setpwnam<S2SV_blank>failed\\n"" ""Shell<S2SV_blank>*NOT*<S2SV_blank>changed.<S2SV_blank><S2SV_blank>Try<S2SV_blank>again<S2SV_blank>later."" ) ) ; # endif printf ( _ ( ""Shell<S2SV_blank>changed.\\n"" ) ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> setpwnam ( pw , "".chsh""
",karelzak@util-linux/bde91c85bdc77975155058276f99d2e0f5eab5a9,CVE-2015-5224,https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9,2017-08-23T15:29Z
CWE-119,"CWE-119 static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx -> cfg . rc_target_bitrate ) return res ; if ( img ) res = validate_img ( ctx , img ) ; if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; <S2SV_StartBug> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) <S2SV_EndBug> || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflicting<S2SV_blank>flags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ; vp8_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP8_ALTR_FRAME ; vp8_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp8_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { flags |= VPX_EFLAG_FORCE_KF ; ctx -> fixed_kf_cntr = 1 ; } } if ( ! res && ctx -> cpi ) { unsigned int lib_flags ; YV12_BUFFER_CONFIG sd ; int64_t dst_time_stamp , dst_end_time_stamp ; unsigned long size , cx_data_sz ; unsigned char * cx_data ; unsigned char * cx_data_end ; int comp_data_state = 0 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) ( ( VP8_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; if ( ctx -> base . init_flags & VPX_CODEC_USE_OUTPUT_PARTITION ) ( ( VP8_COMP * ) ctx -> cpi ) -> output_partition = 1 ; lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; dst_time_stamp = pts * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; if ( img != NULL ) { res = image2yuvconfig ( img , & sd ) ; if ( vp8_receive_raw_frame ( ctx -> cpi , ctx -> next_frame_flag | lib_flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) { VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; res = update_error_state ( ctx , & cpi -> common . error ) ; } ctx -> next_frame_flag = 0 ; } cx_data = ctx -> cx_data ; cx_data_sz = ctx -> cx_data_sz ; cx_data_end = ctx -> cx_data + cx_data_sz ; lib_flags = 0 ; while ( cx_data_sz >= ctx -> cx_data_sz / 2 ) { comp_data_state = vp8_get_compressed_data ( ctx -> cpi , & lib_flags , & size , cx_data , cx_data_end , & dst_time_stamp , & dst_end_time_stamp , ! img ) ; if ( comp_data_state == VPX_CODEC_CORRUPT_FRAME ) return VPX_CODEC_CORRUPT_FRAME ; else if ( comp_data_state == - 1 ) break ; if ( size ) { vpx_codec_pts_t round , delta ; vpx_codec_cx_pkt_t pkt ; VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; <S2SV_StartBug> round = ( vpx_codec_pts_t ) 1000000 <S2SV_EndBug> * ctx -> cfg . g_timebase . num / 2 - 1 ; delta = ( dst_end_time_stamp - dst_time_stamp ) ; pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ; pkt . data . frame . duration = ( unsigned long ) ( ( delta * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) ; pkt . data . frame . flags = lib_flags << 16 ; if ( lib_flags & FRAMEFLAGS_KEY ) pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; if ( ! cpi -> common . show_frame ) { pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen * ctx -> cfg . g_timebase . den + round ) / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; pkt . data . frame . duration = 0 ; } if ( cpi -> droppable ) pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; if ( cpi -> output_partition ) { int i ; const int num_partitions = ( 1 << cpi -> common . multi_token_partition ) + 1 ; pkt . data . frame . flags |= VPX_FRAME_IS_FRAGMENT ; for ( i = 0 ; i < num_partitions ; ++ i ) { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING pkt . data . frame . buf = cpi -> partition_d [ i ] ; # else pkt . data . frame . buf = cx_data ; cx_data += cpi -> partition_sz [ i ] ; cx_data_sz -= cpi -> partition_sz [ i ] ; # endif pkt . data . frame . sz = cpi -> partition_sz [ i ] ; pkt . data . frame . partition_id = i ; if ( i == ( num_partitions - 1 ) ) pkt . data . frame . flags &= ~ VPX_FRAME_IS_FRAGMENT ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING cx_data_sz -= ctx -> cx_data_sz / 2 ; # endif } else { pkt . data . frame . buf = cx_data ; pkt . data . frame . sz = size ; pkt . data . frame . partition_id = - 1 ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; cx_data += size ; cx_data_sz -= size ; } } } } return res ; }
","<S2SV_ModStart> ; if ( ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> if ( ctx <S2SV_ModStart> ( vpx_codec_pts_t ) 10000000 <S2SV_ModEnd> * ctx ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { <S2SV_StartBug> int namelen = strlen ( name ) ; <S2SV_EndBug> int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; <S2SV_StartBug> data ++ ; <S2SV_EndBug> for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; <S2SV_StartBug> if ( ! size ) <S2SV_EndBug> break ; if ( size < 0 || size >= data_end - data ) return - 1 ; data += size ; <S2SV_StartBug> if ( size == namelen && ! memcmp ( data - size , name , namelen ) ) { <S2SV_EndBug> switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : <S2SV_StartBug> snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; <S2SV_EndBug> break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
","<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
",FFmpeg@FFmpeg/ffcc82219cef0928bed2d558b19ef6ea35634130,CVE-2017-11665,https://github.com/FFmpeg/FFmpeg/commit/ffcc82219cef0928bed2d558b19ef6ea35634130,2017-07-27T12:29Z
CWE-399,"CWE-399 static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }
","<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
",torvalds@linux/0b79459b482e85cb7426aa7da683a9f2c97aeae1,CVE-2013-1797,https://github.com/torvalds/linux/commit/0b79459b482e85cb7426aa7da683a9f2c97aeae1,2013-03-22T11:59Z
CWE-476,"CWE-476 int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CC\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
","<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
",torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z
CWE-125,"CWE-125 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; <S2SV_StartBug> BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( unsigned char ) ) ; <S2SV_EndBug> if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
",ImageMagick@ImageMagick/1bc1fd0ff8c555841c78829217ac81fa0598255d,CVE-2016-10071,https://github.com/ImageMagick/ImageMagick/commit/1bc1fd0ff8c555841c78829217ac81fa0598255d,2017-03-02T21:59Z
CWE-119,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { unsigned x , y ; AVFilterContext * ctx = inlink -> dst ; VignetteContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( s -> eval_mode == EVAL_MODE_FRAME ) update_context ( s , inlink , in ) ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_RGB ) { uint8_t * dst = out -> data [ 0 ] ; const uint8_t * src = in -> data [ 0 ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ 0 ] ; const int src_linesize = in -> linesize [ 0 ] ; const int fmap_linesize = s -> fmap_linesize ; for ( y = 0 ; y < inlink -> h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < inlink -> w ; x ++ , dstp += 3 , srcp += 3 ) { const float f = fmap [ x ] ; dstp [ 0 ] = av_clip_uint8 ( srcp [ 0 ] * f + get_dither_value ( s ) ) ; dstp [ 1 ] = av_clip_uint8 ( srcp [ 1 ] * f + get_dither_value ( s ) ) ; dstp [ 2 ] = av_clip_uint8 ( srcp [ 2 ] * f + get_dither_value ( s ) ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize ; } } else { int plane ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> uint8_t * dst = out -> data [ plane ] ; const uint8_t * src = in -> data [ plane ] ; const float * fmap = s -> fmap ; const int dst_linesize = out -> linesize [ plane ] ; const int src_linesize = in -> linesize [ plane ] ; const int fmap_linesize = s -> fmap_linesize ; const int chroma = plane == 1 || plane == 2 ; const int hsub = chroma ? s -> desc -> log2_chroma_w : 0 ; const int vsub = chroma ? s -> desc -> log2_chroma_h : 0 ; const int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; const int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; for ( y = 0 ; y < h ; y ++ ) { uint8_t * dstp = dst ; const uint8_t * srcp = src ; for ( x = 0 ; x < w ; x ++ ) { const double dv = get_dither_value ( s ) ; if ( chroma ) * dstp ++ = av_clip_uint8 ( fmap [ x << hsub ] * ( * srcp ++ - 127 ) + 127 + dv ) ; else * dstp ++ = av_clip_uint8 ( fmap [ x ] * * srcp ++ + dv ) ; } dst += dst_linesize ; src += src_linesize ; fmap += fmap_linesize << vsub ; } } } return ff_filter_frame ( outlink , out ) ; }
","<S2SV_ModStart> in -> data [ plane ] && in -> linesize
",FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
CWE-362,"CWE-362 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <S2SV_StartBug> if ( ! head ) { <S2SV_EndBug> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <S2SV_StartBug> } <S2SV_EndBug> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
","<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
",torvalds@linux/12ca6ad2e3a896256f086497a7c7406a547ee373,CVE-2015-8963,https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373,2016-11-16T05:59Z
CWE-674,"CWE-674 static int bgp_attr_print ( netdissect_options * ndo , <S2SV_StartBug> u_int atype , const u_char * pptr , u_int len ) <S2SV_EndBug> { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) && EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( bgp_aigp_values , ""Unknown"" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) <S2SV_EndBug> return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }
","<S2SV_ModStart> , u_int len , const unsigned attr_set_level <S2SV_ModStart> } if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , ""(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)"" ) ) ; else if ( <S2SV_ModStart> tptr , alen , attr_set_level + 1
",the-tcpdump-group@tcpdump/af2cf04a9394c1a56227c2289ae8da262828294a,CVE-2018-16300,https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a,2019-10-03T16:15Z
CWE-59,"CWE-59 int pidfile_write ( const char * pid_file , int pid ) { FILE * pidfile = NULL ; <S2SV_StartBug> int pidfd = creat ( pid_file , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( pidfd != - 1 ) pidfile = fdopen ( pidfd , ""w"" ) ; if ( ! pidfile ) { log_message ( LOG_INFO , ""pidfile_write<S2SV_blank>:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>pidfile"" , pid_file ) ; return 0 ; } fprintf ( pidfile , ""%d\\n"" , pid ) ; fclose ( pidfile ) ; return 1 ; }
","<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |
",acassen@keepalived/04f2d32871bb3b11d7dc024039952f2fe2750306,CVE-2018-19044,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,2018-11-08T20:29Z
CWE-352,"CWE-352 static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monit<S2SV_blank>runtime<S2SV_blank>status</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'status-table\'><tr>"" ""<th<S2SV_blank>width=\'40%%\'>Parameter</th>"" ""<th<S2SV_blank>width=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Monit<S2SV_blank>ID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Process<S2SV_blank>id</td><td>%d</td></tr>"" , pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Effective<S2SV_blank>user<S2SV_blank>running<S2SV_blank>Monit</td>"" ""<td>%s</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>State<S2SV_blank>file</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , ( Run . flags & Run_Log ) ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>syslog</td><td>%s</td></tr>"" , ( Run . flags & Run_UseSyslog ) ? ""True"" : ""False"" ) ; if ( Run . eventlist_dir ) { if ( Run . eventlist_slots < 0 ) snprintf ( buf , STRLEN , ""unlimited"" ) ; else snprintf ( buf , STRLEN , ""%d"" , Run . eventlist_slots ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Event<S2SV_blank>queue</td>"" ""<td>base<S2SV_blank>directory<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>%d<S2SV_blank>slots</td></tr>"" , Run . eventlist_dir , Run . eventlist_slots ) ; } # ifdef HAVE_OPENSSL { const char * options = Ssl_printOptions ( & ( Run . ssl ) , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>SSL<S2SV_blank>options</td><td>%s</td></tr>"" , options ) ; } # endif if ( Run . mmonits ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>M/Monit<S2SV_blank>server(s)</td><td>"" ) ; for ( Mmonit_T c = Run . mmonits ; c ; c = c -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>with<S2SV_blank>timeout<S2SV_blank>%s"" , c -> url -> url , Str_milliToTime ( c -> timeout , ( char [ 23 ] ) { } ) ) ; # ifdef HAVE_OPENSSL if ( c -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & c -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( c -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ c -> ssl . checksumType ] , c -> ssl . checksum ) ; } # endif if ( c -> url -> user ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>credentials"" ) ; if ( c -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . mailservers ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Mail<S2SV_blank>server(s)</td><td>"" ) ; for ( MailServer_T mta = Run . mailservers ; mta ; mta = mta -> next ) { StringBuffer_append ( res -> outputbuffer , ""%s:%d"" , mta -> host , mta -> port ) ; # ifdef HAVE_OPENSSL if ( mta -> ssl . flags ) { StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>using<S2SV_blank>SSL/TLS"" ) ; const char * options = Ssl_printOptions ( & mta -> ssl , ( char [ STRLEN ] ) { } , STRLEN ) ; if ( options && * options ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>with<S2SV_blank>options<S2SV_blank>{%s}"" , options ) ; if ( mta -> ssl . checksum ) StringBuffer_append ( res -> outputbuffer , ""<S2SV_blank>and<S2SV_blank>certificate<S2SV_blank>checksum<S2SV_blank>%s<S2SV_blank>equal<S2SV_blank>to<S2SV_blank>\'%s\'"" , checksumnames [ mta -> ssl . checksumType ] , mta -> ssl . checksum ) ; } # endif if ( mta -> next ) StringBuffer_append ( res -> outputbuffer , ""</td></tr><tr><td>&nbsp;</td><td>"" ) ; } StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . from ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>from</td><td>"" ) ; if ( Run . MailFormat . from -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . from -> name , Run . MailFormat . from -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . from -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . replyto ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>reply<S2SV_blank>to</td><td>"" ) ; if ( Run . MailFormat . replyto -> name ) StringBuffer_append ( res -> outputbuffer , ""%s<S2SV_blank>&lt;%s&gt;"" , Run . MailFormat . replyto -> name , Run . MailFormat . replyto -> address ) ; else StringBuffer_append ( res -> outputbuffer , ""%s"" , Run . MailFormat . replyto -> address ) ; StringBuffer_append ( res -> outputbuffer , ""</td></tr>"" ) ; } if ( Run . MailFormat . subject ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>subject</td><td>%s</td></tr>"" , Run . MailFormat . subject ) ; if ( Run . MailFormat . message ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Default<S2SV_blank>mail<S2SV_blank>message</td><td>%s</td></tr>"" , Run . MailFormat . message ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>Send/Expect<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . sendExpectBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>file<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . fileContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>HTTP<S2SV_blank>content<S2SV_blank>buffer</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . httpContentBuffer , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>program<S2SV_blank>output</td><td>%s</td></tr>"" , Str_bytesToSize ( Run . limits . programOutput , buf ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>network<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . networkTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>check<S2SV_blank>program<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . programTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>stop<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . stopTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>start<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . startTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Limit<S2SV_blank>for<S2SV_blank>service<S2SV_blank>restart<S2SV_blank>timeout</td><td>%s</td></tr>"" , Str_milliToTime ( Run . limits . restartTimeout , ( char [ 23 ] ) { } ) ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>On<S2SV_blank>reboot</td><td>%s</td></tr>"" , onrebootnames [ Run . onreboot ] ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Poll<S2SV_blank>time</td><td>%d<S2SV_blank>seconds<S2SV_blank>with<S2SV_blank>start<S2SV_blank>delay<S2SV_blank>%d<S2SV_blank>seconds</td></tr>"" , Run . polltime , Run . startdelay ) ; if ( Run . httpd . flags & Httpd_Net ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>bind<S2SV_blank>address</td><td>%s</td></tr>"" , Run . httpd . socket . net . address ? Run . httpd . socket . net . address : ""Any/All"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>portnumber</td><td>%d</td></tr>"" , Run . httpd . socket . net . port ) ; } else if ( Run . httpd . flags & Httpd_Unix ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>unix<S2SV_blank>socket</td><td>%s</td></tr>"" , Run . httpd . socket . unix . path ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>signature</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Signature ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Use<S2SV_blank>ssl<S2SV_blank>encryption</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_Ssl ? ""True"" : ""False"" ) ; if ( Run . httpd . flags & Httpd_Ssl ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>PEM<S2SV_blank>key/certificate<S2SV_blank>file</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . pem ) ; if ( Run . httpd . socket . net . ssl . clientpem != NULL ) { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Enabled"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certificate<S2SV_blank>file"" ""</td><td>%s</td></tr>"" , Run . httpd . socket . net . ssl . clientpem ) ; } else { StringBuffer_append ( res -> outputbuffer , ""<tr><td>Client<S2SV_blank>PEM<S2SV_blank>key/certification"" ""</td><td>%s</td></tr>"" , ""Disabled"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>Allow<S2SV_blank>self<S2SV_blank>certified<S2SV_blank>certificates<S2SV_blank>"" ""</td><td>%s</td></tr>"" , Run . httpd . flags & Httpd_AllowSelfSignedCertificates ? ""True"" : ""False"" ) ; } StringBuffer_append ( res -> outputbuffer , ""<tr><td>httpd<S2SV_blank>auth.<S2SV_blank>style</td><td>%s</td></tr>"" , Run . httpd . credentials && Engine_hasAllow ( ) ? ""Basic<S2SV_blank>Authentication<S2SV_blank>and<S2SV_blank>Host/Net<S2SV_blank>allow<S2SV_blank>list"" : Run . httpd . credentials ? ""Basic<S2SV_blank>Authentication"" : Engine_hasAllow ( ) ? ""Host/Net<S2SV_blank>allow<S2SV_blank>list"" : ""No<S2SV_blank>authentication"" ) ; print_alerts ( res , Run . maillist ) ; StringBuffer_append ( res -> outputbuffer , ""</table>"" ) ; if ( ! is_readonly ( req ) ) { StringBuffer_append ( res -> outputbuffer , ""<table<S2SV_blank>id=\'buttons\'><tr>"" ) ; StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td<S2SV_blank>style=\'color:red;\'><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" <S2SV_EndBug> ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<td><form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank><input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; if ( ( Run . flags & Run_Log ) && ! ( Run . flags & Run_UseSyslog ) ) { StringBuffer_append ( res -> outputbuffer , <S2SV_StartBug> ""<td><form<S2SV_blank>method=GET<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank><input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'></form></td>"" ) ; <S2SV_EndBug> } StringBuffer_append ( res -> outputbuffer , ""</tr></table>"" ) ; } do_foot ( res ) ; }
","<S2SV_ModStart> -> outputbuffer , ""<td<S2SV_blank>style=\'color:red;\'>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , ""<td>"" ""<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>"" ""<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>"" ""<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>"" ""</form>"" ""</td>"" , res -> token <S2SV_ModEnd> ) ; }
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
CWE-59,"CWE-59 static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , <S2SV_StartBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , <S2SV_EndBug> { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_RW , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RW , ""sysfs"" , ""%r/sys"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_RO , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys"" , ""sysfs"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys"" , ""%r/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""sysfs"" , ""%r/sys/devices/virtual/net"" , ""sysfs"" , 0 , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , ""%r/sys/devices/virtual/net/devices/virtual/net"" , ""%r/sys/devices/virtual/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_SYS_MASK , LXC_AUTO_SYS_MIXED , NULL , ""%r/sys/devices/virtual/net"" , NULL , MS_REMOUNT | MS_BIND | MS_NOSUID | MS_NODEV | MS_NOEXEC , NULL } , { 0 , 0 , NULL , NULL , NULL , 0 , NULL } } ; for ( i = 0 ; default_mounts [ i ] . match_mask ; i ++ ) { if ( ( flags & default_mounts [ i ] . match_mask ) == default_mounts [ i ] . match_flag ) { char * source = NULL ; char * destination = NULL ; int saved_errno ; unsigned long mflags ; if ( default_mounts [ i ] . source ) { source = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . source ) ; if ( ! source ) { SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; return - 1 ; } } if ( default_mounts [ i ] . destination ) { destination = lxc_string_replace ( ""%r"" , conf -> rootfs . path ? conf -> rootfs . mount : """" , default_mounts [ i ] . destination ) ; if ( ! destination ) { saved_errno = errno ; SYSERROR ( ""memory<S2SV_blank>allocation<S2SV_blank>error"" ) ; free ( source ) ; errno = saved_errno ; return - 1 ; } } mflags = add_required_remount_flags ( source , destination , default_mounts [ i ] . flags ) ; <S2SV_StartBug> r = mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options ) ; <S2SV_EndBug> saved_errno = errno ; if ( r < 0 && errno == ENOENT ) { INFO ( ""Mount<S2SV_blank>source<S2SV_blank>or<S2SV_blank>target<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>doesn\'t<S2SV_blank>exist.<S2SV_blank>Skipping."" , source , destination ) ; r = 0 ; } else if ( r < 0 ) SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>flags<S2SV_blank>%lu"" , source , destination , mflags ) ; free ( source ) ; free ( destination ) ; if ( r < 0 ) { errno = saved_errno ; return - 1 ; } } } if ( flags & LXC_AUTO_CGROUP_MASK ) { int cg_flags ; cg_flags = flags & LXC_AUTO_CGROUP_MASK ; if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC ) { int has_sys_admin = 0 ; if ( ! lxc_list_empty ( & conf -> keepcaps ) ) { has_sys_admin = in_caplist ( CAP_SYS_ADMIN , & conf -> keepcaps ) ; } else { has_sys_admin = ! in_caplist ( CAP_SYS_ADMIN , & conf -> caps ) ; } if ( cg_flags == LXC_AUTO_CGROUP_NOSPEC ) { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED ; } else { cg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED ; } } if ( ! cgroup_mount ( conf -> rootfs . path ? conf -> rootfs . mount : """" , handler , cg_flags ) ) { SYSERROR ( ""error<S2SV_blank>mounting<S2SV_blank>/sys/fs/cgroup"" ) ; return - 1 ; } } return 0 ; }
","<S2SV_ModStart> , ""%r/proc/sys/net"" , ""%r/proc/tty"" <S2SV_ModEnd> , NULL , <S2SV_ModStart> , LXC_AUTO_PROC_MIXED , ""%r/proc/tty"" <S2SV_ModEnd> , ""%r/proc/sys/net"" , <S2SV_ModStart> ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-125,"CWE-125 static int add_ast_fields ( void ) { PyObject * empty_tuple , * d ; if ( PyType_Ready ( & AST_type ) < 0 ) return - 1 ; d = AST_type . tp_dict ; empty_tuple = PyTuple_New ( 0 ) ; if ( ! empty_tuple || <S2SV_StartBug> PyDict_SetItemString ( d , ""_fields"" , empty_tuple ) < 0 || <S2SV_EndBug> <S2SV_StartBug> PyDict_SetItemString ( d , ""_attributes"" , empty_tuple ) < 0 ) { <S2SV_EndBug> Py_XDECREF ( empty_tuple ) ; return - 1 ; } Py_DECREF ( empty_tuple ) ; return 0 ; }
","<S2SV_ModStart> ! empty_tuple || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__fields <S2SV_ModEnd> , empty_tuple ) <S2SV_ModStart> < 0 || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__attributes <S2SV_ModEnd> , empty_tuple )
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( ""share_creds(%p{%d,%d})"" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }
","<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
",torvalds@linux/79549c6dfda0603dba9a70a53467ce62d9335c33,CVE-2012-2745,https://github.com/torvalds/linux/commit/79549c6dfda0603dba9a70a53467ce62d9335c33,2012-08-09T10:29Z
CWE-119,"CWE-119 void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) src_pitch ; memcpy <S2SV_ModEnd> ( dest ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static inline signed short ReadPropertyMSBShort ( const unsigned char * * p , size_t * length ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 2 ] ; unsigned short value ; if ( * length < 2 ) return ( ( unsigned short ) ~ 0 ) ; for ( i = 0 ; i < 2 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <S2SV_StartBug> value = ( unsigned short ) ( buffer [ 0 ] << 8 ) ; <S2SV_EndBug> <S2SV_StartBug> value |= buffer [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
","<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 8 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
",ImageMagick@ImageMagick/d8ab7f046587f2e9f734b687ba7e6e10147c294b,CVE-2016-5842,https://github.com/ImageMagick/ImageMagick/commit/d8ab7f046587f2e9f734b687ba7e6e10147c294b,2016-12-13T15:59Z
CWE-120,"CWE-120 bool zx_confirmZxLiquidTx ( uint32_t data_total , const EthereumSignTx * msg ) { ( void ) data_total ; const TokenType * token ; char constr1 [ 40 ] , constr2 [ 40 ] , * arStr = """" ; uint8_t * tokenAddress , * deadlineBytes ; bignum256 tokenAmount , tokenMinAmount , ethMinAmount ; uint64_t deadline ; if ( isAddLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>add<S2SV_blank>liquidity"" ; } else if ( isRemoveLiquidityEthCall ( msg ) ) { arStr = ""uniswap<S2SV_blank>remove<S2SV_blank>liquidity"" ; } else { return false ; } tokenAddress = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 32 - 20 ) ; token = tokenByChainAddress ( msg -> chain_id , tokenAddress ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 32 , 32 , & tokenAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 2 * 32 , 32 , & tokenMinAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 3 * 32 , 32 , & ethMinAmount ) ; deadlineBytes = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 6 * 32 - 8 ) ; deadline = ( ( uint64_t ) deadlineBytes [ 0 ] << 8 * 7 ) | ( ( uint64_t ) deadlineBytes [ 1 ] << 8 * 6 ) | ( ( uint64_t ) deadlineBytes [ 2 ] << 8 * 5 ) | ( ( uint64_t ) deadlineBytes [ 3 ] << 8 * 4 ) | ( ( uint64_t ) deadlineBytes [ 4 ] << 8 * 3 ) | ( ( uint64_t ) deadlineBytes [ 5 ] << 8 * 2 ) | ( ( uint64_t ) deadlineBytes [ 6 ] << 8 * 1 ) | ( ( uint64_t ) deadlineBytes [ 7 ] ) ; char tokbuf [ 32 ] ; ethereumFormatAmount ( & tokenAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; ethereumFormatAmount ( & tokenMinAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr2 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""%s\\nMinimum<S2SV_blank>%s"" , constr1 , constr2 ) ; if ( ! confirmFromAccountMatch ( msg , arStr ) ) { return false ; } ethereumFormatAmount ( & ethMinAmount , NULL , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( constr1 , 32 , ""%s"" , tokbuf ) ; confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Minimum<S2SV_blank>%s"" , constr1 ) ; <S2SV_StartBug> snprintf ( constr1 , 32 , ""%lld"" , deadline ) ; <S2SV_EndBug> confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput , arStr , ""Deadline<S2SV_blank>%s"" , ctime ( ( const time_t * ) & deadline ) ) ; return true ; }
","<S2SV_ModStart> constr1 ) ; <S2SV_ModEnd> confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput
",keepkey@keepkey-firmware/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,CVE-2021-31616,https://github.com/keepkey/keepkey-firmware/commit/e49d45594002d4d3fbc1f03488e6dfc0a0a65836,2021-05-06T13:15Z
CWE-119,"CWE-119 int tmx_check_pretran ( sip_msg_t * msg ) { unsigned int chid ; unsigned int slotid ; int dsize ; struct via_param * vbr ; str scallid ; str scseqmet ; str scseqnum ; str sftag ; str svbranch = { NULL , 0 } ; pretran_t * it ; if ( _tmx_ptran_table == NULL ) { LM_ERR ( ""pretran<S2SV_blank>hash<S2SV_blank>table<S2SV_blank>not<S2SV_blank>initialized<S2SV_blank>yet\\n"" ) ; return - 1 ; } if ( get_route_type ( ) != REQUEST_ROUTE ) { LM_ERR ( ""invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>in<S2SV_blank>request<S2SV_blank>route\\n"" ) ; return - 1 ; } if ( msg -> first_line . type != SIP_REQUEST ) { LM_ERR ( ""invalid<S2SV_blank>usage<S2SV_blank>-<S2SV_blank>not<S2SV_blank>a<S2SV_blank>sip<S2SV_blank>request\\n"" ) ; return - 1 ; } if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>required<S2SV_blank>headers\\n"" ) ; return - 1 ; } if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>cseq<S2SV_blank>headers\\n"" ) ; return - 1 ; } if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) { LM_DBG ( ""no<S2SV_blank>pre-transaction<S2SV_blank>management<S2SV_blank>for<S2SV_blank>ACK<S2SV_blank>or<S2SV_blank>CANCEL\\n"" ) ; return - 1 ; } if ( msg -> via1 == 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>Via<S2SV_blank>header\\n"" ) ; return - 1 ; } if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>From<S2SV_blank>header\\n"" ) ; return - 1 ; } if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>callid<S2SV_blank>headers\\n"" ) ; return - 1 ; } vbr = msg -> via1 -> branch ; scallid = msg -> callid -> body ; trim ( & scallid ) ; scseqmet = get_cseq ( msg ) -> method ; trim ( & scseqmet ) ; scseqnum = get_cseq ( msg ) -> number ; trim ( & scseqnum ) ; sftag = get_from ( msg ) -> tag_value ; trim ( & sftag ) ; chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ; slotid = chid & ( _tmx_ptran_size - 1 ) ; if ( unlikely ( _tmx_proc_ptran == NULL ) ) { _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ; if ( _tmx_proc_ptran == NULL ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>structure\\n"" ) ; return - 1 ; } memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ; _tmx_proc_ptran -> pid = my_pid ( ) ; } dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ; if ( likely ( vbr != NULL ) ) { svbranch = vbr -> value ; trim ( & svbranch ) ; <S2SV_StartBug> dsize += svbranch . len ; <S2SV_EndBug> } if ( dsize < 256 ) dsize = 256 ; tmx_pretran_unlink ( ) ; if ( dsize > _tmx_proc_ptran -> dbuf . len ) { if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ; _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ; if ( _tmx_proc_ptran -> dbuf . s == NULL ) { LM_ERR ( ""not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>pretran<S2SV_blank>data\\n"" ) ; return - 1 ; } _tmx_proc_ptran -> dbuf . len = dsize ; } _tmx_proc_ptran -> hid = chid ; _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ; _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ; memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ; _tmx_proc_ptran -> callid . len = scallid . len ; _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ; _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ; memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ; _tmx_proc_ptran -> ftag . len = sftag . len ; _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ; _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ; _tmx_proc_ptran -> cseqnum . len = scseqnum . len ; _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ; _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ; memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ; _tmx_proc_ptran -> cseqmet . len = scseqmet . len ; _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ; if ( likely ( vbr != NULL ) ) { _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ; memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ; _tmx_proc_ptran -> vbranch . len = svbranch . len ; _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ; } else { _tmx_proc_ptran -> vbranch . s = NULL ; _tmx_proc_ptran -> vbranch . len = 0 ; } lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ; it = _tmx_ptran_table [ slotid ] . plist ; tmx_pretran_link_safe ( slotid ) ; for ( ; it != NULL ; it = it -> next ) { if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) { if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ; if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ; if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ; } if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ; if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ; LM_DBG ( ""matched<S2SV_blank>another<S2SV_blank>pre-transaction<S2SV_blank>by<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>[%.*s]\\n"" , it -> pid , it -> callid . len , it -> callid . s ) ; lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 1 ; } lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ; return 0 ; }
","<S2SV_ModStart> svbranch . len + 1
",kamailio@kamailio/e1d8008a09d9390ebaf698abe8909e10dfec4097,CVE-2018-8828,https://github.com/kamailio/kamailio/commit/e1d8008a09d9390ebaf698abe8909e10dfec4097,2018-03-20T20:29Z
CWE-416,"CWE-416 static int usb_audio_probe ( struct usb_interface * intf , const struct usb_device_id * usb_id ) { struct usb_device * dev = interface_to_usbdev ( intf ) ; const struct snd_usb_audio_quirk * quirk = ( const struct snd_usb_audio_quirk * ) usb_id -> driver_info ; struct snd_usb_audio * chip ; int i , err ; struct usb_host_interface * alts ; int ifnum ; u32 id ; alts = & intf -> altsetting [ 0 ] ; ifnum = get_iface_desc ( alts ) -> bInterfaceNumber ; id = USB_ID ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( get_alias_id ( dev , & id ) ) quirk = get_alias_quirk ( dev , id ) ; if ( quirk && quirk -> ifnum >= 0 && ifnum != quirk -> ifnum ) return - ENXIO ; err = snd_usb_apply_boot_quirk ( dev , intf , quirk , id ) ; if ( err < 0 ) return err ; chip = NULL ; mutex_lock ( & register_mutex ) ; for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) { if ( usb_chip [ i ] && usb_chip [ i ] -> dev == dev ) { if ( atomic_read ( & usb_chip [ i ] -> shutdown ) ) { dev_err ( & dev -> dev , ""USB<S2SV_blank>device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>the<S2SV_blank>shutdown<S2SV_blank>state,<S2SV_blank>cannot<S2SV_blank>create<S2SV_blank>a<S2SV_blank>card<S2SV_blank>instance\\n"" ) ; err = - EIO ; goto __error ; } chip = usb_chip [ i ] ; atomic_inc ( & chip -> active ) ; break ; } } if ( ! chip ) { for ( i = 0 ; i < SNDRV_CARDS ; i ++ ) if ( ! usb_chip [ i ] && ( vid [ i ] == - 1 || vid [ i ] == USB_ID_VENDOR ( id ) ) && ( pid [ i ] == - 1 || pid [ i ] == USB_ID_PRODUCT ( id ) ) ) { if ( enable [ i ] ) { err = snd_usb_audio_create ( intf , dev , i , quirk , id , & chip ) ; if ( err < 0 ) goto __error ; chip -> pm_intf = intf ; break ; } else if ( vid [ i ] != - 1 || pid [ i ] != - 1 ) { dev_info ( & dev -> dev , ""device<S2SV_blank>(%04x:%04x)<S2SV_blank>is<S2SV_blank>disabled\\n"" , USB_ID_VENDOR ( id ) , USB_ID_PRODUCT ( id ) ) ; err = - ENOENT ; goto __error ; } } if ( ! chip ) { dev_err ( & dev -> dev , ""no<S2SV_blank>available<S2SV_blank>usb<S2SV_blank>audio<S2SV_blank>device\\n"" ) ; err = - ENODEV ; goto __error ; } } dev_set_drvdata ( & dev -> dev , chip ) ; if ( ! chip -> ctrl_intf ) chip -> ctrl_intf = alts ; chip -> txfr_quirk = 0 ; err = 1 ; if ( quirk && quirk -> ifnum != QUIRK_NO_INTERFACE ) { err = snd_usb_create_quirk ( chip , intf , & usb_audio_driver , quirk ) ; if ( err < 0 ) goto __error ; } if ( err > 0 ) { err = snd_usb_create_streams ( chip , ifnum ) ; if ( err < 0 ) goto __error ; err = snd_usb_create_mixer ( chip , ifnum , ignore_ctl_error ) ; if ( err < 0 ) goto __error ; } err = snd_card_register ( chip -> card ) ; if ( err < 0 ) goto __error ; usb_chip [ chip -> index ] = chip ; chip -> num_interfaces ++ ; usb_set_intfdata ( intf , chip ) ; atomic_dec ( & chip -> active ) ; mutex_unlock ( & register_mutex ) ; return 0 ; __error : if ( chip ) { <S2SV_StartBug> if ( ! chip -> num_interfaces ) <S2SV_EndBug> snd_card_free ( chip -> card ) ; <S2SV_StartBug> atomic_dec ( & chip -> active ) ; <S2SV_EndBug> } mutex_unlock ( & register_mutex ) ; return err ; }
","<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (
",torvalds@linux/5f8cf712582617d523120df67d392059eaf2fc4b,CVE-2018-19824,https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b,2018-12-03T17:29Z
CWE-20,"CWE-20 error_t webSocketParseHeaderField ( WebSocket * webSocket , char_t * line ) { char_t * separator ; char_t * name ; char_t * value ; WebSocketHandshakeContext * handshakeContext ; handshakeContext = & webSocket -> handshakeContext ; TRACE_DEBUG ( ""%s"" , line ) ; <S2SV_StartBug> separator = strchr ( line , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( line ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( ! osStrcasecmp ( name , ""Upgrade"" ) ) { if ( ! osStrcasecmp ( value , ""websocket"" ) ) handshakeContext -> upgradeWebSocket = TRUE ; } else if ( ! osStrcasecmp ( name , ""Connection"" ) ) { webSocketParseConnectionField ( webSocket , value ) ; } else if ( ! osStrcasecmp ( name , ""Sec-WebSocket-Key"" ) ) { if ( webSocket -> endpoint == WS_ENDPOINT_SERVER ) { strSafeCopy ( handshakeContext -> clientKey , value , WEB_SOCKET_CLIENT_KEY_SIZE + 1 ) ; } } else if ( ! osStrcasecmp ( name , ""Sec-WebSocket-Accept"" ) ) { if ( webSocket -> endpoint == WS_ENDPOINT_CLIENT ) { strSafeCopy ( handshakeContext -> serverKey , value , WEB_SOCKET_SERVER_KEY_SIZE + 1 ) ; } } # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""WWW-Authenticate"" ) ) { webSocketParseAuthenticateField ( webSocket , value ) ; } # endif else if ( ! osStrcasecmp ( name , ""Content-Length"" ) ) { handshakeContext -> contentLength = osStrtoul ( value , NULL , 10 ) ; } } return NO_ERROR ; }
","<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( line ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-000,"CWE-000 <S2SV_StartBug> static void encode_share_access ( struct xdr_stream * xdr , int open_flags ) <S2SV_EndBug> { __be32 * p ; RESERVE_SPACE ( 8 ) ; <S2SV_StartBug> switch ( open_flags & ( FMODE_READ | FMODE_WRITE ) ) { <S2SV_EndBug> case FMODE_READ : WRITE32 ( NFS4_SHARE_ACCESS_READ ) ; break ; case FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_WRITE ) ; break ; case FMODE_READ | FMODE_WRITE : WRITE32 ( NFS4_SHARE_ACCESS_BOTH ) ; break ; default : <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } WRITE32 ( 0 ) ; }
","<S2SV_ModStart> * xdr , fmode_t fmode <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ <S2SV_ModStart> ; default : WRITE32 ( 0 <S2SV_ModEnd> ) ; }
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-264,"CWE-264 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z
CWE-20,"CWE-20 static void handle_rx ( struct vhost_net * net ) { struct vhost_net_virtqueue * nvq = & net -> vqs [ VHOST_NET_VQ_RX ] ; struct vhost_virtqueue * vq = & nvq -> vq ; unsigned uninitialized_var ( in ) , log ; struct vhost_log * vq_log ; struct msghdr msg = { . msg_name = NULL , . msg_namelen = 0 , . msg_control = NULL , . msg_controllen = 0 , . msg_iov = vq -> iov , . msg_flags = MSG_DONTWAIT , } ; struct virtio_net_hdr_mrg_rxbuf hdr = { . hdr . flags = 0 , . hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE } ; size_t total_len = 0 ; int err , mergeable ; s16 headcount ; size_t vhost_hlen , sock_hlen ; size_t vhost_len , sock_len ; struct socket * sock ; mutex_lock ( & vq -> mutex ) ; sock = vq -> private_data ; if ( ! sock ) goto out ; vhost_disable_notify ( & net -> dev , vq ) ; vhost_hlen = nvq -> vhost_hlen ; sock_hlen = nvq -> sock_hlen ; vq_log = unlikely ( vhost_has_feature ( & net -> dev , VHOST_F_LOG_ALL ) ) ? vq -> log : NULL ; mergeable = vhost_has_feature ( & net -> dev , VIRTIO_NET_F_MRG_RXBUF ) ; while ( ( sock_len = peek_head_len ( sock -> sk ) ) ) { sock_len += sock_hlen ; vhost_len = sock_len + vhost_hlen ; headcount = get_rx_bufs ( vq , vq -> heads , vhost_len , & in , vq_log , & log , likely ( mergeable ) ? UIO_MAXIOV : 1 ) ; if ( unlikely ( headcount < 0 ) ) break ; <S2SV_StartBug> if ( ! headcount ) { <S2SV_EndBug> if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; <S2SV_StartBug> msg . msg_iovlen = in ; <S2SV_EndBug> err = sock -> ops -> recvmsg ( NULL , sock , & msg , <S2SV_StartBug> sock_len , MSG_DONTWAIT | MSG_TRUNC ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( err != sock_len ) ) { <S2SV_EndBug> pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>"" ""<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%zd\\n"" , err , sock_len ) ; vhost_discard_vq_desc ( vq , headcount ) ; continue ; } if ( unlikely ( vhost_hlen ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & hdr , 0 , vhost_hlen ) ) { vq_err ( vq , ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>vnet_hdr<S2SV_blank>at<S2SV_blank>addr<S2SV_blank>%p\\n"" , vq -> iov -> iov_base ) ; break ; } if ( likely ( mergeable ) && memcpy_toiovecend ( nvq -> hdr , ( unsigned char * ) & headcount , offsetof ( typeof ( hdr ) , num_buffers ) , sizeof hdr . num_buffers ) ) { vq_err ( vq , ""Failed<S2SV_blank>num_buffers<S2SV_blank>write"" ) ; vhost_discard_vq_desc ( vq , headcount ) ; break ; } vhost_add_used_and_signal_n ( & net -> dev , vq , vq -> heads , headcount ) ; if ( unlikely ( vq_log ) ) vhost_log_write ( vq , vq_log , log , vhost_len ) ; total_len += vhost_len ; if ( unlikely ( total_len >= VHOST_NET_WEIGHT ) ) { vhost_poll_queue ( & vq -> poll ) ; break ; } } out : mutex_unlock ( & vq -> mutex ) ; }
","<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( ""Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n"" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
",torvalds@linux/d8316f3991d207fe32881a9ac20241be8fa2bad0,CVE-2014-0077,https://github.com/torvalds/linux/commit/d8316f3991d207fe32881a9ac20241be8fa2bad0,2014-04-14T23:55Z
CWE-119,"CWE-119 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; <S2SV_StartBug> name . name = buf ; <S2SV_EndBug> name . len = outarg . namelen ; <S2SV_StartBug> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <S2SV_EndBug> if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }
","<S2SV_ModStart> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> outarg . namelen <S2SV_ModStart> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )
",torvalds@linux/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae,CVE-2011-3353,https://github.com/torvalds/linux/commit/c2183d1e9b3f313dd8ba2b1b0197c8d9fb86a7ae,2012-05-24T23:55Z
CWE-000,"CWE-000 static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }
","<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
",torvalds@linux/92117d8443bc5afacc8d5ba82e541946310f106e,CVE-2016-4558,https://github.com/torvalds/linux/commit/92117d8443bc5afacc8d5ba82e541946310f106e,2016-05-23T10:59Z
CWE-119,"CWE-119 protected int file_check_mem ( struct magic_set * ms , unsigned int level ) { size_t len ; if ( level >= ms -> c . len ) { <S2SV_StartBug> len = ( ms -> c . len += 20 ) * sizeof ( * ms -> c . li ) ; <S2SV_EndBug> ms -> c . li = CAST ( struct level_info * , ( ms -> c . li == NULL ) ? malloc ( len ) : realloc ( ms -> c . li , len ) ) ; if ( ms -> c . li == NULL ) { file_oomem ( ms , len ) ; return - 1 ; } } ms -> c . li [ level ] . got_match = 0 ; # ifdef ENABLE_CONDITIONALS ms -> c . li [ level ] . last_match = 0 ; ms -> c . li [ level ] . last_cond = COND_NONE ; # endif return 0 ; }
","<S2SV_ModStart> c . len = 20 + level <S2SV_ModEnd> ) * sizeof
",file@file/6713ca45e7757297381f4b4cdb9cf5e624a9ad36,CVE-2015-8865,https://github.com/file/file/commit/6713ca45e7757297381f4b4cdb9cf5e624a9ad36,2016-05-20T10:59Z
CWE-269,"CWE-269 static void setup_namespaces ( struct lo_data * lo , struct fuse_session * se ) { <S2SV_StartBug> pid_t child ; <S2SV_EndBug> char template [ ] = ""virtiofsd-XXXXXX"" ; char * tmpdir ; if ( unshare ( CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET ) != 0 ) { fuse_log ( FUSE_LOG_ERR , ""unshare(CLONE_NEWPID<S2SV_blank>|<S2SV_blank>CLONE_NEWNS):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } child = fork ( ) ; if ( child < 0 ) { fuse_log ( FUSE_LOG_ERR , ""fork()<S2SV_blank>failed:<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } if ( child > 0 ) { pid_t waited ; int wstatus ; setup_wait_parent_capabilities ( ) ; do { waited = waitpid ( child , & wstatus , 0 ) ; } while ( waited < 0 && errno == EINTR && ! se -> exited ) ; if ( se -> exited ) { exit ( 0 ) ; } if ( WIFEXITED ( wstatus ) ) { exit ( WEXITSTATUS ( wstatus ) ) ; } exit ( 1 ) ; } prctl ( PR_SET_PDEATHSIG , SIGTERM ) ; if ( mount ( NULL , ""/"" , NULL , MS_REC | MS_SLAVE , NULL ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""mount(/,<S2SV_blank>MS_REC|MS_SLAVE):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } if ( mount ( ""proc"" , ""/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME , NULL ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""mount(/proc):<S2SV_blank>%m\\n"" ) ; exit ( 1 ) ; } <S2SV_StartBug> tmpdir = mkdtemp ( template ) ; <S2SV_EndBug> if ( ! tmpdir ) { fuse_log ( FUSE_LOG_ERR , ""tmpdir(%s):<S2SV_blank>%m\\n"" , template ) ; exit ( 1 ) ; } <S2SV_StartBug> if ( mount ( ""/proc/self/fd"" , tmpdir , NULL , MS_BIND , NULL ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>%s,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" , <S2SV_EndBug> tmpdir ) ; exit ( 1 ) ; } <S2SV_StartBug> lo -> proc_self_fd = open ( tmpdir , O_PATH ) ; <S2SV_EndBug> if ( lo -> proc_self_fd == - 1 ) { <S2SV_StartBug> fuse_log ( FUSE_LOG_ERR , ""open(%s,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" , tmpdir ) ; <S2SV_EndBug> exit ( 1 ) ; } if ( umount2 ( tmpdir , MNT_DETACH ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""umount2(%s,<S2SV_blank>MNT_DETACH):<S2SV_blank>%m\\n"" , tmpdir ) ; exit ( 1 ) ; } if ( rmdir ( tmpdir ) < 0 ) { fuse_log ( FUSE_LOG_ERR , ""rmdir(%s):<S2SV_blank>%m\\n"" , tmpdir ) ; } }
","<S2SV_ModStart> { pid_t child <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( mount <S2SV_ModStart> ( ""/proc/self/fd"" , ""/proc"" <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( FUSE_LOG_ERR , ""mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n"" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> = open ( ""/proc"" <S2SV_ModEnd> , O_PATH ) <S2SV_ModStart> ( FUSE_LOG_ERR , ""open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n"" ) ; exit ( 1 <S2SV_ModEnd> ) ; }
",qemu@qemu/ebf101955ce8f8d72fba103b5151115a4335de2c,CVE-2020-35517,https://github.com/qemu/qemu/commit/ebf101955ce8f8d72fba103b5151115a4335de2c,2021-01-28T20:15Z
CWE-119,"CWE-119 int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) { char frame [ 6 ] ; int pic_sz ; int c_w ; int c_h ; <S2SV_StartBug> int c_sz ; <S2SV_EndBug> if ( ! file_read ( frame , 6 , _fin ) ) return 0 ; if ( memcmp ( frame , ""FRAME"" , 5 ) ) { fprintf ( stderr , ""Loss<S2SV_blank>of<S2SV_blank>framing<S2SV_blank>in<S2SV_blank>Y4M<S2SV_blank>input<S2SV_blank>data\\n"" ) ; return - 1 ; } if ( frame [ 5 ] != '\\n' ) { char c ; int j ; for ( j = 0 ; j < 79 && file_read ( & c , 1 , _fin ) && c != '\\n' ; j ++ ) { } if ( j == 79 ) { fprintf ( stderr , ""Error<S2SV_blank>parsing<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>header\\n"" ) ; return - 1 ; } } if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) { fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\n"" ) ; return - 1 ; } if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) { fprintf ( stderr , ""Error<S2SV_blank>reading<S2SV_blank>Y4M<S2SV_blank>frame<S2SV_blank>data.\\n"" ) ; return - 1 ; } ( * _y4m -> convert ) ( _y4m , _y4m -> dst_buf , _y4m -> aux_buf ) ; memset ( _img , 0 , sizeof ( * _img ) ) ; _img -> fmt = _y4m -> vpx_fmt ; _img -> w = _img -> d_w = _y4m -> pic_w ; _img -> h = _img -> d_h = _y4m -> pic_h ; _img -> x_chroma_shift = _y4m -> dst_c_dec_h >> 1 ; _img -> y_chroma_shift = _y4m -> dst_c_dec_v >> 1 ; <S2SV_StartBug> _img -> bps = _y4m -> vpx_bps ; <S2SV_EndBug> <S2SV_StartBug> pic_sz = _y4m -> pic_w * _y4m -> pic_h ; <S2SV_EndBug> c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ; <S2SV_StartBug> c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ; <S2SV_EndBug> c_sz = c_w * c_h ; <S2SV_StartBug> _img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_Y ] = _y4m -> dst_buf ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ; <S2SV_EndBug> <S2SV_StartBug> _img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> ; int c_sz ; int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 <S2SV_ModStart> = _y4m -> bps <S2SV_ModEnd> ; pic_sz = <S2SV_ModStart> _y4m -> pic_h * bytes_per_sample <S2SV_ModStart> -> dst_c_dec_h ; c_w *= bytes_per_sample ; <S2SV_ModStart> -> stride [ VPX_PLANE_Y <S2SV_ModEnd> ] = _img <S2SV_ModStart> -> stride [ VPX_PLANE_ALPHA ] = <S2SV_ModEnd> _y4m -> pic_w <S2SV_ModStart> _y4m -> pic_w * bytes_per_sample <S2SV_ModStart> -> stride [ VPX_PLANE_U <S2SV_ModEnd> ] = _img <S2SV_ModStart> -> stride [ VPX_PLANE_V <S2SV_ModEnd> ] = c_w <S2SV_ModStart> -> planes [ VPX_PLANE_Y <S2SV_ModEnd> ] = _y4m <S2SV_ModStart> -> planes [ VPX_PLANE_U <S2SV_ModEnd> ] = _y4m <S2SV_ModStart> -> planes [ VPX_PLANE_V <S2SV_ModEnd> ] = _y4m <S2SV_ModStart> -> planes [ VPX_PLANE_ALPHA <S2SV_ModEnd> ] = _y4m
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-404,"CWE-404 static int cp2112_gpio_direction_input ( struct gpio_chip * chip , unsigned offset ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto exit ; } buf [ 1 ] &= ~ ( 1 << offset ) ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto exit ; } ret = 0 ; exit : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret <= 0 ? ret : - EIO ; }
","<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
",torvalds@linux/7a7b5df84b6b4e5d599c7289526eed96541a0654,CVE-2017-8071,https://github.com/torvalds/linux/commit/7a7b5df84b6b4e5d599c7289526eed96541a0654,2017-04-23T05:59Z
CWE-125,"CWE-125 static Image * ExtractPostscript ( Image * image , const ImageInfo * image_info , MagickOffsetType PS_Offset , ssize_t PS_Size , ExceptionInfo * exception ) { char postscript_file [ MaxTextExtent ] ; const MagicInfo * magic_info ; FILE * ps_file ; ImageInfo * clone_info ; Image * image2 ; unsigned char magick [ 2 * MaxTextExtent ] ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) return ( image ) ; clone_info -> blob = ( void * ) NULL ; clone_info -> length = 0 ; ( void ) AcquireUniqueFilename ( postscript_file ) ; ps_file = fopen_utf8 ( postscript_file , ""wb"" ) ; if ( ps_file == ( FILE * ) NULL ) goto FINISH ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; ( void ) ReadBlob ( image , 2 * MaxTextExtent , magick ) ; ( void ) SeekBlob ( image , PS_Offset , SEEK_SET ) ; while ( PS_Size -- > 0 ) { ( void ) fputc ( ReadBlobByte ( image ) , ps_file ) ; } ( void ) fclose ( ps_file ) ; magic_info = GetMagicInfo ( magick , 2 * MaxTextExtent , exception ) ; if ( magic_info == ( const MagicInfo * ) NULL ) goto FINISH_UNL ; if ( exception -> severity != UndefinedException ) goto FINISH_UNL ; if ( magic_info -> name == ( char * ) NULL ) goto FINISH_UNL ; <S2SV_StartBug> ( void ) CopyMagickMemory ( clone_info -> magick , magic_info -> name , MaxTextExtent ) ; <S2SV_EndBug> FormatLocaleString ( clone_info -> filename , MaxTextExtent , ""%s"" , postscript_file ) ; image2 = ReadImage ( clone_info , exception ) ; if ( ! image2 ) goto FINISH_UNL ; ( void ) CopyMagickMemory ( image2 -> filename , image -> filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick_filename , image -> magick_filename , MaxTextExtent ) ; ( void ) CopyMagickMemory ( image2 -> magick , image -> magick , MaxTextExtent ) ; image2 -> depth = image -> depth ; DestroyBlob ( image2 ) ; image2 -> blob = ReferenceBlob ( image -> blob ) ; if ( ( image -> rows == 0 ) || ( image -> columns == 0 ) ) DeleteImageFromList ( & image ) ; AppendImageToList ( & image , image2 ) ; FINISH_UNL : ( void ) RelinquishUniqueFileResource ( postscript_file ) ; FINISH : DestroyImageInfo ( clone_info ) ; return ( image ) ; }
","<S2SV_ModStart> ( void ) strncpy <S2SV_ModEnd> ( clone_info ->
",ImageMagick@ImageMagick/a251039393f423c7858e63cab6aa98d17b8b7a41,CVE-2016-7527,https://github.com/ImageMagick/ImageMagick/commit/a251039393f423c7858e63cab6aa98d17b8b7a41,2017-04-20T18:59Z
CWE-17,"CWE-17 int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid"" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld"" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container"" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>"" ""namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess"" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process"" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)"" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)"" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)"" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( ""failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'"" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( ""failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
","<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( ""/proc"" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc"" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd
",lxc@lxc/5c3fcae78b63ac9dd56e36075903921bd9461f9e,CVE-2015-1334,https://github.com/lxc/lxc/commit/5c3fcae78b63ac9dd56e36075903921bd9461f9e,2015-08-12T14:59Z
CWE-000,"CWE-000 IHEVCD_ERROR_T ihevcd_parse_slice_header ( codec_t * ps_codec , nal_header_t * ps_nal ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; <S2SV_StartBug> WORD32 i ; <S2SV_EndBug> WORD32 sps_id ; pps_t * ps_pps ; sps_t * ps_sps ; slice_header_t * ps_slice_hdr ; WORD32 disable_deblocking_filter_flag ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 idr_pic_flag ; WORD32 pps_id ; WORD32 first_slice_in_pic_flag ; WORD32 no_output_of_prior_pics_flag = 0 ; WORD8 i1_nal_unit_type = ps_nal -> i1_nal_unit_type ; WORD32 num_poc_total_curr = 0 ; WORD32 slice_address ; if ( ps_codec -> i4_slice_error == 1 ) return ret ; idr_pic_flag = ( NAL_IDR_W_LP == i1_nal_unit_type ) || ( NAL_IDR_N_LP == i1_nal_unit_type ) ; BITS_PARSE ( ""first_slice_in_pic_flag"" , first_slice_in_pic_flag , ps_bitstrm , 1 ) ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { BITS_PARSE ( ""no_output_of_prior_pics_flag"" , no_output_of_prior_pics_flag , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""pic_parameter_set_id"" , pps_id , ps_bitstrm ) ; pps_id = CLIP3 ( pps_id , 0 , MAX_PPS_CNT - 2 ) ; ps_pps = ps_codec -> s_parse . ps_pps_base + pps_id ; if ( 0 == ps_pps -> i1_pps_valid ) { pps_t * ps_pps_ref = ps_codec -> ps_pps_base ; while ( 0 == ps_pps_ref -> i1_pps_valid ) ps_pps_ref ++ ; if ( ( ps_pps_ref - ps_codec -> ps_pps_base >= MAX_PPS_CNT - 1 ) ) return IHEVCD_INVALID_HEADER ; ihevcd_copy_pps ( ps_codec , pps_id , ps_pps_ref -> i1_pps_id ) ; } sps_id = ps_pps -> i1_sps_id ; ps_sps = ps_codec -> s_parse . ps_sps_base + sps_id ; if ( ( 0 != ps_codec -> u4_pic_cnt || ps_codec -> i4_pic_present ) && first_slice_in_pic_flag ) { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { ps_codec -> i4_slice_error = 0 ; } } if ( first_slice_in_pic_flag ) { ps_codec -> s_parse . i4_cur_slice_idx = 0 ; } else { if ( 0 == ps_codec -> i4_pic_present ) ps_codec -> s_parse . i4_cur_slice_idx = 1 ; } ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; if ( ( ps_pps -> i1_dependent_slice_enabled_flag ) && ( ! first_slice_in_pic_flag ) ) { BITS_PARSE ( ""dependent_slice_flag"" , value , ps_bitstrm , 1 ) ; if ( value && ( ps_codec -> s_parse . i4_cur_slice_idx > 0 ) ) { ihevcd_copy_slice_hdr ( ps_codec , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) , ( ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; } ps_slice_hdr -> i1_dependent_slice_flag = value ; } else { ps_slice_hdr -> i1_dependent_slice_flag = 0 ; } ps_slice_hdr -> i1_nal_unit_type = i1_nal_unit_type ; ps_slice_hdr -> i1_pps_id = pps_id ; ps_slice_hdr -> i1_first_slice_in_pic_flag = first_slice_in_pic_flag ; ps_slice_hdr -> i1_no_output_of_prior_pics_flag = 1 ; if ( ( NAL_BLA_W_LP <= i1_nal_unit_type ) && ( NAL_RSV_RAP_VCL23 >= i1_nal_unit_type ) ) { ps_slice_hdr -> i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag ; } ps_slice_hdr -> i1_pps_id = pps_id ; if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { WORD32 num_bits ; num_bits = 32 - CLZ ( ps_sps -> i4_pic_size_in_ctb - 1 ) ; BITS_PARSE ( ""slice_address"" , value , ps_bitstrm , num_bits ) ; slice_address = value ; if ( value >= ps_sps -> i4_pic_size_in_ctb ) return IHEVCD_IGNORE_SLICE ; } else { slice_address = 0 ; } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i1_pic_output_flag = 1 ; ps_slice_hdr -> i4_pic_order_cnt_lsb = 0 ; ps_slice_hdr -> i1_num_long_term_sps = 0 ; ps_slice_hdr -> i1_num_long_term_pics = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_extra_slice_header_bits ; i ++ ) { BITS_PARSE ( ""slice_reserved_undetermined_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; } UEV_PARSE ( ""slice_type"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_type = value ; if ( ( ps_slice_hdr -> i1_nal_unit_type >= NAL_BLA_W_LP ) && ( ps_slice_hdr -> i1_nal_unit_type <= NAL_RSV_RAP_VCL23 ) ) ps_slice_hdr -> i1_slice_type = ISLICE ; if ( ( ps_slice_hdr -> i1_slice_type < 0 ) || ( ps_slice_hdr -> i1_slice_type > 2 ) ) return IHEVCD_IGNORE_SLICE ; if ( ps_pps -> i1_output_flag_present_flag ) { BITS_PARSE ( ""pic_output_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_pic_output_flag = value ; } ps_slice_hdr -> i1_colour_plane_id = 0 ; if ( 1 == ps_sps -> i1_separate_colour_plane_flag ) { BITS_PARSE ( ""colour_plane_id"" , value , ps_bitstrm , 2 ) ; ps_slice_hdr -> i1_colour_plane_id = value ; } ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = 0 ; if ( ! idr_pic_flag ) { WORD32 st_rps_idx ; WORD32 num_neg_pics ; WORD32 num_pos_pics ; WORD8 * pi1_used ; BITS_PARSE ( ""pic_order_cnt_lsb"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> i4_pic_order_cnt_lsb = value ; BITS_PARSE ( ""short_term_ref_pic_set_sps_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag = value ; if ( 1 == ps_slice_hdr -> i1_short_term_ref_pic_set_sps_flag ) { WORD32 numbits ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = 0 ; if ( ps_sps -> i1_num_short_term_ref_pic_sets > 1 ) { numbits = 32 - CLZ ( ps_sps -> i1_num_short_term_ref_pic_sets - 1 ) ; BITS_PARSE ( ""short_term_ref_pic_set_idx"" , value , ps_bitstrm , numbits ) ; ps_slice_hdr -> i1_short_term_ref_pic_set_idx = value ; } st_rps_idx = ps_slice_hdr -> i1_short_term_ref_pic_set_idx ; num_neg_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_neg_pics ; num_pos_pics = ps_sps -> as_stref_picset [ st_rps_idx ] . i1_num_pos_pics ; pi1_used = ps_sps -> as_stref_picset [ st_rps_idx ] . ai1_used ; } else { ihevcd_short_term_ref_pic_set ( ps_bitstrm , & ps_sps -> as_stref_picset [ 0 ] , ps_sps -> i1_num_short_term_ref_pic_sets , ps_sps -> i1_num_short_term_ref_pic_sets , & ps_slice_hdr -> s_stref_picset ) ; st_rps_idx = ps_sps -> i1_num_short_term_ref_pic_sets ; num_neg_pics = ps_slice_hdr -> s_stref_picset . i1_num_neg_pics ; num_pos_pics = ps_slice_hdr -> s_stref_picset . i1_num_pos_pics ; pi1_used = ps_slice_hdr -> s_stref_picset . ai1_used ; } if ( ps_sps -> i1_long_term_ref_pics_present_flag ) { if ( ps_sps -> i1_num_long_term_ref_pics_sps > 0 ) { UEV_PARSE ( ""num_long_term_sps"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_sps = value ; ps_slice_hdr -> i1_num_long_term_sps = CLIP3 ( ps_slice_hdr -> i1_num_long_term_sps , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics ) ; } UEV_PARSE ( ""num_long_term_pics"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_long_term_pics = value ; ps_slice_hdr -> i1_num_long_term_pics = CLIP3 ( ps_slice_hdr -> i1_num_long_term_pics , 0 , MAX_DPB_SIZE - num_neg_pics - num_pos_pics - ps_slice_hdr -> i1_num_long_term_sps ) ; for ( i = 0 ; i < ( ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ) ; i ++ ) { if ( i < ps_slice_hdr -> i1_num_long_term_sps ) { WORD32 num_bits = 32 - CLZ ( ps_sps -> i1_num_long_term_ref_pics_sps ) ; BITS_PARSE ( ""lt_idx_sps[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , num_bits ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = ps_sps -> ai1_lt_ref_pic_poc_lsb_sps [ value ] ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = ps_sps -> ai1_used_by_curr_pic_lt_sps_flag [ value ] ; } else { BITS_PARSE ( ""poc_lsb_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , ps_sps -> i1_log2_max_pic_order_cnt_lsb ) ; ps_slice_hdr -> ai4_poc_lsb_lt [ i ] = value ; BITS_PARSE ( ""used_by_curr_pic_lt_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] = value ; } BITS_PARSE ( ""delta_poc_msb_present_flag[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] = value ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = 0 ; if ( ps_slice_hdr -> ai1_delta_poc_msb_present_flag [ i ] ) { UEV_PARSE ( ""delata_poc_msb_cycle_lt[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] = value ; } if ( ( i != 0 ) && ( i != ps_slice_hdr -> i1_num_long_term_sps ) ) { ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i ] += ps_slice_hdr -> ai1_delta_poc_msb_cycle_lt [ i - 1 ] ; } } } for ( i = 0 ; i < num_neg_pics + num_pos_pics ; i ++ ) { if ( pi1_used [ i ] ) { num_poc_total_curr ++ ; } } for ( i = 0 ; i < ps_slice_hdr -> i1_num_long_term_sps + ps_slice_hdr -> i1_num_long_term_pics ; i ++ ) { if ( ps_slice_hdr -> ai1_used_by_curr_pic_lt_flag [ i ] ) { num_poc_total_curr ++ ; } } if ( ps_sps -> i1_sps_temporal_mvp_enable_flag ) { BITS_PARSE ( ""enable_temporal_mvp_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag = value ; } } ps_slice_hdr -> i1_slice_sao_luma_flag = 0 ; ps_slice_hdr -> i1_slice_sao_chroma_flag = 0 ; if ( ps_sps -> i1_sample_adaptive_offset_enabled_flag ) { BITS_PARSE ( ""slice_sao_luma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_luma_flag = value ; BITS_PARSE ( ""slice_sao_chroma_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_sao_chroma_flag = value ; } ps_slice_hdr -> i1_max_num_merge_cand = 1 ; ps_slice_hdr -> i1_cabac_init_flag = 0 ; ps_slice_hdr -> i1_num_ref_idx_l0_active = 0 ; ps_slice_hdr -> i1_num_ref_idx_l1_active = 0 ; ps_slice_hdr -> i1_slice_cb_qp_offset = 0 ; ps_slice_hdr -> i1_slice_cr_qp_offset = 0 ; if ( ( PSLICE == ps_slice_hdr -> i1_slice_type ) || ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) { BITS_PARSE ( ""num_ref_idx_active_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_num_ref_idx_active_override_flag = value ; if ( ps_slice_hdr -> i1_num_ref_idx_active_override_flag ) { UEV_PARSE ( ""num_ref_idx_l0_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l0_active = value + 1 ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { UEV_PARSE ( ""num_ref_idx_l1_active_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = value + 1 ; } } else { ps_slice_hdr -> i1_num_ref_idx_l0_active = ps_pps -> i1_num_ref_idx_l0_default_active ; if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { ps_slice_hdr -> i1_num_ref_idx_l1_active = ps_pps -> i1_num_ref_idx_l1_default_active ; } } ps_slice_hdr -> i1_num_ref_idx_l0_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l0_active , 0 , MAX_DPB_SIZE - 1 ) ; ps_slice_hdr -> i1_num_ref_idx_l1_active = CLIP3 ( ps_slice_hdr -> i1_num_ref_idx_l1_active , 0 , MAX_DPB_SIZE - 1 ) ; if ( 0 == num_poc_total_curr ) return IHEVCD_IGNORE_SLICE ; if ( ( ps_pps -> i1_lists_modification_present_flag ) && ( num_poc_total_curr > 1 ) ) { ihevcd_ref_pic_list_modification ( ps_bitstrm , ps_slice_hdr , num_poc_total_curr ) ; } else { ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l0 = 0 ; ps_slice_hdr -> s_rplm . i1_ref_pic_list_modification_flag_l1 = 0 ; } if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""mvd_l1_zero_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_mvd_l1_zero_flag = value ; } ps_slice_hdr -> i1_cabac_init_flag = 0 ; if ( ps_pps -> i1_cabac_init_present_flag ) { BITS_PARSE ( ""cabac_init_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_cabac_init_flag = value ; } ps_slice_hdr -> i1_collocated_from_l0_flag = 1 ; ps_slice_hdr -> i1_collocated_ref_idx = 0 ; if ( ps_slice_hdr -> i1_slice_temporal_mvp_enable_flag ) { if ( BSLICE == ps_slice_hdr -> i1_slice_type ) { BITS_PARSE ( ""collocated_from_l0_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_collocated_from_l0_flag = value ; } if ( ( ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l0_active > 1 ) ) || ( ! ps_slice_hdr -> i1_collocated_from_l0_flag && ( ps_slice_hdr -> i1_num_ref_idx_l1_active > 1 ) ) ) { UEV_PARSE ( ""collocated_ref_idx"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_collocated_ref_idx = value ; } } ps_slice_hdr -> i1_collocated_ref_idx = CLIP3 ( ps_slice_hdr -> i1_collocated_ref_idx , 0 , MAX_DPB_SIZE - 1 ) ; if ( ( ps_pps -> i1_weighted_pred_flag && ( PSLICE == ps_slice_hdr -> i1_slice_type ) ) || ( ps_pps -> i1_weighted_bipred_flag && ( BSLICE == ps_slice_hdr -> i1_slice_type ) ) ) { ihevcd_parse_pred_wt_ofst ( ps_bitstrm , ps_sps , ps_pps , ps_slice_hdr ) ; } UEV_PARSE ( ""five_minus_max_num_merge_cand"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_max_num_merge_cand = 5 - value ; } ps_slice_hdr -> i1_max_num_merge_cand = CLIP3 ( ps_slice_hdr -> i1_max_num_merge_cand , 1 , 5 ) ; SEV_PARSE ( ""slice_qp_delta"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_qp_delta = value ; if ( ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag ) { SEV_PARSE ( ""slice_cb_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cb_qp_offset = value ; SEV_PARSE ( ""slice_cr_qp_offset"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_slice_cr_qp_offset = value ; } ps_slice_hdr -> i1_deblocking_filter_override_flag = 0 ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; ps_slice_hdr -> i1_beta_offset_div2 = ps_pps -> i1_beta_offset_div2 ; ps_slice_hdr -> i1_tc_offset_div2 = ps_pps -> i1_tc_offset_div2 ; disable_deblocking_filter_flag = ps_pps -> i1_pic_disable_deblocking_filter_flag ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { if ( ps_pps -> i1_deblocking_filter_override_enabled_flag ) { BITS_PARSE ( ""deblocking_filter_override_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_deblocking_filter_override_flag = value ; } if ( ps_slice_hdr -> i1_deblocking_filter_override_flag ) { BITS_PARSE ( ""slice_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag = value ; disable_deblocking_filter_flag = ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ; if ( ! ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { SEV_PARSE ( ""beta_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""tc_offset_div2"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_tc_offset_div2 = value ; } } } ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = ps_pps -> i1_loop_filter_across_slices_enabled_flag ; if ( ps_pps -> i1_loop_filter_across_slices_enabled_flag && ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag || ! disable_deblocking_filter_flag ) ) { BITS_PARSE ( ""slice_loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_slice_hdr -> i1_slice_loop_filter_across_slices_enabled_flag = value ; } } if ( ( ! first_slice_in_pic_flag ) && ( ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_base = ps_codec -> ps_slice_hdr_base ; if ( ( ps_slice_hdr_base -> i1_pps_id != ps_slice_hdr -> i1_pps_id ) || ( ps_slice_hdr_base -> i4_pic_order_cnt_lsb != ps_slice_hdr -> i4_pic_order_cnt_lsb ) ) { return IHEVCD_IGNORE_SLICE ; } } if ( 0 == ps_codec -> i4_pic_present ) { ps_slice_hdr -> i4_abs_pic_order_cnt = ihevcd_calc_poc ( ps_codec , ps_nal , ps_sps -> i1_log2_max_pic_order_cnt_lsb , ps_slice_hdr -> i4_pic_order_cnt_lsb ) ; } else { ps_slice_hdr -> i4_abs_pic_order_cnt = ps_codec -> s_parse . i4_abs_pic_order_cnt ; } if ( ! first_slice_in_pic_flag ) { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) { if ( slice_address > ps_codec -> s_parse . i4_next_ctb_indx ) { if ( ps_codec -> i4_pic_present ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; return ret ; } else { return IHEVCD_IGNORE_SLICE ; } } else if ( slice_address < ps_codec -> s_parse . i4_next_ctb_indx ) { return IHEVCD_IGNORE_SLICE ; } else { ps_codec -> i4_slice_error = 0 ; } } else { if ( ps_codec -> i4_pic_present ) { slice_header_t * ps_slice_hdr_next ; ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ( ps_codec -> s_parse . i4_cur_slice_idx + 1 ) & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_slice_hdr_next -> i2_ctb_x = 0 ; ps_slice_hdr_next -> i2_ctb_y = ps_codec -> s_parse . ps_sps -> i2_pic_ht_in_ctb ; return ret ; } else { if ( ps_slice_hdr -> i1_dependent_slice_flag ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } } } else { if ( ps_codec -> s_parse . i4_abs_pic_order_cnt == ps_slice_hdr -> i4_abs_pic_order_cnt ) return IHEVCD_IGNORE_SLICE ; ps_codec -> s_parse . i4_abs_pic_order_cnt = ps_slice_hdr -> i4_abs_pic_order_cnt ; } ps_slice_hdr -> i4_num_entry_point_offsets = 0 ; if ( ( ps_pps -> i1_tiles_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { UEV_PARSE ( ""num_entry_point_offsets"" , value , ps_bitstrm ) ; ps_slice_hdr -> i4_num_entry_point_offsets = value ; { WORD32 max_num_entry_point_offsets ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } else if ( ps_pps -> i1_tiles_enabled_flag ) { max_num_entry_point_offsets = ps_pps -> i1_num_tile_columns * ps_pps -> i1_num_tile_rows ; } else { max_num_entry_point_offsets = ( ps_sps -> i2_pic_ht_in_ctb - 1 ) ; } ps_slice_hdr -> i4_num_entry_point_offsets = CLIP3 ( ps_slice_hdr -> i4_num_entry_point_offsets , 0 , max_num_entry_point_offsets ) ; } if ( ps_slice_hdr -> i4_num_entry_point_offsets > 0 ) { UEV_PARSE ( ""offset_len_minus1"" , value , ps_bitstrm ) ; ps_slice_hdr -> i1_offset_len = value + 1 ; for ( i = 0 ; i < ps_slice_hdr -> i4_num_entry_point_offsets ; i ++ ) { BITS_PARSE ( ""entry_point_offset"" , value , ps_bitstrm , ps_slice_hdr -> i1_offset_len ) ; } } } if ( ps_pps -> i1_slice_header_extension_present_flag ) { UEV_PARSE ( ""slice_header_extension_length"" , value , ps_bitstrm ) ; ps_slice_hdr -> i2_slice_header_extension_length = value ; for ( i = 0 ; i < ps_slice_hdr -> i2_slice_header_extension_length ; i ++ ) { BITS_PARSE ( ""slice_header_extension_data_byte"" , value , ps_bitstrm , 8 ) ; } } ihevcd_bits_flush_to_byte_boundary ( ps_bitstrm ) ; { dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; WORD32 r_idx ; if ( ( NAL_IDR_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_IDR_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_N_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_DLP == ps_slice_hdr -> i1_nal_unit_type ) || ( NAL_BLA_W_LP == ps_slice_hdr -> i1_nal_unit_type ) || ( 0 == ps_codec -> u4_pic_cnt ) ) { for ( i = 0 ; i < MAX_DPB_BUFS ; i ++ ) { if ( ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ) { pic_buf_t * ps_pic_buf = ps_dpb_mgr -> as_dpb_info [ i ] . ps_pic_buf ; mv_buf_t * ps_mv_buf ; ihevc_dpb_mgr_del_ref ( ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr , ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_pic_buf -> i4_abs_poc ) ; ps_mv_buf = ( mv_buf_t * ) ps_codec -> ps_mv_buf ; <S2SV_StartBug> for ( i = 0 ; i < BUF_MGR_MAX_CNT ; i ++ ) <S2SV_EndBug> { if ( ps_mv_buf && ps_mv_buf -> i4_abs_poc == ps_pic_buf -> i4_abs_poc ) { <S2SV_StartBug> ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , i , BUF_MGR_REF ) ; <S2SV_EndBug> break ; } ps_mv_buf ++ ; } } } for ( r_idx = 0 ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = NULL ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = NULL ; } } else { ret = ihevcd_ref_list ( ps_codec , ps_pps , ps_sps , ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; } } } if ( ps_codec -> i4_pic_present ) { pic_buf_t * ps_pic_buf_ref ; mv_buf_t * ps_mv_buf_ref ; WORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc ( ps_dpb_mgr , ps_slice_hdr -> i4_abs_pic_order_cnt ) ; if ( NULL == ps_pic_buf_ref ) { ps_pic_buf_ref = ps_codec -> as_process [ 0 ] . ps_cur_pic ; ps_mv_buf_ref = ps_codec -> s_parse . ps_cur_mv_buf ; } else { ps_mv_buf_ref = ihevcd_mv_mgr_get_poc ( ps_mv_buf_mgr , ps_pic_buf_ref -> i4_abs_poc ) ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l0_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list0 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } for ( r_idx = 0 ; r_idx < ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx ++ ) { if ( NULL == ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } for ( r_idx = ps_slice_hdr -> i1_num_ref_idx_l1_active ; r_idx < MAX_DPB_SIZE ; r_idx ++ ) { ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_pic_buf = ( void * ) ps_pic_buf_ref ; ps_slice_hdr -> as_ref_pic_list1 [ r_idx ] . pv_mv_buf = ( void * ) ps_mv_buf_ref ; } } if ( ! ps_slice_hdr -> i1_first_slice_in_pic_flag ) { ps_slice_hdr -> i2_ctb_x = slice_address % ps_sps -> i2_pic_wd_in_ctb ; ps_slice_hdr -> i2_ctb_y = slice_address / ps_sps -> i2_pic_wd_in_ctb ; if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_slice_hdr -> i2_independent_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_slice_hdr -> i2_independent_ctb_y = ps_slice_hdr -> i2_ctb_y ; } } else { ps_slice_hdr -> i2_ctb_x = 0 ; ps_slice_hdr -> i2_ctb_y = 0 ; ps_slice_hdr -> i2_independent_ctb_x = 0 ; ps_slice_hdr -> i2_independent_ctb_y = 0 ; } if ( ( ! first_slice_in_pic_flag ) && ( 0 == ps_codec -> i4_pic_present ) ) { slice_header_t * ps_slice_hdr_prev = ps_codec -> s_parse . ps_slice_hdr_base ; ihevcd_copy_slice_hdr ( ps_codec , 0 , ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ; ps_codec -> i4_slice_error = 1 ; ps_slice_hdr_prev -> i2_ctb_x = 0 ; ps_slice_hdr_prev -> i2_ctb_y = 0 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = 0 ; ps_codec -> s_parse . i4_cur_slice_idx = 0 ; if ( ( ps_slice_hdr -> i2_ctb_x == 0 ) && ( ps_slice_hdr -> i2_ctb_y == 0 ) ) { ps_slice_hdr -> i2_ctb_x ++ ; } } { if ( ( i1_nal_unit_type < NAL_BLA_W_LP ) && ( i1_nal_unit_type % 2 == 0 ) ) { if ( IVD_SKIP_B == ps_codec -> e_pic_skip_mode ) return IHEVCD_IGNORE_SLICE ; } if ( ( IVD_SKIP_PB == ps_codec -> e_pic_skip_mode ) && ( ISLICE != ps_slice_hdr -> i1_slice_type ) ) { return IHEVCD_IGNORE_SLICE ; } } return ret ; }
","<S2SV_ModStart> ; WORD32 i , j <S2SV_ModStart> ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> -> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF )
",external@libhevc/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,CVE-2017-0642,https://android.googlesource.com/platform/external/libhevc/+/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,2017-06-14T13:29Z
CWE-476,"CWE-476 static void <S2SV_StartBug> sraSpanRemove ( sraSpan * span ) { <S2SV_EndBug> span -> _prev -> _next = span -> _next ; span -> _next -> _prev = span -> _prev ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ( sraSpan * span ) { if ( <S2SV_ModStart> _prev ; } }
",LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,CVE-2020-14397,https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,2020-06-17T16:15Z
CWE-787,"CWE-787 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kmalloc_array ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) return ERR_PTR ( - EINVAL ) ; * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free ; } ptr = next + len ; N ++ ; ret = - 1 ; while ( 1 ) { next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case ')' : case '\\0' : break ; case '&' : case '|' : if ( next [ 1 ] == next [ 0 ] ) { ptr ++ ; break ; } default : parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } invert = * top & INVERT ; if ( * top & PROCESS_AND ) { update_preds ( prog , N - 1 , invert ) ; * top &= ~ PROCESS_AND ; } if ( * next == '&' ) { * top |= PROCESS_AND ; break ; } if ( * top & PROCESS_OR ) { update_preds ( prog , N - 1 , ! invert ) ; * top &= ~ PROCESS_OR ; } if ( * next == '|' ) { * top |= PROCESS_OR ; break ; } if ( ! * next ) goto out ; if ( top == op_stack ) { ret = - 1 ; parse_error ( pe , FILT_ERR_TOO_MANY_CLOSE , ptr - str ) ; goto out_free ; } top -- ; } } out : if ( top != op_stack ) { parse_error ( pe , FILT_ERR_TOO_MANY_OPEN , ptr - str ) ; goto out_free ; } <S2SV_StartBug> prog [ N ] . pred = NULL ; <S2SV_EndBug> prog [ N ] . target = 1 ; prog [ N + 1 ] . pred = NULL ; prog [ N + 1 ] . target = 0 ; prog [ N - 1 ] . target = N ; prog [ N - 1 ] . when_to_branch = false ; for ( i = N - 1 ; i -- ; ) { int target = prog [ i ] . target ; if ( prog [ i ] . when_to_branch == prog [ target ] . when_to_branch ) prog [ i ] . target = prog [ target ] . target ; } for ( i = 0 ; i < N ; i ++ ) { invert = inverts [ i ] ^ prog [ i ] . when_to_branch ; prog [ i ] . when_to_branch = invert ; if ( WARN_ON ( prog [ i ] . target <= i ) ) { ret = - EINVAL ; goto out_free ; } } return prog ; out_free : kfree ( op_stack ) ; kfree ( prog_stack ) ; kfree ( inverts ) ; return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> out_free ; } if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; }
",torvalds@linux/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03,CVE-2018-12714,https://github.com/torvalds/linux/commit/81f9c4e4177d31ced6f52a89bb70e93bfb77ca03,2018-06-24T23:29Z
CWE-476,"CWE-476 static int decode_nal_unit ( HEVCContext * s , const H2645NAL * nal ) { HEVCLocalContext * lc = s -> HEVClc ; GetBitContext * gb = & lc -> gb ; int ctb_addr_ts , ret ; * gb = nal -> gb ; s -> nal_unit_type = nal -> type ; s -> temporal_id = nal -> temporal_id ; switch ( s -> nal_unit_type ) { case HEVC_NAL_VPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_vps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sps ( gb , s -> avctx , & s -> ps , s -> apply_defdispwin ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_PPS : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_pps ( gb , s -> avctx , & s -> ps ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_SEI_PREFIX : case HEVC_NAL_SEI_SUFFIX : if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_params ) { ret = s -> avctx -> hwaccel -> decode_params ( s -> avctx , nal -> type , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } ret = ff_hevc_decode_nal_sei ( gb , s -> avctx , & s -> sei , & s -> ps , s -> nal_unit_type ) ; if ( ret < 0 ) goto fail ; break ; case HEVC_NAL_TRAIL_R : case HEVC_NAL_TRAIL_N : case HEVC_NAL_TSA_N : case HEVC_NAL_TSA_R : case HEVC_NAL_STSA_N : case HEVC_NAL_STSA_R : case HEVC_NAL_BLA_W_LP : case HEVC_NAL_BLA_W_RADL : case HEVC_NAL_BLA_N_LP : case HEVC_NAL_IDR_W_RADL : case HEVC_NAL_IDR_N_LP : case HEVC_NAL_CRA_NUT : case HEVC_NAL_RADL_N : case HEVC_NAL_RADL_R : case HEVC_NAL_RASL_N : case HEVC_NAL_RASL_R : ret = hls_slice_header ( s ) ; if ( ret < 0 ) <S2SV_StartBug> return ret ; <S2SV_EndBug> if ( ( s -> avctx -> skip_frame >= AVDISCARD_BIDIR && s -> sh . slice_type == HEVC_SLICE_B ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONINTRA && s -> sh . slice_type != HEVC_SLICE_I ) || ( s -> avctx -> skip_frame >= AVDISCARD_NONKEY && ! IS_IRAP ( s ) ) ) { break ; } if ( s -> sh . first_slice_in_pic_flag ) { <S2SV_StartBug> if ( s -> ref ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , ""Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n"" ) ; goto fail ; } if ( s -> max_ra == INT_MAX ) { if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA ( s ) ) { s -> max_ra = s -> poc ; } else { if ( IS_IDR ( s ) ) s -> max_ra = INT_MIN ; } } if ( ( s -> nal_unit_type == HEVC_NAL_RASL_R || s -> nal_unit_type == HEVC_NAL_RASL_N ) && s -> poc <= s -> max_ra ) { s -> is_decoded = 0 ; break ; } else { if ( s -> nal_unit_type == HEVC_NAL_RASL_R && s -> poc > s -> max_ra ) s -> max_ra = INT_MIN ; } s -> overlap ++ ; ret = hevc_frame_start ( s ) ; if ( ret < 0 ) return ret ; } else if ( ! s -> ref ) { av_log ( s -> avctx , AV_LOG_ERROR , ""First<S2SV_blank>slice<S2SV_blank>in<S2SV_blank>a<S2SV_blank>frame<S2SV_blank>missing.\\n"" ) ; goto fail ; } if ( s -> nal_unit_type != s -> first_nal_type ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Non-matching<S2SV_blank>NAL<S2SV_blank>types<S2SV_blank>of<S2SV_blank>the<S2SV_blank>VCL<S2SV_blank>NALUs:<S2SV_blank>%d<S2SV_blank>%d\\n"" , s -> first_nal_type , s -> nal_unit_type ) ; return AVERROR_INVALIDDATA ; } if ( ! s -> sh . dependent_slice_segment_flag && s -> sh . slice_type != HEVC_SLICE_I ) { ret = ff_hevc_slice_rpl ( s ) ; if ( ret < 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""Error<S2SV_blank>constructing<S2SV_blank>the<S2SV_blank>reference<S2SV_blank>lists<S2SV_blank>for<S2SV_blank>the<S2SV_blank>current<S2SV_blank>slice.\\n"" ) ; goto fail ; } } if ( s -> sh . first_slice_in_pic_flag && s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> start_frame ( s -> avctx , NULL , 0 ) ; if ( ret < 0 ) goto fail ; } if ( s -> avctx -> hwaccel ) { ret = s -> avctx -> hwaccel -> decode_slice ( s -> avctx , nal -> raw_data , nal -> raw_size ) ; if ( ret < 0 ) goto fail ; } else { if ( s -> threads_number > 1 && s -> sh . num_entry_point_offsets > 0 ) ctb_addr_ts = hls_slice_data_wpp ( s , nal ) ; else ctb_addr_ts = hls_slice_data ( s ) ; if ( ctb_addr_ts >= ( s -> ps . sps -> ctb_width * s -> ps . sps -> ctb_height ) ) { s -> is_decoded = 1 ; } if ( ctb_addr_ts < 0 ) { ret = ctb_addr_ts ; goto fail ; } } break ; case HEVC_NAL_EOS_NUT : case HEVC_NAL_EOB_NUT : s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; break ; case HEVC_NAL_AUD : case HEVC_NAL_FD_NUT : break ; default : av_log ( s -> avctx , AV_LOG_INFO , ""Skipping<S2SV_blank>NAL<S2SV_blank>unit<S2SV_blank>%d\\n"" , s -> nal_unit_type ) ; } return 0 ; fail : if ( s -> avctx -> err_recognition & AV_EF_EXPLODE ) return ret ; return 0 ; }
","<S2SV_ModStart> return ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> ( s -> <S2SV_ModEnd> max_ra == INT_MAX
",FFmpeg@FFmpeg/54655623a82632e7624714d7b2a3e039dc5faa7e,CVE-2019-11338,https://github.com/FFmpeg/FFmpeg/commit/54655623a82632e7624714d7b2a3e039dc5faa7e,2019-04-19T00:29Z
CWE-000,"CWE-000 <S2SV_StartBug> static inline __u32 dccp_v6_init_sequence ( struct sk_buff * skb ) <S2SV_EndBug> { return secure_dccpv6_sequence_number ( ipv6_hdr ( skb ) -> daddr . s6_addr32 , ipv6_hdr ( skb ) -> saddr . s6_addr32 , dccp_hdr ( skb ) -> dccph_dport , dccp_hdr ( skb ) -> dccph_sport ) ; }
","<S2SV_ModStart> <S2SV_null> static inline __u64 <S2SV_ModEnd> dccp_v6_init_sequence ( struct
",torvalds@linux/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,CVE-2011-3188,https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,2012-05-24T23:55Z
CWE-119,"CWE-119 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }
","<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
",torvalds@linux/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,CVE-2014-8369,https://github.com/torvalds/linux/commit/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,2014-11-10T11:55Z
CWE-125,"CWE-125 static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
","<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
",torvalds@linux/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,CVE-2014-3145,https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3,2014-05-11T21:55Z
CWE-399,"CWE-399 static void rpc_init_task ( struct rpc_task * task , const struct rpc_task_setup * task_setup_data ) { memset ( task , 0 , sizeof ( * task ) ) ; atomic_set ( & task -> tk_count , 1 ) ; task -> tk_flags = task_setup_data -> flags ; task -> tk_ops = task_setup_data -> callback_ops ; task -> tk_calldata = task_setup_data -> callback_data ; INIT_LIST_HEAD ( & task -> tk_task ) ; task -> tk_garb_retry = 2 ; task -> tk_cred_retry = 2 ; <S2SV_StartBug> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <S2SV_EndBug> task -> tk_owner = current -> tgid ; task -> tk_workqueue = task_setup_data -> workqueue ; if ( task -> tk_ops -> rpc_call_prepare != NULL ) task -> tk_action = rpc_prepare_task ; task -> tk_start = ktime_get ( ) ; dprintk ( ""RPC:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>new<S2SV_blank>task<S2SV_blank>initialized,<S2SV_blank>procpid<S2SV_blank>%u\\n"" , task_pid_nr ( current ) ) ; }
","<S2SV_ModStart> ; task -> tk_rebind_retry = 2 ; task ->
",torvalds@linux/0b760113a3a155269a3fba93a409c640031dd68f,CVE-2011-2491,https://github.com/torvalds/linux/commit/0b760113a3a155269a3fba93a409c640031dd68f,2013-03-01T12:37Z
CWE-125,"CWE-125 int obj2ast_stmt ( PyObject * obj , stmt_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; int lineno ; int col_offset ; int end_lineno ; int end_col_offset ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } if ( _PyObject_LookupAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_lineno = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_col_offset = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; <S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Py_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""FunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( decorator_list , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = FunctionDef ( name , args , body , decorator_list , returns , lineno , <S2SV_EndBug> col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFunctionDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; arguments_ty args ; asdl_seq * body ; asdl_seq * decorator_list ; <S2SV_StartBug> expr_ty returns ; <S2SV_EndBug> if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""args\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Py_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFunctionDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( decorator_list , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = AsyncFunctionDef ( name , args , body , decorator_list , returns , <S2SV_EndBug> <S2SV_StartBug> lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ClassDef_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier name ; asdl_seq * bases ; asdl_seq * keywords ; asdl_seq * body ; asdl_seq * decorator_list ; if ( _PyObject_LookupAttrId ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""name\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_bases , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; bases = _Py_asdl_seq_new ( len , arena ) ; if ( bases == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""bases\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( bases , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; keywords = _Py_asdl_seq_new ( len , arena ) ; if ( keywords == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { keyword_ty val ; res = obj2ast_keyword ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""keywords\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( keywords , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; decorator_list = _Py_asdl_seq_new ( len , arena ) ; if ( decorator_list == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ClassDef<S2SV_blank>field<S2SV_blank>\\""decorator_list\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( decorator_list , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = ClassDef ( name , bases , keywords , body , decorator_list , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Return_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; if ( _PyObject_LookupAttrId ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Return ( value , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Delete_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Py_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Delete<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( targets , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Delete ( targets , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * targets ; expr_ty value ; <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_targets , & tmp ) < 0 ) { <S2SV_EndBug> return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; targets = _Py_asdl_seq_new ( len , arena ) ; if ( targets == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Assign<S2SV_blank>field<S2SV_blank>\\""targets\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( targets , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = Assign ( targets , value , lineno , col_offset , end_lineno , <S2SV_EndBug> end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AugAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; operator_ty op ; expr_ty value ; if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""op\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = AugAssign ( target , op , value , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AnnAssign_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty annotation ; expr_ty value ; int simple ; if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""annotation\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & annotation , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_simple , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""simple\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & simple , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = AnnAssign ( target , annotation , value , simple , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) For_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Py_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""For<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( orelse , i , val ) ; } Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = For ( target , iter , body , orelse , lineno , col_offset , end_lineno , <S2SV_EndBug> end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncFor_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty target ; expr_ty iter ; asdl_seq * body ; <S2SV_StartBug> asdl_seq * orelse ; <S2SV_EndBug> if ( _PyObject_LookupAttrId ( obj , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""target\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""iter\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Py_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncFor<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( orelse , i , val ) ; } Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = AsyncFor ( target , iter , body , orelse , lineno , col_offset , <S2SV_EndBug> end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) While_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; if ( _PyObject_LookupAttrId ( obj , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Py_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""While<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( orelse , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = While ( test , body , orelse , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) If_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; asdl_seq * body ; asdl_seq * orelse ; if ( _PyObject_LookupAttrId ( obj , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Py_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""If<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( orelse , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = If ( test , body , orelse , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) With_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; asdl_seq * body ; <S2SV_StartBug> if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) { <S2SV_EndBug> return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Py_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { withitem_ty val ; res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( items , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""With<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = With ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) AsyncWith_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * items ; <S2SV_StartBug> asdl_seq * body ; <S2SV_EndBug> if ( _PyObject_LookupAttrId ( obj , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; items = _Py_asdl_seq_new ( len , arena ) ; if ( items == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { withitem_ty val ; res = obj2ast_withitem ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""items\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( items , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""AsyncWith<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = AsyncWith ( items , body , lineno , col_offset , end_lineno , <S2SV_EndBug> end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Raise_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty exc ; expr_ty cause ; if ( _PyObject_LookupAttrId ( obj , & PyId_exc , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; exc = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & exc , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_cause , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; cause = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & cause , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Raise ( exc , cause , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Try_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * handlers ; asdl_seq * orelse ; asdl_seq * finalbody ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""body\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_handlers , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; handlers = _Py_asdl_seq_new ( len , arena ) ; if ( handlers == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { excepthandler_ty val ; res = obj2ast_excepthandler ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""handlers\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( handlers , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; orelse = _Py_asdl_seq_new ( len , arena ) ; if ( orelse == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""orelse\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( orelse , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_finalbody , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; finalbody = _Py_asdl_seq_new ( len , arena ) ; if ( finalbody == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Try<S2SV_blank>field<S2SV_blank>\\""finalbody\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( finalbody , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Try ( body , handlers , orelse , finalbody , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Assert_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty test ; expr_ty msg ; if ( _PyObject_LookupAttrId ( obj , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""test\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_msg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; msg = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & msg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Assert ( test , msg , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Import_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; if ( _PyObject_LookupAttrId ( obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Py_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { alias_ty val ; res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Import<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( names , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Import ( names , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ImportFrom_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { identifier module ; asdl_seq * names ; int level ; if ( _PyObject_LookupAttrId ( obj , & PyId_module , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; module = NULL ; } else { int res ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Py_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { alias_ty val ; res = obj2ast_alias ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""ImportFrom<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( names , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_level , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; level = 0 ; } else { int res ; res = obj2ast_int ( tmp , & level , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = ImportFrom ( module , names , level , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Global_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; if ( _PyObject_LookupAttrId ( obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Py_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { identifier val ; res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Global<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( names , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Global ( names , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Nonlocal_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * names ; if ( _PyObject_LookupAttrId ( obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal"" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; names = _Py_asdl_seq_new ( len , arena ) ; if ( names == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { identifier val ; res = obj2ast_identifier ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Nonlocal<S2SV_blank>field<S2SV_blank>\\""names\\""<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration"" ) ; goto failed ; } asdl_seq_SET ( names , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Nonlocal ( names , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty value ; if ( _PyObject_LookupAttrId ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""value\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr"" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expr ( value , lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Pass_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Pass ( lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Break_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Break ( lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Continue_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { * out = Continue ( lineno , col_offset , end_lineno , end_col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format ( PyExc_TypeError , ""expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>stmt,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R"" , obj ) ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> ; expr_ty returns ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , returns , type_comment , <S2SV_ModStart> ; expr_ty returns ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , returns , type_comment , <S2SV_ModStart> expr_ty value ; string type_comment ; <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , value , type_comment , <S2SV_ModStart> asdl_seq * orelse ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , orelse , type_comment , <S2SV_ModStart> asdl_seq * orelse ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , orelse , type_comment , <S2SV_ModStart> * body ; string type_comment ; <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> items , body , type_comment <S2SV_ModStart> asdl_seq * body ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , body , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-400,"CWE-400 static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , <S2SV_StartBug> USB_DT_OTG , ( void * * ) & desc ) ; <S2SV_EndBug> if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , ""Dual-Role<S2SV_blank>OTG<S2SV_blank>device<S2SV_blank>on<S2SV_blank>%sHNP<S2SV_blank>port\\n"" , ( port1 == bus -> otg_port ) ? """" : ""non-"" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , ""can\'t<S2SV_blank>set<S2SV_blank>HNP<S2SV_blank>mode:<S2SV_blank>%d\\n"" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , ""set<S2SV_blank>a_alt_hnp_support<S2SV_blank>failed:<S2SV_blank>%d\\n"" , err ) ; } } # endif return err ; }
","<S2SV_ModStart> ) & desc , sizeof ( * desc )
",torvalds@linux/704620afc70cf47abb9d6a1a57f3825d2bca49cf,CVE-2018-20169,https://github.com/torvalds/linux/commit/704620afc70cf47abb9d6a1a57f3825d2bca49cf,2018-12-17T07:29Z
CWE-362,"CWE-362 static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ; <S2SV_StartBug> struct list_head tmplist ; <S2SV_EndBug> newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; <S2SV_StartBug> if ( oldsp -> do_auto_asconf ) { <S2SV_EndBug> memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , GFP_KERNEL ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } skb_queue_head_init ( & newsp -> pd_lobby ) ; atomic_set ( & sctp_sk ( newsk ) -> pd_mode , assoc -> ulpq . pd_mode ) ; if ( atomic_read ( & sctp_sk ( oldsk ) -> pd_mode ) ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } } if ( assoc -> ulpq . pd_mode ) sctp_clear_pd ( oldsk , NULL ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) sctp_skb_set_owner_r_frag ( skb , newsk ) ; newsp -> type = type ; lock_sock_nested ( newsk , SINGLE_DEPTH_NESTING ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; release_sock ( newsk ) ; }
","<S2SV_ModStart> * head ; <S2SV_ModEnd> newsk -> sk_sndbuf <S2SV_ModStart> -> sk_rcvbuf ; sctp_copy_descendant <S2SV_ModEnd> ( newsk ,
",torvalds@linux/2d45a02d0166caf2627fe91897c6ffc3b19514c4,CVE-2015-3212,https://github.com/torvalds/linux/commit/2d45a02d0166caf2627fe91897c6ffc3b19514c4,2015-08-31T10:59Z
CWE-416,"CWE-416 int snd_ctl_replace ( struct snd_card * card , struct snd_kcontrol * kcontrol , bool add_on_replace ) { <S2SV_StartBug> struct snd_ctl_elem_id id ; <S2SV_EndBug> unsigned int idx ; struct snd_kcontrol * old ; int ret ; if ( ! kcontrol ) return - EINVAL ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) { ret = - EINVAL ; goto error ; } id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; old = snd_ctl_find_id ( card , & id ) ; if ( ! old ) { if ( add_on_replace ) goto add ; up_write ( & card -> controls_rwsem ) ; ret = - EINVAL ; goto error ; } ret = snd_ctl_remove ( card , old ) ; if ( ret < 0 ) { up_write ( & card -> controls_rwsem ) ; goto error ; } add : if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; ret = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; <S2SV_StartBug> up_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> <S2SV_StartBug> for ( idx = 0 ; idx < kcontrol -> count ; idx ++ , id . index ++ , id . numid ++ ) <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return ret ; }
","<S2SV_ModStart> struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
",torvalds@linux/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,CVE-2014-4653,https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d,2014-07-03T04:22Z
CWE-787,"CWE-787 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; size_t i , o4 , nelements , j , slen , left ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , cdf_offset ( sst -> sst_tab , offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } if ( cdf_check_stream_offset ( sst , h , shp , sh . sh_len , __LINE__ ) == - 1 ) goto out ; sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; inp = cdf_grow_info ( info , maxcount , sh . sh_properties ) ; if ( inp == NULL ) goto out ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , cdf_offset ( sst -> sst_tab , offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , cdf_offset ( shp , sh . sh_len ) ) ; if ( p >= e || cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { if ( ( q = cdf_get_property_info_pos ( sst , h , p , e , i ) ) == NULL ) goto out ; inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; left = CAST ( size_t , e - q ) ; if ( left < sizeof ( uint32_t ) ) { DPRINTF ( ( ""short<S2SV_blank>info<S2SV_blank>(no<S2SV_blank>type)_\\n"" ) ) ; goto out ; } inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%#x<S2SV_blank>type=%#x<S2SV_blank>offs=%#tx,%#x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { if ( left < sizeof ( uint32_t ) * 2 ) { DPRINTF ( ( ""missing<S2SV_blank>CDF_VECTOR<S2SV_blank>length\\n"" ) ) ; goto out ; } nelements = CDF_GETUINT32 ( q , 1 ) ; <S2SV_StartBug> if ( nelements == 0 ) { <S2SV_EndBug> <S2SV_StartBug> DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; <S2SV_EndBug> goto out ; } slen = 2 ; } else { nelements = 1 ; slen = 1 ; } o4 = slen * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int16_t ) ) ) goto unknown ; break ; case CDF_SIGNED32 : case CDF_BOOL : case CDF_UNSIGNED32 : case CDF_FLOAT : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int32_t ) ) ) goto unknown ; break ; case CDF_SIGNED64 : case CDF_UNSIGNED64 : case CDF_DOUBLE : case CDF_FILETIME : if ( ! cdf_copy_info ( & inp [ i ] , & q [ o4 ] , e , sizeof ( int64_t ) ) ) goto unknown ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; inp = cdf_grow_info ( info , maxcount , nelements ) ; if ( inp == NULL ) goto out ; inp += nelem ; } <S2SV_StartBug> DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_EndBug> nelements ) ) ; for ( j = 0 ; j < nelements && i < sh . sh_properties ; j ++ , i ++ ) { uint32_t l ; if ( o4 + sizeof ( uint32_t ) > left ) goto out ; l = CDF_GETUINT32 ( q , slen ) ; o4 += sizeof ( uint32_t ) ; if ( o4 + l > left ) goto out ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = CAST ( const char * , CAST ( const void * , & q [ o4 ] ) ) ; DPRINTF ( ( ""o=%"" SIZE_T_FORMAT ""u<S2SV_blank>l=%d(%"" SIZE_T_FORMAT ""u),<S2SV_blank>t=%"" SIZE_T_FORMAT ""u<S2SV_blank>s=%s\\n"" , o4 , l , CDF_ROUND ( l , sizeof ( l ) ) , left , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; slen += l >> 1 ; o4 = slen * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : memset ( & inp [ i ] . pi_val , 0 , sizeof ( inp [ i ] . pi_val ) ) ; DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%#x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; * info = NULL ; * count = 0 ; * maxcount = 0 ; errno = EFTYPE ; return - 1 ; }
","<S2SV_ModStart> if ( nelements > CDF_ELEMENT_LIMIT || nelements <S2SV_ModStart> DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements <S2SV_ModEnd> ) ) ; <S2SV_ModStart> nelem ; } <S2SV_ModEnd> for ( j
",file@file/46a8443f76cec4b41ec736eca396984c74664f84,CVE-2019-18218,https://github.com/file/file/commit/46a8443f76cec4b41ec736eca396984c74664f84,2019-10-21T05:15Z
CWE-200,"CWE-200 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { bool disconnect ; p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; __touch_mnt_namespace ( p -> mnt_ns ) ; p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; <S2SV_StartBug> disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_EndBug> pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; } }
","<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
",torvalds@linux/e0c9c0afd2fc958ffa34b697972721d81df8a56f,CVE-2015-4176,https://github.com/torvalds/linux/commit/e0c9c0afd2fc958ffa34b697972721d81df8a56f,2016-05-02T10:59Z
CWE-369,"CWE-369 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> ; uint16_t numChannels = 0 <S2SV_ModStart> numChannels < 1 || numChannels > 256 <S2SV_ModStart> ) ) { if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
",dbry@WavPack/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc,CVE-2019-1010315,https://github.com/dbry/WavPack/commit/4c0faba32fddbd0745cbfaf1e1aeb3da5d35b9fc,2019-07-11T20:15Z
CWE-310,"CWE-310 int test_sqr ( BIO * bp , BN_CTX * ctx ) { <S2SV_StartBug> BIGNUM a , c , d , e ; <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> BN_init ( & a ) ; BN_init ( & c ) ; BN_init ( & d ) ; BN_init ( & e ) ; for ( i = 0 ; i < num0 ; i ++ ) { <S2SV_StartBug> BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> a . neg = rand_neg ( ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sqr ( & c , & a , ctx ) ; <S2SV_EndBug> if ( bp != NULL ) { if ( ! results ) { <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; <S2SV_StartBug> BN_print ( bp , & a ) ; <S2SV_EndBug> BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } <S2SV_StartBug> BN_print ( bp , & c ) ; <S2SV_EndBug> BIO_puts ( bp , ""\\n"" ) ; } <S2SV_StartBug> BN_div ( & d , & e , & c , & a , ctx ) ; <S2SV_EndBug> <S2SV_StartBug> BN_sub ( & d , & d , & a ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) <S2SV_EndBug> { <S2SV_StartBug> fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> } } BN_free ( & a ) ; BN_free ( & c ) ; BN_free ( & d ) ; BN_free ( & e ) ; return ( 1 ) ; }
","<S2SV_ModStart> ) { BIGNUM * a , * c , * d , * <S2SV_ModEnd> e ; int <S2SV_ModStart> ; int i , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> { BN_bntest_rand ( <S2SV_ModEnd> a , 40 <S2SV_ModStart> ) ; a -> <S2SV_ModEnd> neg = rand_neg <S2SV_ModStart> ; BN_sqr ( c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> c ) ; <S2SV_ModStart> } BN_div ( d , e , c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ; BN_sub ( d , d , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ! BN_is_zero ( <S2SV_ModEnd> d ) || <S2SV_ModStart> ! BN_is_zero ( e ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed!\\n"" ) ; goto err ; } } BN_hex2bn ( & a , ""80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } BN_hex2bn ( & a , ""80000000000000000000000080000001FFFFFFFE000000000000000000000000"" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>*<S2SV_blank>"" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , ""<S2SV_blank>-<S2SV_blank>"" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , ""\\n"" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , ""Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>"" ""different<S2SV_blank>results!\\n"" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z
CWE-119,"CWE-119 png_charp PNGAPI png_convert_to_rfc1123 ( png_structp png_ptr , png_timep ptime ) { static PNG_CONST char short_months [ 12 ] [ 4 ] = { ""Jan"" , ""Feb"" , ""Mar"" , ""Apr"" , ""May"" , ""Jun"" , ""Jul"" , ""Aug"" , ""Sep"" , ""Oct"" , ""Nov"" , ""Dec"" } ; if ( png_ptr == NULL ) return ( NULL ) ; if ( png_ptr -> time_buffer == NULL ) { png_ptr -> time_buffer = ( png_charp ) png_malloc ( png_ptr , ( png_uint_32 ) ( 29 * png_sizeof ( char ) ) ) ; } # ifdef _WIN32_WCE { wchar_t time_buf [ 29 ] ; wsprintf ( time_buf , TEXT ( ""%d<S2SV_blank>%S<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" ) , <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ; WideCharToMultiByte ( CP_ACP , 0 , time_buf , - 1 , png_ptr -> time_buffer , 29 , NULL , NULL ) ; } # else # ifdef USE_FAR_KEYWORD { char near_time_buf [ 29 ] ; png_snprintf6 ( near_time_buf , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ; png_memcpy ( png_ptr -> time_buffer , near_time_buf , 29 * png_sizeof ( char ) ) ; } # else png_snprintf6 ( png_ptr -> time_buffer , 29 , ""%d<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%02d:%02d:%02d<S2SV_blank>+0000"" , <S2SV_StartBug> ptime -> day % 32 , short_months [ ( ptime -> month - 1 ) % 12 ] , <S2SV_EndBug> ptime -> year , ptime -> hour % 24 , ptime -> minute % 60 , ptime -> second % 61 ) ; # endif # endif return ( ( png_charp ) png_ptr -> time_buffer ) ; }
","<S2SV_ModStart> -> month - 1U <S2SV_ModEnd> ) % 12 <S2SV_ModStart> -> month - 1U <S2SV_ModEnd> ) % 12 <S2SV_ModStart> -> month - 1U <S2SV_ModEnd> ) % 12
",chromium@chromium/7f3d85b096f66870a15b37c2f40b219b2e292693,CVE-2015-8126,https://github.com/chromium/chromium/commit/7f3d85b096f66870a15b37c2f40b219b2e292693,2015-11-13T03:59Z
CWE-255,"CWE-255 static void setup_remaining_vcs ( int src_fd , unsigned src_idx , bool utf8 ) { struct console_font_op cfo = { . op = KD_FONT_OP_GET , . width = UINT_MAX , . height = UINT_MAX , . charcount = UINT_MAX , } ; struct unimapinit adv = { } ; struct unimapdesc unimapd ; _cleanup_free_ struct unipair * unipairs = NULL ; _cleanup_free_ void * fontbuf = NULL ; unsigned i ; int r ; unipairs = new ( struct unipair , USHRT_MAX ) ; if ( ! unipairs ) { log_oom ( ) ; return ; } r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , ""KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>font<S2SV_blank>metadata:<S2SV_blank>%m"" ) ; else { if ( cfo . width > 32 || cfo . height > 32 || cfo . charcount > 512 ) log_warning ( ""Invalid<S2SV_blank>font<S2SV_blank>metadata<S2SV_blank>-<S2SV_blank>width:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>height:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>32),<S2SV_blank>count:<S2SV_blank>%u<S2SV_blank>(max<S2SV_blank>512)"" , cfo . width , cfo . height , cfo . charcount ) ; else { fontbuf = malloc_multiply ( ( cfo . width + 7 ) / 8 * 32 , cfo . charcount ) ; if ( ! fontbuf ) { log_oom ( ) ; return ; } cfo . data = fontbuf ; r = ioctl ( src_fd , KDFONTOP , & cfo ) ; if ( r < 0 ) log_warning_errno ( errno , ""KD_FONT_OP_GET<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>font<S2SV_blank>data:<S2SV_blank>%m"" ) ; else { unimapd . entries = unipairs ; unimapd . entry_ct = USHRT_MAX ; r = ioctl ( src_fd , GIO_UNIMAP , & unimapd ) ; if ( r < 0 ) log_warning_errno ( errno , ""GIO_UNIMAP<S2SV_blank>failed<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>read<S2SV_blank>unicode<S2SV_blank>mappings:<S2SV_blank>%m"" ) ; else cfo . op = KD_FONT_OP_SET ; } } } if ( cfo . op != KD_FONT_OP_SET ) log_warning ( ""Fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>remaining<S2SV_blank>consoles"" ) ; for ( i = 1 ; i <= 63 ; i ++ ) { char ttyname [ sizeof ( ""/dev/tty63"" ) ] ; _cleanup_close_ int fd_d = - 1 ; if ( i == src_idx || verify_vc_allocation ( i ) < 0 ) continue ; xsprintf ( ttyname , ""/dev/tty%u"" , i ) ; fd_d = open_terminal ( ttyname , O_RDWR | O_CLOEXEC | O_NOCTTY ) ; if ( fd_d < 0 ) { log_warning_errno ( fd_d , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tty%u,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied:<S2SV_blank>%m"" , i ) ; continue ; } <S2SV_StartBug> if ( verify_vc_kbmode ( fd_d ) < 0 ) <S2SV_EndBug> continue ; toggle_utf8 ( ttyname , fd_d , utf8 ) ; if ( cfo . op != KD_FONT_OP_SET ) continue ; r = ioctl ( fd_d , KDFONTOP , & cfo ) ; if ( r < 0 ) { int last_errno , mode ; last_errno = errno ; if ( ioctl ( fd_d , KDGETMODE , & mode ) >= 0 && mode != KD_TEXT ) log_debug ( ""KD_FONT_OP_SET<S2SV_blank>skipped:<S2SV_blank>tty%u<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>text<S2SV_blank>mode"" , i ) ; else log_warning_errno ( last_errno , ""KD_FONT_OP_SET<S2SV_blank>failed,<S2SV_blank>fonts<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>tty%u:<S2SV_blank>%m"" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAPCLR , & adv ) ; if ( r < 0 ) { log_warning_errno ( errno , ""PIO_UNIMAPCLR<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m"" , i ) ; continue ; } r = ioctl ( fd_d , PIO_UNIMAP , & unimapd ) ; if ( r < 0 ) { log_warning_errno ( errno , ""PIO_UNIMAP<S2SV_blank>failed,<S2SV_blank>unimaps<S2SV_blank>might<S2SV_blank>be<S2SV_blank>incorrect<S2SV_blank>for<S2SV_blank>tty%u:<S2SV_blank>%m"" , i ) ; continue ; } log_debug ( ""Font<S2SV_blank>and<S2SV_blank>unimap<S2SV_blank>successfully<S2SV_blank>copied<S2SV_blank>to<S2SV_blank>%s"" , ttyname ) ; } }
","<S2SV_ModStart> } if ( vt_verify_kbmode <S2SV_ModEnd> ( fd_d )
",systemd@systemd/9725f1a10f80f5e0ae7d9b60547458622aeb322f,CVE-2018-20839,https://github.com/systemd/systemd/commit/9725f1a10f80f5e0ae7d9b60547458622aeb322f,2019-05-17T04:29Z
CWE-200,"CWE-200 static int raptor_rss_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rss_parser * rss_parser = ( raptor_rss_parser * ) rdf_parser -> context ; int n ; if ( ! uri ) return 1 ; for ( n = 0 ; n < RAPTOR_RSS_NAMESPACES_SIZE ; n ++ ) rss_parser -> nspaces_seen [ n ] = 'N' ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <S2SV_StartBug> if ( rdf_parser -> uri_filter ) <S2SV_EndBug> raptor_sax2_set_uri_filter ( rss_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rss_parser -> sax2 , uri ) ; return 0 ; }
","<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
",dajobe@raptor/a676f235309a59d4aa78eeffd2574ae5d341fcb0,CVE-2012-0037,https://github.com/dajobe/raptor/commit/a676f235309a59d4aa78eeffd2574ae5d341fcb0,2012-06-17T03:41Z
CWE-400,"CWE-400 static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { <S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize"" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
","<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
",php@php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8,CVE-2015-9253,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,2018-02-19T19:29Z
CWE-119,"CWE-119 long fuse_do_ioctl ( struct file * file , unsigned int cmd , unsigned long arg , unsigned int flags ) { struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg = { . fh = ff -> fh , . cmd = cmd , . arg = arg , . flags = flags } ; struct fuse_ioctl_out outarg ; struct fuse_req * req = NULL ; struct page * * pages = NULL ; struct page * iov_page = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; BUILD_BUG_ON ( sizeof ( struct iovec ) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE ) ; err = - ENOMEM ; pages = kzalloc ( sizeof ( pages [ 0 ] ) * FUSE_MAX_PAGES_PER_REQ , GFP_KERNEL ) ; iov_page = alloc_page ( GFP_KERNEL ) ; if ( ! pages || ! iov_page ) goto out ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) { struct iovec * iov = page_address ( iov_page ) ; iov -> iov_base = ( void __user * ) arg ; iov -> iov_len = _IOC_SIZE ( cmd ) ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { in_iov = iov ; in_iovs = 1 ; } if ( _IOC_DIR ( cmd ) & _IOC_READ ) { out_iov = iov ; out_iovs = 1 ; } } retry : inarg . in_size = in_size = iov_length ( in_iov , in_iovs ) ; inarg . out_size = out_size = iov_length ( out_iov , out_iovs ) ; out_size = max_t ( size_t , out_size , PAGE_SIZE ) ; max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ) ; err = - ENOMEM ; if ( max_pages > FUSE_MAX_PAGES_PER_REQ ) goto out ; while ( num_pages < max_pages ) { pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ) ; if ( ! pages [ num_pages ] ) goto out ; num_pages ++ ; } req = fuse_get_req ( fc ) ; if ( IS_ERR ( req ) ) { err = PTR_ERR ( req ) ; req = NULL ; goto out ; } memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ) ; req -> num_pages = num_pages ; req -> in . h . opcode = FUSE_IOCTL ; req -> in . h . nodeid = ff -> nodeid ; req -> in . numargs = 1 ; req -> in . args [ 0 ] . size = sizeof ( inarg ) ; req -> in . args [ 0 ] . value = & inarg ; if ( in_size ) { req -> in . numargs ++ ; req -> in . args [ 1 ] . size = in_size ; req -> in . argpages = 1 ; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ) ; if ( err ) goto out ; } req -> out . numargs = 2 ; req -> out . args [ 0 ] . size = sizeof ( outarg ) ; req -> out . args [ 0 ] . value = & outarg ; req -> out . args [ 1 ] . size = out_size ; req -> out . argpages = 1 ; req -> out . argvar = 1 ; fuse_request_send ( fc , req ) ; err = req -> out . h . error ; transferred = req -> out . args [ 1 ] . size ; fuse_put_request ( fc , req ) ; req = NULL ; if ( err ) goto out ; if ( outarg . flags & FUSE_IOCTL_RETRY ) { char * vaddr ; err = - EIO ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) ) goto out ; in_iovs = outarg . in_iovs ; out_iovs = outarg . out_iovs ; err = - ENOMEM ; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV ) goto out ; vaddr = kmap_atomic ( pages [ 0 ] , KM_USER0 ) ; err = fuse_copy_ioctl_iovec ( page_address ( iov_page ) , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ) ; kunmap_atomic ( vaddr , KM_USER0 ) ; if ( err ) goto out ; in_iov = page_address ( iov_page ) ; out_iov = in_iov + in_iovs ; <S2SV_StartBug> goto retry ; <S2SV_EndBug> } err = - EIO ; if ( transferred > inarg . out_size ) goto out ; err = fuse_ioctl_copy_user ( pages , out_iov , out_iovs , transferred , true ) ; out : if ( req ) fuse_put_request ( fc , req ) ; if ( iov_page ) __free_page ( iov_page ) ; while ( num_pages ) __free_page ( pages [ -- num_pages ] ) ; kfree ( pages ) ; return err ? err : outarg . result ; }
","<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
",torvalds@linux/7572777eef78ebdee1ecb7c258c0ef94d35bad16,CVE-2010-4650,https://github.com/torvalds/linux/commit/7572777eef78ebdee1ecb7c258c0ef94d35bad16,2012-06-21T23:55Z
CWE-77,"CWE-77 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( ""device<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s"" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : ""(null)"" ) ) ; fprintf ( file , ""<device<S2SV_blank>DEVNO=\\""0x%04lx\\""<S2SV_blank>TIME=\\""%ld.%ld\\"""" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , ""<S2SV_blank>PRI=\\""%d\\"""" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ; <S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> } fprintf ( file , "">%s</device>\\n"" , dev -> bid_name ) ; return 0 ; }
","<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
",karelzak@util-linux/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,CVE-2014-9114,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,2017-03-31T16:59Z
CWE-476,"CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; <S2SV_StartBug> if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> sh_info && ( end - <S2SV_ModStart> * ) defs > i <S2SV_ModEnd> ) ; ++ <S2SV_ModStart> vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free
",radare@radare2/62e39f34b2705131a2d08aff0c2e542c6a52cf0e,CVE-2017-16359,https://github.com/radare/radare2/commit/62e39f34b2705131a2d08aff0c2e542c6a52cf0e,2017-11-01T17:29Z
CWE-125,"CWE-125 int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input == * ( ip + 1 ) ) { bytes_matched ++ ; input += input_incr ; ip += 2 ; } else { stop = TRUE ; } break ; case RE_OPCODE_MASKED_LITERAL : value = * ( int16_t * ) ( ip + 1 ) & 0xFF ; mask = * ( int16_t * ) ( ip + 1 ) >> 8 ; if ( ( * input & mask ) == value ) { bytes_matched ++ ; input += input_incr ; ip += 3 ; } else { stop = TRUE ; } break ; case RE_OPCODE_ANY : bytes_matched ++ ; input += input_incr ; ip += 1 ; break ; case RE_OPCODE_REPEAT_ANY_UNGREEDY : repeat_any_args = ( RE_REPEAT_ANY_ARGS * ) ( ip + 1 ) ; next_opcode = ip + 1 + sizeof ( RE_REPEAT_ANY_ARGS ) ; for ( i = repeat_any_args -> min + 1 ; i <= repeat_any_args -> max ; i ++ ) { <S2SV_StartBug> next_input = input + i * input_incr ; <S2SV_EndBug> if ( bytes_matched + i >= max_bytes_matched ) <S2SV_StartBug> break ; <S2SV_EndBug> if ( * ( next_opcode ) != RE_OPCODE_LITERAL || ( * ( next_opcode ) == RE_OPCODE_LITERAL && * ( next_opcode + 1 ) == * next_input ) ) { if ( sp >= MAX_FAST_RE_STACK ) return - 4 ; code_stack [ sp ] = next_opcode ; input_stack [ sp ] = next_input ; matches_stack [ sp ] = bytes_matched + i ; sp ++ ; } } input += input_incr * repeat_any_args -> min ; bytes_matched += repeat_any_args -> min ; <S2SV_StartBug> ip = next_opcode ; <S2SV_EndBug> break ; default : assert ( FALSE ) ; } } } if ( matches != NULL ) * matches = - 1 ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z
CWE-000,"CWE-000 static void tun_net_init ( struct net_device * dev ) { struct tun_struct * tun = netdev_priv ( dev ) ; switch ( tun -> flags & TUN_TYPE_MASK ) { case TUN_TUN_DEV : dev -> netdev_ops = & tun_netdev_ops ; dev -> hard_header_len = 0 ; dev -> addr_len = 0 ; dev -> mtu = 1500 ; dev -> type = ARPHRD_NONE ; dev -> flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST ; dev -> tx_queue_len = TUN_READQ_SIZE ; break ; case TUN_TAP_DEV : dev -> netdev_ops = & tap_netdev_ops ; ether_setup ( dev ) ; <S2SV_StartBug> random_ether_addr ( dev -> dev_addr ) ; <S2SV_EndBug> dev -> tx_queue_len = TUN_READQ_SIZE ; break ; } }
","<S2SV_ModStart> dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
